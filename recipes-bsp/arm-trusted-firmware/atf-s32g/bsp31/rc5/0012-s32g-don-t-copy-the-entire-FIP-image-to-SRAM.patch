From 99a0a4261bcf9cea3787dfeabc502cb288d94e0b Mon Sep 17 00:00:00 2001
From: Catalin Udma <catalin-dan.udma@nxp.com>
Date: Thu, 4 Nov 2021 17:51:45 +0200
Subject: [PATCH 12/14] s32g: don't copy the entire FIP image to SRAM

Before this change, FIP header and then the entire FIP are copied to SRAM:
	INFO: Loading image id=0 at address 0x34400000
	INFO: Image id=0 loaded: 0x34400000 - 0x34400200
	INFO: Loading image id=0 at address 0x34400000
	INFO: Image id=0 loaded: 0x34400000 - 0x34518400
Then, after the FIP images are parsed, each image is loaded from SRAM to
the destination address in DDRAM. This procedure has implications in
boot time (as extra unneeded copying is done) and SRAM memory usage.

This patch updates the procedure for accessing and loading FIP images
from storage to obtain more efficient SRAM usage and faster boot time.
- Only the FIP header is copied from storage to SRAM.
- The FIP header  is parsed to compute the real offset and length of each
image in the FIP (e.g. BL31, BL33...). This is done before loading the
FIP images.
- Once the real offset and length is computed, each image from FIP is
loaded directly from storage to DDRAM.

What it is optimized with this change:
 * smaller SRAM usage in BL2. This change reduces the SRAM usage with
   about 1.2 MB.
 * faster boot time: unneeded fip.bin copy into SRAM as images can be copied
   directly from storage into DDRAM. Also BL2 image (as part of fip.bin)
   is not copied anymore

Raw boot time measurements on SDHC booting (without optee) shows an
improvement from 109 ms to 68 ms.

Issue: ALB-7892

Upstream-Status: Pending 

Signed-off-by: Catalin Udma <catalin-dan.udma@nxp.com>
Signed-off-by: Zhantao Tang <zhantao.tang@windriver.com>
---
 plat/nxp/s32/s32g/include/s32g_storage.h |  14 +-
 plat/nxp/s32/s32g/s32g_bl2_el3.c         |  43 +---
 plat/nxp/s32/s32g/s32g_storage.c         | 285 +++++++++++++----------
 3 files changed, 181 insertions(+), 161 deletions(-)

diff --git a/plat/nxp/s32/s32g/include/s32g_storage.h b/plat/nxp/s32/s32g/include/s32g_storage.h
index 85c933e02..f90ab3448 100644
--- a/plat/nxp/s32/s32g/include/s32g_storage.h
+++ b/plat/nxp/s32/s32g/include/s32g_storage.h
@@ -1,11 +1,15 @@
 /*
- * Copyright 2019-2020 NXP
+ * Copyright 2019-2021 NXP
  *
  * SPDX-License-Identifier: BSD-3-Clause
  */
 #ifndef S32G_STORAGE_H
 #define S32G_STORAGE_H
 
+#include <tools_share/uuid.h>
+
+#define FIP_HEADER_SIZE		(0x200)
+
 struct plat_io_policy {
 	uintptr_t *dev_handle;
 	uintptr_t image_spec;
@@ -14,4 +18,12 @@ struct plat_io_policy {
 
 void s32g_io_setup(void);
 
+/* Return 0 for equal uuids. */
+static inline int compare_uuids(const uuid_t *uuid1, const uuid_t *uuid2)
+{
+	return memcmp(uuid1, uuid2, sizeof(uuid_t));
+}
+
+void set_image_spec(const uuid_t *uuid, uint64_t size, uint64_t offset);
+
 #endif /* S32G_STORAGE_H */
diff --git a/plat/nxp/s32/s32g/s32g_bl2_el3.c b/plat/nxp/s32/s32g/s32g_bl2_el3.c
index 377e25fee..46b2dabb8 100644
--- a/plat/nxp/s32/s32g/s32g_bl2_el3.c
+++ b/plat/nxp/s32/s32g/s32g_bl2_el3.c
@@ -42,8 +42,6 @@
 #define AARCH64_UNCOND_BRANCH_OP	(BIT(26) | BIT(28))
 #define BL33_DTB_MAGIC			(0xedfe0dd0)
 
-#define FIP_HEADER_SIZE			(0x200)
-
 static bl_mem_params_node_t s32g_bl2_mem_params_descs[6];
 REGISTER_BL_IMAGE_DESCS(s32g_bl2_mem_params_descs)
 
@@ -373,21 +371,15 @@ static bool is_branch_op(uint32_t op)
 	return (op & AARCH64_UNCOND_BRANCH_MASK) == AARCH64_UNCOND_BRANCH_OP;
 }
 
-/* Return 0 for equal uuids. */
-static inline int compare_uuids(const uuid_t *uuid1, const uuid_t *uuid2)
-{
-	return memcmp(uuid1, uuid2, sizeof(uuid_t));
-}
-
-/* Computes the real FIP image size and updates image info.
- * At this point, only FIP header was read so we can walk though all
+/* Computes the size of the images inside FIP and updates image io_block spec.
+ * Only FIP header was read from storage to SRAM so we can walk through all
  * fip_toc_entry_t entries until the last one.
- * The last entry will give us FIP image size.
+ * For each images it is updated the real size and offset as read from the
+ * FIP header.
  */
-static int set_fip_size(bl_mem_params_node_t *fip_params)
+static int set_fip_images_size(bl_mem_params_node_t *fip_params)
 {
 	static const uuid_t uuid_null = { {0} };
-	uint64_t last_offset = 0, last_size = 0;
 	image_info_t *image_info = &fip_params->image_info;
 	char *buf = (char *)image_info->image_base;
 	char *buf_end = buf + image_info->image_size;
@@ -398,15 +390,11 @@ static int set_fip_size(bl_mem_params_node_t *fip_params)
 		if (compare_uuids(&toc_entry->uuid, &uuid_null) == 0)
 			break;
 
-		last_offset = toc_entry->offset_address;
-		last_size = toc_entry->size;
-
+		set_image_spec(&toc_entry->uuid, toc_entry->size,
+			       toc_entry->offset_address);
 		toc_entry++;
 	}
 
-	/* Update the real image size. */
-	image_info->image_size = last_size + last_offset;
-
 	return 0;
 }
 
@@ -419,26 +407,11 @@ int bl2_plat_handle_post_image_load(unsigned int image_id)
 	bl_mem_params_node_t *pager_mem_params = NULL;
 	bl_mem_params_node_t *paged_mem_params = NULL;
 
-#define AARCH64_UNCOND_BRANCH_MASK	(0x7c000000)
-#define AARCH64_UNCOND_BRANCH_OP	(BIT(26) | BIT(28))
-#define BL33_DTB_MAGIC			(0xedfe0dd0)
-
 	if (image_id == FIP_IMAGE_ID) {
 		bl_mem_params = get_bl_mem_params_node(image_id);
 		assert(bl_mem_params && "FIP params cannot be NULL");
 
-		set_fip_size(bl_mem_params);
-
-		/* Now that we know the real image size, we can load
-		 * the entire FIP.
-		 */
-		s32_sram_clear(FIP_BASE, FIP_BASE + bl_mem_params->image_info.image_size);
-		ret = load_auth_image(image_id, &bl_mem_params->image_info);
-		if (ret != 0) {
-			ERROR("BL2: Failed to load image id %d (%i)\n",
-			      image_id, ret);
-			plat_error_handler(ret);
-		}
+		set_fip_images_size(bl_mem_params);
 	}
 
 	if (image_id == BL33_IMAGE_ID) {
diff --git a/plat/nxp/s32/s32g/s32g_storage.c b/plat/nxp/s32/s32g/s32g_storage.c
index 0cb96a09c..20c6098ff 100644
--- a/plat/nxp/s32/s32g/s32g_storage.c
+++ b/plat/nxp/s32/s32g/s32g_storage.c
@@ -30,78 +30,75 @@
 static const io_dev_connector_t *s32g_mmc_io_conn;
 static uintptr_t s32g_mmc_dev_handle;
 
-static const io_dev_connector_t *s32g_fip_io_conn;
-static uintptr_t s32g_fip_dev_handle;
-
 static const io_dev_connector_t *s32g_memmap_io_conn;
 static uintptr_t s32g_memmap_dev_handle;
 
 static int s32g_check_mmc_dev(const uintptr_t spec);
-static int s32g_check_fip_dev(const uintptr_t spec);
 static int s32g_check_memmap_dev(const uintptr_t spec);
 
-static io_block_spec_t fip_mmc_spec = {
-	.offset = FIP_MMC_OFFSET,
-};
-
 static const io_block_spec_t fip_memmap_spec = {
 	.offset = FIP_BASE,
-	.length = ROUND_TO_MMC_BLOCK_SIZE(FIP_MAXIMUM_SIZE),
-};
-
-static const io_uuid_spec_t bl31_uuid_spec = {
-	.uuid = UUID_EL3_RUNTIME_FIRMWARE_BL31,
+	.length = ROUND_TO_MMC_BLOCK_SIZE(FIP_HEADER_SIZE),
 };
 
-#ifdef SPD_opteed
-static const io_uuid_spec_t bl32_uuid_spec = {
-	.uuid = UUID_SECURE_PAYLOAD_BL32,
-};
-
-static const io_uuid_spec_t bl32_extra1_uuid_spec = {
-	.uuid = UUID_SECURE_PAYLOAD_BL32_EXTRA1,
-};
+struct image_storage_info {
+	uuid_t uuid;
+	unsigned int image_id;
+	io_block_spec_t mmc_spec;
+	io_block_spec_t qspi_spec;
+#ifdef FIP_MEM_OFFSET
+	io_block_spec_t mem_spec;
 #endif
-
-static const io_uuid_spec_t bl33_uuid_spec = {
-	.uuid = UUID_NON_TRUSTED_FIRMWARE_BL33,
-};
-
-static io_block_spec_t qspi_fip_memmap_spec = {
-	.offset = FIP_QSPI_OFFSET,
-	.length = FIP_MAXIMUM_SIZE,
 };
 
+static struct image_storage_info images_info[] = {
+	{
+		.image_id = FIP_IMAGE_ID,
+		/* The selection of mmc, qspi, or mem spec is done dynamically,
+		 * based on the boot source and config (e.g. FIP_MEM_OFFSET)
+		 * */
+		.mmc_spec = {
+			.offset = FIP_MMC_OFFSET,
+			.length = FIP_HEADER_SIZE,
+		},
+		.qspi_spec = {
+			.offset = FIP_QSPI_OFFSET,
+			.length = FIP_HEADER_SIZE,
+		},
 #ifdef FIP_MEM_OFFSET
-static io_block_spec_t mem_fip_memmap_spec = {
-	.offset = FIP_MEM_OFFSET,
-	.length = FIP_MAXIMUM_SIZE,
-};
+		.mem_spec = {
+			.offset = FIP_MEM_OFFSET,
+			.length = FIP_HEADER_SIZE,
+		},
 #endif
-
-static struct plat_io_policy s32g_policies[] = {
-	[BL31_IMAGE_ID] = {
-		&s32g_fip_dev_handle,
-		(uintptr_t)&bl31_uuid_spec,
-		s32g_check_fip_dev
+	},
+	{
+		.image_id = BL31_IMAGE_ID,
+		.uuid = UUID_EL3_RUNTIME_FIRMWARE_BL31,
+
+		/* The offset and length for the specs will be dynamically
+		 * adjusted after reading FIP header. This is done after
+		 * reading FIP header in SRAM, before loading any other
+		 * image from FIP, by calling set_image_spec() function
+		 * */
 	},
 #ifdef SPD_opteed
-	[BL32_IMAGE_ID] = {
-		&s32g_fip_dev_handle,
-		(uintptr_t)&bl32_uuid_spec,
-		s32g_check_fip_dev
+	{
+		.image_id = BL32_IMAGE_ID,
+		.uuid = UUID_SECURE_PAYLOAD_BL32,
 	},
-	[BL32_EXTRA1_IMAGE_ID] = {
-		&s32g_fip_dev_handle,
-		(uintptr_t)&bl32_extra1_uuid_spec,
-		s32g_check_fip_dev
+	{
+		.image_id = BL32_EXTRA1_IMAGE_ID,
+		.uuid = UUID_SECURE_PAYLOAD_BL32_EXTRA1,
 	},
 #endif
-	[BL33_IMAGE_ID] = {
-		&s32g_fip_dev_handle,
-		(uintptr_t)&bl33_uuid_spec,
-		s32g_check_fip_dev
+	{
+		.image_id = BL33_IMAGE_ID,
+		.uuid = UUID_NON_TRUSTED_FIRMWARE_BL33,
 	},
+};
+
+static struct plat_io_policy s32g_policies[] = {
 	[FIP_BACKEND_MEMMAP_ID] = {
 		&s32g_memmap_dev_handle,
 		(uintptr_t)&fip_memmap_spec,
@@ -109,24 +106,6 @@ static struct plat_io_policy s32g_policies[] = {
 	},
 };
 
-static int s32g_check_fip_dev(const uintptr_t spec)
-{
-	int ret;
-	uintptr_t local_image_handle;
-
-	ret = io_dev_init(s32g_fip_dev_handle,
-			  (uintptr_t)FIP_BACKEND_MEMMAP_ID);
-	if (ret)
-		return ret;
-	ret = io_open(s32g_fip_dev_handle, spec, &local_image_handle);
-	if (ret)
-		return ret;
-	/* must be closed, as load_image() will do another io_open() */
-	io_close(local_image_handle);
-
-	return 0;
-}
-
 static int s32g_check_mmc_dev(const uintptr_t spec)
 {
 	uintptr_t local_handle;
@@ -228,64 +207,127 @@ static uint8_t get_boot_source(void)
 	}
 }
 
-static void set_fip_img_source(struct plat_io_policy *policy)
+static bool is_mmc_boot_source()
 {
-	bl_mem_params_node_t *fip_params =
-			get_bl_mem_params_node(FIP_IMAGE_ID);
-	image_info_t *image_info;
-	io_block_spec_t *io_mem_spec = &qspi_fip_memmap_spec;
-	bool use_mem_offset = false;
-
-	/* No need to check boot_source value integrity here.
-	 * If the previous check had failed, the boot flow would
-	 * not have reached this point.
-	 */
 	uint8_t boot_source = get_boot_source();
 
-	if (fip_params == NULL) {
-		ERROR("Invalid (NULL) fip parameters\n");
-		return;
-	}
-	image_info = &fip_params->image_info;
+#ifdef FIP_MEM_OFFSET
+	return false;
+#endif
+
+	if ((boot_source == BOOT_SOURCE_SD) ||
+	    (boot_source == BOOT_SOURCE_MMC))
+		return true;
 
-	/* We know the real FIP image length only after FIP header
-	 * is read and parsed in bl2_plat_handle_post_image_load.
-	 * This code will be executed twice: the first time when the
-	 * FIP header is read and the image_size will be FIP_HEADER_SIZE
-	 * and second time when the entire FIP is read and image_size
-	 * will be the one obtained in bl2_plat_handle_post_image_load.
-	 */
+	return false;
+}
+
+static io_block_spec_t *get_image_spec_source(struct image_storage_info *info)
+{
+	uint8_t boot_source = get_boot_source();
+
+	if (info == NULL)
+		return NULL;
 
 #ifdef FIP_MEM_OFFSET
-	/* Independent of the boot source, read FIP from Memory */
-	io_mem_spec = &mem_fip_memmap_spec;
-	use_mem_offset = true;
+	return &info->mem_spec;
 #endif
 
-	if ((use_mem_offset == true) ||
-		(boot_source == BOOT_SOURCE_QSPI)) {
-		/* io_dev_init will check the header before image_info->image_size
-		 * is computed.
-		 */
-		io_mem_spec->length = image_info->image_size ?
-			image_info->image_size : io_mem_spec->length;
-		*policy = (struct plat_io_policy) {
-			.dev_handle = &s32g_memmap_dev_handle,
-			.image_spec = (uintptr_t)io_mem_spec,
-			.check = s32g_check_memmap_dev,
-		};
+	switch (boot_source) {
+		case BOOT_SOURCE_QSPI:
+			return &info->qspi_spec;
+		case BOOT_SOURCE_SD:
+		case BOOT_SOURCE_MMC:
+			return &info->mmc_spec;
+		default:
+			return NULL;
+	}
+}
+
+static io_block_spec_t * get_image_spec_from_id(unsigned int image_id)
+{
+	unsigned int i;
+
+	for (i = 0; i < ARRAY_SIZE(images_info); i++) {
+		if (images_info[i].image_id == image_id)
+			return get_image_spec_source(&images_info[i]);
+	}
+
+	return NULL;
+}
+
+static io_block_spec_t * get_image_spec_from_uuid(const uuid_t *uuid)
+{
+	unsigned int i;
+
+	for (i = 0; i < ARRAY_SIZE(images_info); i++) {
+		if (compare_uuids(&images_info[i].uuid, uuid) == 0)
+			return get_image_spec_source(&images_info[i]);
+	}
+
+	return NULL;
+}
+
+/* This function is called after reading the FIP header and before loading
+ * any other image from FIP.
+ * The size and offset parameters are read from the FIP header
+ * */
+void set_image_spec(const uuid_t *uuid, uint64_t size, uint64_t offset)
+{
+	io_block_spec_t *spec = get_image_spec_from_uuid(uuid);
+	io_block_spec_t *fip_spec = get_image_spec_from_id(FIP_IMAGE_ID);
+
+	if (spec == NULL)
+		return;
+
+	if (fip_spec == NULL) {
+		ERROR("Invalid FIP io block spec\n");
+		return;
+	}
+
+	if (is_mmc_boot_source())
+		spec->length = ROUND_TO_MMC_BLOCK_SIZE(size);
+	else
+		spec->length = size;
+
+	/* In FIP header the offset is relative to the FIP header start.
+	 * The real offset of the image is computed by adding the offset
+	 * from the FIP header to the real FIP offset
+	 * */
+	spec->offset = fip_spec->offset + offset;
+}
+
+/* Before loading each image (e.g. load_image), this function is called from
+ * plat_get_image_source() and performs the following actions:
+ * - For FIP_IMAGE_ID it sets the io_block spec source: mmc, qspi, or memory.
+ *   The offset and length are statically initialized and always only the FIP
+ *   header is read.
+ * - For the other images in FIP (e.g. BL31, BL32, BL33) this function is
+ *   is called after the FIP header is parsed and the right offset and length
+ *   for each image in the FIP header are set.
+ *   When the function is called, it just passes the spec source (mmc, qspi or
+ *   mem) that should have been already updated.
+ * */
+static void set_img_source(struct plat_io_policy *policy,
+			       unsigned int image_id)
+{
+	io_block_spec_t *crt_spec = get_image_spec_from_id(image_id);
+
+	if (crt_spec == NULL)
+		return;
+
+	policy->image_spec = (uintptr_t)crt_spec;
+
+	if (is_mmc_boot_source()) {
+		policy->dev_handle = &s32g_mmc_dev_handle;
+		policy->check = s32g_check_mmc_dev;
 	} else {
-		fip_mmc_spec.length = image_info->image_size ?
-			ROUND_TO_MMC_BLOCK_SIZE(image_info->image_size) :
-			fip_mmc_spec.length;
-		*policy = (struct plat_io_policy) {
-			.dev_handle = &s32g_mmc_dev_handle,
-			.image_spec = (uintptr_t)&fip_mmc_spec,
-			.check = s32g_check_mmc_dev,
-		};
+		policy->dev_handle = &s32g_memmap_dev_handle;
+		policy->check = s32g_check_memmap_dev;
 	}
 }
 
+
 int plat_get_image_source(unsigned int image_id, uintptr_t *dev_handle,
 			  uintptr_t *image_spec)
 {
@@ -294,7 +336,7 @@ int plat_get_image_source(unsigned int image_id, uintptr_t *dev_handle,
 
 	assert(image_id < ARRAY_SIZE(s32g_policies));
 
-	set_fip_img_source(&s32g_policies[FIP_IMAGE_ID]);
+	set_img_source(&s32g_policies[image_id], image_id);
 
 	policy = &s32g_policies[image_id];
 	assert(policy && policy->check);
@@ -334,21 +376,14 @@ void s32g_io_setup(void)
 			goto err;
 		if (register_io_dev_mmc(&s32g_mmc_io_conn))
 			goto err;
-		if (io_dev_open(s32g_mmc_io_conn, (uintptr_t)&fip_mmc_spec,
+		if (io_dev_open(s32g_mmc_io_conn,
+				(uintptr_t)get_image_spec_from_id(FIP_IMAGE_ID),
 				&s32g_mmc_dev_handle))
 			goto err;
 		if (io_dev_init(s32g_mmc_dev_handle, FIP_IMAGE_ID))
 			goto err;
 	}
 
-	if (register_io_dev_fip(&s32g_fip_io_conn))
-		goto err;
-	if (io_dev_open(s32g_fip_io_conn, (uintptr_t)&bl31_uuid_spec,
-			&s32g_fip_dev_handle))
-		goto err;
-	if (io_dev_init(s32g_fip_dev_handle, FIP_IMAGE_ID))
-		goto err;
-
 	return;
 err:
 	ERROR("Error: %s failed\n", __func__);
-- 
2.17.1

