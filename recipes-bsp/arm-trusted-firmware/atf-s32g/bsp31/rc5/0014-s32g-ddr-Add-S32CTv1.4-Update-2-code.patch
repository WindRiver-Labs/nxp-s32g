From daa402f07e4d88e5c887a64a709b2f9839038c14 Mon Sep 17 00:00:00 2001
From: Andrei Cherechesu <andrei.cherechesu@nxp.com>
Date: Thu, 11 Nov 2021 20:36:37 +0200
Subject: [PATCH 14/14] s32g: ddr: Add S32CTv1.4 Update 2 code

Added the DDR code from the latest Configuration Tool
version for S32G2/G3/R45 platforms.

Issue: ALB-8104
Upstream-Status: Pending 

Signed-off-by: Andrei Cherechesu <andrei.cherechesu@nxp.com>
Signed-off-by: Zhantao Tang <zhantao.tang@windriver.com>
---
 drivers/nxp/s32g/ddr/ddr_init.c          |   2 +-
 drivers/nxp/s32g/ddr/ddr_lp_mmio.c       |   1 +
 drivers/nxp/s32g/ddr/ddr_utils_mmio.c    | 154 +++++++++++------------
 include/drivers/nxp/s32g/ddr/ddr_lp.h    |  10 +-
 include/drivers/nxp/s32g/ddr/ddr_utils.h | 144 ++++++++++-----------
 5 files changed, 151 insertions(+), 160 deletions(-)

diff --git a/drivers/nxp/s32g/ddr/ddr_init.c b/drivers/nxp/s32g/ddr/ddr_init.c
index f5cc84bb4..27138b3bb 100644
--- a/drivers/nxp/s32g/ddr/ddr_init.c
+++ b/drivers/nxp/s32g/ddr/ddr_init.c
@@ -204,7 +204,7 @@ static uint32_t load_phy_image(uint32_t start_addr, size_t size,
 
 	for (i = 0; i < size; i++) {
 		mmio_write_32((uintptr_t)current_addr, image[i]);
-		current_addr += sizeof(uint32_t);
+		current_addr += (uint32_t)sizeof(uint32_t);
 	}
 	return NO_ERR;
 }
diff --git a/drivers/nxp/s32g/ddr/ddr_lp_mmio.c b/drivers/nxp/s32g/ddr/ddr_lp_mmio.c
index 8e1a2f81d..07afc542e 100644
--- a/drivers/nxp/s32g/ddr/ddr_lp_mmio.c
+++ b/drivers/nxp/s32g/ddr/ddr_lp_mmio.c
@@ -149,6 +149,7 @@ void ddrss_to_io_retention_mode(void)
 	/* Set PwrOkIn to 0 */
 	tmp32 = mmio_read_32(DDR_RET_CONTROL_REG);
 	mmio_write_32(DDR_RET_CONTROL_REG, tmp32 & (~DDR_RET_CONTROL_MASK));
+
 	tmp32 = mmio_read_32(DDR_CONFIG_0_REG);
 	mmio_write_32(DDR_CONFIG_0_REG, tmp32 | DDR_CONFIG_0_MEM_RET);
 }
diff --git a/drivers/nxp/s32g/ddr/ddr_utils_mmio.c b/drivers/nxp/s32g/ddr/ddr_utils_mmio.c
index 56f9f4c35..2e1fefb81 100644
--- a/drivers/nxp/s32g/ddr/ddr_utils_mmio.c
+++ b/drivers/nxp/s32g/ddr/ddr_utils_mmio.c
@@ -40,7 +40,7 @@ static uint32_t enable_axi_ports(void);
 static uint32_t get_mail(uint32_t *mail);
 static uint32_t ack_mail(void);
 static uint32_t init_memory_ecc_scrubber(void);
-static bool sel_clk_src(uint32_t clk_src);
+static void sel_clk_src(uint32_t clk_src, bool *already_set);
 
 #if (ERRATA_S32G2_050543 == 1)
 uint8_t polling_needed = 2;
@@ -64,62 +64,67 @@ bool update_bf(uint32_t *v, uint8_t pos, uint32_t mask, int32_t delta)
 /*
  * Set the ddr clock source, FIRC or DDR_PLL_PHI0.
  * @param clk_src - requested clock source
- * @return - true whether clock source has been changed, false otherwise
+ * @param already_set - whether clock source is already set to clk_src or not
  */
-static bool sel_clk_src(uint32_t clk_src)
+static void sel_clk_src(uint32_t clk_src, bool *already_set)
 {
 	uint32_t tmp32;
-	bool ret = true;
 
 	/* Check if the clock source is already set to clk_src*/
 	tmp32 = mmio_read_32(MC_CGM5_BASE_ADDR + OFFSET_MUX_0_CSS);
 	if (((tmp32 & CSS_SELSTAT_MASK) >> CSS_SELSTAT_POS) == clk_src) {
-		ret = false;
+		*already_set = true;
 	} else {
+		*already_set = false;
+
 		/* To wait till clock switching is completed */
 		do {
 			tmp32 = mmio_read_32(MC_CGM5_BASE_ADDR +
 					     OFFSET_MUX_0_CSS);
-		} while (((tmp32 >> CSS_SWIP_POS) &
-			  CSS_SW_IN_PROGRESS) != CSS_SW_COMPLETED);
+		} while (((tmp32 >> CSS_SWIP_POS) & CSS_SW_IN_PROGRESS) !=
+			 CSS_SW_COMPLETED);
 
 		/* Set DDR_CLK source on src_clk */
 		tmp32 = mmio_read_32(MC_CGM5_BASE_ADDR + OFFSET_MUX_0_CSC);
 		mmio_write_32(MC_CGM5_BASE_ADDR + OFFSET_MUX_0_CSC,
-		      (CSC_SELCTL_MASK & tmp32) | (clk_src << CSC_SELCTL_POS));
+			      (CSC_SELCTL_MASK & tmp32) |
+			      (clk_src << CSC_SELCTL_POS));
 
 		/* Request clock switch */
 		tmp32 = mmio_read_32(MC_CGM5_BASE_ADDR + OFFSET_MUX_0_CSC);
 		mmio_write_32(MC_CGM5_BASE_ADDR + OFFSET_MUX_0_CSC,
-		      (CSC_CLK_SWITCH_REQUEST << CSC_CLK_SWITCH_POS) | tmp32);
+			      (CSC_CLK_SWITCH_REQUEST << CSC_CLK_SWITCH_POS) |
+			      tmp32);
 
 		/* To wait till clock switching is completed */
 		do {
-			tmp32 = mmio_read_32(MC_CGM5_BASE_ADDR + OFFSET_MUX_0_CSS);
-		} while (((tmp32 >> CSS_SWIP_POS) & CSS_SW_IN_PROGRESS) !=
-			 CSS_SW_COMPLETED);
+			tmp32 = mmio_read_32(MC_CGM5_BASE_ADDR +
+					     OFFSET_MUX_0_CSS);
+		} while (((tmp32 >> CSS_SWIP_POS) &
+			  CSS_SW_IN_PROGRESS) != CSS_SW_COMPLETED);
 
 		/* To wait till Switch after request is succeeded */
 		do {
-			tmp32 = mmio_read_32(MC_CGM5_BASE_ADDR + OFFSET_MUX_0_CSS);
+			tmp32 = mmio_read_32(MC_CGM5_BASE_ADDR +
+					     OFFSET_MUX_0_CSS);
 		} while (((tmp32 >> CSS_SW_TRIGGER_CAUSE_POS) &
 			  CSS_SW_AFTER_REQUEST_SUCCEDED) !=
 			 CSS_SW_AFTER_REQUEST_SUCCEDED);
 
 		/* Make sure correct clock source is selected */
 		do {
-			tmp32 = mmio_read_32(MC_CGM5_BASE_ADDR + OFFSET_MUX_0_CSS);
-		} while (((tmp32 & CSS_SELSTAT_MASK) >> CSS_SELSTAT_POS)
-			 != clk_src);
+			tmp32 = mmio_read_32(MC_CGM5_BASE_ADDR +
+					     OFFSET_MUX_0_CSS);
+		} while (((tmp32 & CSS_SELSTAT_MASK) >> CSS_SELSTAT_POS) !=
+			 clk_src);
 	}
-	return ret;
 }
 
 /* Sets default AXI parity. */
 uint32_t set_axi_parity(void)
 {
 	uint32_t tmp32;
-	bool switched_to_firc;
+	bool already_set;
 
 	/* Enable Parity For All AXI Interfaces */
 	tmp32 = mmio_read_32(DDR_SS_REG);
@@ -138,19 +143,18 @@ uint32_t set_axi_parity(void)
 
 	/*
 	 * Set ddr clock source on FIRC_CLK.
-	 * If it's already set on FIRC_CLK, it returns false.
+	 * If it's already set on FIRC_CLK, already_set becomes true.
 	 */
-	switched_to_firc = sel_clk_src(FIRC_CLK_SRC);
+	sel_clk_src(FIRC_CLK_SRC, &already_set);
 
 	/* De-assert Reset To Controller and AXI Ports */
 	tmp32 = mmio_read_32(MC_RGM_PRST_0);
-	mmio_write_32(MC_RGM_PRST_0,
-		~(FORCED_RESET_ON_PERIPH << PRST_0_PERIPH_3_RST_POS) &
-		 tmp32);
+	mmio_write_32(MC_RGM_PRST_0, ~(FORCED_RESET_ON_PERIPH <<
+				       PRST_0_PERIPH_3_RST_POS) & tmp32);
 
-	/* Check if the initial clock source was not on FIRC */
-	if (switched_to_firc)
-		switched_to_firc = sel_clk_src(DDR_PHI0_PLL);
+	/* Check if the initial clock source was not already set on FIRC */
+	if (!already_set)
+		sel_clk_src(DDR_PHI0_PLL, &already_set);
 
 	/* Enable HIF, CAM Queueing */
 	mmio_write_32(DDRC_BASE_ADDR + OFFSET_DDRC_DBG1,
@@ -180,8 +184,7 @@ uint32_t set_axi_parity(void)
 		      ((~PWRCTL_EN_DFI_DRAM_CLOCK_DIS_MASK) & tmp32));
 
 	/* Enable Quasi-Dynamic Programming */
-	mmio_write_32(DDRC_BASE_ADDR + OFFSET_DDRC_SWCTL,
-		      SWCTL_SWDONE_ENABLE);
+	mmio_write_32(DDRC_BASE_ADDR + OFFSET_DDRC_SWCTL, SWCTL_SWDONE_ENABLE);
 
 	/* Confirm Register Programming Done Ack is Cleared */
 	do {
@@ -190,12 +193,11 @@ uint32_t set_axi_parity(void)
 
 	/* DFI_INIT_COMPLETE_EN set to 0 */
 	tmp32 = mmio_read_32(DDRC_BASE_ADDR + OFFSET_DDRC_DFIMISC);
-	mmio_write_32(DDRC_BASE_ADDR + OFFSET_DDRC_DFIMISC,
-		      (~DFIMISC_DFI_INIT_COMPLETE_EN_MASK) & tmp32);
+	mmio_write_32(DDRC_BASE_ADDR + OFFSET_DDRC_DFIMISC, tmp32 &
+		      (~DFIMISC_DFI_INIT_COMPLETE_EN_MASK));
 
 	/* Set SWCTL.sw_done to 1 */
-	mmio_write_32(DDRC_BASE_ADDR + OFFSET_DDRC_SWCTL,
-		      SWCTL_SWDONE_DONE);
+	mmio_write_32(DDRC_BASE_ADDR + OFFSET_DDRC_SWCTL, SWCTL_SWDONE_DONE);
 
 	do {
 		tmp32 = mmio_read_32(DDRC_BASE_ADDR + OFFSET_DDRC_SWSTAT);
@@ -223,7 +225,7 @@ static uint32_t enable_axi_ports(void)
 /*
  * Post PHY training setup - complementary settings that need to be
  * performed after running the firmware.
- * @param options - various flags controlling post training actions
+ *  @param options - various flags controlling post training actions
  * (whether to init memory with ECC scrubber / whether to store CSR)
  */
 uint32_t post_train_setup(uint8_t options)
@@ -245,8 +247,7 @@ uint32_t post_train_setup(uint8_t options)
 #endif
 
 	/* Set SWCTL.sw_done to 0 */
-	mmio_write_32(DDRC_BASE_ADDR + OFFSET_DDRC_SWCTL,
-		      SWCTL_SWDONE_ENABLE);
+	mmio_write_32(DDRC_BASE_ADDR + OFFSET_DDRC_SWCTL, SWCTL_SWDONE_ENABLE);
 	do {
 		tmp32 = mmio_read_32(DDRC_BASE_ADDR + OFFSET_DDRC_SWSTAT);
 	} while ((tmp32 & SWSTAT_SWDONE_ACK_MASK) != SWSTAT_SW_NOT_DONE);
@@ -257,8 +258,7 @@ uint32_t post_train_setup(uint8_t options)
 		      (DFIMISC_DFI_INIT_START_MASK | tmp32));
 
 	/* Set SWCTL.sw_done to 1 */
-	mmio_write_32(DDRC_BASE_ADDR + OFFSET_DDRC_SWCTL,
-		      SWCTL_SWDONE_DONE);
+	mmio_write_32(DDRC_BASE_ADDR + OFFSET_DDRC_SWCTL, SWCTL_SWDONE_DONE);
 	/* Wait SWSTAT.sw_done_ack to 1*/
 	do {
 		tmp32 = mmio_read_32(DDRC_BASE_ADDR + OFFSET_DDRC_SWSTAT);
@@ -271,8 +271,7 @@ uint32_t post_train_setup(uint8_t options)
 		 DFISTAT_DFI_INIT_INCOMPLETE);
 
 	/* Set SWCTL.sw_done to 0 */
-	mmio_write_32(DDRC_BASE_ADDR + OFFSET_DDRC_SWCTL,
-		      SWCTL_SWDONE_ENABLE);
+	mmio_write_32(DDRC_BASE_ADDR + OFFSET_DDRC_SWCTL, SWCTL_SWDONE_ENABLE);
 	do {
 		tmp32 = mmio_read_32(DDRC_BASE_ADDR + OFFSET_DDRC_SWSTAT);
 	} while ((tmp32 & SWSTAT_SWDONE_ACK_MASK) != SWSTAT_SW_NOT_DONE);
@@ -293,8 +292,7 @@ uint32_t post_train_setup(uint8_t options)
 		      ((~PWRCTL_SELFREF_SW_MASK) & tmp32));
 
 	/* Set SWCTL.sw_done to 1 */
-	mmio_write_32(DDRC_BASE_ADDR + OFFSET_DDRC_SWCTL,
-		      SWCTL_SWDONE_DONE);
+	mmio_write_32(DDRC_BASE_ADDR + OFFSET_DDRC_SWCTL, SWCTL_SWDONE_DONE);
 	do {
 		tmp32 = mmio_read_32(DDRC_BASE_ADDR + OFFSET_DDRC_SWSTAT);
 	} while ((tmp32 & SWSTAT_SWDONE_ACK_MASK) == SWSTAT_SW_NOT_DONE);
@@ -324,12 +322,12 @@ uint32_t post_train_setup(uint8_t options)
 		/* Enable power down: PWRCTL.powerdown_en = 1 */
 		tmp32 = mmio_read_32(DDRC_BASE_ADDR + OFFSET_DDRC_PWRCTL);
 		mmio_write_32(DDRC_BASE_ADDR + OFFSET_DDRC_PWRCTL,
-		      PWRCTL_POWER_DOWN_ENABLE_MASK | tmp32);
+			      PWRCTL_POWER_DOWN_ENABLE_MASK | tmp32);
 
-		/* Enable self-refresh: PWRCTL.selfref_en = 1*/
+		/* Enable self-refresh: PWRCTL.selfref_en = 1 */
 		tmp32 = mmio_read_32(DDRC_BASE_ADDR + OFFSET_DDRC_PWRCTL);
 		mmio_write_32(DDRC_BASE_ADDR + OFFSET_DDRC_PWRCTL,
-		      PWRCTL_SELF_REFRESH_ENABLE_MASK | tmp32);
+			      PWRCTL_SELF_REFRESH_ENABLE_MASK | tmp32);
 
 		/*
 		 * Enable assertion of dfi_dram_clk_disable:
@@ -337,11 +335,12 @@ uint32_t post_train_setup(uint8_t options)
 		 */
 		tmp32 = mmio_read_32(DDRC_BASE_ADDR + OFFSET_DDRC_PWRCTL);
 		mmio_write_32(DDRC_BASE_ADDR + OFFSET_DDRC_PWRCTL,
-		      PWRCTL_EN_DFI_DRAM_CLOCK_DIS_MASK | tmp32);
+			      PWRCTL_EN_DFI_DRAM_CLOCK_DIS_MASK | tmp32);
 
 #if (ERRATA_S32G2_050543 == 1)
 		ret |= enable_derating_temp_errata();
 #endif
+
 		/*
 		 * Each platform has a different number of AXI ports so this
 		 * method should be implemented in hardware specific source
@@ -355,24 +354,15 @@ uint32_t post_train_setup(uint8_t options)
 uint32_t wait_firmware_execution(void)
 {
 	uint32_t mail = 0;
-	uint32_t ret;
-	bool exit_loop = false;
+	uint32_t ret = NO_ERR;
 
-	while (!exit_loop) {
-		/* Obtain message from PHY (major message) */
+	while ((mail != TRAINING_OK_MSG) && (ret == NO_ERR)) {
 		ret = get_mail(&mail);
 
-		if (ret == NO_ERR) {
-			if (mail == TRAINING_OK_MSG) {
-				/* 0x07 means OK, 0xFF means failure */
-				exit_loop = true;
-			} else if (mail == TRAINING_FAILED_MSG) {
-				/* Training stage failed */
-				ret = TRAINING_FAILED;
-				exit_loop = true;
-			}
-		} else {
-			exit_loop = true;
+		/* 0x07 means OK, 0xFF means failure */
+		if (mail == TRAINING_FAILED_MSG) {
+			/* Training stage failed */
+			ret = TRAINING_FAILED;
 		}
 	}
 
@@ -388,7 +378,8 @@ static uint32_t ack_mail(void)
 	uint32_t tmp32 = mmio_read_32(DDR_PHYA_APBONLY_UCTSHADOWREGS);
 
 	/* Wait firmware to respond to ACK (UctWriteProtShadow to be set) */
-	while ((--timeout != 0u) && ((tmp32 & UCT_WRITE_PROT_SHADOW_MASK) ==
+	while ((--timeout != 0u) &&
+	       ((tmp32 & UCT_WRITE_PROT_SHADOW_MASK) ==
 				     UCT_WRITE_PROT_SHADOW_ACK))
 		tmp32 = mmio_read_32(DDR_PHYA_APBONLY_UCTSHADOWREGS);
 
@@ -426,7 +417,8 @@ static uint32_t init_memory_ecc_scrubber(void)
 	uint32_t tmp32, pattern = 0x00000000U;
 
 	/* Save previous ecc region parity locked state. */
-	region_lock = (uint8_t)(mmio_read_32(DDRC_BASE_ADDR + OFFSET_DDRC_ECCCFG1) &
+	region_lock = (uint8_t)(mmio_read_32(DDRC_BASE_ADDR +
+					     OFFSET_DDRC_ECCCFG1) &
 				(ECCCFG1_REGION_PARITY_LOCKED <<
 				 ECCCFG1_REGION_PARITY_LOCK_POS));
 
@@ -439,8 +431,8 @@ static uint32_t init_memory_ecc_scrubber(void)
 	/* Set SBRCTL.scrub_mode = 1. */
 	tmp32 = mmio_read_32(DDRC_BASE_ADDR + OFFSET_DDRC_SBRCTL);
 	mmio_write_32(DDRC_BASE_ADDR + OFFSET_DDRC_SBRCTL,
-		      (SBRCTL_SCRUB_MODE_WRITE << SBRCTL_SCRUB_MODE_POS) |
-		       tmp32);
+		      (SBRCTL_SCRUB_MODE_WRITE <<
+		       SBRCTL_SCRUB_MODE_POS) | tmp32);
 
 	/* Set SBRCTL.scrub_during_lowpower = 1. */
 	tmp32 = mmio_read_32(DDRC_BASE_ADDR + OFFSET_DDRC_SBRCTL);
@@ -488,8 +480,8 @@ static uint32_t init_memory_ecc_scrubber(void)
 	/* Enter normal scrub operation (Reads): SBRCTL.scrub_mode = 0. */
 	tmp32 = mmio_read_32(DDRC_BASE_ADDR + OFFSET_DDRC_SBRCTL);
 	mmio_write_32(DDRC_BASE_ADDR + OFFSET_DDRC_SBRCTL,
-		      ~(SBRCTL_SCRUB_MODE_WRITE << SBRCTL_SCRUB_MODE_POS) &
-			tmp32);
+		      ~(SBRCTL_SCRUB_MODE_WRITE <<
+			SBRCTL_SCRUB_MODE_POS) & tmp32);
 
 	/* Set SBRCTL.scrub_interval = 1. */
 	tmp32 = mmio_read_32(DDRC_BASE_ADDR + OFFSET_DDRC_SBRCTL);
@@ -556,8 +548,8 @@ uint32_t read_lpddr4_mr(uint8_t mr_index)
 
 	/* Initiate MR transaction: MR_WR = 0x1 */
 	tmp32 = mmio_read_32(DDRC_BASE_ADDR + OFFSET_DDRC_MRCTRL0);
-	mmio_write_32(DDRC_BASE_ADDR + OFFSET_DDRC_MRCTRL0,
-		      tmp32 | (MRCTRL0_WR_ENGAGE << MRCTRL0_WR_ENGAGE_POS));
+	mmio_write_32(DDRC_BASE_ADDR + OFFSET_DDRC_MRCTRL0, tmp32 |
+		      (MRCTRL0_WR_ENGAGE << MRCTRL0_WR_ENGAGE_POS));
 
 	/* Wait until MR transaction completed */
 	succesive_reads = 0;
@@ -581,7 +573,7 @@ uint32_t write_lpddr4_mr(uint8_t mr_index, uint8_t mr_data)
 	/* Set MRR_DDR_SEL_REG to 0x1 to enable LPDDR4 mode */
 	tmp32 = mmio_read_32(PERF_BASE_ADDR + OFFSET_MRR_0_DATA_REG_ADDR);
 	mmio_write_32(PERF_BASE_ADDR + OFFSET_MRR_0_DATA_REG_ADDR,
-		      tmp32 | MRCTRL0_MR_TYPE_READ);
+		      tmp32 | MRR_0_DDR_SEL_REG_MASK);
 
 	/*
 	 * Ensure no MR transaction is in progress:
@@ -614,8 +606,8 @@ uint32_t write_lpddr4_mr(uint8_t mr_index, uint8_t mr_data)
 
 	/* Initiate MR transaction: MR_WR = 0x1 */
 	tmp32 = mmio_read_32(DDRC_BASE_ADDR + OFFSET_DDRC_MRCTRL0);
-	mmio_write_32(DDRC_BASE_ADDR + OFFSET_DDRC_MRCTRL0,
-		      tmp32 | (MRCTRL0_WR_ENGAGE << MRCTRL0_WR_ENGAGE_POS));
+	mmio_write_32(DDRC_BASE_ADDR + OFFSET_DDRC_MRCTRL0, tmp32 |
+		      (MRCTRL0_WR_ENGAGE << MRCTRL0_WR_ENGAGE_POS));
 
 	/* Wait until MR transaction completed */
 	succesive_reads = 0;
@@ -665,7 +657,6 @@ uint32_t enable_derating_temp_errata(void)
 		polling_needed = 0;
 		return NO_ERR;
 	}
-
 	/* Disable timing parameter derating: DERATEEN.DERATE_EN = 0 */
 	tmp32 = mmio_read_32(DDRC_BASE_ADDR + OFFSET_DDRC_DERATEEN);
 	mmio_write_32(DDRC_BASE_ADDR + OFFSET_DDRC_DERATEEN,
@@ -678,8 +669,7 @@ uint32_t enable_derating_temp_errata(void)
 	tmp32 = mmio_read_32(DDRC_BASE_ADDR + OFFSET_DDRC_RFSHTMG);
 	bf_val = (tmp32 >> RFSHTMG_VAL_SHIFT) & RFSHTMG_VAL;
 	bf_val = bf_val >> RFSHTMG_UPDATE_SHIFT;
-	tmp32 = (tmp32 & ~RFSHTMG_MASK) |
-		(uint32_t)(bf_val << RFSHTMG_VAL_SHIFT);
+	tmp32 = (tmp32 & ~RFSHTMG_MASK) | (bf_val << RFSHTMG_VAL_SHIFT);
 	mmio_write_32(DDRC_BASE_ADDR + OFFSET_DDRC_RFSHTMG, tmp32);
 
 	/*
@@ -693,13 +683,13 @@ uint32_t enable_derating_temp_errata(void)
 	mmio_write_32(DDRC_BASE_ADDR + OFFSET_DDRC_RFSHCTL3, tmp32);
 
 	/* Set SWCTL.sw_done to 0 */
-	mmio_write_32(DDRC_BASE_ADDR + OFFSET_DDRC_SWCTL,
-		      SWCTL_SWDONE_ENABLE);
+	mmio_write_32(DDRC_BASE_ADDR + OFFSET_DDRC_SWCTL, SWCTL_SWDONE_ENABLE);
 	do {
 		tmp32 = mmio_read_32(DDRC_BASE_ADDR + OFFSET_DDRC_SWSTAT);
 	} while ((tmp32 & SWSTAT_SWDONE_ACK_MASK) != SWSTAT_SW_NOT_DONE);
 
 	tmp32 = mmio_read_32(DDRC_BASE_ADDR + OFFSET_DDRC_DRAMTMG4);
+
 	/*
 	 * Set minimum time from activate to read/write command to same
 	 * bank: DRAMTMG4.T_RCD += 2
@@ -723,8 +713,8 @@ uint32_t enable_derating_temp_errata(void)
 	 * DRAMTMG0.T_RAS_MIN += 2
 	 */
 	tmp32 = mmio_read_32(DDRC_BASE_ADDR + OFFSET_DDRC_DRAMTMG0);
-	if (!update_bf(&tmp32, DRAMTMG0_TRAS_POS,
-		       DRAMTMG0_TRAS_MASK, DRAMTMG0_TRAS_DELTA_TIME))
+	if (!update_bf(&tmp32, DRAMTMG0_TRAS_POS, DRAMTMG0_TRAS_MASK,
+		       DRAMTMG0_TRAS_DELTA_TIME))
 		return BITFIELD_EXCEEDED;
 
 	mmio_write_32(DDRC_BASE_ADDR + OFFSET_DDRC_DRAMTMG0, tmp32);
@@ -734,8 +724,8 @@ uint32_t enable_derating_temp_errata(void)
 	 * same bank: DRAMTMG4.T_RP += 2
 	 */
 	tmp32 = mmio_read_32(DDRC_BASE_ADDR + OFFSET_DDRC_DRAMTMG4);
-	if (!update_bf(&tmp32, DRAMTMG4_TRP_POS,
-		       DRAMTMG4_TRP_MASK, DRAMTMG4_TRP_DELTA_TIME))
+	if (!update_bf(&tmp32, DRAMTMG4_TRP_POS, DRAMTMG4_TRP_MASK,
+		       DRAMTMG4_TRP_DELTA_TIME))
 		return BITFIELD_EXCEEDED;
 
 	mmio_write_32(DDRC_BASE_ADDR + OFFSET_DDRC_DRAMTMG4, tmp32);
@@ -745,8 +735,8 @@ uint32_t enable_derating_temp_errata(void)
 	 * DRAMTMG1.T_RC += 3
 	 */
 	tmp32 = mmio_read_32(DDRC_BASE_ADDR + OFFSET_DDRC_DRAMTMG1);
-	if (!update_bf(&tmp32, DRAMTMG1_TRC_POS,
-		       DRAMTMG1_TRC_MASK, DRAMTMG1_TRC_DELTA_TIME))
+	if (!update_bf(&tmp32, DRAMTMG1_TRC_POS, DRAMTMG1_TRC_MASK,
+		       DRAMTMG1_TRC_DELTA_TIME))
 		return BITFIELD_EXCEEDED;
 
 	mmio_write_32(DDRC_BASE_ADDR + OFFSET_DDRC_DRAMTMG1, tmp32);
diff --git a/include/drivers/nxp/s32g/ddr/ddr_lp.h b/include/drivers/nxp/s32g/ddr/ddr_lp.h
index 6afdebc6a..2a608fb50 100644
--- a/include/drivers/nxp/s32g/ddr/ddr_lp.h
+++ b/include/drivers/nxp/s32g/ddr/ddr_lp.h
@@ -36,20 +36,20 @@
 #define DDRSS_BASE_ADDR                 0x40380000U
 
 #define DDR_GPR_OFFSET                  (0x4007c600U)
-#define DDR_CONFIG_0_REG                (DDR_GPR_OFFSET + 0x00U)
-#define DDR_RET_CONTROL_REG             (DDR_GPR_OFFSET + 0x1cU)
+#define DDR_CONFIG_0_REG                (uint32_t)(DDR_GPR_OFFSET + 0x00U)
+#define DDR_RET_CONTROL_REG             (uint32_t)(DDR_GPR_OFFSET + 0x1cU)
 #define DDR_RET_CONTROL_MASK            SHIFT_BIT(0)
 #define DDR_CONFIG_0_MEM_RET            SHIFT_BIT(14)
 
 #define DFI_FREQUENCY(f)                ((f) << 8)
-#define SELFREF_STATE_SRPD              (0x2UL << 8)
+#define SELFREF_STATE_SRPD              ((uint32_t)0x2U << 8)
 #define SELFREF_STATE_MASK              (SHIFT_BIT(8) | SHIFT_BIT(9))
-#define SELFREF_TYPE_NOT_AUTO_SR_CTRL   (0x2UL << 4)
+#define SELFREF_TYPE_NOT_AUTO_SR_CTRL   ((uint32_t)0x2U << 4)
 #define OPERATING_MODE_SELF_REFRESH     0x3U
 
 #define DISABLE_AXI_PORT                0x0
 #define DFIMISC_TRANSITION_PHY_TO_LP3   0x0
-#define DFIMISC_LP3_PHY_STATE           0x1fUL
+#define DFIMISC_LP3_PHY_STATE           (uint32_t)0x1fU
 #define	STAT_RESET_VALUE                0x0U
 
 extern const uint32_t csr_to_store[];
diff --git a/include/drivers/nxp/s32g/ddr/ddr_utils.h b/include/drivers/nxp/s32g/ddr/ddr_utils.h
index e024729d4..68f20cbdd 100644
--- a/include/drivers/nxp/s32g/ddr/ddr_utils.h
+++ b/include/drivers/nxp/s32g/ddr/ddr_utils.h
@@ -44,29 +44,29 @@
 #define BITFIELD_EXCEEDED   0x00000004U
 
 /* DDRC related */
-#define DDRC_BASE_ADDR                   0x403C0000U
-#define OFFSET_DDRC_SWCTL                0x320U
-#define OFFSET_DDRC_DFIMISC              0x1b0U
-#define OFFSET_DDRC_DFISTAT              0x1bcU
-#define OFFSET_DDRC_PWRCTL               0x30U
-#define OFFSET_DDRC_SWSTAT               0x324U
-#define OFFSET_DDRC_STAT                 0x04U
-#define OFFSET_DDRC_DBG1                 0x304U
-#define OFFSET_DDRC_ECCCFG0              0x70U
-#define OFFSET_DDRC_ECCCFG1              0x74U
-#define OFFSET_DDRC_SBRCTL               0xf24U
-#define OFFSET_DDRC_SBRSTAT              0xf28U
-#define OFFSET_DDRC_SBRWDATA0            0xf2cU
-#define OFFSET_DDRC_MRSTAT               0x18U
-#define OFFSET_DDRC_MRCTRL0              0x10U
-#define OFFSET_DDRC_MRCTRL1              0x14U
+#define DDRC_BASE_ADDR                   (uint32_t)0x403C0000U
+#define OFFSET_DDRC_SWCTL                (uint32_t)0x320U
+#define OFFSET_DDRC_DFIMISC              (uint32_t)0x1b0U
+#define OFFSET_DDRC_DFISTAT              (uint32_t)0x1bcU
+#define OFFSET_DDRC_PWRCTL               (uint32_t)0x30U
+#define OFFSET_DDRC_SWSTAT               (uint32_t)0x324U
+#define OFFSET_DDRC_STAT                 (uint32_t)0x04U
+#define OFFSET_DDRC_DBG1                 (uint32_t)0x304U
+#define OFFSET_DDRC_ECCCFG0              (uint32_t)0x70U
+#define OFFSET_DDRC_ECCCFG1              (uint32_t)0x74U
+#define OFFSET_DDRC_SBRCTL               (uint32_t)0xf24U
+#define OFFSET_DDRC_SBRSTAT              (uint32_t)0xf28U
+#define OFFSET_DDRC_SBRWDATA0            (uint32_t)0xf2cU
+#define OFFSET_DDRC_MRSTAT               (uint32_t)0x18U
+#define OFFSET_DDRC_MRCTRL0              (uint32_t)0x10U
+#define OFFSET_DDRC_MRCTRL1              (uint32_t)0x14U
 
 #if (ERRATA_S32G2_050543 == 1)
-#define OFFSET_DDRC_DERATEEN             0x20U
-#define OFFSET_DDRC_RFSHTMG              0x64U
-#define OFFSET_DDRC_DRAMTMG0             0x100U
-#define OFFSET_DDRC_DRAMTMG1             0x104U
-#define OFFSET_DDRC_DRAMTMG4             0x110U
+#define OFFSET_DDRC_DERATEEN             (uint32_t)0x20U
+#define OFFSET_DDRC_RFSHTMG              (uint32_t)0x64U
+#define OFFSET_DDRC_DRAMTMG0             (uint32_t)0x100U
+#define OFFSET_DDRC_DRAMTMG1             (uint32_t)0x104U
+#define OFFSET_DDRC_DRAMTMG4             (uint32_t)0x110U
 #endif
 
 /* DDRC masks and values */
@@ -80,7 +80,7 @@
 
 #if (ERRATA_S32G2_050543 == 1)
 #define RFSHTMG_VAL_SHIFT           16
-#define RFSHTMG_VAL                 0xfffUL
+#define RFSHTMG_VAL                 (uint32_t)0xfffU
 #define RFSHTMG_MASK                (RFSHTMG_VAL << \
 	RFSHTMG_VAL_SHIFT)
 #define RFSHCTL3_UPDATE_SHIFT       1
@@ -144,58 +144,58 @@
 #define	DFISTAT_DFI_INIT_DONE		0x1U
 #define	DFISTAT_DFI_INIT_INCOMPLETE	0x0U
 #define	PWRCTL_SELFREF_SW_MASK		0x00000020U
-#define	STAT_OPERATING_MODE_MASK		0x7U
-#define	STAT_OPERATING_MODE_INIT		0x0U
+#define	STAT_OPERATING_MODE_MASK	0x7U
+#define	STAT_OPERATING_MODE_INIT	0x0U
 #define	RFSHCTL3_DIS_AUTO_REFRESH_MASK	0x00000001U
 #define	ECCCFG0_ECC_MODE_MASK		0x7U
 #define	ECCCFG0_ECC_DISABLED		0x0U
 #define	TRAINING_OK_MSG			0x07U
 #define	TRAINING_FAILED_MSG		0xFFU
-#define	ECCCFG1_REGION_PARITY_LOCKED	0x1UL
+#define	ECCCFG1_REGION_PARITY_LOCKED	(uint32_t)0x1U
 #define	ECCCFG1_REGION_PARITY_LOCK_POS	4
-#define	SBRCTL_SCRUB_MODE_WRITE		0x1UL
+#define	SBRCTL_SCRUB_MODE_WRITE		(uint32_t)0x1U
 #define	SBRCTL_SCRUB_MODE_POS		2
 
-#define	APBONLY_DCTWRITEPROT_ACK_EN	0
-#define	APBONLY_DCTWRITEPROT_ACK_DIS	1
-#define	SBRCTL_SCRUB_DURING_LOWPOWER_CONTINUED	0x1UL
-#define	SBRCTL_SCRUB_DURING_LOWPOWER_POS		1
-
-#define	SBRCTL_SCRUB_INTERVAL_FIELD	0x1FFFU
-#define	SBRCTL_SCRUB_INTERVAL_POS		8
-#define	SBRCTL_SCRUB_EN		0x1U
-#define	SBRSTAT_SCRUB_DONE_MASK		0x2U
-#define	SBRSTAT_SCRUBBER_NOT_DONE		0x0U
-#define	SBRSTAT_SCRUBBER_BUSY_MASK		0x1U
-#define	SBRSTAT_SCRUBBER_NOT_BUSY		0x0U
-#define	SBRCTL_SCRUB_INTERVAL_VALUE_1	0x1UL
-#define	MRR_0_DDR_SEL_REG_MASK	0x1U
-
-#define	MRSTAT_MR_BUSY			0x1U
-#define	MRSTAT_MR_NOT_BUSY			0x0U
-#define	MRCTRL0_MR_TYPE_READ		0x1U
-#define	MRCTRL0_RANK_ACCESS_POS		4
-#define	MRCTRL0_RANK_ACCESS_FIELD		0xfUL
-#define	MRCTRL0_RANK_0			0x1UL
-#define	MRCTRL1_MR_ADDRESS_FIELD		0xffUL
-#define	MRCTRL1_MR_ADDRESS_POS		8
-#define	MRCTRL0_WR_ENGAGE			0x1UL
-#define	MRCTRL0_WR_ENGAGE_POS		31
-#define	MRCTRL1_MR_DATA_ADDRESS_FIELD	0xffffUL
-#define	MRCTRL1_MR_DATA_ADDRESS_POS	16
-#define STORE_CSR_DISABLED			0x0U
-#define INIT_MEM_DISABLED			0x0U
+#define	APBONLY_DCTWRITEPROT_ACK_EN              0
+#define	APBONLY_DCTWRITEPROT_ACK_DIS             1
+#define	SBRCTL_SCRUB_DURING_LOWPOWER_CONTINUED   (uint32_t)0x1U
+#define	SBRCTL_SCRUB_DURING_LOWPOWER_POS         1
+
+#define	SBRCTL_SCRUB_INTERVAL_FIELD     0x1FFFU
+#define	SBRCTL_SCRUB_INTERVAL_POS       8
+#define	SBRCTL_SCRUB_EN	                0x1U
+#define	SBRSTAT_SCRUB_DONE_MASK         0x2U
+#define	SBRSTAT_SCRUBBER_NOT_DONE       0x0U
+#define	SBRSTAT_SCRUBBER_BUSY_MASK      0x1U
+#define	SBRSTAT_SCRUBBER_NOT_BUSY       0x0U
+#define	SBRCTL_SCRUB_INTERVAL_VALUE_1   (uint32_t)0x1U
+#define	MRR_0_DDR_SEL_REG_MASK          0x1U
+
+#define	MRSTAT_MR_BUSY                  0x1U
+#define	MRSTAT_MR_NOT_BUSY              0x0U
+#define	MRCTRL0_MR_TYPE_READ            0x1U
+#define	MRCTRL0_RANK_ACCESS_POS         4
+#define	MRCTRL0_RANK_ACCESS_FIELD       (uint32_t)0xfU
+#define	MRCTRL0_RANK_0                  0x1U
+#define	MRCTRL1_MR_ADDRESS_FIELD        (uint32_t)0xffU
+#define	MRCTRL1_MR_ADDRESS_POS          8
+#define	MRCTRL0_WR_ENGAGE               (uint32_t)0x1U
+#define	MRCTRL0_WR_ENGAGE_POS           31
+#define	MRCTRL1_MR_DATA_ADDRESS_FIELD   (uint32_t)0xffffU
+#define	MRCTRL1_MR_DATA_ADDRESS_POS     16
+#define STORE_CSR_DISABLED              0x0U
+#define INIT_MEM_DISABLED               0x0U
 
 /* Performance monitoring registers */
-#define PERF_BASE_ADDR                   0x403E0000U
-#define OFFSET_MRR_0_DATA_REG_ADDR       0x40U
-#define OFFSET_MRR_1_DATA_REG_ADDR       0x44U
+#define PERF_BASE_ADDR                   (uint32_t)0x403E0000U
+#define OFFSET_MRR_0_DATA_REG_ADDR       (uint32_t)0x40U
+#define OFFSET_MRR_1_DATA_REG_ADDR       (uint32_t)0x44U
 
 /* uMCTL2 Multi-Port Registers */
-#define DDRC_UMCTL2_MP_BASE_ADDR         0x403C03F8U
-#define OFFSET_DDRC_PCTRL_0              0x98U
-#define OFFSET_DDRC_PCTRL_1              0x148U
-#define OFFSET_DDRC_PCTRL_2              0x1f8U
+#define DDRC_UMCTL2_MP_BASE_ADDR         (uint32_t)0x403C03F8U
+#define OFFSET_DDRC_PCTRL_0              (uint32_t)0x98U
+#define OFFSET_DDRC_PCTRL_1              (uint32_t)0x148U
+#define OFFSET_DDRC_PCTRL_2              (uint32_t)0x1f8U
 
 /* PHY related */
 #define DDR_PHYA_MASTER0_CALBUSY		0x4038165C
@@ -203,14 +203,14 @@
 #define UCT_WRITE_PROT_SHADOW_MASK              0x1U
 #define DDR_PHYA_DCTWRITEPROT			0x4038040C
 #define DDR_PHYA_APBONLY_UCTWRITEONLYSHADOW	0x40380410
-#define OFFSET_DDRC_RFSHCTL3			0x60U
+#define OFFSET_DDRC_RFSHCTL3			(uint32_t)0x60U
 #define DDR_PHYA_UCCLKHCLKENABLES		0x40380BEC
 #define UCT_WRITE_PROT_SHADOW_ACK		0x0U
 
-#define SHIFT_BIT(nr)             ((1UL) << (nr))
+#define SHIFT_BIT(nr)             (((uint32_t)0x1U) << (nr))
 #define UCCLKEN_MASK              SHIFT_BIT(0)
 #define HCLKEN_MASK               SHIFT_BIT(1)
-#define OFFSET_DDRC_INIT0         0xd0U
+#define OFFSET_DDRC_INIT0         (uint32_t)0xd0U
 
 #define STORE_CSR_MASK            SHIFT_BIT(0)
 #define INIT_MEM_MASK             SHIFT_BIT(1)
@@ -235,10 +235,10 @@
 /* Reset Generation Module */
 #define MC_RGM_PRST_0             0x40078040
 #ifndef MC_CGM5_BASE_ADDR
-#define MC_CGM5_BASE_ADDR         0x40068000U
+#define MC_CGM5_BASE_ADDR         (uint32_t)0x40068000U
 #endif
-#define OFFSET_MUX_0_CSS          0x304U
-#define OFFSET_MUX_0_CSC          0x300U
+#define OFFSET_MUX_0_CSS          (uint32_t)0x304U
+#define OFFSET_MUX_0_CSC          (uint32_t)0x300U
 #define FIRC_CLK_SRC              0x0U
 #define DDR_PHI0_PLL              0x24U
 
@@ -251,10 +251,10 @@
 
 #if (ERRATA_S32G2_050543 == 1)
 /* ERR050543 related defines */
-#define MR4_IDX 4
-#define MR4_MASK	0x7U
-#define MR4_SHIFT	16
-#define TUF_THRESHOLD 0x3U
+#define MR4_IDX            4
+#define MR4_MASK           0x7U
+#define MR4_SHIFT          16
+#define TUF_THRESHOLD      0x3U
 #define REQUIRED_OK_CHECKS 0x3U
 #endif
 
-- 
2.17.1

