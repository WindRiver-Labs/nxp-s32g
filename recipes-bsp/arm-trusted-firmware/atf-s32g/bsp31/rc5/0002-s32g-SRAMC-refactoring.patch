From 5160f092881981cf68ced5048c6c78408c6cb819 Mon Sep 17 00:00:00 2001
From: Ghennadi Procopciuc <ghennadi.procopciuc@nxp.com>
Date: Mon, 25 Oct 2021 11:32:40 +0300
Subject: [PATCH 02/14] s32g: SRAMC refactoring

Move SRAMC initialization from assembly code to C implementation
by using a small, temporary stack in .data section. This helps
code maintenance and adds readability.

Issue: ALB-8002
Upstream-Status: Pending 

Signed-off-by: Ghennadi Procopciuc <ghennadi.procopciuc@nxp.com>
Signed-off-by: Zhantao Tang <zhantao.tang@windriver.com>
---
 plat/nxp/s32/s32g/include/s32g_platform_def.h |   1 -
 plat/nxp/s32/s32g/include/s32g_sramc.h        |  69 +---
 .../nxp/s32/s32g/s32g2/include/platform_def.h |   2 +
 plat/nxp/s32/s32g/s32g2/platform.mk           |   1 +
 plat/nxp/s32/s32g/s32g2/s32g2_sramc.c         |  42 +++
 .../nxp/s32/s32g/s32g3/include/platform_def.h |   1 +
 plat/nxp/s32/s32g/s32g3/platform.mk           |   1 +
 plat/nxp/s32/s32g/s32g3/s32g3_sramc.c         |  59 ++++
 plat/nxp/s32/s32g/s32g_bl2_el3.c              |   8 +-
 plat/nxp/s32/s32g/s32g_lowlevel_bl2.S         |  20 +-
 plat/nxp/s32/s32g/s32g_psci.c                 |   2 +-
 plat/nxp/s32/s32g/s32g_sramc.c                | 110 +++++--
 plat/nxp/s32/s32g/s32g_sramc_asm.S            | 307 +-----------------
 13 files changed, 231 insertions(+), 392 deletions(-)
 create mode 100644 plat/nxp/s32/s32g/s32g2/s32g2_sramc.c
 create mode 100644 plat/nxp/s32/s32g/s32g3/s32g3_sramc.c

diff --git a/plat/nxp/s32/s32g/include/s32g_platform_def.h b/plat/nxp/s32/s32g/include/s32g_platform_def.h
index 42ab48935..ada537895 100644
--- a/plat/nxp/s32/s32g/include/s32g_platform_def.h
+++ b/plat/nxp/s32/s32g/include/s32g_platform_def.h
@@ -102,7 +102,6 @@
  * Virtual Code RAM
  */
 #define S32G_SRAM_BASE		0x34000000
-#define S32G_SRAM_SIZE		0x00800000
 #define S32G_SRAM_END		(S32G_SRAM_BASE + S32G_SRAM_SIZE)
 
 #define S32G_SSRAM_BASE		(0x24000000)
diff --git a/plat/nxp/s32/s32g/include/s32g_sramc.h b/plat/nxp/s32/s32g/include/s32g_sramc.h
index 96f1deb23..420f1054e 100644
--- a/plat/nxp/s32/s32g/include/s32g_sramc.h
+++ b/plat/nxp/s32/s32g/include/s32g_sramc.h
@@ -8,71 +8,26 @@
 
 #include <lib/utils_def.h>
 
-#define S32G_SRAM_BASE          0x34000000
-#define S32G_SRAM_SIZE          0x00800000
-#define S32G_SRAM_END           (S32G_SRAM_BASE + S32G_SRAM_SIZE)
-
-/* SRAM controller is able to erase 64 bits at once */
-#define SRAM_BLOCK              512
-#define SRAM_BLOCK_MASK         (SRAM_BLOCK - 1)
-#define SRAM_INV_BLOCK_MASK     (~(SRAM_BLOCK_MASK))
-
 #define SRAMC0_BASE_ADDR        0x4019C000
-#define SRAMC0_BASE_ADDR_H      (SRAMC0_BASE_ADDR >> 16)
-#define SRAMC0_BASE_ADDR_L      ((SRAMC0_BASE_ADDR & 0xFFFF))
 #define SRAMC1_BASE_ADDR        0x401A0000
-#define SRAMC1_BASE_ADDR_H      (SRAMC1_BASE_ADDR >> 16)
-#define SRAMC1_BASE_ADDR_L      ((SRAMC1_BASE_ADDR & 0xFFFF))
-#if defined(PLAT_s32g3)
-#define SRAMC2_BASE_ADDR        0x4055A000
-#define SRAMC2_BASE_ADDR_H      (SRAMC0_BASE_ADDR >> 16)
-#define SRAMC2_BASE_ADDR_L      ((SRAMC0_BASE_ADDR & 0xFFFF))
-#define SRAMC3_BASE_ADDR        0x4055E000
-#define SRAMC3_BASE_ADDR_H      (SRAMC1_BASE_ADDR >> 16)
-#define SRAMC3_BASE_ADDR_L      ((SRAMC1_BASE_ADDR & 0xFFFF))
-#endif
-#define SSRAMC_BASE_ADDR        0x44028000
 #define SRAMC_SIZE              0x3000
 
-/* Block ranges */
-
-#if defined(PLAT_s32g2)
-#define SRAMC0_MIN_ADDR         (0x0)
-#define SRAMC0_MAX_ADDR         (0x7FFF)
-#define SRAMC1_MIN_ADDR         (SRAMC0_MAX_ADDR + 1)
-#define SRAMC1_MAX_ADDR         (0x10000)
-
-#elif defined(PLAT_s32g3)
-#define SRAMC0_MIN_ADDR         (0x0)
-#define SRAMC0_MAX_ADDR         (0x7FFF)
-#define SRAMC1_MIN_ADDR         (SRAMC0_MAX_ADDR + 1)
-#define SRAMC1_MAX_ADDR         (0xFFFF)
-#define SRAMC2_MIN_ADDR         (SRAMC1_MAX_ADDR + 1)
-#define SRAMC2_MAX_ADDR         (0x17FFF)
-#define SRAMC2_MAX_ADDR_H       (SRAMC2_MAX_ADDR >> 16)
-#define SRAMC2_MAX_ADDR_L       (SRAMC2_MAX_ADDR & 0xFFFF)
-#define SRAMC3_MIN_ADDR         (SRAMC2_MAX_ADDR + 1)
-#define SRAMC3_MIN_ADDR_H       (SRAMC3_MIN_ADDR >> 16)
-#define SRAMC3_MIN_ADDR_L       (SRAMC3_MIN_ADDR & 0xFFFF)
-#define SRAMC3_MAX_ADDR         (0x1FFFF)
-#define SRAMC3_MAX_ADDR_H       (SRAMC3_MAX_ADDR >> 16)
-#define SRAMC3_MAX_ADDR_L       (SRAMC3_MAX_ADDR & 0xFFFF)
-#endif
-
-#define SRAMC_PRAMCR_OFFSET     0x0
-#define SRAMC_PRAMCR_INITREQ    1
-#define SRAMC_PRAMIAS_OFFSET    0x4
-#define SRAMC_PRAMIAE_OFFSET    0x8
-#define SRAMC_PRAMSR_OFFSET     0xC
-#define SRAMC_PRAMSR_IDONE      1
-
-#define SSRAM_MAX_ADDR          0x7FF
+#define SSRAMC_BASE_ADDR        0x44028000
 
 #ifndef __ASSEMBLER__
+#include <stddef.h>
 #include <stdint.h>
 
-int s32g_sram_clear(uintptr_t start, uintptr_t end);
-void s32g_ssram_clear(void);
+struct sram_ctrl {
+	uintptr_t base_addr;
+	uint32_t min_addr;
+	uint32_t max_addr;
+};
+
+int s32_sram_clear(uintptr_t start, uintptr_t end);
+void s32_ssram_clear(void);
+void s32_get_sramc(struct sram_ctrl **ctrls, size_t *size);
+uintptr_t a53_to_sramc_addr(uintptr_t addr);
 #endif
 #endif
 
diff --git a/plat/nxp/s32/s32g/s32g2/include/platform_def.h b/plat/nxp/s32/s32g/s32g2/include/platform_def.h
index 2daa88b55..659f9834b 100644
--- a/plat/nxp/s32/s32g/s32g2/include/platform_def.h
+++ b/plat/nxp/s32/s32g/s32g2/include/platform_def.h
@@ -19,5 +19,7 @@
 #define S32G_MPIDR_CPU_MASK		0x1
 #define S32G_MPIDR_CPU_MASK_BITS	0x1
 
+#define S32G_SRAM_SIZE			0x00800000
+
 #endif /* PLATFORM_DEF_H */
 
diff --git a/plat/nxp/s32/s32g/s32g2/platform.mk b/plat/nxp/s32/s32g/s32g2/platform.mk
index 12573f9c1..ecba75be2 100644
--- a/plat/nxp/s32/s32g/s32g2/platform.mk
+++ b/plat/nxp/s32/s32g/s32g2/platform.mk
@@ -17,6 +17,7 @@ PLAT_INCLUDES		+= -Iplat/nxp/s32/s32g/s32g2/include \
 PLAT_BL_COMMON_SOURCES	+= drivers/nxp/s32g/clk/s32g274a_clk.c \
 			   plat/nxp/s32/s32g/s32g2/s32g2_mc_me.c \
 			   plat/nxp/s32/s32g/s32g2/s32g2_mc_rgm.c \
+			   plat/nxp/s32/s32g/s32g2/s32g2_sramc.c \
 			   lib/cpus/aarch64/s32g2.S \
 			   lib/cpus/aarch64/cortex_a53.S \
 
diff --git a/plat/nxp/s32/s32g/s32g2/s32g2_sramc.c b/plat/nxp/s32/s32g/s32g2/s32g2_sramc.c
new file mode 100644
index 000000000..4c397d2ce
--- /dev/null
+++ b/plat/nxp/s32/s32g/s32g2/s32g2_sramc.c
@@ -0,0 +1,42 @@
+/*
+ * Copyright 2021 NXP
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ */
+#include <platform_def.h>
+#include <s32g_sramc.h>
+
+#define SRAMC0_MIN_ADDR         (0x0)
+#define SRAMC0_MAX_ADDR         (0x7FFF)
+#define SRAMC1_MIN_ADDR         (SRAMC0_MAX_ADDR + 1)
+#define SRAMC1_MAX_ADDR         (0x10000)
+
+void s32_get_sramc(struct sram_ctrl **ctrls, size_t *size)
+{
+	static struct sram_ctrl controllers[] = {
+		{
+			.base_addr = SRAMC0_BASE_ADDR,
+			.min_addr = SRAMC0_MIN_ADDR,
+			.max_addr = SRAMC0_MAX_ADDR,
+		},
+		{
+			.base_addr = SRAMC1_BASE_ADDR,
+			.min_addr = SRAMC1_MIN_ADDR,
+			.max_addr = SRAMC1_MAX_ADDR,
+		},
+	};
+
+	*ctrls = &controllers[0];
+	*size = ARRAY_SIZE(controllers);
+}
+
+uintptr_t a53_to_sramc_addr(uintptr_t addr)
+{
+	addr -= S32G_SRAM_BASE;
+
+	/* mem_addr[16:0] = {bus_addr[23:9], bus_addr[5:4]} */
+	addr = ((addr >> 9) << 2) | ((addr >> 4) & 0x3);
+
+	return addr;
+}
+
diff --git a/plat/nxp/s32/s32g/s32g3/include/platform_def.h b/plat/nxp/s32/s32g/s32g3/include/platform_def.h
index db92a7668..dadcf3927 100644
--- a/plat/nxp/s32/s32g/s32g3/include/platform_def.h
+++ b/plat/nxp/s32/s32g/s32g3/include/platform_def.h
@@ -23,6 +23,7 @@
 #define S32G_MPIDR_CPU_MASK		0x3
 #define S32G_MPIDR_CPU_MASK_BITS	0x2
 
+#define S32G_SRAM_SIZE			0x1400000
 
 #endif /* PLATFORM_DEF_H */
 
diff --git a/plat/nxp/s32/s32g/s32g3/platform.mk b/plat/nxp/s32/s32g/s32g3/platform.mk
index 391b5525d..8504db415 100644
--- a/plat/nxp/s32/s32g/s32g3/platform.mk
+++ b/plat/nxp/s32/s32g/s32g3/platform.mk
@@ -16,6 +16,7 @@ PLAT_INCLUDES		+= -Iplat/nxp/s32/s32g/s32g3/include \
 
 PLAT_BL_COMMON_SOURCES	+= plat/nxp/s32/s32g/s32g3/s32g3_mc_me.c \
 			   plat/nxp/s32/s32g/s32g3/s32g3_mc_rgm.c \
+			   plat/nxp/s32/s32g/s32g3/s32g3_sramc.c \
 			   drivers/nxp/s32g/clk/s32g398a_clk.c \
 			   lib/cpus/aarch64/cortex_a53.S \
 
diff --git a/plat/nxp/s32/s32g/s32g3/s32g3_sramc.c b/plat/nxp/s32/s32g/s32g3/s32g3_sramc.c
new file mode 100644
index 000000000..c70996145
--- /dev/null
+++ b/plat/nxp/s32/s32g/s32g3/s32g3_sramc.c
@@ -0,0 +1,59 @@
+/*
+ * Copyright 2021 NXP
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ */
+#include <platform_def.h>
+#include <s32g_sramc.h>
+
+#define SRAMC2_BASE_ADDR        0x4055A000
+#define SRAMC3_BASE_ADDR        0x4055E000
+
+#define SRAMC0_MIN_ADDR         (0x0)
+#define SRAMC0_MAX_ADDR         (0x7FFF)
+#define SRAMC1_MIN_ADDR         (SRAMC0_MAX_ADDR + 1)
+#define SRAMC1_MAX_ADDR         (0xFFFF)
+#define SRAMC2_MIN_ADDR         (SRAMC1_MAX_ADDR + 1)
+#define SRAMC2_MAX_ADDR         (0x17FFF)
+#define SRAMC3_MIN_ADDR         (SRAMC2_MAX_ADDR + 1)
+#define SRAMC3_MAX_ADDR         (0x1FFFF)
+
+void s32_get_sramc(struct sram_ctrl **ctrls, size_t *size)
+{
+	static struct sram_ctrl controllers[] = {
+		{
+			.base_addr = SRAMC0_BASE_ADDR,
+			.min_addr = SRAMC0_MIN_ADDR,
+			.max_addr = SRAMC0_MAX_ADDR,
+		},
+		{
+			.base_addr = SRAMC1_BASE_ADDR,
+			.min_addr = SRAMC1_MIN_ADDR,
+			.max_addr = SRAMC1_MAX_ADDR,
+		},
+		{
+			.base_addr = SRAMC2_BASE_ADDR,
+			.min_addr = SRAMC2_MIN_ADDR,
+			.max_addr = SRAMC2_MAX_ADDR,
+		},
+		{
+			.base_addr = SRAMC3_BASE_ADDR,
+			.min_addr = SRAMC3_MIN_ADDR,
+			.max_addr = SRAMC3_MAX_ADDR,
+		},
+	};
+
+	*ctrls = &controllers[0];
+	*size = ARRAY_SIZE(controllers);
+}
+
+uintptr_t a53_to_sramc_addr(uintptr_t addr)
+{
+	addr -= S32G_SRAM_BASE;
+
+	/* mem_addr[16:0] = {bus_addr[23:10], bus_addr[5:4]} */
+	addr = ((addr >> 10) << 2) | ((addr >> 4) & 0x3);
+
+	return addr;
+}
+
diff --git a/plat/nxp/s32/s32g/s32g_bl2_el3.c b/plat/nxp/s32/s32g/s32g_bl2_el3.c
index 9b4551143..377e25fee 100644
--- a/plat/nxp/s32/s32g/s32g_bl2_el3.c
+++ b/plat/nxp/s32/s32g/s32g_bl2_el3.c
@@ -432,7 +432,7 @@ int bl2_plat_handle_post_image_load(unsigned int image_id)
 		/* Now that we know the real image size, we can load
 		 * the entire FIP.
 		 */
-		s32g_sram_clear(FIP_BASE, FIP_BASE + bl_mem_params->image_info.image_size);
+		s32_sram_clear(FIP_BASE, FIP_BASE + bl_mem_params->image_info.image_size);
 		ret = load_auth_image(image_id, &bl_mem_params->image_info);
 		if (ret != 0) {
 			ERROR("BL2: Failed to load image id %d (%i)\n",
@@ -691,14 +691,14 @@ void bl2_el3_plat_arch_setup(void)
 	if (ret)
 		ERROR("Failed to disable VR5510 watchdog\n");
 
-	s32g_sram_clear(S32G_BL33_IMAGE_BASE, DTB_BASE);
+	s32_sram_clear(S32G_BL33_IMAGE_BASE, DTB_BASE);
 	/* Clear only the necessary part for the FIP header. The rest will
 	 * be cleared in bl2_plat_handle_post_image_load, before loading
 	 * the entire FIP image.
 	 */
-	s32g_sram_clear(FIP_BASE, FIP_BASE + FIP_HEADER_SIZE);
+	s32_sram_clear(FIP_BASE, FIP_BASE + FIP_HEADER_SIZE);
 
-	s32g_ssram_clear();
+	s32_ssram_clear();
 
 	copy_bl31ssram_image();
 #endif
diff --git a/plat/nxp/s32/s32g/s32g_lowlevel_bl2.S b/plat/nxp/s32/s32g/s32g_lowlevel_bl2.S
index 1ea687ccd..c2cebed08 100644
--- a/plat/nxp/s32/s32g/s32g_lowlevel_bl2.S
+++ b/plat/nxp/s32/s32g/s32g_lowlevel_bl2.S
@@ -16,7 +16,7 @@
 .globl s32g_ncore_isol_cluster0
 .globl reset_registers_for_lockstep
 
-/* Clobber list: x0,x1,x2,x3,x4,x5,x6,x7,x8,x9,x10,x11,x12,x13,x14,x15,x16 */
+/* Clobber list: x0,x1,x16 */
 func plat_reset_handler
 	mov	x16, x30
 
@@ -26,6 +26,14 @@ func plat_reset_handler
 	/* Ncore quirks */
 	bl	s32g_ncore_isol_cluster0
 
+	mov	x30, x16
+	ret
+endfunc plat_reset_handler
+
+
+/* Clobber list: x0,x1,x16 */
+func platform_mem_init
+	mov	x16, x30
 	/*
 	 * Initialize SRAM, as BootROM did us no favours
 	 */
@@ -33,19 +41,9 @@ func plat_reset_handler
 	ldr	x0,=__STACKS_START__
 	ldr	x1,=__BL2_END__
 
-	/* To bus addresses */
-	mov	x2, #S32G_SRAM_BASE
-	sub	x0, x0, x2
-	sub	x1, x1, x2
-
 	bl	_s32g_sram_clr
-
 	mov	x30, x16
-	ret
-endfunc plat_reset_handler
-
 
-func platform_mem_init
 	ret
 endfunc platform_mem_init
 
diff --git a/plat/nxp/s32/s32g/s32g_psci.c b/plat/nxp/s32/s32g/s32g_psci.c
index 8b2a39240..0265b47b9 100644
--- a/plat/nxp/s32/s32g/s32g_psci.c
+++ b/plat/nxp/s32/s32g/s32g_psci.c
@@ -110,7 +110,7 @@ static void copy_bl31sram_image(void)
 	int ret;
 
 	/* Clear all BL31SRAM sections */
-	ret = s32g_sram_clear(BL31SRAM_BASE, BL31SRAM_LIMIT);
+	ret = s32_sram_clear(BL31SRAM_BASE, BL31SRAM_LIMIT);
 	if (ret)
 		ERROR("Failed to initialize SRAM from BL31SRAM stage\n");
 
diff --git a/plat/nxp/s32/s32g/s32g_sramc.c b/plat/nxp/s32/s32g/s32g_sramc.c
index d641b1d46..fb0896e69 100644
--- a/plat/nxp/s32/s32g/s32g_sramc.c
+++ b/plat/nxp/s32/s32g/s32g_sramc.c
@@ -1,25 +1,71 @@
 /*
- * Copyright 2020 NXP
+ * Copyright 2020-2021 NXP
  *
  * SPDX-License-Identifier: BSD-3-Clause
  */
-#include <lib/mmio.h>
+#include <arch_helpers.h>
 #include <errno.h>
+#include <lib/mmio.h>
 #include <platform_def.h>
-#include "s32g_sramc.h"
+#include <s32g_sramc.h>
+
+/* SRAM controller is able to erase 64 bits at once */
+#define SRAM_BLOCK              512
+#define SRAM_BLOCK_MASK         (SRAM_BLOCK - 1)
+
+#define SRAMC_PRAMCR_OFFSET     0x0
+#define SRAMC_PRAMCR_INITREQ    1
+#define SRAMC_PRAMIAS_OFFSET    0x4
+#define SRAMC_PRAMIAE_OFFSET    0x8
+#define SRAMC_PRAMSR_OFFSET     0xC
+#define SRAMC_PRAMSR_IDONE      1
+
+#define SSRAM_MAX_ADDR          0x7FF
 
 int _s32g_sram_clr(uintptr_t start, uintptr_t end);
 
-void s32g_ssram_clear(void)
+static void a53_sram_init(void *start, size_t len)
+{
+	memset(start, 0, len);
+	if (is_dcache_enabled())
+		flush_dcache_range((uintptr_t)start, len);
+}
+
+static void clear_unaligned_ends(uintptr_t *start, uintptr_t *end)
 {
-	uintptr_t base = SSRAMC_BASE_ADDR;
+	uintptr_t leftover;
+
+	if (*start % SRAM_BLOCK) {
+		leftover = SRAM_BLOCK - (*start & SRAM_BLOCK_MASK);
+
+		a53_sram_init((void *)*start, round_up(leftover, 8));
+		*start += leftover;
+	}
+
+	if (*end % SRAM_BLOCK) {
+		leftover = *end & SRAM_BLOCK_MASK;
+
+		a53_sram_init((void *)(*end - leftover), round_up(leftover, 8));
+		*end -= leftover;
+	}
+}
+
+static bool in_overlap(uintptr_t s1, uintptr_t e1, uintptr_t s2, uintptr_t e2)
+{
+	return MAX(s1, s2) <= MIN(e1, e2);
+}
+
+static void clear_sramc_range(struct sram_ctrl *c, uintptr_t start,
+			      uintptr_t end)
+{
+	uintptr_t base = c->base_addr;
 
 	/* Disable the controller */
 	mmio_write_32(base + SRAMC_PRAMCR_OFFSET, 0x0);
 
 	/* Max range */
-	mmio_write_32(base + SRAMC_PRAMIAS_OFFSET, 0x0);
-	mmio_write_32(base + SRAMC_PRAMIAE_OFFSET, SSRAM_MAX_ADDR);
+	mmio_write_32(base + SRAMC_PRAMIAS_OFFSET, start);
+	mmio_write_32(base + SRAMC_PRAMIAE_OFFSET, end);
 
 	/* Initialization request */
 	mmio_write_32(base + SRAMC_PRAMCR_OFFSET, SRAMC_PRAMCR_INITREQ);
@@ -29,10 +75,23 @@ void s32g_ssram_clear(void)
 	mmio_write_32(base + SRAMC_PRAMSR_OFFSET, SRAMC_PRAMSR_IDONE);
 }
 
-int s32g_sram_clear(uintptr_t start, uintptr_t end)
+void s32_ssram_clear(void)
+{
+	static struct sram_ctrl ssramc = {
+		.base_addr = SSRAMC_BASE_ADDR,
+		.min_addr = 0x0,
+		.max_addr = SSRAM_MAX_ADDR,
+	};
+
+	clear_sramc_range(&ssramc, 0x0, SSRAM_MAX_ADDR);
+}
+
+int s32_sram_clear(uintptr_t start, uintptr_t end)
 {
-	uintptr_t low, high;
-	int ret;
+	struct sram_ctrl *ctrls;
+	struct sram_ctrl *c;
+	size_t i, n_ctrls;
+	uintptr_t s, e;
 
 	if (start == end)
 		return 0;
@@ -40,22 +99,35 @@ int s32g_sram_clear(uintptr_t start, uintptr_t end)
 	if (end < start)
 		return -EINVAL;
 
-	start = round_down(start, SRAM_BLOCK);
-	end = round_up(end, SRAM_BLOCK);
-
 	if (start < S32G_SRAM_BASE)
 		return -EINVAL;
 
 	if (end > S32G_SRAM_END)
 		return -EINVAL;
 
-	/* Bus addresses */
-	low = (start - S32G_SRAM_BASE);
-	high = (end - S32G_SRAM_BASE);
+	clear_unaligned_ends(&start, &end);
+
+	/* To bus addresses */
+	start = a53_to_sramc_addr(start);
+	end = a53_to_sramc_addr(end);
+
+	s32_get_sramc(&ctrls, &n_ctrls);
+
+	for (i = 0u; i < n_ctrls; i++) {
+		c = &ctrls[i];
+
+		if (!in_overlap(start, end, c->min_addr, c->max_addr))
+			continue;
+
+		/* Adapt the range to current controller */
+		s = MAX(start, (uintptr_t)c->min_addr);
+		e = MIN(end, (uintptr_t)c->max_addr);
+
+		s -= c->min_addr;
+		e -= c->min_addr;
 
-	ret = _s32g_sram_clr(low, high);
-	if (ret)
-		return ret;
+		clear_sramc_range(c, s, e);
+	}
 
 	return 0;
 }
diff --git a/plat/nxp/s32/s32g/s32g_sramc_asm.S b/plat/nxp/s32/s32g/s32g_sramc_asm.S
index 5918db6da..a8569b09c 100644
--- a/plat/nxp/s32/s32g/s32g_sramc_asm.S
+++ b/plat/nxp/s32/s32g/s32g_sramc_asm.S
@@ -5,316 +5,25 @@
  */
 
 #include <asm_macros.S>
-#include <console_macros.S>
-#include "platform_def.h"
+#include <plat_macros.S>
 #include "s32g_sramc.h"
-#include <lib/utils_def.h>
 
 .globl _s32g_sram_clr
 
-/*
- * Translate a bus address in SRAM controller initialization address based on:
- * S32G2:
- * 	mem_addr[16:0] = {bus_addr[23:9], bus_addr[5:4]}
- * 	addr := ((addr >> 9) << 2) | ((addr >> 4) & 0x3);
- * S32G3:
- * 	mem_addr[16:0] = {bus_addr[23:10], bus_addr[5:4]}
- * 	addr := ((addr >> 10) << 2) | ((addr >> 4) & 0x3);
- *
- * x0: SRAM bus address
- * ret: x0: Initialization address
- *
- * Clobber list: x0,x4,x5
- */
-func calc_sramc_addr
-#if defined(PLAT_s32g2)
-	lsr	x4, x0, #9
-#else /* PLAT_s32g3 */
-	lsr	x4, x0, #10
-#endif
-	lsl	x4, x4, #2
-	lsr	x5, x0, #4
-	and	x5, x5, #3
-	orr	x0, x4, x5
-	ret
-endfunc calc_sramc_addr
-
-/**
- * Check if two intervals are in overlap
- *
- * x0: start index of the first interval
- * x1: end index of the first interval
- * x2: start index of the second interval
- * x3: end index of the second interval
- *
- * x0: return 0 if the intervals do not overlap and 1 otherwise
- * Clobber list: x0,x1,x2,x3,x4,x5,x6
- */
-func in_overlap
-	/* x4 = max */
-	cmp	x1, x3
-	b.gt	1f
-	mov	x4, x3
-	b	2f
-1:
-	mov	x4, x1
-2:
-	/* x5 = min */
-	cmp	x0, x2
-	b.lt	3f
-	mov	x5, x2
-	b	4f
-3:
-	mov	x5, x0
-4:
-	/* x5 = max - min */
-	sub	x5, x4, x5
-	/* x4 = first interval size */
-	sub	x4, x1, x0
-	/* x6 = second interval size */
-	sub	x6, x3, x2
-	/* x4 = len1 + len2 */
-	add	x4, x4, x6
-	cmp	x4, x5
-	bgt	overlap
-	mov	x0, #0
-	ret
-overlap:
-	mov	x0, #1
-	ret
-endfunc in_overlap
-
 /**
- * Clear SRAM range using SRAM controller
- *
- * x0: SRAM controller address
- * x1: Initialization Start Address
- * x2: Initialization End Address
- *
- * Clobber list: x0,x1,x2,x3
- */
-func clear_sramc_range
-	/* Disable the module */
-	mov	x3, #0
-	str	w3, [x0, #SRAMC_PRAMCR_OFFSET]
-
-	/* Address range */
-	str	w1, [x0, #SRAMC_PRAMIAS_OFFSET]
-	str	w2, [x0, #SRAMC_PRAMIAE_OFFSET]
-
-	/* Request initialization */
-	mov	x3, #SRAMC_PRAMCR_INITREQ
-	str	w3, [x0, #SRAMC_PRAMCR_OFFSET]
-
-wait_init:
-	ldr	w3, [x0, #SRAMC_PRAMSR_OFFSET]
-	and	w3, w3, #SRAMC_PRAMSR_IDONE
-	cbz	w3, wait_init
-
-	/* Clear status */
-	mov	w3, #SRAMC_PRAMSR_IDONE
-	str	w3, [x0, #SRAMC_PRAMSR_OFFSET]
-
-	ret
-endfunc clear_sramc_range
-
-/* x0: start address of memory area to clear
- * x1: end address of memory area to clear
- *
- * Clobber list: x0,x1,x9,x10
- */
-func a53_sram_clr
-	mov	x10, #0x0
-	cmp	x1, x0
-	bgt	pos_step
-	mov	x9, #-8
-	b	clr_loop
-pos_step:
-	mov	x9, #8
-clr_loop:
-	cmp	x1, x0
-	beq	finish
-	str	x10, [x0]
-	add	x0, x0, x9
-	b	clr_loop
-finish:
-	ret
-endfunc a53_sram_clr
-
-func clear_unaligned_ends
-	/* Save x30 */
-	mov	x12, x30
-	/*
-	 * Obtain SRAM addresses
-	 */
-	mov	x9, #S32G_SRAM_BASE
-	add	x11, x1, x9
-	add	x9, x0, x9
-
-	and	x1, x9, #SRAM_INV_BLOCK_MASK
-	cmp	x1, x9
-	beq	clear_end
-	add	x1, x1, SRAM_BLOCK
-	mov	x0, x9
-	bl	a53_sram_clr
-
-clear_end:
-	and	x0, x11, #SRAM_INV_BLOCK_MASK
-	cmp	x0, x11
-	beq	clr_exit
-	mov	x1, x11
-	bl	a53_sram_clr
-clr_exit:
-	mov	x30, x12
-	ret
-endfunc clear_unaligned_ends
-
-/* x0: start address of memory area to clear
+ * x0: start address of memory area to clear
  * x1: end address of memory area to clear
  * x0: return 0 on error or size of memory cleared on success
  *
- * Clobber list: x0,x1,x2,x3,x4,x5,x6,x7,x8,x9,x11,x12,x13,x14,x15
+ * Clobber list: x0,x1,x9,x10
  */
 func _s32g_sram_clr
-	/* Save x30 */
-	mov	x15, x30
-
-	mov	x13, x0
-	mov	x14, x1
-	bl	clear_unaligned_ends
-	mov	x0, x13
-	mov	x1, x14
-
-	/* Align to SRAM blocks */
-	and	x9, x0, #SRAM_INV_BLOCK_MASK
-	cmp	x0, x9
-	beq	align_high_addr
-	add	x0, x9, SRAM_BLOCK
-
-align_high_addr:
-	and	x1, x1, #SRAM_INV_BLOCK_MASK
-	cbz	x1, sram_exit
-
-	sub	x1, x1, #1
-	/* Low address */
-	bl	calc_sramc_addr
-	mov	x7, x0
-	mov	x0, x1
+	s32_save_regs
+	s32_init_local_stack
 
-	/* High address */
-	bl	calc_sramc_addr
-
-	/**
-	 * x7 - Low initialization address
-	 * x10 - High initialization address
-	 */
-	mov	x10, x0
-	mov	x9, #SRAMC1_MAX_ADDR
-	cmp	x10, x9
-	bgt	error
-
-	mov	x0, #SRAMC0_MIN_ADDR
-	mov	x1, #SRAMC0_MAX_ADDR
-	mov	x2, x7
-	mov	x3, x10
-	bl	in_overlap
-	cbz	x0, check_sramc1
-
-init_sramc0:
-	mov	x0, #SRAMC0_BASE_ADDR_L
-	movk	x0, #SRAMC0_BASE_ADDR_H, lsl #16
-	mov	x1, x7
-	mov	x2, x10
-	mov	x9, #SRAMC0_MAX_ADDR
-	cmp	x2, x9
-	b.gt	1f
-	b	2f
-1:
-	mov	x2, #SRAMC0_MAX_ADDR
-2:
-	bl	clear_sramc_range
-
-check_sramc1:
-	mov	x0, #SRAMC1_MIN_ADDR
-	mov	x1, #SRAMC1_MAX_ADDR
-	mov	x2, x7
-	mov	x3, x10
-	bl	in_overlap
-#if defined(PLAT_s32g2)
-	cbz	x0, sram_exit
-#else /* PLAT_s32g3 */
-	cbz	x0, check_sramc2
-#endif
-
-init_sramc1:
-	mov	x0, #SRAMC1_BASE_ADDR
-	movk	x0, #SRAMC1_BASE_ADDR_H, lsl #16
-	cmp	x7, #SRAMC1_MIN_ADDR
-	b.lt	3f
-	sub	x1, x7, #SRAMC1_MIN_ADDR
-	b	4f
-3:
-	mov	x1, #0
-4:
-	sub	x2, x10, #SRAMC1_MIN_ADDR
-	bl	clear_sramc_range
-
-#if defined(PLAT_s32g3)
-check_sramc2:
-	mov	x0, #SRAMC2_MIN_ADDR
-	mov	x1, #SRAMC2_MAX_ADDR_L
-	movk	x1, #SRAMC2_MAX_ADDR_H, lsl #16
-	mov	x2, x7
-	mov	x3, x10
-	bl	in_overlap
-	cbz	x0, check_sramc3
-
-init_sramc2:
-	mov	x0, #SRAMC2_BASE_ADDR_L
-	movk	x0, #SRAMC2_BASE_ADDR_H, lsl #16
-	cmp	x7, #SRAMC2_MIN_ADDR
-	b.lt	5f
-	sub	x1, x7, #SRAMC2_MIN_ADDR
-	b	6f
-5:
-	mov	x1, #0
-6:
-	sub	x2, x10, #SRAMC2_MIN_ADDR
-	bl	clear_sramc_range
-
-check_sramc3:
-	mov	x0, #SRAMC3_MIN_ADDR
-	mov	x1, #SRAMC3_MAX_ADDR_L
-	movk	x1, #SRAMC3_MAX_ADDR_H, lsl #16
-	mov	x2, x7
-	mov	x3, x10
-	bl	in_overlap
-	cbz	x0, sram_exit
-
-init_sramc3:
-	mov	x0, #SRAMC2_BASE_ADDR_L
-	movk	x0, #SRAMC2_BASE_ADDR_H, lsl #16
-	cmp	x7, #SRAMC2_MIN_ADDR
-	b.lt	7f
-	sub	x1, x7, #SRAMC2_MIN_ADDR
-	b	8f
-7:
-	mov	x1, #0
-8:
-	sub	x2, x10, #SRAMC2_MIN_ADDR
-	bl	clear_sramc_range
-#endif
-
-	mov	x0, #0
-
-sram_exit:
-	/* Restore x30 */
-	mov	x30, x15
-	ret
+	bl s32_sram_clear
 
-error:
-	/* Restore x30 */
-	mov	x30, x15
-	mov	x0, #-1
+	s32_check_stack_guard
+	s32_restore_regs
 	ret
 endfunc _s32g_sram_clr
-- 
2.17.1

