From 5e114c92a534661635f176ac17ce55d7ec692272 Mon Sep 17 00:00:00 2001
From: Bogdan Hamciuc <bogdan.hamciuc@nxp.com>
Date: Thu, 6 Feb 2020 14:42:48 +0200
Subject: [PATCH 074/269] s32g274a: Minor refactoring of core reset code

Cosmetic changes to the MC_ME code for taking secondary cores out of
reset.

Upstream-Status: Pending 

Signed-off-by: Bogdan Hamciuc <bogdan.hamciuc@nxp.com>
Signed-off-by: Zhantao Tang <zhantao.tang@windriver.com>
Issue: ALB-4497
---
 plat/s32g/s32g_mc_me.c | 41 +++++++++++++++++++++++++++--------------
 1 file changed, 27 insertions(+), 14 deletions(-)

diff --git a/plat/s32g/s32g_mc_me.c b/plat/s32g/s32g_mc_me.c
index 35338ea13..6f56786d3 100644
--- a/plat/s32g/s32g_mc_me.c
+++ b/plat/s32g/s32g_mc_me.c
@@ -150,14 +150,32 @@ static void core_high_addr_write(uintptr_t addr, uint32_t core)
 	mmio_write_32(GPR_BASE_ADDR + GPR09_OFF, gpr09);
 }
 
+static bool s32g_core_in_reset(uint32_t core)
+{
+	uint32_t stat, rst;
+
+	rst = S32G_MC_RGM_RST_CA53_BIT(core);
+	stat = mmio_read_32(S32G_MC_RGM_PSTAT(S32G_MC_RGM_RST_DOMAIN_CA53));
+	return ((stat & rst) != 0);
+}
+
+static bool s32g_core_clock_running(uint32_t core)
+{
+	uint32_t stat;
+	const uint32_t part = S32G_MC_ME_CA53_PART;
+
+	stat = mmio_read_32(S32G_MC_ME_PRTN_N_CORE_M_STAT(part, core & ~1));
+	return ((stat & S32G_MC_ME_PRTN_N_CORE_M_STAT_CCS_MASK) != 0);
+}
+
 /** Reset and initialize secondary A53 core identified by its number
  *  in one of the MC_ME partitions
  */
-static void s32g_kick_secondary_ca53_core(uint32_t part, uint32_t core)
+static void s32g_kick_secondary_ca53_core(uint32_t core)
 {
 	uintptr_t core_start_addr = (uintptr_t)&plat_secondary_cold_boot_setup;
 	uint32_t rst;
-	uint32_t stat;
+	const uint32_t part = S32G_MC_ME_CA53_PART;
 
 	/* GPR09 provides the 8 high-order bits for the core's start addr */
 	core_high_addr_write(core_start_addr, core);
@@ -176,20 +194,16 @@ static void s32g_kick_secondary_ca53_core(uint32_t part, uint32_t core)
 	mc_me_part_core_pupd_write_ccupd(1, part, core & ~1);
 	mc_me_apply_hw_changes();
 	/* Wait for the core clock to become active */
-	do {
-		stat = mmio_read_32(S32G_MC_ME_PRTN_N_CORE_M_STAT(part,
-								  core & ~1));
-	} while ((stat & S32G_MC_ME_PRTN_N_CORE_M_STAT_CCS_MASK) == 0);
+	while (!s32g_core_clock_running(core))
+		;
 
 	/* Release the core reset */
 	rst = mmio_read_32(S32G_MC_RGM_PRST(S32G_MC_RGM_RST_DOMAIN_CA53));
 	rst &= ~(S32G_MC_RGM_RST_CA53_BIT(core));
 	mmio_write_32(S32G_MC_RGM_PRST(S32G_MC_RGM_RST_DOMAIN_CA53), rst);
 	/* Wait for reset bit to deassert */
-	do {
-		stat = mmio_read_32(S32G_MC_RGM_PSTAT(
-						S32G_MC_RGM_RST_DOMAIN_CA53));
-	} while (stat != rst);
+	while (s32g_core_in_reset(core))
+		;
 }
 
 
@@ -202,8 +216,7 @@ void s32g_kick_secondary_ca53_cores(void)
 	mc_me_part_pupd_write_pcud(1, S32G_MC_ME_CA53_PART);
 	mc_me_apply_hw_changes();
 
-	/* TODO read secondary core IDs dynamically */
-	s32g_kick_secondary_ca53_core(S32G_MC_ME_CA53_PART, 1);
-	s32g_kick_secondary_ca53_core(S32G_MC_ME_CA53_PART, 2);
-	s32g_kick_secondary_ca53_core(S32G_MC_ME_CA53_PART, 3);
+	s32g_kick_secondary_ca53_core(1);
+	s32g_kick_secondary_ca53_core(2);
+	s32g_kick_secondary_ca53_core(3);
 }
-- 
2.17.1

