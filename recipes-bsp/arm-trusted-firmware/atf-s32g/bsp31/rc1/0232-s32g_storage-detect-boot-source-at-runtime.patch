From 0bd39c5bdfe990fc89acdc5729b226a2d3ebc507 Mon Sep 17 00:00:00 2001
From: Bogdan-Gabriel Roman <bogdan-gabriel.roman@nxp.com>
Date: Wed, 12 May 2021 00:17:21 +0300
Subject: [PATCH 232/269] s32g_storage: detect boot source at runtime

Whether ATF has booted from QSPI, SD or eMMC can be detected at runtime
by reading the register BOOT_GPR_BMR1 which is populated with the values
of RCON[31:0] at every power-on-reset.

Issue: ALB-7120
Upstream-Status: Pending 

Signed-off-by: Bogdan-Gabriel Roman <bogdan-gabriel.roman@nxp.com>
Signed-off-by: Zhantao Tang <zhantao.tang@windriver.com>
---
 drivers/nxp/s32g/mmc/s32g_mmc.c         | 39 +++++++++++++++----------
 include/drivers/nxp/s32g/mmc/s32g_mmc.h |  4 +--
 plat/nxp/s32g/include/platform_def.h    |  1 +
 plat/nxp/s32g/platform.mk               |  5 ----
 plat/nxp/s32g/s32g_storage.c            | 32 +++++++++++++++-----
 5 files changed, 51 insertions(+), 30 deletions(-)

diff --git a/drivers/nxp/s32g/mmc/s32g_mmc.c b/drivers/nxp/s32g/mmc/s32g_mmc.c
index d01c74b18..c5dc71948 100644
--- a/drivers/nxp/s32g/mmc/s32g_mmc.c
+++ b/drivers/nxp/s32g/mmc/s32g_mmc.c
@@ -105,30 +105,27 @@
  * is an application command, otherwise, it is a standard command.
  */
 
-#ifdef S32G_BOOT_FROM_EMMC
-#define MMC_CMD_ADTC_MASK		(BIT(18) | BIT(17))
-#else
-#define MMC_CMD_ADTC_MASK		(BIT(6) | BIT(18) | BIT(17))
-#endif
+#define MMC_CMD_ADTC_MASK(src)	(src == BOOT_SOURCE_SD ? \
+			(BIT(6) | BIT(18) | BIT(17)) : (BIT(18) | BIT(17)))
 
 #define MMC_ACMD_ADTC_MASK		(BIT(51))
-#define ADTC_MASK_FROM_CMD_XFR_TYP(r)	\
-			((CMDINX_FROM_CMD_XFR_TYP(r) == MMC_CMD(55)) ? \
-			 MMC_ACMD_ADTC_MASK : MMC_CMD_ADTC_MASK)
+#define ADTC_MASK_FROM_CMD_XFR_TYP(r_0, r_1)	\
+			((CMDINX_FROM_CMD_XFR_TYP(r_0) == MMC_CMD(55)) ? \
+			 MMC_ACMD_ADTC_MASK : MMC_CMD_ADTC_MASK(r_1))
 
 #define IDENTIFICATION_MODE_FREQUENCY	(400 * 1000)
 #define MMC_FULL_SPEED_MODE_FREQUENCY	(26 * 1000 * 1000)
 
-#ifdef S32G_BOOT_FROM_EMMC
-static struct mmc_device_info device_info = {
+static struct mmc_device_info emmc_device_info = {
 	.mmc_dev_type = MMC_IS_EMMC,
 };
-#else
-static struct mmc_device_info device_info = {
+
+static struct mmc_device_info sd_device_info = {
 	.mmc_dev_type = MMC_IS_SD,
 	.ocr_voltage = OCR_3_2_3_3 | OCR_3_3_3_4,
 };
-#endif
+
+static uint32_t mmc_boot_source;
 
 static uint32_t prepare_ds_addr;
 static uint32_t prepare_blk_att;
@@ -234,7 +231,8 @@ static int s32g274a_mmc_send_cmd(struct mmc_cmd *cmd)
 		break;
 	}
 
-	adtc_mask = ADTC_MASK_FROM_CMD_XFR_TYP(mmio_read_32(USDHC_CMD_XFR_TYP));
+	adtc_mask = ADTC_MASK_FROM_CMD_XFR_TYP(mmio_read_32(USDHC_CMD_XFR_TYP),
+					mmc_boot_source);
 	if (adtc_mask & (BIT(cmd->cmd_idx))) {
 		cmd_xfr_typ |= CMD_XFR_TYP_DPSEL;
 		mix_ctrl |= MIX_CTRL_DTDSEL;
@@ -356,8 +354,17 @@ static const struct mmc_ops s32g274a_mmc_ops = {
 	.write		= s32g274a_mmc_write,
 };
 
-int s32g274a_mmc_register(void)
+int s32g274a_mmc_register(uint32_t boot_source)
 {
+	struct mmc_device_info *device_info;
+
+	mmc_boot_source = boot_source;
+
+	if (boot_source == BOOT_SOURCE_SD)
+		device_info = &sd_device_info;
+	else
+		device_info = &emmc_device_info;
+
 	return mmc_init(&s32g274a_mmc_ops, MMC_FULL_SPEED_MODE_FREQUENCY,
-			MMC_BUS_WIDTH_4, 0, &device_info);
+			MMC_BUS_WIDTH_4, 0, device_info);
 }
diff --git a/include/drivers/nxp/s32g/mmc/s32g_mmc.h b/include/drivers/nxp/s32g/mmc/s32g_mmc.h
index 4344ef99b..6e32e7ba2 100644
--- a/include/drivers/nxp/s32g/mmc/s32g_mmc.h
+++ b/include/drivers/nxp/s32g/mmc/s32g_mmc.h
@@ -1,5 +1,5 @@
 /*
- * Copyright 2020 NXP
+ * Copyright 2020-2021 NXP
  *
  * SPDX-License-Identifier: BSD-3-Clause
  */
@@ -7,6 +7,6 @@
 #ifndef S32G274A_MMC_H
 #define S32G274A_MMC_H
 
-int s32g274a_mmc_register(void);
+int s32g274a_mmc_register(uint32_t boot_source);
 
 #endif /* S32G274A_MMC_H */
diff --git a/plat/nxp/s32g/include/platform_def.h b/plat/nxp/s32g/include/platform_def.h
index abb72def8..f7417ef1e 100644
--- a/plat/nxp/s32g/include/platform_def.h
+++ b/plat/nxp/s32g/include/platform_def.h
@@ -86,6 +86,7 @@
 #define BOOT_SOURCE_QSPI	0
 #define BOOT_SOURCE_SD		2
 #define BOOT_SOURCE_MMC		3
+#define INVALID_BOOT_SOURCE	1
 
 #define S32G_XRDC_0_PAC_0_BASE_ADDR	0x40000000ULL
 #define S32G_XRDC_0_PAC_0_SIZE		SIZE_1M
diff --git a/plat/nxp/s32g/platform.mk b/plat/nxp/s32g/platform.mk
index 2e0ffdceb..ac9761ae0 100644
--- a/plat/nxp/s32g/platform.mk
+++ b/plat/nxp/s32g/platform.mk
@@ -202,8 +202,3 @@ LOG_LEVEL		?= 50
 ifneq ($(BL32_EXTRA1),)
 $(eval $(call TOOL_ADD_IMG,bl32_extra1,--tos-fw-extra1))
 endif
-
-# Check if we are booting from eMMC
-ifneq ($(S32G_BOOT_FROM_EMMC),)
-$(eval $(call add_define,S32G_BOOT_FROM_EMMC))
-endif
diff --git a/plat/nxp/s32g/s32g_storage.c b/plat/nxp/s32g/s32g_storage.c
index c935e58d8..8a0347d9b 100644
--- a/plat/nxp/s32g/s32g_storage.c
+++ b/plat/nxp/s32g/s32g_storage.c
@@ -140,15 +140,21 @@ static int s32g_check_memmap_dev(const uintptr_t spec)
 	return 0;
 }
 
-static bool boot_from_qspi(void)
+static uint32_t get_boot_source(void)
 {
 	uint32_t boot_cfg = mmio_read_32(BOOT_GPR_BASE + BOOT_GPR_BMR1_OFF);
 	uint32_t boot_source = (boot_cfg & BOOT_SOURCE_MASK) >> BOOT_SOURCE_OFF;
 
-	if (boot_source == BOOT_SOURCE_QSPI)
-		return true;
+	switch (boot_source) {
 
-	return false;
+	case BOOT_SOURCE_QSPI:
+	case BOOT_SOURCE_SD:
+	case BOOT_SOURCE_MMC:
+		return boot_source;
+
+	default:
+		return INVALID_BOOT_SOURCE;
+	}
 }
 
 static void set_fip_img_source(struct plat_io_policy *policy)
@@ -157,6 +163,12 @@ static void set_fip_img_source(struct plat_io_policy *policy)
 			get_bl_mem_params_node(FIP_IMAGE_ID);
 	image_info_t *image_info = &fip_params->image_info;
 
+	/* No need to check boot_source value integrity here.
+	 * If the previous check had failed, the boot flow would
+	 * not have reached this point.
+	 */
+	uint32_t boot_source = get_boot_source();
+
 	/* We know the real FIP image length only after FIP header
 	 * is read and parsed in bl2_plat_handle_post_image_load.
 	 * This code will be executed twice: the first time when the
@@ -164,7 +176,7 @@ static void set_fip_img_source(struct plat_io_policy *policy)
 	 * and second time when the entire FIP is read and image_size
 	 * will be the one obtained in bl2_plat_handle_post_image_load.
 	 */
-	if (boot_from_qspi()) {
+	if (boot_source == BOOT_SOURCE_QSPI) {
 		qspi_fip_memmap_spec.length =
 			image_info->image_size;
 		*policy = (struct plat_io_policy) {
@@ -210,6 +222,8 @@ int plat_get_image_source(unsigned int image_id, uintptr_t *dev_handle,
 
 void s32g_io_setup(void)
 {
+	uint32_t boot_source;
+
 	if (register_io_dev_memmap(&s32g_memmap_io_conn))
 		goto err;
 	if (io_dev_open(s32g_memmap_io_conn, (uintptr_t)&fip_memmap_spec,
@@ -219,9 +233,13 @@ void s32g_io_setup(void)
 			(uintptr_t)FIP_BACKEND_MEMMAP_ID))
 		goto err;
 
+	boot_source = get_boot_source();
+	if (boot_source == INVALID_BOOT_SOURCE)
+		goto err;
+
 	/* MMC/SD may not be inserted */
-	if (!boot_from_qspi()) {
-		if (s32g274a_mmc_register())
+	if (boot_source != BOOT_SOURCE_QSPI) {
+		if (s32g274a_mmc_register(boot_source))
 			goto err;
 		if (register_io_dev_mmc(&s32g_mmc_io_conn))
 			goto err;
-- 
2.17.1

