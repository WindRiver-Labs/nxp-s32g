From c04bf0698416966965ac38e7c05cf07a88dd26b3 Mon Sep 17 00:00:00 2001
From: Bogdan Hamciuc <bogdan.hamciuc@nxp.com>
Date: Fri, 7 Feb 2020 16:16:10 +0200
Subject: [PATCH 079/269] s32g274a: Fix MC_ME partition initialization

MC_ME partitions used by peripherals such as PFE require more complex
initialization than we had before. This is required for integration with
U-Boot's PFENG driver.

Upstream-Status: Pending 

Signed-off-by: Bogdan Hamciuc <bogdan.hamciuc@nxp.com>
Signed-off-by: Zhantao Tang <zhantao.tang@windriver.com>
Issue: ALB-4497
---
 plat/s32g/include/s32g_mc_me.h  | 35 +++++++------
 plat/s32g/include/s32g_mc_rgm.h |  8 +++
 plat/s32g/s32g274a_pm.c         |  2 +-
 plat/s32g/s32g_clocks.c         |  9 ++++
 plat/s32g/s32g_mc_me.c          | 93 +++++++++++++++++++++++++--------
 5 files changed, 107 insertions(+), 40 deletions(-)

diff --git a/plat/s32g/include/s32g_mc_me.h b/plat/s32g/include/s32g_mc_me.h
index baaf5e576..2d9c3a4f7 100644
--- a/plat/s32g/include/s32g_mc_me.h
+++ b/plat/s32g/include/s32g_mc_me.h
@@ -1,7 +1,7 @@
 /*
- * Magic Carpet (MC) modules definitions for S32G274A and compatible SoCs
+ * MC Mode Entry definitions for S32G274A and compatible SoCs
  *
- * Copyright 2019 NXP
+ * Copyright 2019-2020 NXP
  *
  * SPDX-License-Identifier: BSD-3-Clause
  */
@@ -10,9 +10,6 @@
 
 #include "platform_def.h"
 
-/*
- * MC Mode Entry
- */
 
 #define S32G_MC_ME_BASE_ADDR	0x40088000ul
 #define S32G_MC_ME_SIZE		0x1000ul
@@ -35,10 +32,12 @@
 	(S32G_MC_ME_PRTN_N_BASE(n) + 0x0)
 #define S32G_MC_ME_PRTN_N_PUPD(n) \
 	(S32G_MC_ME_PRTN_N_BASE(n) + 0x4)
-/* PRTNn_PCONF[PCE] mask */
-#define S32G_MC_ME_PRTN_N_PCONF_PCE_MASK	0x1ul
-/* PRTNn_PUPD[PCUD] mask */
-#define S32G_MC_ME_PRTN_N_PUPD_PCUD_MASK	0x1ul
+#define S32G_MC_ME_PRTN_N_STAT(n) \
+	(S32G_MC_ME_PRTN_N_BASE(n) + 0x8)
+#define S32G_MC_ME_PRTN_N_PCONF_PCE_MASK	BIT(0)
+#define S32G_MC_ME_PRTN_N_PCONF_OSSE_MASK	BIT(2)
+#define S32G_MC_ME_PRTN_N_PUPD_PCUD_MASK	BIT(0)
+#define S32G_MC_ME_PRTN_N_PUPD_OSSUD_MASK	BIT(2)
 
 /* PRTNn_COREm registers */
 #define S32G_MC_ME_PRTN_N_CORE_M_BASE(n, m) \
@@ -51,28 +50,32 @@
 	(S32G_MC_ME_PRTN_N_CORE_M_BASE(n, m) + 0x4)
 #define S32G_MC_ME_PRTN_N_CORE_M_STAT(n, m) \
 	(S32G_MC_ME_PRTN_N_CORE_M_BASE(n, m) + 0x8)
-/* PRTNn_COREm_PCONF[CCE] mask */
 #define S32G_MC_ME_PRTN_N_CORE_M_PCONF_CCE_MASK		0x1ul
-/* PRTNn_COREm_PUPD[CCUPD] mask */
 #define S32G_MC_ME_PRTN_N_CORE_M_PUPD_CCUPD_MASK	0x1ul
-/* PRTNn_COREm_STAT[CCS] mask */
 #define S32G_MC_ME_PRTN_N_CORE_M_STAT_CCS_MASK		0x1ul
 
 /* PRTNn_COFBm registers */
-
 #define S32G_MC_ME_PRTN_N_COFB_0_CLKEN(n) \
 	(S32G_MC_ME_PRTN_N_BASE(n) + 0x30)
 
+enum s32g_mc_me_part_no {
+	S32G_MC_ME_PRTN0 = 0,
+	S32G_MC_ME_PRTN1,
+	S32G_MC_ME_PRTN2,
+	S32G_MC_ME_PRTN3,
+};
+#define S32G_MC_ME_CA53_PART	S32G_MC_ME_PRTN1
+#define S32G_MC_ME_DDR_0_PART	S32G_MC_ME_PRTN0
+#define S32G_MC_ME_USDHC_PART	S32G_MC_ME_PRTN0
+#define S32G_MC_ME_PFE_PART	S32G_MC_ME_PRTN2
 
-#define S32G_MC_ME_CA53_PART	1
-#define S32G_MC_ME_DDR_0_PART	0
-#define S32G_MC_ME_USDHC_PART	0
 #define S32G_MC_ME_DDR_0_REQ	1
 #define S32G_MC_ME_USDHC_REQ	0
 
 
 void s32g_kick_secondary_ca53_cores(void);
 void mc_me_enable_partition_block(uint32_t part, uint32_t block);
+void mc_me_enable_partition(uint32_t part);
 
 
 #endif /* __S32G_MC_ME_H__ */
diff --git a/plat/s32g/include/s32g_mc_rgm.h b/plat/s32g/include/s32g_mc_rgm.h
index f4e93750d..4df613722 100644
--- a/plat/s32g/include/s32g_mc_rgm.h
+++ b/plat/s32g/include/s32g_mc_rgm.h
@@ -14,6 +14,8 @@
 /* Peripheral reset */
 #define S32G_MC_RGM_PRST(p)	(S32G_MC_RGM_PRST_BASE_ADDR + 0x8 * p)
 #define S32G_MC_RGM_PSTAT(p)	(S32G_MC_RGM_PSTAT_BASE_ADDR + 0x8 * p)
+#define MC_RGM_PRST_PERIPH_N_RST(n)	BIT(n)
+#define MC_RGM_STAT_PERIPH_N_STAT(n)	BIT(n)
 
 #define PERIPH_3_RST		BIT(3)
 
@@ -45,4 +47,10 @@ enum reset_cause {
 	CAUSE_ERROR
 };
 
+/* Reset Domain Controller definitions */
+#define S32G_RDC_BASE_ADDR	0x40080000ull
+#define RDC_RD_CTRL(part)	(S32G_RDC_BASE_ADDR + (part) * 4)
+#define RDC_CTRL_UNLOCK		BIT(31)
+#define RDC_CTRL_XBAR_DISABLE	BIT(3)
+
 #endif /* __S32G_MC_RGM_H__ */
diff --git a/plat/s32g/s32g274a_pm.c b/plat/s32g/s32g274a_pm.c
index 4600fd349..0680ab632 100644
--- a/plat/s32g/s32g274a_pm.c
+++ b/plat/s32g/s32g274a_pm.c
@@ -221,7 +221,7 @@ void periph_clock_ctrl(enum periph_clock_id id,
 		       enum req_clk_state req_clk_state)
 {
 	int i;
-	const struct periph_clock *periph_clock;
+	const struct periph_clock *periph_clock = NULL;
 
 	for (i = 0; i < n_periph_clocks; i++)
 		if (periph_clocks[i].id == id) {
diff --git a/plat/s32g/s32g_clocks.c b/plat/s32g/s32g_clocks.c
index cab195304..0d2a4af80 100644
--- a/plat/s32g/s32g_clocks.c
+++ b/plat/s32g/s32g_clocks.c
@@ -338,6 +338,10 @@ void s32g_plat_clock_init(void)
 
 	/* Prepare FXOSC to run on */
 	start_fxosc();
+	/* Enable various partitions */
+	mc_me_enable_partition(S32G_MC_ME_PRTN0);
+	mc_me_enable_partition(S32G_MC_ME_PRTN1);
+	mc_me_enable_partition(S32G_MC_ME_PRTN2);
 	/* Enable partition clock for SDHC */
 	mc_me_enable_partition_block(S32G_MC_ME_USDHC_PART,
 				     S32G_MC_ME_USDHC_REQ);
@@ -364,6 +368,11 @@ void s32g_plat_clock_init(void)
 	/* Configure the LinFlexD CGM mux */
 	sw_mux_clk_config(MC_CGM0, 8, MC_CGM_MUXn_CSC_SEL_PERIPH_PLL_PHI3);
 
+	/* Configure the ACCEL_PLL */
+	program_pll(S32G_ACCEL_PLL, S32G_REFCLK_FXOSC, s32g_accel_pll_phi_freq,
+		    s32g_pll_rdiv[S32G_ACCEL_PLL], s32g_pll_mfi[S32G_ACCEL_PLL],
+		    s32g_pll_mfn[S32G_ACCEL_PLL]);
+
 	/* Configure the DDR_PLL */
 	program_pll(S32G_DDR_PLL, S32G_REFCLK_FXOSC, s32g_ddr_pll_phi_freq,
 		    s32g_pll_rdiv[S32G_DDR_PLL], s32g_pll_mfi[S32G_DDR_PLL],
diff --git a/plat/s32g/s32g_mc_me.c b/plat/s32g/s32g_mc_me.c
index 6f56786d3..11a0c82ab 100644
--- a/plat/s32g/s32g_mc_me.c
+++ b/plat/s32g/s32g_mc_me.c
@@ -12,6 +12,13 @@
 void plat_secondary_cold_boot_setup(void);
 
 
+/* Apply changes to MC_ME partitions */
+static void mc_me_apply_hw_changes(void)
+{
+	mmio_write_32(S32G_MC_ME_CTL_KEY, S32G_MC_ME_CTL_KEY_KEY);
+	mmio_write_32(S32G_MC_ME_CTL_KEY, S32G_MC_ME_CTL_KEY_INVERTEDKEY);
+}
+
 /*
  * PART<n>_CORE<m> register accessors
  */
@@ -25,7 +32,6 @@ static void mc_me_part_core_addr_write(uintptr_t addr, uint32_t part,
 	mmio_write_32(S32G_MC_ME_PRTN_N_CORE_M_ADDR(part, core), addr_lo);
 }
 
-
 static void mc_me_part_core_pconf_write_cce(uint32_t cce_bit, uint32_t p,
 					    uint32_t c)
 {
@@ -37,7 +43,6 @@ static void mc_me_part_core_pconf_write_cce(uint32_t cce_bit, uint32_t p,
 	mmio_write_32(S32G_MC_ME_PRTN_N_CORE_M_PCONF(p, c), pconf);
 }
 
-
 static void mc_me_part_core_pupd_write_ccupd(uint32_t ccupd_bit, uint32_t p,
 					    uint32_t c)
 {
@@ -49,7 +54,6 @@ static void mc_me_part_core_pupd_write_ccupd(uint32_t ccupd_bit, uint32_t p,
 	mmio_write_32(S32G_MC_ME_PRTN_N_CORE_M_PUPD(p, c), pupd);
 }
 
-
 /*
  * PART<n>_[XYZ] register accessors
  */
@@ -64,7 +68,6 @@ static void mc_me_part_pconf_write_pce(uint32_t pce_bit, uint32_t p)
 	mmio_write_32(S32G_MC_ME_PRTN_N_PCONF(p), pconf);
 }
 
-
 static void mc_me_part_pupd_write_pcud(uint32_t pcud_bit, uint32_t p)
 {
 	uint32_t pupd;
@@ -75,6 +78,22 @@ static void mc_me_part_pupd_write_pcud(uint32_t pcud_bit, uint32_t p)
 	mmio_write_32(S32G_MC_ME_PRTN_N_PUPD(p), pupd);
 }
 
+static void mc_me_part_pupd_update_and_wait(uint32_t mask, uint32_t p)
+{
+	uint32_t pupd, pconf, stat;
+
+	pupd = mmio_read_32(S32G_MC_ME_PRTN_N_PUPD(p));
+	pupd |= mask;
+	mmio_write_32(S32G_MC_ME_PRTN_N_PUPD(p), pupd);
+
+	mc_me_apply_hw_changes();
+
+	/* wait for the updates to apply */
+	pconf = mmio_read_32(S32G_MC_ME_PRTN_N_PCONF(p));
+	do {
+		stat = mmio_read_32(S32G_MC_ME_PRTN_N_STAT(p));
+	} while ((stat & mask) != (pconf & mask));
+}
 
 /*
  * PART<n>_COFB<m> register accessors
@@ -90,32 +109,61 @@ static void mc_me_part_cofb_clken_write_req(uint32_t req, uint32_t val,
 	mmio_write_32(S32G_MC_ME_PRTN_N_COFB_0_CLKEN(part), clken);
 }
 
-
-/* Apply changes to MC_ME partitions */
-static void mc_me_apply_hw_changes(void)
-{
-	mmio_write_32(S32G_MC_ME_CTL_KEY, S32G_MC_ME_CTL_KEY_KEY);
-	mmio_write_32(S32G_MC_ME_CTL_KEY, S32G_MC_ME_CTL_KEY_INVERTEDKEY);
-}
-
-
 /*
  * Higher-level constructs
  */
 
-void mc_me_enable_partition_block(uint32_t part, uint32_t block)
+/* First part of the "Software reset partition turn-on flow chart",
+ * as per S32G RefMan.
+ */
+void mc_me_enable_partition(uint32_t part)
 {
-	uint32_t pcud;
+	uint32_t reg;
+
+	/* Partition 0 is already enabled by BootROM */
+	if (part == 0)
+		return;
 
 	mc_me_part_pconf_write_pce(1, part);
-	mc_me_part_cofb_clken_write_req(block, 1, part);
-	mc_me_part_pupd_write_pcud(1, part);
-	mc_me_apply_hw_changes();
+	mc_me_part_pupd_update_and_wait(S32G_MC_ME_PRTN_N_PUPD_PCUD_MASK, part);
+
+	/* Unlock RDC register write */
+	mmio_write_32(RDC_RD_CTRL(part), RDC_CTRL_UNLOCK);
+	/* Enable the XBAR interface */
+	mmio_write_32(RDC_RD_CTRL(part),
+		      mmio_read_32(RDC_RD_CTRL(part)) & ~RDC_CTRL_XBAR_DISABLE);
+	/* Wait until XBAR interface is enabled */
+	while (mmio_read_32(RDC_RD_CTRL(part)) & RDC_CTRL_XBAR_DISABLE)
+		;
+	/* Release partition reset */
+	reg = mmio_read_32(S32G_MC_RGM_PRST(part));
+	reg &= ~MC_RGM_PRST_PERIPH_N_RST(0);
+	mmio_write_32(S32G_MC_RGM_PRST(part), reg);
+	/* Clear OSSE bit */
+	reg = mmio_read_32(S32G_MC_ME_PRTN_N_PCONF(part));
+	reg &= ~S32G_MC_ME_PRTN_N_PCONF_OSSE_MASK;
+	mmio_write_32(S32G_MC_ME_PRTN_N_PCONF(part), reg);
+	mc_me_part_pupd_update_and_wait(S32G_MC_ME_PRTN_N_PUPD_OSSUD_MASK,
+					part);
+	while (mmio_read_32(S32G_MC_RGM_PSTAT(part)) &
+			    MC_RGM_STAT_PERIPH_N_STAT(0))
+		;
+	/* Lock RDC register write */
+	reg = mmio_read_32(RDC_RD_CTRL(part));
+	reg &= ~RDC_CTRL_UNLOCK;
+	mmio_write_32(RDC_RD_CTRL(part), reg);
+}
 
-	do {
-		pcud = mmio_read_32(S32G_MC_ME_PRTN_N_PUPD(part)) &
-			S32G_MC_ME_PRTN_N_PUPD_PCUD_MASK;
-	} while (pcud);
+/* Second part of the "Software reset partition turn-on flow chart" from the
+ * S32G RefMan.
+ *
+ * Partition blocks must only be enabled after mc_me_enable_partition()
+ * has been called for their respective partition.
+ */
+void mc_me_enable_partition_block(uint32_t part, uint32_t block)
+{
+	mc_me_part_cofb_clken_write_req(block, 1, part);
+	mc_me_part_pupd_update_and_wait(S32G_MC_ME_PRTN_N_PUPD_PCUD_MASK, part);
 }
 
 static void core_high_addr_write(uintptr_t addr, uint32_t core)
@@ -206,7 +254,6 @@ static void s32g_kick_secondary_ca53_core(uint32_t core)
 		;
 }
 
-
 /** Reset and initialize all secondary A53 cores
  */
 void s32g_kick_secondary_ca53_cores(void)
-- 
2.17.1

