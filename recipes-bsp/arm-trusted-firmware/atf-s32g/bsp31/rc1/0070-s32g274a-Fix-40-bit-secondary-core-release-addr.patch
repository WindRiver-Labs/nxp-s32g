From 9f1cb869b13c42ee83c2554d622912c981afed6a Mon Sep 17 00:00:00 2001
From: Bogdan Hamciuc <bogdan.hamciuc@nxp.com>
Date: Tue, 14 Jan 2020 16:57:05 +0200
Subject: [PATCH 070/269] s32g274a: Fix 40-bit secondary core release addr

Having moved to upper DDR, the release address of the secondary cores
has exceeded 32 bits and we must place the upper 8 bits into GPR09.

Upstream-Status: Pending 

Signed-off-by: Bogdan Hamciuc <bogdan.hamciuc@nxp.com>
Signed-off-by: Zhantao Tang <zhantao.tang@windriver.com>
Issue: ALB-4497
---
 plat/s32g/include/platform_def.h | 16 ++++++++++
 plat/s32g/s32g275_bl31.c         |  3 ++
 plat/s32g/s32g_mc_me.c           | 52 ++++++++++++++++++++++++++++++--
 3 files changed, 68 insertions(+), 3 deletions(-)

diff --git a/plat/s32g/include/platform_def.h b/plat/s32g/include/platform_def.h
index 35687aa6f..0a3161b5e 100644
--- a/plat/s32g/include/platform_def.h
+++ b/plat/s32g/include/platform_def.h
@@ -15,6 +15,8 @@
 #include <common_def.h>
 #include <tbbr_img_def.h>
 
+#define SIZE_1M		(1024 * 1024)
+
 /* MPIDR_EL1 for the four A53 cores is as follows:
  *	A53_0_cpu0:	0x8000_0000
  *	A53_0_cpu1:	0x8000_0001
@@ -65,6 +67,20 @@
 #define SIUL2_0_BASE_ADDR	0x4009C000UL
 #define SIUL2_1_BASE_ADDR	0x44010000UL
 
+#define GPR_BASE_ADDR		0x4007C400UL
+#define GPR09_OFF		0x24
+#define CA53_0_0_RVBARADDR_39_32_OFF	(0)
+#define CA53_0_0_RVBARADDR_39_32_MASK	(0xFFUL)
+#define CA53_0_1_RVBARADDR_39_32_OFF	(8)
+#define CA53_0_1_RVBARADDR_39_32_MASK	(0xFFUL)
+#define CA53_1_0_RVBARADDR_39_32_OFF	(16)
+#define CA53_1_0_RVBARADDR_39_32_MASK	(0xFFUL)
+#define CA53_1_1_RVBARADDR_39_32_OFF	(24)
+#define CA53_1_1_RVBARADDR_39_32_MASK	(0xFFUL)
+
+#define S32G_XRDC_0_PAC_0_BASE_ADDR	0x40000000ULL
+#define S32G_XRDC_0_PAC_0_SIZE		SIZE_1M
+
 /* GIC (re)definitions */
 #define S32G275_GIC_BASE	0x50800000
 #define PLAT_GICD_BASE		S32G275_GIC_BASE
diff --git a/plat/s32g/s32g275_bl31.c b/plat/s32g/s32g275_bl31.c
index 5b511472b..3afbac9b9 100644
--- a/plat/s32g/s32g275_bl31.c
+++ b/plat/s32g/s32g275_bl31.c
@@ -42,6 +42,9 @@ static const mmap_region_t s32g_mmap[] = {
 	MAP_REGION_FLAT(MC_CGM0_BASE_ADDR,
 			MMU_ROUND_UP_TO_4K(S32G_DFS_ADDR(S32G_DFS_NR)),
 			MT_DEVICE | MT_RW),
+	/* This will cover both the MC_RGM and the GPR accesses, while reducing
+	 * the number of used up MMU regions.
+	 */
 	MAP_REGION_FLAT(S32G_MC_RGM_BASE_ADDR, S32G_MC_RGM_SIZE,
 			MT_DEVICE | MT_RW),
 	/* When we execute at System Monitor on behalf of EL2/EL1, we might
diff --git a/plat/s32g/s32g_mc_me.c b/plat/s32g/s32g_mc_me.c
index ead2ba675..2a3aff77f 100644
--- a/plat/s32g/s32g_mc_me.c
+++ b/plat/s32g/s32g_mc_me.c
@@ -11,16 +11,21 @@
 
 void plat_secondary_cold_boot_setup(void);
 
+
 /*
  * PART<n>_CORE<m> register accessors
  */
 
-static void mc_me_part_core_addr_write(uint32_t val, uint32_t part,
+static void mc_me_part_core_addr_write(uintptr_t addr, uint32_t part,
 				       uint32_t core)
 {
-	mmio_write_32(S32G_MC_ME_PRTN_N_CORE_M_ADDR(part, core), val);
+	uint32_t addr_lo;
+
+	addr_lo = (uint32_t)(addr & 0xFFFFFFFC);
+	mmio_write_32(S32G_MC_ME_PRTN_N_CORE_M_ADDR(part, core), addr_lo);
 }
 
+
 static void mc_me_part_core_pconf_write_cce(uint32_t cce_bit, uint32_t p,
 					    uint32_t c)
 {
@@ -32,6 +37,7 @@ static void mc_me_part_core_pconf_write_cce(uint32_t cce_bit, uint32_t p,
 	mmio_write_32(S32G_MC_ME_PRTN_N_CORE_M_PCONF(p, c), pconf);
 }
 
+
 static void mc_me_part_core_pupd_write_ccupd(uint32_t ccupd_bit, uint32_t p,
 					    uint32_t c)
 {
@@ -43,6 +49,7 @@ static void mc_me_part_core_pupd_write_ccupd(uint32_t ccupd_bit, uint32_t p,
 	mmio_write_32(S32G_MC_ME_PRTN_N_CORE_M_PUPD(p, c), pupd);
 }
 
+
 /*
  * PART<n>_[XYZ] register accessors
  */
@@ -57,6 +64,7 @@ static void mc_me_part_pconf_write_pce(uint32_t pce_bit, uint32_t p)
 	mmio_write_32(S32G_MC_ME_PRTN_N_PCONF(p), pconf);
 }
 
+
 static void mc_me_part_pupd_write_pcud(uint32_t pcud_bit, uint32_t p)
 {
 	uint32_t pupd;
@@ -67,6 +75,7 @@ static void mc_me_part_pupd_write_pcud(uint32_t pcud_bit, uint32_t p)
 	mmio_write_32(S32G_MC_ME_PRTN_N_PUPD(p), pupd);
 }
 
+
 /*
  * PART<n>_COFB<m> register accessors
  */
@@ -89,6 +98,7 @@ static void mc_me_apply_hw_changes(void)
 	mmio_write_32(S32G_MC_ME_CTL_KEY, S32G_MC_ME_CTL_KEY_INVERTEDKEY);
 }
 
+
 /*
  * Higher-level constructs
  */
@@ -108,6 +118,38 @@ void mc_me_enable_partition_block(uint32_t part, uint32_t block)
 	} while (pcud);
 }
 
+static void core_high_addr_write(uintptr_t addr, uint32_t core)
+{
+	uint32_t addr_hi;
+	uint32_t gpr09;
+
+	addr_hi = (uint32_t)(addr >> 32);
+	gpr09 = mmio_read_32(GPR_BASE_ADDR + GPR09_OFF);
+
+	switch (core) {
+	case 0:
+		gpr09 |= ((addr_hi & CA53_0_0_RVBARADDR_39_32_MASK) <<
+			   CA53_0_0_RVBARADDR_39_32_OFF);
+		break;
+	case 1:
+		gpr09 |= ((addr_hi & CA53_0_1_RVBARADDR_39_32_MASK) <<
+			   CA53_0_1_RVBARADDR_39_32_OFF);
+		break;
+	case 2:
+		gpr09 |= ((addr_hi & CA53_1_0_RVBARADDR_39_32_MASK) <<
+			   CA53_1_0_RVBARADDR_39_32_OFF);
+		break;
+	case 3:
+		gpr09 |= ((addr_hi & CA53_1_1_RVBARADDR_39_32_MASK) <<
+			   CA53_1_1_RVBARADDR_39_32_OFF);
+		break;
+	default:
+		panic();
+	}
+
+	mmio_write_32(GPR_BASE_ADDR + GPR09_OFF, gpr09);
+}
+
 /** Reset and initialize secondary A53 core identified by its number
  *  in one of the MC_ME partitions
  */
@@ -117,10 +159,13 @@ static void s32g_kick_secondary_ca53_core(uint32_t part, uint32_t core)
 	uint32_t reset;
 	uint32_t status = 0;
 
+	/* GPR09 provides the 8 high-order bits for the core's start addr */
+	core_high_addr_write(core_start_addr, core);
+
 	/* The MC_ME provides the 32 low-order bits for the core's
 	 * start address
 	 */
-	mc_me_part_core_addr_write((uint32_t)core_start_addr, part, core);
+	mc_me_part_core_addr_write(core_start_addr, part, core);
 
 	/* Reset the requested secondary core */
 	/* TODO: shouldn't this come last, after configuring the reset addr? */
@@ -142,6 +187,7 @@ static void s32g_kick_secondary_ca53_core(uint32_t part, uint32_t core)
 	}
 }
 
+
 /** Reset and initialize all secondary A53 cores
  */
 void s32g_kick_secondary_ca53_cores(void)
-- 
2.17.1

