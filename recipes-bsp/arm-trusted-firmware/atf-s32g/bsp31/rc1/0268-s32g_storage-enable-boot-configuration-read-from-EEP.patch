From 13902e8d594107896ac41ec55a12f897aa5d1077 Mon Sep 17 00:00:00 2001
From: Bogdan-Gabriel Roman <bogdan-gabriel.roman@nxp.com>
Date: Fri, 6 Aug 2021 00:42:09 +0300
Subject: [PATCH 268/269] s32g_storage: enable boot configuration read from
 EEPROM

When booting from serial RCON, i.e RCON[8] = 1, the boot configuration
must be fetched from EEPROM. EEPROM is present only on EVB boards and is
connected through the i2c-0 bus.

Issue: ALB-7478
Upstream-Status: Pending 

Signed-off-by: Bogdan-Gabriel Roman <bogdan-gabriel.roman@nxp.com>
Signed-off-by: Zhantao Tang <zhantao.tang@windriver.com>
---
 plat/nxp/s32g/include/platform_def.h |  1 +
 plat/nxp/s32g/s32g_storage.c         | 59 +++++++++++++++++++++++++++-
 2 files changed, 59 insertions(+), 1 deletion(-)

diff --git a/plat/nxp/s32g/include/platform_def.h b/plat/nxp/s32g/include/platform_def.h
index f7417ef1e..3cdb6c2ed 100644
--- a/plat/nxp/s32g/include/platform_def.h
+++ b/plat/nxp/s32g/include/platform_def.h
@@ -81,6 +81,7 @@
 
 #define BOOT_GPR_BASE		0x4007C900UL
 #define BOOT_GPR_BMR1_OFF	0
+#define BOOT_RCON_MODE_MASK	0x100
 #define BOOT_SOURCE_MASK	0xE0
 #define BOOT_SOURCE_OFF		5
 #define BOOT_SOURCE_QSPI	0
diff --git a/plat/nxp/s32g/s32g_storage.c b/plat/nxp/s32g/s32g_storage.c
index e63226662..161effab5 100644
--- a/plat/nxp/s32g/s32g_storage.c
+++ b/plat/nxp/s32g/s32g_storage.c
@@ -14,10 +14,19 @@
 #include <assert.h>
 #include <tools_share/firmware_image_package.h>
 #include <lib/mmio.h>
+#include <libfdt.h>
+#include <common/fdt_wrappers.h>
+
 #include "s32g_storage.h"
+#include "s32g_bl_common.h"
+#include "s32g_dt.h"
 
 #define FIP_BACKEND_MEMMAP_ID	(BL33_IMAGE_ID + 1)
 
+#define EEPROM_CHIP_ADDR		0x50
+#define EEPROM_BOOT_CFG_OFF		0x0
+#define EEPROM_ADDR_LEN			1
+
 static const io_dev_connector_t *s32g_mmc_io_conn;
 static uintptr_t s32g_mmc_dev_handle;
 
@@ -141,6 +150,49 @@ static int s32g_check_memmap_dev(const uintptr_t spec)
 	return 0;
 }
 
+static uint8_t eeprom_boot_source(void)
+{
+	void *fdt;
+	const char *path;
+	int i2c_node, ret;
+	struct s32g_i2c_driver *driver;
+	uint8_t boot_source;
+
+	ret = dt_open_and_check();
+	if (ret < 0)
+		goto eeprom_boot_src_err;
+
+	if (fdt_get_address(&fdt) == 0)
+		goto eeprom_boot_src_err;
+
+	path = fdt_get_alias(fdt, "i2c0");
+	if (path == NULL) {
+		INFO("No i2c0 property in aliases node\n");
+		goto eeprom_boot_src_err;
+	}
+
+	i2c_node = fdt_path_offset(fdt, path);
+	if (i2c_node < 0) {
+		INFO("Failed to locate i2c0 node using its path\n");
+		goto eeprom_boot_src_err;
+	}
+
+	driver = s32g_add_i2c_module(fdt, i2c_node);
+	if (driver ==  NULL) {
+		NOTICE("Failed to register i2c0 instance!\n");
+		goto eeprom_boot_src_err;
+	}
+
+	s32g_i2c_read(&driver->bus, EEPROM_CHIP_ADDR, EEPROM_BOOT_CFG_OFF,
+					EEPROM_ADDR_LEN, &boot_source, 1);
+	boot_source = boot_source >> BOOT_SOURCE_OFF;
+
+	return boot_source;
+
+eeprom_boot_src_err:
+	return INVALID_BOOT_SOURCE;
+}
+
 static uint8_t get_boot_source(void)
 {
 	uint32_t boot_cfg;
@@ -150,7 +202,11 @@ static uint8_t get_boot_source(void)
 		return boot_source;
 
 	boot_cfg = mmio_read_32(BOOT_GPR_BASE + BOOT_GPR_BMR1_OFF);
-	boot_source = (boot_cfg & BOOT_SOURCE_MASK) >> BOOT_SOURCE_OFF;
+
+	if (boot_cfg & BOOT_RCON_MODE_MASK)
+		boot_source = eeprom_boot_source();
+	else
+		boot_source = (boot_cfg & BOOT_SOURCE_MASK) >> BOOT_SOURCE_OFF;
 
 	switch (boot_source) {
 
@@ -160,6 +216,7 @@ static uint8_t get_boot_source(void)
 		return boot_source;
 
 	default:
+		ERROR("Could not identify the boot source\n");
 		return INVALID_BOOT_SOURCE;
 	}
 }
-- 
2.17.1

