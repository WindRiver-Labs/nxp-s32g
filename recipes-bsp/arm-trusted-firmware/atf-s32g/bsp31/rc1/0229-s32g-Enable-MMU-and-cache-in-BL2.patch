From 0e26ce83f3e2036687fd32c9f005c8f479f5afbf Mon Sep 17 00:00:00 2001
From: Ghennadi Procopciuc <Ghennadi.Procopciuc@nxp.com>
Date: Tue, 11 May 2021 17:13:48 +0300
Subject: [PATCH 229/269] s32g: Enable MMU and cache in BL2

MMU and cache enablement improves bl2_load_images time.
In SD case, the time decreases from ~507ms to ~200ms.
In QSPI case, the time decreases from ~1s to 725ms.
The measurements were done with default FIP_MAXIMUM_SIZE.

Issue: ALB-6995
Upstream-Status: Pending 

Signed-off-by: Ghennadi Procopciuc <Ghennadi.Procopciuc@nxp.com>
Signed-off-by: Larisa Grigore <larisa.grigore@nxp.com>
Signed-off-by: Zhantao Tang <zhantao.tang@windriver.com>
---
 plat/nxp/s32g/include/platform_def.h | 10 +++
 plat/nxp/s32g/platform.mk            |  1 +
 plat/nxp/s32g/s32g_bl2_el3.c         | 93 ++++++++++++++++++++++++++++
 3 files changed, 104 insertions(+)

diff --git a/plat/nxp/s32g/include/platform_def.h b/plat/nxp/s32g/include/platform_def.h
index 852fd2f56..abb72def8 100644
--- a/plat/nxp/s32g/include/platform_def.h
+++ b/plat/nxp/s32g/include/platform_def.h
@@ -218,6 +218,11 @@
 #define MAX_MMAP_REGIONS		17
 #define MAX_XLAT_TABLES			(MAX_MMAP_REGIONS + BL31SRAM_MAX_PAGES)
 #endif
+
+#if defined IMAGE_BL2
+#define MAX_MMAP_REGIONS		16
+#define MAX_XLAT_TABLES			(MAX_MMAP_REGIONS + BL31SRAM_MAX_PAGES)
+#endif
 #if defined IMAGE_BL33
 #pragma warning "BL33 image is being built; you should configure it out."
 #endif
@@ -230,4 +235,9 @@
 #define S32G_SCMI_SHARED_MEM		0xd0000000U
 #define S32G_SCMI_SHARED_MEM_SIZE	0x400000U
 
+#define S32G_QSPI_BASE		(0x40134000ul)
+#define S32G_QSPI_SIZE		(0x1000)
+
+#define S32G_FLASH_BASE		(0x0)
+
 #endif /* PLATFORM_DEF_H */
diff --git a/plat/nxp/s32g/platform.mk b/plat/nxp/s32g/platform.mk
index 611a052f0..2e0ffdceb 100644
--- a/plat/nxp/s32g/platform.mk
+++ b/plat/nxp/s32g/platform.mk
@@ -71,6 +71,7 @@ BL2_SOURCES		+= plat/nxp/s32g/s32g_lowlevel_bl2.S \
 			   ${BL31SSRAM_SRC_DUMP} \
 			   ${DDR_DRV_SRCS} \
 			   lib/optee/optee_utils.c \
+			   ${XLAT_TABLES_LIB_SRCS} \
 
 BL31_SOURCES		+= plat/nxp/s32g/s32g_bl31.c \
 			   plat/nxp/s32g/s32g_psci.c \
diff --git a/plat/nxp/s32g/s32g_bl2_el3.c b/plat/nxp/s32g/s32g_bl2_el3.c
index fa8f8789c..f072611a8 100644
--- a/plat/nxp/s32g/s32g_bl2_el3.c
+++ b/plat/nxp/s32g/s32g_bl2_el3.c
@@ -13,6 +13,8 @@
 #include <drivers/console.h>
 #include <lib/mmio.h>
 #include <lib/optee_utils.h>
+#include <lib/xlat_tables/xlat_tables_v2.h>
+#include "s32g_clocks.h"
 #include "s32g_linflexuart.h"
 #include "s32g_storage.h"
 #include "s32g_mc_rgm.h"
@@ -427,6 +429,93 @@ static void resume_bl31(struct s32g_ssram_mailbox *ssram_mb)
 	resume_entrypoint();
 }
 
+#define MMU_ROUND_UP_TO_4K(x)	\
+			(((x) & ~0xfff) == (x) ? (x) : ((x) & ~0xfff) + 0x1000)
+
+IMPORT_SYM(uintptr_t, __RW_START__, BL2_RW_START);
+
+static const mmap_region_t s32g_mmap[] = {
+	MAP_REGION_FLAT(S32G_SSRAM_BASE, S32G_SSRAM_LIMIT - S32G_SSRAM_BASE,
+			 MT_MEMORY | MT_RW | MT_SECURE),
+	MAP_REGION_FLAT(S32G_UART_BASE, S32G_UART_SIZE,
+			MT_DEVICE | MT_RW | MT_NS),
+	MAP_REGION_FLAT(S32G_MC_ME_BASE_ADDR, S32G_MC_ME_SIZE,
+			MT_DEVICE | MT_RW),
+	MAP_REGION_FLAT(MC_CGM0_BASE_ADDR,
+			MMU_ROUND_UP_TO_4K(S32G_DFS_ADDR(S32G_DFS_NR)),
+			MT_DEVICE | MT_RW),
+	/* This will cover both the MC_RGM and the GPR accesses, while reducing
+	 * the number of used up MMU regions.
+	 */
+	MAP_REGION_FLAT(S32G_MC_RGM_BASE_ADDR, S32G_MC_RGM_SIZE,
+			MT_DEVICE | MT_RW),
+	MAP_REGION_FLAT(SRAMC0_BASE_ADDR, SRAMC_SIZE,
+			MT_DEVICE | MT_RW),
+	MAP_REGION_FLAT(SSRAMC_BASE_ADDR, SRAMC_SIZE,
+			MT_DEVICE | MT_RW),
+	MAP_REGION2(S32G_BL32_BASE, S32G_BL32_BASE,
+			MMU_ROUND_UP_TO_4K(S32G_BL32_SIZE),
+			MT_MEMORY | MT_RW, PAGE_SIZE),
+	MAP_REGION2(S32G_BL33_IMAGE_BASE, S32G_BL33_IMAGE_BASE,
+			MMU_ROUND_UP_TO_4K(S32G_BL33_IMAGE_SIZE),
+			MT_MEMORY | MT_RW, PAGE_SIZE),
+	MAP_REGION_FLAT(S32G_PMEM_START, S32G_PMEM_LEN,
+			MT_MEMORY | MT_RW | MT_SECURE),
+	MAP_REGION_FLAT(S32G_SCMI_SHARED_MEM, S32G_SCMI_SHARED_MEM_SIZE,
+			MT_NON_CACHEABLE | MT_RW | MT_SECURE),
+	MAP_REGION_FLAT(S32G_QSPI_BASE, S32G_QSPI_SIZE, MT_DEVICE | MT_RW),
+	MAP_REGION_FLAT(FIP_BASE, FIP_MAXIMUM_SIZE, MT_RW | MT_SECURE),
+	MAP_REGION_FLAT(S32G_FLASH_BASE, FIP_MAXIMUM_SIZE, MT_RW | MT_SECURE),
+	{0},
+};
+
+void s32g_el3_mmu_fixup(void)
+{
+	const unsigned long code_start = BL_CODE_BASE;
+	const unsigned long code_size = BL_CODE_END - BL_CODE_BASE;
+	const unsigned long rw_start = BL2_RW_START;
+	const unsigned long rw_size = BL_END - BL2_RW_START;
+	mmap_region_t regions[] = {
+		{
+			.base_pa = code_start,
+			.base_va = code_start,
+			.size = code_size,
+			.attr = MT_CODE | MT_SECURE,
+		},
+		{
+			.base_pa = rw_start,
+			.base_va = rw_start,
+			.size = rw_size,
+			.attr = MT_RW | MT_MEMORY | MT_SECURE,
+		},
+	};
+	int i;
+
+	/* The calls to mmap_add_region() consume mmap regions,
+	 * so they must be counted in the static asserts
+	 */
+	_Static_assert(ARRAY_SIZE(s32g_mmap) + ARRAY_SIZE(regions) - 1 <=
+		       MAX_MMAP_REGIONS,
+		       "Fewer MAX_MMAP_REGIONS than in s32g_mmap will likely "
+		       "result in a MMU exception at runtime");
+	_Static_assert(ARRAY_SIZE(s32g_mmap) + ARRAY_SIZE(regions) - 1 +
+		       BL31SRAM_MAX_PAGES <= MAX_XLAT_TABLES,
+		       "Fewer MAX_XLAT_TABLES than in s32g_mmap will likely "
+		       "result in a MMU exception at runtime");
+
+	/* MMU initialization; while technically not necessary, improves
+	 * bl2_load_images execution time.
+	 */
+	for (i = 0; i < ARRAY_SIZE(regions); i++)
+		mmap_add_region(regions[i].base_pa, regions[i].base_va,
+				regions[i].size, regions[i].attr);
+
+	mmap_add(s32g_mmap);
+
+	init_xlat_tables();
+	enable_mmu_el3(0);
+}
+
 void bl2_el3_plat_arch_setup(void)
 {
 	struct s32g_ssram_mailbox *ssram_mb = (void *)BL31SSRAM_MAILBOX;
@@ -441,7 +530,11 @@ void bl2_el3_plat_arch_setup(void)
 		panic();
 	}
 
+	s32g_el3_mmu_fixup();
+
 	s32g_sram_clear(S32G_BL33_IMAGE_BASE, DTB_BASE);
+	s32g_sram_clear(FIP_BASE, FIP_BASE + FIP_MAXIMUM_SIZE);
+
 	s32g_ssram_clear();
 
 	copy_bl31ssram_image();
-- 
2.17.1

