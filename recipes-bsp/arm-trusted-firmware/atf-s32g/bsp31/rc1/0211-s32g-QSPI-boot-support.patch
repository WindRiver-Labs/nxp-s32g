From dad87fc8a6d79e890322317fd12cefdb6707cbc4 Mon Sep 17 00:00:00 2001
From: Ghennadi Procopciuc <Ghennadi.Procopciuc@nxp.com>
Date: Tue, 2 Feb 2021 12:50:11 +0200
Subject: [PATCH 211/269] s32g: QSPI boot support

TF-A will rely on QSPI controller settings left by BootROM and will copy
all images from AHB buffer.

Issue: ALB-6427
Upstream-Status: Pending 

Signed-off-by: Ghennadi Procopciuc <Ghennadi.Procopciuc@nxp.com>
Signed-off-by: Zhantao Tang <zhantao.tang@windriver.com>
---
 plat/nxp/s32g/include/platform_def.h |  9 ++++
 plat/nxp/s32g/s32g_bl2_el3.c         | 16 ++----
 plat/nxp/s32g/s32g_storage.c         | 77 ++++++++++++++++++++--------
 3 files changed, 68 insertions(+), 34 deletions(-)

diff --git a/plat/nxp/s32g/include/platform_def.h b/plat/nxp/s32g/include/platform_def.h
index a2230fd8f..d3d5b185f 100644
--- a/plat/nxp/s32g/include/platform_def.h
+++ b/plat/nxp/s32g/include/platform_def.h
@@ -79,6 +79,14 @@
 #define CA53_1_1_RVBARADDR_39_32_OFF	(24)
 #define CA53_1_1_RVBARADDR_39_32_MASK	(0xFFUL)
 
+#define BOOT_GPR_BASE		0x4007C900UL
+#define BOOT_GPR_BMR1_OFF	0
+#define BOOT_SOURCE_MASK	0xE0
+#define BOOT_SOURCE_OFF		5
+#define BOOT_SOURCE_QSPI	0
+#define BOOT_SOURCE_SD		2
+#define BOOT_SOURCE_MMC		3
+
 #define S32G_XRDC_0_PAC_0_BASE_ADDR	0x40000000ULL
 #define S32G_XRDC_0_PAC_0_SIZE		SIZE_1M
 
@@ -191,6 +199,7 @@
  * aligned to the block size of 512 bytes
  */
 #define FIP_MMC_OFFSET		(0x3400)
+#define FIP_QSPI_OFFSET		(0x3400)
 
 /* FIXME value randomly chosen; should probably be revisited */
 #define PLATFORM_STACK_SIZE		0x4000
diff --git a/plat/nxp/s32g/s32g_bl2_el3.c b/plat/nxp/s32g/s32g_bl2_el3.c
index ab42bf9b6..fa8f8789c 100644
--- a/plat/nxp/s32g/s32g_bl2_el3.c
+++ b/plat/nxp/s32g/s32g_bl2_el3.c
@@ -39,7 +39,7 @@ REGISTER_BL_IMAGE_DESCS(s32g_bl2_mem_params_descs)
 static void add_fip_img_to_mem_params_descs(bl_mem_params_node_t *params,
 					    size_t *index)
 {
-	bl_mem_params_node_t node = {
+	params[(*index)++] = (bl_mem_params_node_t) {
 		.image_id = FIP_IMAGE_ID,
 
 		SET_STATIC_PARAM_HEAD(ep_info, PARAM_EP, VERSION_2,
@@ -52,14 +52,12 @@ static void add_fip_img_to_mem_params_descs(bl_mem_params_node_t *params,
 		.image_info.image_base = FIP_BASE,
 		.next_handoff_image_id = BL31_IMAGE_ID,
 	};
-
-	params[(*index)++] = node;
 }
 
 static void add_bl31_img_to_mem_params_descs(bl_mem_params_node_t *params,
 					     size_t *index)
 {
-	bl_mem_params_node_t node = {
+	params[(*index)++] = (bl_mem_params_node_t) {
 		.image_id = BL31_IMAGE_ID,
 
 		SET_STATIC_PARAM_HEAD(ep_info, PARAM_EP, VERSION_2,
@@ -79,15 +77,13 @@ static void add_bl31_img_to_mem_params_descs(bl_mem_params_node_t *params,
 		.next_handoff_image_id = BL33_IMAGE_ID,
 #endif
 	};
-
-	params[(*index)++] = node;
 }
 
 #ifdef SPD_opteed
 static void add_bl32_img_to_mem_params_descs(bl_mem_params_node_t *params,
 					     size_t *index)
 {
-	bl_mem_params_node_t node = {
+	params[(*index)++] = (bl_mem_params_node_t) {
 		.image_id = BL32_IMAGE_ID,
 
 		SET_STATIC_PARAM_HEAD(ep_info, PARAM_EP, VERSION_2,
@@ -101,15 +97,13 @@ static void add_bl32_img_to_mem_params_descs(bl_mem_params_node_t *params,
 		.image_info.image_base = S32G_BL32_BASE,
 		.next_handoff_image_id = BL33_IMAGE_ID,
 	};
-
-	params[(*index)++] = node;
 }
 
 static void add_bl32_extra1_img_to_mem_params_descs(
 	bl_mem_params_node_t *params,
 	size_t *index)
 {
-	bl_mem_params_node_t node = {
+	params[(*index)++] = (bl_mem_params_node_t) {
 
 		.image_id = BL32_EXTRA1_IMAGE_ID,
 
@@ -124,8 +118,6 @@ static void add_bl32_extra1_img_to_mem_params_descs(
 
 		.next_handoff_image_id = INVALID_IMAGE_ID,
 	};
-
-	params[(*index)++] = node;
 }
 
 #else
diff --git a/plat/nxp/s32g/s32g_storage.c b/plat/nxp/s32g/s32g_storage.c
index 5c5d9e859..407e1c0d1 100644
--- a/plat/nxp/s32g/s32g_storage.c
+++ b/plat/nxp/s32g/s32g_storage.c
@@ -1,5 +1,5 @@
 /*
- * Copyright 2019-2020 NXP
+ * Copyright 2019-2021 NXP
  *
  * SPDX-License-Identifier: BSD-3-Clause
  */
@@ -12,6 +12,7 @@
 #include <drivers/nxp/s32g/mmc/s32g_mmc.h>
 #include <assert.h>
 #include <tools_share/firmware_image_package.h>
+#include <lib/mmio.h>
 #include "s32g_storage.h"
 
 #define FIP_BACKEND_MEMMAP_ID	(BL33_IMAGE_ID + 1)
@@ -57,12 +58,12 @@ static const io_uuid_spec_t bl33_uuid_spec = {
 	.uuid = UUID_NON_TRUSTED_FIRMWARE_BL33,
 };
 
-static const struct plat_io_policy s32g_policies[] = {
-	[FIP_IMAGE_ID] = {
-		&s32g_mmc_dev_handle,
-		(uintptr_t)&fip_mmc_spec,
-		s32g_check_mmc_dev
-	},
+static const io_block_spec_t qspi_fip_memmap_spec = {
+	.offset = FIP_QSPI_OFFSET,
+	.length = ROUND_TO_MMC_BLOCK_SIZE(FIP_MAXIMUM_SIZE),
+};
+
+static struct plat_io_policy s32g_policies[] = {
 	[BL31_IMAGE_ID] = {
 		&s32g_fip_dev_handle,
 		(uintptr_t)&bl31_uuid_spec,
@@ -140,6 +141,33 @@ static int s32g_check_memmap_dev(const uintptr_t spec)
 	return 0;
 }
 
+static bool boot_from_qspi(void)
+{
+	uint32_t boot_cfg = mmio_read_32(BOOT_GPR_BASE + BOOT_GPR_BMR1_OFF);
+	uint32_t boot_source = (boot_cfg & BOOT_SOURCE_MASK) >> BOOT_SOURCE_OFF;
+
+	if (boot_source == BOOT_SOURCE_QSPI)
+		return true;
+
+	return false;
+}
+
+static void set_fip_img_source(struct plat_io_policy *policy)
+{
+	if (boot_from_qspi())
+		*policy = (struct plat_io_policy) {
+			.dev_handle = &s32g_memmap_dev_handle,
+			.image_spec = (uintptr_t)&qspi_fip_memmap_spec,
+			.check = s32g_check_memmap_dev,
+		};
+	else
+		*policy = (struct plat_io_policy) {
+			.dev_handle = &s32g_mmc_dev_handle,
+			.image_spec = (uintptr_t)&fip_mmc_spec,
+			.check = s32g_check_mmc_dev,
+		};
+}
+
 int plat_get_image_source(unsigned int image_id, uintptr_t *dev_handle,
 			  uintptr_t *image_spec)
 {
@@ -148,6 +176,8 @@ int plat_get_image_source(unsigned int image_id, uintptr_t *dev_handle,
 
 	assert(image_id < ARRAY_SIZE(s32g_policies));
 
+	set_fip_img_source(&s32g_policies[FIP_IMAGE_ID]);
+
 	policy = &s32g_policies[image_id];
 	assert(policy && policy->check);
 	ret = policy->check(policy->image_spec);
@@ -165,16 +195,28 @@ int plat_get_image_source(unsigned int image_id, uintptr_t *dev_handle,
 
 void s32g_io_setup(void)
 {
-	if (s32g274a_mmc_register())
-		goto err;
-	if (register_io_dev_mmc(&s32g_mmc_io_conn))
+	if (register_io_dev_memmap(&s32g_memmap_io_conn))
 		goto err;
-	if (io_dev_open(s32g_mmc_io_conn, (uintptr_t)&fip_mmc_spec,
-			&s32g_mmc_dev_handle))
+	if (io_dev_open(s32g_memmap_io_conn, (uintptr_t)&fip_memmap_spec,
+			&s32g_memmap_dev_handle))
 		goto err;
-	if (io_dev_init(s32g_mmc_dev_handle, 0))
+	if (io_dev_init(s32g_memmap_dev_handle,
+			(uintptr_t)FIP_BACKEND_MEMMAP_ID))
 		goto err;
 
+	/* MMC/SD may not be inserted */
+	if (!boot_from_qspi()) {
+		if (s32g274a_mmc_register())
+			goto err;
+		if (register_io_dev_mmc(&s32g_mmc_io_conn))
+			goto err;
+		if (io_dev_open(s32g_mmc_io_conn, (uintptr_t)&fip_mmc_spec,
+				&s32g_mmc_dev_handle))
+			goto err;
+		if (io_dev_init(s32g_mmc_dev_handle, 0))
+			goto err;
+	}
+
 	if (register_io_dev_fip(&s32g_fip_io_conn))
 		goto err;
 	if (io_dev_open(s32g_fip_io_conn, (uintptr_t)&bl31_uuid_spec,
@@ -183,15 +225,6 @@ void s32g_io_setup(void)
 	if (io_dev_init(s32g_fip_dev_handle, 0))
 		goto err;
 
-	if (register_io_dev_memmap(&s32g_memmap_io_conn))
-		goto err;
-	if (io_dev_open(s32g_memmap_io_conn, (uintptr_t)&fip_memmap_spec,
-			&s32g_memmap_dev_handle))
-		goto err;
-	if (io_dev_init(s32g_memmap_dev_handle,
-			(uintptr_t)FIP_BACKEND_MEMMAP_ID))
-		goto err;
-
 	return;
 err:
 	ERROR("Error: %s failed\n", __func__);
-- 
2.17.1

