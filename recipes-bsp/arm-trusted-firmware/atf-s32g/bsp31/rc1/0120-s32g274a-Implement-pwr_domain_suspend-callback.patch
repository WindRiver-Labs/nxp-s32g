From d06470f94da1bef5300c6671ba59712a7ffb99de Mon Sep 17 00:00:00 2001
From: Ghennadi Procopciuc <Ghennadi.Procopciuc@nxp.com>
Date: Wed, 27 May 2020 12:11:23 +0300
Subject: [PATCH 120/269] s32g274a: Implement pwr_domain_suspend callback

Issue: ALB-4907
Upstream-Status: Pending 

Signed-off-by: Ghennadi Procopciuc <Ghennadi.Procopciuc@nxp.com>
Signed-off-by: Zhantao Tang <zhantao.tang@windriver.com>
---
 plat/s32g/include/s32g_clocks.h |   7 ++
 plat/s32g/include/s32g_mc_me.h  |  28 +++++-
 plat/s32g/include/s32g_mc_rgm.h |   8 +-
 plat/s32g/platform.mk           |   1 +
 plat/s32g/s32g_clocks.c         | 112 +++++++++++++++++++++--
 plat/s32g/s32g_mc_me.c          |  98 +++++++++++++++++++++
 plat/s32g/s32g_psci.c           | 151 ++++++++++++++++++++++++++++++--
 7 files changed, 387 insertions(+), 18 deletions(-)

diff --git a/plat/s32g/include/s32g_clocks.h b/plat/s32g/include/s32g_clocks.h
index b6a6f59d5..40fc20dd2 100644
--- a/plat/s32g/include/s32g_clocks.h
+++ b/plat/s32g/include/s32g_clocks.h
@@ -6,6 +6,8 @@
 #ifndef _S32G_CLOCKS_H_
 #define _S32G_CLOCKS_H_
 
+#include <stdint.h>
+
 #define S32G_FXOSC_FREQ		(40000000ul)
 #define S32G_FIRC_FREQ		(48000000ul)
 #define S32G_ERR_CLK_FREQ	(0ul)
@@ -332,5 +334,10 @@ void s32g_plat_ddr_clock_init(void);
 static const uint32_t core_pll_odiv_supported[] = { 1, 2, 4, 10, 20, 40 };
 
 int s32g_set_a53_core_clk(uint64_t freq);
+void s32g_ddr2firc(void);
+void s32g_sw_clks2firc(void);
+void s32g_disable_dfs(enum s32g_dfs_type dfs);
+void s32g_disable_pll(enum s32g_pll_type pll, uint32_t ndivs);
+void s32g_disable_fxosc(void);
 
 #endif /* _S32G_CLOCKS_H_ */
diff --git a/plat/s32g/include/s32g_mc_me.h b/plat/s32g/include/s32g_mc_me.h
index 2d9c3a4f7..23fa1c286 100644
--- a/plat/s32g/include/s32g_mc_me.h
+++ b/plat/s32g/include/s32g_mc_me.h
@@ -14,9 +14,19 @@
 #define S32G_MC_ME_BASE_ADDR	0x40088000ul
 #define S32G_MC_ME_SIZE		0x1000ul
 
+#define MC_ME_MODE_CONF		(S32G_MC_ME_BASE_ADDR + 0x4)
+#define MC_ME_MODE_CONF_STANDBY	BIT(15)
+
+#define MC_ME_MODE_UPD		(S32G_MC_ME_BASE_ADDR + 0x8)
+#define MC_ME_MODE_UPD_UPD	BIT(0)
+
 #define MC_ME_MODE_STAT		(S32G_MC_ME_BASE_ADDR + 0xc)
 #define MODE_STAT_PREV_MODE	BIT(0)
 
+#define MC_ME_MAIN_COREID	(S32G_MC_ME_BASE_ADDR + 0x10)
+#define MC_ME_COREID_PIDX(n)	((n) << 8)
+#define MC_ME_COREID_CIDX(n)	((n) << 0)
+
 #define S32G_MC_ME_PRIMARY_CORE_MASK	((1ul << S32G_PLAT_PRIMARY_CPU) & 0xF)
 #define S32G_MC_ME_SECONDARY_CORE_MASK	(~S32G_MC_ME_PRIMARY_CORE_MASK & 0xF)
 
@@ -34,10 +44,18 @@
 	(S32G_MC_ME_PRTN_N_BASE(n) + 0x4)
 #define S32G_MC_ME_PRTN_N_STAT(n) \
 	(S32G_MC_ME_PRTN_N_BASE(n) + 0x8)
+
+/* COFB0 */
+#define S32G_MC_ME_PRTN_N_COFB0_STAT(n) \
+	(S32G_MC_ME_PRTN_N_BASE(n) + 0x10)
+#define S32G_MC_ME_PRTN_N_COFB0_CLKEN(n) \
+	(S32G_MC_ME_PRTN_N_BASE(n) + 0x30)
+
 #define S32G_MC_ME_PRTN_N_PCONF_PCE_MASK	BIT(0)
 #define S32G_MC_ME_PRTN_N_PCONF_OSSE_MASK	BIT(2)
 #define S32G_MC_ME_PRTN_N_PUPD_PCUD_MASK	BIT(0)
 #define S32G_MC_ME_PRTN_N_PUPD_OSSUD_MASK	BIT(2)
+#define S32G_MC_ME_PRTN_N_REQ(n)		BIT(n)
 
 /* PRTNn_COREm registers */
 #define S32G_MC_ME_PRTN_N_CORE_M_BASE(n, m) \
@@ -52,7 +70,8 @@
 	(S32G_MC_ME_PRTN_N_CORE_M_BASE(n, m) + 0x8)
 #define S32G_MC_ME_PRTN_N_CORE_M_PCONF_CCE_MASK		0x1ul
 #define S32G_MC_ME_PRTN_N_CORE_M_PUPD_CCUPD_MASK	0x1ul
-#define S32G_MC_ME_PRTN_N_CORE_M_STAT_CCS_MASK		0x1ul
+#define S32G_MC_ME_PRTN_N_CORE_M_STAT_CCS_MASK		BIT(0)
+#define S32G_MC_ME_PRTN_N_CORE_M_STAT_WFI_MASK		BIT(31)
 
 /* PRTNn_COFBm registers */
 #define S32G_MC_ME_PRTN_N_COFB_0_CLKEN(n) \
@@ -65,6 +84,7 @@ enum s32g_mc_me_part_no {
 	S32G_MC_ME_PRTN3,
 };
 #define S32G_MC_ME_CA53_PART	S32G_MC_ME_PRTN1
+#define S32G_MC_ME_CM7_PART	S32G_MC_ME_PRTN0
 #define S32G_MC_ME_DDR_0_PART	S32G_MC_ME_PRTN0
 #define S32G_MC_ME_USDHC_PART	S32G_MC_ME_PRTN0
 #define S32G_MC_ME_PFE_PART	S32G_MC_ME_PRTN2
@@ -72,8 +92,14 @@ enum s32g_mc_me_part_no {
 #define S32G_MC_ME_DDR_0_REQ	1
 #define S32G_MC_ME_USDHC_REQ	0
 
+/* Standby master core: A53, cluster 0, core 0*/
+#define S32G_STBY_MASTER_CORE	0
+#define S32G_STBY_MASTER_PART	1
 
 void s32g_kick_secondary_ca53_cores(void);
+void s32g_turn_off_core(uint8_t part, uint8_t core);
+void s32g_disable_cofb_clk(uint8_t part, uint32_t keep_blocks);
+void s32g_set_stby_master_core(uint8_t part, uint8_t core);
 void mc_me_enable_partition_block(uint32_t part, uint32_t block);
 void mc_me_enable_partition(uint32_t part);
 
diff --git a/plat/s32g/include/s32g_mc_rgm.h b/plat/s32g/include/s32g_mc_rgm.h
index 4df613722..3b586555a 100644
--- a/plat/s32g/include/s32g_mc_rgm.h
+++ b/plat/s32g/include/s32g_mc_rgm.h
@@ -19,10 +19,16 @@
 
 #define PERIPH_3_RST		BIT(3)
 
+
+/* Software-resettable domain/partition 0: M7 cores */
+#define S32G_MC_RGM_RST_DOMAIN_CM7	0
+/* Bit corresponding to CM7_n in the cores' RGM reset partition (n=0..2) */
+#define S32G_MC_RGM_RST_CM7_BIT(n)	BIT(n)
+
 /* Software-resettable domain/partition 1: CA53 cores */
 #define S32G_MC_RGM_RST_DOMAIN_CA53	1
 /* Bit corresponding to CA53_n in the cores' RGM reset partition (n=0..3) */
-#define S32G_MC_RGM_RST_CA53_BIT(n)	BIT(n + 1)
+#define S32G_MC_RGM_RST_CA53_BIT(n)	BIT((n) + 1)
 /* The entire domain defined by S32G_MC_RGM_RST_DOMAIN_CA53 can be reset */
 #define S32G_MC_RGM_RST_CA53_PART_BIT	BIT(0)
 
diff --git a/plat/s32g/platform.mk b/plat/s32g/platform.mk
index 5de64d7c3..35c0588d6 100644
--- a/plat/s32g/platform.mk
+++ b/plat/s32g/platform.mk
@@ -56,6 +56,7 @@ BL2_SOURCES		+= plat/s32g/s32g_lowlevel_bl2.S \
 			   ${DDR_DRV}/ddrss_regconf.c
 
 BL31_SOURCES		+= plat/s32g/s32g274a_bl31.c \
+			   plat/s32g/s32g_clocks.c \
 			   plat/s32g/s32g_psci.c \
 			   plat/s32g/s32g274a_pm.c \
 			   plat/common/plat_psci_common.c \
diff --git a/plat/s32g/s32g_clocks.c b/plat/s32g/s32g_clocks.c
index 3f61d4e1d..c897524c4 100644
--- a/plat/s32g/s32g_clocks.c
+++ b/plat/s32g/s32g_clocks.c
@@ -3,11 +3,12 @@
  *
  * SPDX-License-Identifier: BSD-3-Clause
  */
-#include <lib/mmio.h>
-#include <errno.h>
-#include <assert.h>
 #include "s32g_clocks.h"
 #include "s32g_mc_me.h"
+
+#include <assert.h>
+#include <errno.h>
+#include <lib/mmio.h>
 #include <stdbool.h>
 
 static uint64_t plldig_set_refclk(enum s32g_pll_type pll,
@@ -34,6 +35,18 @@ static uint64_t plldig_set_refclk(enum s32g_pll_type pll,
 	return refclk_freq;
 }
 
+void s32g_disable_pll(enum s32g_pll_type pll, uint32_t ndivs)
+{
+	uint32_t div;
+
+	/* Disable all dividers */
+	for (div = 0; div < ndivs; div++)
+		mmio_write_32(PLLDIG_PLLODIV(pll, div), 0);
+
+	/* Disable pll */
+	mmio_write_32(PLLDIG_PLLCR(pll), PLLDIG_PLLCR_PLLPD);
+}
+
 /*
  * Program the pll for various blocks
  *
@@ -156,7 +169,20 @@ static void start_fxosc(void)
 		;
 }
 
-static void disable_dfs(enum s32g_dfs_type dfs)
+void s32g_disable_fxosc(void)
+{
+	uint32_t ctrl = mmio_read_32(FXOSC_CTRL);
+
+	/* Switch OFF the crystal oscillator. */
+	ctrl &= ~FXOSC_CTRL_OSCON;
+
+	mmio_write_32(FXOSC_CTRL, ctrl);
+
+	while (mmio_read_32(FXOSC_STAT) & FXOSC_STAT_OSC_STAT)
+		;
+}
+
+void s32g_disable_dfs(enum s32g_dfs_type dfs)
 {
 	mmio_write_32(DFS_PORTRESET(dfs), DFS_PORTRESET_RESET_MASK);
 	while ((mmio_read_32(DFS_PORTSR(dfs)) & DFS_PORTSR_PORTSTAT_MASK))
@@ -198,7 +224,7 @@ static int program_dfs(enum s32g_dfs_type dfs,
 {
 	uint32_t port = 0;
 
-	disable_dfs(dfs);
+	s32g_disable_dfs(dfs);
 
 	for (port = 0; port < S32G_DFS_PORTS_NR; port++) {
 		if (!(params[port][DFS_PORT_EN]))
@@ -236,7 +262,7 @@ static uintptr_t mc_cgm_addr(enum s32g_mc_cgm mc_cgm)
  *      Clock selection multiplexer::
  *        Software-controlled clock multiplexer"
  */
-int sw_mux_clk_config(uint8_t cgm, uint8_t mux, uint8_t source)
+static int sw_mux_clk_config(enum s32g_mc_cgm cgm, uint8_t mux, uint8_t source)
 {
 	uint32_t css, csc;
 	uintptr_t cgm_addr;
@@ -275,12 +301,81 @@ int sw_mux_clk_config(uint8_t cgm, uint8_t mux, uint8_t source)
 	return -EIO;
 }
 
+static void switch_muxes_to_firc(enum s32g_mc_cgm cgm, uint8_t *muxes,
+				 size_t nmuxes)
+{
+	size_t i;
+
+	for (i = 0; i < nmuxes; i++)
+		sw_mux_clk_config(cgm, muxes[i],
+				  MC_CGM_MUXn_CSC_SEL_CORE_PLL_FIRC);
+}
+
+/**
+ * Switch all platform's clocks to FIRC
+ */
+void s32g_sw_clks2firc(void)
+{
+	/* MC_CGM_MUXn_CSC_SEL_FIRC */
+	uint8_t cgm0_muxes[] = {
+		16, /* SPI */
+		15, /* GMAC_0_REF */
+		14, /* SDHC */
+		12, /* QSPI */
+		11, /* GMAC_0_RX */
+		10, /* GMAC_0_TX */
+		9, /* GMAC_TS */
+		8, /* LINFLEX */
+		7, /* CAN_PE */
+		6, /* FLEXRAY */
+		5, /* FTM_1 */
+		4, /* FTM_0 */
+		3, /* PER */
+		0, /* XBAR_2X */
+	};
+
+	uint8_t cgm1_muxes[] = {
+		0, /* A53_CORE */
+	};
+
+	uint8_t cgm2_muxes[] = {
+		9, /* PFE_MAC_2_REF */
+		8, /* PFE_MAC_1_REF */
+		7, /* PFE_MAC_0_REF */
+		6, /* PEF_MAC_2_RX */
+		5, /* PEF_MAC_1_RX */
+		4, /* PEF_MAC_0_RX */
+		3, /* PFE_MAC_2_TX */
+		2, /* PFE_MAC_1_TX */
+		1, /* PFE_MAC_0_TX_DIV */
+		0, /* PFE_PE */
+	};
+
+	switch_muxes_to_firc(MC_CGM2, &cgm2_muxes[0],
+			     ARRAY_SIZE(cgm2_muxes));
+	switch_muxes_to_firc(MC_CGM1, &cgm1_muxes[0],
+			     ARRAY_SIZE(cgm1_muxes));
+	switch_muxes_to_firc(MC_CGM0, &cgm0_muxes[0],
+			     ARRAY_SIZE(cgm0_muxes));
+}
+
+void s32g_ddr2firc(void)
+{
+	uint8_t cgm5_muxes[] = {
+		0, /* DDR */
+	};
+
+	switch_muxes_to_firc(MC_CGM5, &cgm5_muxes[0],
+			     ARRAY_SIZE(cgm5_muxes));
+}
+
 /* Program a software-controlled clock divider as per chapter
  * "Clock Generation Module (MC_CGM)::
  *    Functional description::
  *      Clock dividers"
  */
-int sw_mux_div_clk_config(uint8_t cgm, uint8_t mux, uint8_t dc, uint8_t divider)
+static int sw_mux_div_clk_config(uint8_t cgm, uint8_t mux,
+				 uint8_t dc, uint8_t divider)
 {
 	uintptr_t cgm_addr;
 
@@ -336,7 +431,7 @@ int s32g_set_a53_core_clk(uint64_t clk)
 
 	sw_mux_clk_config(MC_CGM1, 0,
 			  MC_CGM_MUXn_CSC_SEL_CORE_PLL_FIRC);
-	disable_dfs(S32G_CORE_DFS);
+	s32g_disable_dfs(S32G_CORE_DFS);
 
 	/* Configure the CORE_PLL */
 	program_pll(S32G_CORE_PLL, S32G_REFCLK_FXOSC, core_pll_phi_freq,
@@ -424,3 +519,4 @@ void s32g_plat_ddr_clock_init(void)
 		    s32g_pll_mfn[S32G_DDR_PLL]);
 	sw_mux_clk_config(MC_CGM5, 0, MC_CGM_MUXn_CSC_SEL_DDR_PLL_PHI0);
 }
+
diff --git a/plat/s32g/s32g_mc_me.c b/plat/s32g/s32g_mc_me.c
index 0d7d78fc7..4428df7fd 100644
--- a/plat/s32g/s32g_mc_me.c
+++ b/plat/s32g/s32g_mc_me.c
@@ -278,3 +278,101 @@ void s32g_kick_secondary_ca53_cores(void)
 	s32g_kick_secondary_ca53_core(2);
 	s32g_kick_secondary_ca53_core(3);
 }
+
+void s32g_turn_off_core(uint8_t part, uint8_t core)
+{
+	uint32_t resetc;
+	uint32_t stat;
+	uint32_t statv;
+	uintptr_t prst;
+	uintptr_t pstat;
+
+	/* Assumption : The core is already in WFI */
+	stat = mmio_read_32(S32G_MC_ME_PRTN_N_CORE_M_STAT(part, core));
+
+	/* The clock isn't enabled */
+	if (!(stat & S32G_MC_ME_PRTN_N_CORE_M_STAT_CCS_MASK))
+		return;
+
+	/* Wait for WFI */
+	do {
+		stat = mmio_read_32(S32G_MC_ME_PRTN_N_CORE_M_STAT(part, core));
+	} while (!(stat & S32G_MC_ME_PRTN_N_CORE_M_STAT_WFI_MASK));
+
+	/* Disable the core clock */
+	mc_me_part_core_pconf_write_cce(0, part, core);
+	mc_me_part_core_pupd_write_ccupd(1, part, core);
+
+	/* Write valid key sequence to trigger the update. */
+	mc_me_apply_hw_changes();
+
+	/* Wait for the core clock to become inactive */
+	while (s32g_core_clock_running(part, core))
+		;
+
+	if (part == S32G_MC_ME_CA53_PART) {
+		resetc = S32G_MC_RGM_RST_CA53_BIT(core);
+		prst = S32G_MC_RGM_PRST(S32G_MC_RGM_RST_DOMAIN_CA53);
+		pstat = S32G_MC_RGM_PSTAT(S32G_MC_RGM_RST_DOMAIN_CA53);
+	} else {
+		/* M7 cores */
+		resetc = S32G_MC_RGM_RST_CM7_BIT(core);
+		prst = S32G_MC_RGM_PRST(S32G_MC_RGM_RST_DOMAIN_CM7);
+		pstat = S32G_MC_RGM_PSTAT(S32G_MC_RGM_RST_DOMAIN_CM7);
+	}
+	statv = resetc;
+
+	/* Assert the core reset */
+	resetc |= mmio_read_32(prst);
+	mmio_write_32(prst, resetc);
+
+
+	/* Wait reset status */
+	while (!(mmio_read_32(pstat) & statv))
+		;
+}
+
+void s32g_disable_cofb_clk(uint8_t part, uint32_t keep_blocks)
+{
+	uint32_t pconf;
+
+	if (!mmio_read_32(S32G_MC_ME_PRTN_N_COFB0_CLKEN(part)))
+		return;
+
+	/* Disable all blocks */
+	mmio_write_32(S32G_MC_ME_PRTN_N_COFB0_CLKEN(part), keep_blocks);
+
+	pconf = mmio_read_32(S32G_MC_ME_PRTN_N_PCONF(part));
+
+	/* Keep the partition on if not all the blocks are disabled */
+	if (keep_blocks == 0)
+		pconf &= ~S32G_MC_ME_PRTN_N_PCONF_PCE_MASK;
+
+	/* Disable the clock to IPs */
+	mmio_write_32(S32G_MC_ME_PRTN_N_PCONF(part), pconf);
+
+	/* Initiate the clock hardware process */
+	mc_me_part_pupd_write_pcud(S32G_MC_ME_PRTN_N_PUPD_PCUD_MASK, part);
+
+	/* Write valid key sequence to trigger the update. */
+	mc_me_apply_hw_changes();
+
+	/* Make sure the COFB clock is gated */
+	while (mmio_read_32(S32G_MC_ME_PRTN_N_COFB0_STAT(part)) != keep_blocks)
+		;
+}
+
+void s32g_set_stby_master_core(uint8_t part, uint8_t core)
+{
+	/* Set the master core for the standby sequence */
+	mmio_write_32(MC_ME_MAIN_COREID,
+		      MC_ME_COREID_PIDX(part) |
+		      MC_ME_COREID_CIDX(core));
+
+	/* Initiate standby */
+	mmio_write_32(MC_ME_MODE_CONF, MC_ME_MODE_CONF_STANDBY);
+	mmio_write_32(MC_ME_MODE_UPD, MC_ME_MODE_UPD_UPD);
+
+	/* Write valid key sequence to trigger the update. */
+	mc_me_apply_hw_changes();
+}
diff --git a/plat/s32g/s32g_psci.c b/plat/s32g/s32g_psci.c
index cdca6e884..1e8c03374 100644
--- a/plat/s32g/s32g_psci.c
+++ b/plat/s32g/s32g_psci.c
@@ -3,20 +3,22 @@
  *
  * SPDX-License-Identifier: BSD-3-Clause
  */
+#include "platform_def.h"
+#include "pmic/vr5510.h"
+#include "s32g_clocks.h"
+#include "s32g_lowlevel.h"	/* plat_is_my_cpu_primary() */
+#include "s32g_mc_me.h"
+#include "s32g_ncore.h"
+
 #include <arch_helpers.h>
+#include <assert.h>
 #include <bl31/bl31.h>		/* for bl31_warm_entrypoint() */
 #include <bl31/interrupt_mgmt.h>
-#include <string.h>
-#include <assert.h>
 #include <common/debug.h>	/* printing macros such as INFO() */
-#include <plat/common/platform.h>
 #include <drivers/arm/gicv3.h>
 #include <lib/mmio.h>
-
-#include "s32g_ncore.h"
-#include "s32g_mc_me.h"
-#include "platform_def.h"
-#include "s32g_lowlevel.h"	/* plat_is_my_cpu_primary() */
+#include <plat/common/platform.h>
+#include <string.h>
 
 IMPORT_SYM(unsigned long, __BL31_START__, bl31_start);
 IMPORT_SYM(unsigned long, __BL31_END__, bl31_end);
@@ -177,6 +179,9 @@ static void __dead2 s32g_pwr_domain_pwr_down_wfi(
 	 */
 	s32g_pwr_down_wfi_fixups();
 
+	/* Set standby master core and request the standby transition */
+	s32g_set_stby_master_core(S32G_STBY_MASTER_PART, S32G_STBY_MASTER_CORE);
+
 	/*
 	 * A torn-apart variant of psci_power_down_wfi()
 	 */
@@ -204,9 +209,139 @@ static void s32g_pwr_domain_suspend_finish(
 	NOTICE("S32G TF-A: %s\n", __func__);
 }
 
+static int prepare_vr5510(void)
+{
+	int ret;
+	vr5510_t mu, fsu;
+
+	uint16_t reg;
+	uint8_t *regp = (uint8_t *)&reg;
+
+	ret = vr5510_get_inst(VR5510_MU_NAME, &mu);
+	if (ret)
+		return ret;
+
+	ret = vr5510_get_inst(VR5510_FSU_NAME, &fsu);
+	if (ret)
+		return ret;
+
+
+	/* Clear I2C errors if any */
+	reg = VR5510_FLAG3_I2C_M_REQ | VR5510_FLAG3_I2C_M_CRC;
+	ret = vr5510_write(mu, VR5510_M_FLAG3, regp, sizeof(reg));
+	if (ret)
+		return ret;
+
+	/* Wait forever */
+	reg = 0x0;
+	ret = vr5510_write(mu, VR5510_M_SM_CTRL1, regp, sizeof(reg));
+	if (ret)
+		return ret;
+
+	reg = VR5510_CTRL3_VPREV_STBY | VR5510_CTRL3_HVLDO_STBY
+		| VR5510_CTRL3_BUCK3_STBY |  VR5510_CTRL3_LDO2_STBY;
+	ret = vr5510_write(mu, VR5510_M_REG_CTRL3, regp, sizeof(reg));
+	if (ret)
+		return ret;
+
+	reg = VR5510_FLAG1_ALL_FLAGS;
+	ret = vr5510_write(mu, VR5510_M_FLAG1, regp, sizeof(reg));
+	if (ret)
+		return ret;
+
+	reg = VR5510_FLAG2_ALL_FLAGS;
+	ret = vr5510_write(mu, VR5510_M_FLAG2, regp, sizeof(reg));
+	if (ret)
+		return ret;
+
+	reg = VR5510_M_CLOCK2_600KHZ;
+	ret = vr5510_write(mu, VR5510_M_CLOCK2, regp, sizeof(reg));
+	if (ret)
+		return ret;
+
+	/* Check for I2C errors */
+	ret = vr5510_read(mu, VR5510_M_FLAG3, regp, sizeof(reg));
+	if (ret)
+		return ret;
+
+	if (reg & (VR5510_FLAG3_I2C_M_REQ | VR5510_FLAG3_I2C_M_CRC)) {
+		ERROR("VR5510-MU: Detected I2C errors");
+		return -EIO;
+	}
+
+	/* Clear I2C errors if any */
+	reg = VR5510_GRL_FLAGS_I2C_FS_REQ | VR5510_GRL_FLAGS_I2C_FS_CRC;
+	ret = vr5510_write(fsu, VR5510_FS_GRL_FLAGS, regp, sizeof(reg));
+	if (ret)
+		return ret;
+
+	/* Disable I2C timeout */
+	reg = 0;
+	ret = vr5510_write(fsu, VR5510_FS_I_SAFE_INPUTS, regp, sizeof(reg));
+	if (ret)
+		return ret;
+
+	reg = VR5510_FS_I_NOT_VALUE(reg);
+	ret = vr5510_write(fsu, VR5510_FS_I_NOT_SAFE_INPUTS, regp, sizeof(reg));
+	if (ret)
+		return ret;
+
+	/* Check for I2C errors */
+	ret = vr5510_read(fsu, VR5510_FS_GRL_FLAGS, regp, sizeof(reg));
+	if (ret)
+		return ret;
+
+	if (reg & (VR5510_GRL_FLAGS_I2C_FS_REQ | VR5510_GRL_FLAGS_I2C_FS_CRC)) {
+		ERROR("VR5510-FSU: Detected I2C errors\n");
+		return -EIO;
+	}
+
+	/* Standby request */
+	ret = vr5510_read(fsu, VR5510_FS_SAFE_IOS, regp, sizeof(reg));
+	if (ret)
+		return ret;
+
+	reg |= VR5510_SAFE_IOS_STBY_REQ;
+	ret = vr5510_write(fsu, VR5510_FS_SAFE_IOS, regp, sizeof(reg));
+	if (ret)
+		return ret;
+
+	return 0;
+}
+
 static void s32g_pwr_domain_suspend(const psci_power_state_t *target_state)
 {
 	NOTICE("S32G TF-A: %s\n", __func__);
+	prepare_vr5510();
+
+	/* Shutting down cores */
+	/* M7 cores */
+	s32g_turn_off_core(S32G_MC_ME_CM7_PART, 2);
+	s32g_turn_off_core(S32G_MC_ME_CM7_PART, 1);
+	s32g_turn_off_core(S32G_MC_ME_CM7_PART, 0);
+
+	/* A53 cores */
+	s32g_turn_off_core(S32G_MC_ME_CA53_PART, 3);
+	s32g_turn_off_core(S32G_MC_ME_CA53_PART, 2);
+	s32g_turn_off_core(S32G_MC_ME_CA53_PART, 1);
+
+	/* PFE blocks */
+	s32g_disable_cofb_clk(S32G_MC_ME_PFE_PART, 0);
+	/* Keep the DDR clock */
+	s32g_disable_cofb_clk(S32G_MC_ME_USDHC_PART,
+			S32G_MC_ME_PRTN_N_REQ(S32G_MC_ME_DDR_0_REQ));
+
+	/* Switching all MC_CGM muxes to FIRC */
+	s32g_sw_clks2firc();
+
+	/* Turn off DFS */
+	s32g_disable_dfs(S32G_PERIPH_DFS);
+	s32g_disable_dfs(S32G_CORE_DFS);
+
+	/* Turn off PLL */
+	s32g_disable_pll(S32G_ACCEL_PLL, 2);
+	s32g_disable_pll(S32G_PERIPH_PLL, 8);
+	s32g_disable_pll(S32G_CORE_PLL, 2);
 }
 
 static void s32g_get_sys_suspend_power_state(psci_power_state_t *req_state)
-- 
2.17.1

