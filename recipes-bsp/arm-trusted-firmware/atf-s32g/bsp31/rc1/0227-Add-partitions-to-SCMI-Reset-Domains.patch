From 05145b9c66b2a9b14f29a556acd388ed957a611f Mon Sep 17 00:00:00 2001
From: Ghennadi Procopciuc <ghennadi.procopciuc@nxp.com>
Date: Fri, 23 Apr 2021 15:29:53 +0300
Subject: [PATCH 227/269] Add partitions to SCMI Reset Domains

Issue: ALB-7039
Upstream-Status: Pending 

Signed-off-by: Ghennadi Procopciuc <Ghennadi.Procopciuc@nxp.com>
Signed-off-by: Zhantao Tang <zhantao.tang@windriver.com>
---
 drivers/nxp/s32g/clk/enable_clk.c             | 112 +++++++++++++++---
 drivers/nxp/s32g/rst/s32gen1_rst.c            |  30 ++++-
 .../drivers/nxp/s32g/clk/s32gen1_clk_funcs.h  |   4 +
 .../drivers/nxp/s32g/clk/s32gen1_scmi_rst.h   |   2 +
 plat/nxp/s32g/s32g_scmi_rst.c                 |  27 ++++-
 5 files changed, 150 insertions(+), 25 deletions(-)

diff --git a/drivers/nxp/s32g/clk/enable_clk.c b/drivers/nxp/s32g/clk/enable_clk.c
index b6464e944..ff11ae21a 100644
--- a/drivers/nxp/s32g/clk/enable_clk.c
+++ b/drivers/nxp/s32g/clk/enable_clk.c
@@ -79,15 +79,104 @@ static void mc_me_wait_update(uint32_t partition_n, uint32_t mask,
 		;
 }
 
-static void enable_partition(uint32_t partition_n,
-			     struct s32gen1_clk_priv *priv)
+static void set_rdc_lock(void *rdc, uint32_t partition_n, bool lock)
+{
+	uint32_t rdc_ctrl = mmio_read_32(RDC_RD_N_CTRL(rdc, partition_n));
+
+	if (lock)
+		rdc_ctrl &= ~RD_CTRL_UNLOCK_MASK;
+	else
+		rdc_ctrl |= RD_CTRL_UNLOCK_MASK;
+
+	mmio_write_32(RDC_RD_N_CTRL(rdc, partition_n), rdc_ctrl);
+}
+
+static void unlock_rdc_write(void *rdc, uint32_t partition_n)
+{
+	set_rdc_lock(rdc, partition_n, false);
+}
+
+static void lock_rdc_write(void *rdc, uint32_t partition_n)
+{
+	set_rdc_lock(rdc, partition_n, true);
+}
+
+void s32gen1_disable_partition(struct s32gen1_clk_priv *priv,
+			       uint32_t partition_n)
+{
+	void *mc_me = priv->mc_me;
+	void *rdc = priv->rdc;
+	void *rgm = priv->rgm;
+	uint32_t rdc_ctrl, prst, pconf, part_status;
+
+	part_status = mmio_read_32(MC_ME_PRTN_N_STAT(mc_me, partition_n));
+
+	/* Skip if already disabled */
+	if (!(MC_ME_PRTN_N_PCS & part_status))
+		return;
+
+	/* Unlock RDC register write */
+	unlock_rdc_write(rdc, partition_n);
+
+	/* Disable the XBAR interface */
+	rdc_ctrl = mmio_read_32(RDC_RD_N_CTRL(rdc, partition_n));
+	rdc_ctrl |= RDC_RD_INTERCONNECT_DISABLE;
+	mmio_write_32(RDC_RD_N_CTRL(rdc, partition_n), rdc_ctrl);
+
+	/* Wait until XBAR interface gets disabled */
+	while (!(mmio_read_32(RDC_RD_N_STATUS(rdc, partition_n)) &
+		RDC_RD_INTERCONNECT_DISABLE_STAT))
+		;
+
+	/* Disable partition clock */
+	pconf = mmio_read_32(MC_ME_PRTN_N_PCONF(mc_me, partition_n));
+	mmio_write_32(MC_ME_PRTN_N_PCONF(mc_me, partition_n),
+		      pconf & ~MC_ME_PRTN_N_PCE);
+
+	mc_me_wait_update(partition_n, MC_ME_PRTN_N_PCUD, priv);
+
+	while (mmio_read_32(MC_ME_PRTN_N_STAT(mc_me, partition_n)) &
+	       MC_ME_PRTN_N_PCS)
+		;
+
+	/* Partition isolation */
+	mmio_write_32(MC_ME_PRTN_N_PCONF(mc_me, partition_n),
+		      mmio_read_32(MC_ME_PRTN_N_PCONF(mc_me, partition_n)) |
+		      MC_ME_PRTN_N_OSSE);
+
+	mc_me_wait_update(partition_n, MC_ME_PRTN_N_OSSUD, priv);
+
+	while (!(mmio_read_32(MC_ME_PRTN_N_STAT(mc_me, partition_n)) &
+	       MC_ME_PRTN_N_OSSS))
+		;
+
+	/* Assert partition reset */
+	prst = mmio_read_32(RGM_PRST(rgm, partition_n));
+	mmio_write_32(RGM_PRST(rgm, partition_n),
+		      prst | PRST_PERIPH_n_RST(0));
+
+	while (!(mmio_read_32(RGM_PSTAT(rgm, partition_n)) &
+			PSTAT_PERIPH_n_STAT(0)))
+		;
+
+	lock_rdc_write(rdc, partition_n);
+}
+
+void s32gen1_enable_partition(struct s32gen1_clk_priv *priv,
+			      uint32_t partition_n)
 {
 	void *mc_me = priv->mc_me;
 	void *rdc = priv->rdc;
 	void *rgm = priv->rgm;
-	uint32_t rdc_ctrl, prst, ctrl;
-	uint32_t pconf = mmio_read_32(MC_ME_PRTN_N_PCONF(mc_me, partition_n));
+	uint32_t rdc_ctrl, prst, part_status, pconf;
+
+	part_status = mmio_read_32(MC_ME_PRTN_N_STAT(mc_me, partition_n));
+
+	/* Enable a partition only if it's disabled */
+	if (MC_ME_PRTN_N_PCS & part_status)
+		return;
 
+	pconf = mmio_read_32(MC_ME_PRTN_N_PCONF(mc_me, partition_n));
 	mmio_write_32(MC_ME_PRTN_N_PCONF(mc_me, partition_n),
 		      pconf | MC_ME_PRTN_N_PCE);
 
@@ -98,9 +187,7 @@ static void enable_partition(uint32_t partition_n,
 		;
 
 	/* Unlock RDC register write */
-	rdc_ctrl = mmio_read_32(RDC_RD_N_CTRL(rdc, partition_n));
-	mmio_write_32(RDC_RD_N_CTRL(rdc, partition_n),
-		      rdc_ctrl | RD_CTRL_UNLOCK_MASK);
+	unlock_rdc_write(rdc, partition_n);
 
 	/* Enable the XBAR interface */
 	rdc_ctrl = mmio_read_32(RDC_RD_N_CTRL(rdc, partition_n));
@@ -133,9 +220,7 @@ static void enable_partition(uint32_t partition_n,
 		;
 
 	/* Lock RDC register write */
-	ctrl = mmio_read_32(RDC_RD_N_CTRL(rdc, partition_n));
-	mmio_write_32(RDC_RD_N_CTRL(rdc, partition_n),
-		      ctrl & ~RD_CTRL_UNLOCK_MASK);
+	lock_rdc_write(rdc, partition_n);
 }
 
 static void enable_part_cofb(uint32_t partition_n, uint32_t block,
@@ -144,14 +229,9 @@ static void enable_part_cofb(uint32_t partition_n, uint32_t block,
 {
 	void *mc_me = priv->mc_me;
 	uint32_t block_mask = MC_ME_PRTN_N_REQ(block);
-	uint32_t part_status;
 	uint32_t clken, pconf, cofb_stat_addr;
 
-	part_status = mmio_read_32(MC_ME_PRTN_N_STAT(mc_me, partition_n));
-
-	/* Enable a partition only if it's disabled */
-	if (!(MC_ME_PRTN_N_PCS & part_status))
-		enable_partition(partition_n, priv);
+	s32gen1_enable_partition(priv, partition_n);
 
 	clken = mmio_read_32(MC_ME_PRTN_N_COFB0_CLKEN(mc_me, partition_n));
 	mmio_write_32(MC_ME_PRTN_N_COFB0_CLKEN(mc_me, partition_n),
diff --git a/drivers/nxp/s32g/rst/s32gen1_rst.c b/drivers/nxp/s32g/rst/s32gen1_rst.c
index 01f865b2b..adc3db2c8 100644
--- a/drivers/nxp/s32g/rst/s32gen1_rst.c
+++ b/drivers/nxp/s32g/rst/s32gen1_rst.c
@@ -4,10 +4,11 @@
  */
 #include <clk/clk.h>
 #include <clk/mc_rgm_regs.h>
+#include <clk/s32gen1_clk_funcs.h>
 #include <clk/s32gen1_clk_modules.h>
 #include <clk/s32gen1_scmi_clk.h>
-#include <lib/mmio.h>
 #include <drivers/delay_timer.h>
+#include <lib/mmio.h>
 
 #define S32GEN1_RESET_TIMEOUT_US	(1000)
 
@@ -98,15 +99,38 @@ static int s32gen1_assert_rgm(uintptr_t rgm, bool asserted, uint32_t id)
 	return -EINVAL;
 }
 
-int s32gen1_reset_periph(uint32_t periph_id, bool assert)
+static struct clk_driver *get_clk_drv(void)
 {
 	static struct clk_driver *drv;
-	struct s32gen1_clk_priv *priv;
 
 	if (!drv)
 		drv = get_clk_driver_by_name(S32GEN1_CLK_DRV_NAME);
 
+	return drv;
+}
+
+int s32gen1_reset_periph(uint32_t periph_id, bool assert)
+{
+	struct clk_driver *drv = get_clk_drv();
+	struct s32gen1_clk_priv *priv;
+
 	priv = get_clk_drv_data(drv);
 
 	return s32gen1_assert_rgm((uintptr_t)priv->rgm, assert, periph_id);
 }
+
+int s32gen1_reset_partition(unsigned int part_id, bool assert_not_deassert)
+{
+	struct clk_driver *drv = get_clk_drv();
+	struct s32gen1_clk_priv *priv;
+
+	priv = get_clk_drv_data(drv);
+
+	if (assert_not_deassert)
+		s32gen1_disable_partition(priv, part_id);
+	else
+		s32gen1_enable_partition(priv, part_id);
+
+	return 0;
+}
+
diff --git a/include/drivers/nxp/s32g/clk/s32gen1_clk_funcs.h b/include/drivers/nxp/s32g/clk/s32gen1_clk_funcs.h
index 801748342..b985b6233 100644
--- a/include/drivers/nxp/s32g/clk/s32gen1_clk_funcs.h
+++ b/include/drivers/nxp/s32g/clk/s32gen1_clk_funcs.h
@@ -15,6 +15,10 @@ unsigned long s32gen1_set_rate(struct clk *c, unsigned long rate);
 int s32gen1_set_parent(struct clk *c, struct clk *p);
 int s32gen1_enable(struct clk *c, int enable);
 int s32gen1_disable(struct clk *c);
+void s32gen1_disable_partition(struct s32gen1_clk_priv *priv,
+			       uint32_t partition_n);
+void s32gen1_enable_partition(struct s32gen1_clk_priv *priv,
+			      uint32_t partition_n);
 
 unsigned long s32gen1_get_rate(struct clk *clk);
 unsigned long get_module_rate(struct s32gen1_clk_obj *module,
diff --git a/include/drivers/nxp/s32g/clk/s32gen1_scmi_rst.h b/include/drivers/nxp/s32g/clk/s32gen1_scmi_rst.h
index cf0a82b25..e2d734317 100644
--- a/include/drivers/nxp/s32g/clk/s32gen1_scmi_rst.h
+++ b/include/drivers/nxp/s32g/clk/s32gen1_scmi_rst.h
@@ -6,8 +6,10 @@
 #define S32GEN1_SCMI_RST_H
 
 #include <stdint.h>
+#include <stdbool.h>
 
 int s32gen1_reset_periph(uint32_t periph_id, bool assert);
+int s32gen1_reset_partition(unsigned int part_id, bool assert_not_deassert);
 
 #endif
 
diff --git a/plat/nxp/s32g/s32g_scmi_rst.c b/plat/nxp/s32g/s32g_scmi_rst.c
index 53a486d91..03da70133 100644
--- a/plat/nxp/s32g/s32g_scmi_rst.c
+++ b/plat/nxp/s32g/s32g_scmi_rst.c
@@ -1,11 +1,11 @@
 // SPDX-License-Identifier: BSD-3-Clause
 /* Copyright 2021 NXP */
 #include <cdefs.h>
+#include <clk/s32gen1_scmi_rst.h>
 #include <common/debug.h>
-#include <drivers/st/scmi.h>
 #include <drivers/st/scmi-msg.h>
+#include <drivers/st/scmi.h>
 #include <dt-bindings/reset/s32g-scmi-reset.h>
-#include <clk/s32gen1_scmi_rst.h>
 
 struct reset_entry {
 	const char *name;
@@ -38,8 +38,9 @@ static const struct reset_entry reset_table[] = {
 	[S32GEN1_SCMI_RST_A53_1] = PERIPH_RESET(66, "a53_1"),
 	[S32GEN1_SCMI_RST_A53_2] = PERIPH_RESET(67, "a53_2"),
 	[S32GEN1_SCMI_RST_A53_3] = PERIPH_RESET(68, "a53_3"),
-	[S32G_SCMI_RST_PFE] = PERIPH_RESET(128, "pfe"),
-	[S32G_SCMI_RST_LLCE] = PERIPH_RESET(192, "llce"),
+	/* PFE and LLCE cannot be reset as an independent peripherals */
+	[S32G_SCMI_RST_PFE] = PART_RESET(2, "pfe"),
+	[S32G_SCMI_RST_LLCE] = PART_RESET(3, "llce"),
 };
 
 uint32_t get_reset_block(uint32_t scmi_id)
@@ -47,6 +48,10 @@ uint32_t get_reset_block(uint32_t scmi_id)
 	return reset_table[scmi_id].id;
 }
 
+uint32_t get_part_id(uint32_t scmi_id)
+{
+	return reset_table[scmi_id].id;
+}
 
 size_t plat_scmi_rstd_count(unsigned int agent_id __unused)
 {
@@ -69,6 +74,11 @@ int32_t plat_scmi_rstd_autonomous(unsigned int agent_id __unused,
 	return SCMI_NOT_SUPPORTED;
 }
 
+static bool is_partition(unsigned int scmi_id)
+{
+	return reset_table[scmi_id].part;
+}
+
 int32_t plat_scmi_rstd_set_state(unsigned int agent_id __unused,
 				 unsigned int scmi_id,
 				 bool assert_not_deassert)
@@ -78,8 +88,13 @@ int32_t plat_scmi_rstd_set_state(unsigned int agent_id __unused,
 	if (scmi_id >= ARRAY_SIZE(reset_table))
 		return SCMI_OUT_OF_RANGE;
 
-	ret = s32gen1_reset_periph(get_reset_block(scmi_id),
-				   assert_not_deassert);
+	if (is_partition(scmi_id))
+		ret = s32gen1_reset_partition(get_part_id(scmi_id),
+					      assert_not_deassert);
+	else
+		ret = s32gen1_reset_periph(get_reset_block(scmi_id),
+					   assert_not_deassert);
+
 	if (ret)
 		return SCMI_HARDWARE_ERROR;
 
-- 
2.17.1

