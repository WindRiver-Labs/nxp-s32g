From 65b2f8cb8b43076981c312e378bf3b28ad2bae5a Mon Sep 17 00:00:00 2001
From: Larisa Grigore <larisa.grigore@nxp.com>
Date: Thu, 2 Jul 2020 15:32:28 +0300
Subject: [PATCH 165/269] s32g: i2c: Replace i2c driver

Re-implement driver under a BSD-3 license.

Issue: ALB-5052
Upstream-Status: Pending 

Signed-off-by: Larisa Grigore <larisa.grigore@nxp.com>
Signed-off-by: Zhantao Tang <zhantao.tang@windriver.com>
---
 drivers/nxp/s32g/i2c/s32g_i2c.c         | 626 ++++++++++--------------
 include/drivers/nxp/s32g/i2c/s32g_i2c.h |  24 +-
 2 files changed, 267 insertions(+), 383 deletions(-)

diff --git a/drivers/nxp/s32g/i2c/s32g_i2c.c b/drivers/nxp/s32g/i2c/s32g_i2c.c
index e5b146b52..961da5a72 100644
--- a/drivers/nxp/s32g/i2c/s32g_i2c.c
+++ b/drivers/nxp/s32g/i2c/s32g_i2c.c
@@ -1,17 +1,6 @@
-// SPDX-License-Identifier: GPL-2.0+
+// SPDX-License-Identifier: BSD-3-Clause
 /*
- * i2c driver for Freescale i.MX series
- *
- * (c) 2007 Pengutronix, Sascha Hauer <s.hauer@pengutronix.de>
- * (c) 2011 Marek Vasut <marek.vasut@gmail.com>
- *
- * Based on i2c-imx.c from linux kernel:
- *  Copyright (C) 2005 Torsten Koschorrek <koschorrek at synertronixx.de>
- *  Copyright (C) 2005 Matthias Blaschke <blaschke at synertronixx.de>
- *  Copyright (C) 2007 RightHand Technologies, Inc.
- *  Copyright (C) 2008 Darius Augulis <darius.augulis at teltonika.lt>
- *  Copyright 2020 NXP
- *
+ * Copyright 2020 NXP
  */
 
 #include <stdio.h>
@@ -22,476 +11,381 @@
 #include "s32g_clocks.h"
 #include "s32g_dt.h"
 
-#define I2C_QUIRK_FLAG		(1 << 0)
-#define I2C_QUIRK_REG
-
-#define IMX_I2C_REGSHIFT	2
-#define VF610_I2C_REGSHIFT	0
-
 /* Register index */
-#define IADR	0
-#define IFDR	1
-#define I2CR	2
-#define I2SR	3
-#define I2DR	4
-
-#define I2CR_IIEN	(1 << 6)
-#define I2CR_MSTA	(1 << 5)
-#define I2CR_MTX	(1 << 4)
-#define I2CR_TX_NO_AK	(1 << 3)
-#define I2CR_RSTA	(1 << 2)
-
-#define I2SR_ICF	(1 << 7)
-#define I2SR_IBB	(1 << 5)
-#define I2SR_IAL	(1 << 4)
-#define I2SR_IIF	(1 << 1)
-#define I2SR_RX_NO_AK	(1 << 0)
-
-#ifdef I2C_QUIRK_REG
-#define I2CR_IEN	(0 << 7)
-#define I2CR_IDIS	(1 << 7)
-#define I2SR_IIF_CLEAR	(1 << 1)
-#else
-#define I2CR_IEN	(1 << 7)
-#define I2CR_IDIS	(0 << 7)
-#define I2SR_IIF_CLEAR	(0 << 1)
-#endif
-
-#ifdef I2C_QUIRK_REG
-static uint16_t i2c_clk_div[60][2] = {
-	{ 20,	0x00 }, { 22,	0x01 }, { 24,	0x02 }, { 26,	0x03 },
-	{ 28,	0x04 },	{ 30,	0x05 },	{ 32,	0x09 }, { 34,	0x06 },
-	{ 36,	0x0A }, { 40,	0x07 }, { 44,	0x0C }, { 48,	0x0D },
-	{ 52,	0x43 },	{ 56,	0x0E }, { 60,	0x45 }, { 64,	0x12 },
-	{ 68,	0x0F },	{ 72,	0x13 },	{ 80,	0x14 },	{ 88,	0x15 },
-	{ 96,	0x19 },	{ 104,	0x16 },	{ 112,	0x1A },	{ 128,	0x17 },
-	{ 136,	0x4F }, { 144,	0x1C },	{ 160,	0x1D }, { 176,	0x55 },
-	{ 192,	0x1E }, { 208,	0x56 },	{ 224,	0x22 }, { 228,	0x24 },
-	{ 240,	0x1F },	{ 256,	0x23 }, { 288,	0x5C },	{ 320,	0x25 },
-	{ 384,	0x26 }, { 448,	0x2A },	{ 480,	0x27 }, { 512,	0x2B },
-	{ 576,	0x2C },	{ 640,	0x2D },	{ 768,	0x31 }, { 896,	0x32 },
-	{ 960,	0x2F },	{ 1024,	0x33 },	{ 1152,	0x34 }, { 1280,	0x35 },
-	{ 1536,	0x36 }, { 1792,	0x3A },	{ 1920,	0x37 },	{ 2048,	0x3B },
-	{ 2304,	0x3C },	{ 2560,	0x3D },	{ 3072,	0x3E }, { 3584,	0x7A },
-	{ 3840,	0x3F }, { 4096,	0x7B }, { 5120,	0x7D },	{ 6144,	0x7E },
+#define IBFD	1
+#define IBCR	2
+#define IBSR	3
+#define IBDR	4
+
+#define IBSR_RXAK	BIT(0)
+#define IBSR_IBIF	BIT(1)
+#define IBSR_IBAL	BIT(4)
+#define IBSR_IBB	BIT(5)
+
+#define IBCR_RSTA	BIT(2)
+#define IBCR_NOACK	BIT(3)
+#define IBCR_TX		BIT(4)
+#define IBCR_MSSL	BIT(5)
+
+#define IBSR_IBIF_CLEAR	BIT(1)
+#define IBCR_MDIS_EN	(0 << 7)
+#define IBCR_MDIS_DIS	BIT(7)
+
+#define I2C_READ	1
+#define I2C_WRITE	0
+
+#define I2C_MAX_RETRY_CNT               10
+
+#define I2C_IDLE			0
+#define I2C_TRANSMISSION_COMPLETE	2
+
+static uint16_t s32g_clk_div[] = {
+	20,   22,   24,   26,   28,   30,   34,   40,   28,   32,
+	36,   40,   44,   48,   58,   64,   48,   56,   64,   72,
+	80,   88,   104,  128,  80,   96,   112,  128,  144,  160,
+	192,  240,  160,  192,  224,  256,  288,  320,  384,  480,
+	320,  384,  448,  512,  576,  640,  768,  960,  640,  768,
+	896,  1024, 1152, 1280, 1536, 1920, 1280, 1536, 1792, 2048,
+	2304, 2560, 3072, 3840
 };
-#else
-static uint16_t i2c_clk_div[50][2] = {
-	{ 22,	0x20 }, { 24,	0x21 }, { 26,	0x22 }, { 28,	0x23 },
-	{ 30,	0x00 }, { 32,	0x24 }, { 36,	0x25 }, { 40,	0x26 },
-	{ 42,	0x03 }, { 44,	0x27 }, { 48,	0x28 }, { 52,	0x05 },
-	{ 56,	0x29 }, { 60,	0x06 }, { 64,	0x2A }, { 72,	0x2B },
-	{ 80,	0x2C }, { 88,	0x09 }, { 96,	0x2D }, { 104,	0x0A },
-	{ 112,	0x2E }, { 128,	0x2F }, { 144,	0x0C }, { 160,	0x30 },
-	{ 192,	0x31 }, { 224,	0x32 }, { 240,	0x0F }, { 256,	0x33 },
-	{ 288,	0x10 }, { 320,	0x34 }, { 384,	0x35 }, { 448,	0x36 },
-	{ 480,	0x13 }, { 512,	0x37 }, { 576,	0x14 }, { 640,	0x38 },
-	{ 768,	0x39 }, { 896,	0x3A }, { 960,	0x17 }, { 1024,	0x3B },
-	{ 1152,	0x18 }, { 1280,	0x3C }, { 1536,	0x3D }, { 1792,	0x3E },
-	{ 1920,	0x1B }, { 2048,	0x3F }, { 2304,	0x1C }, { 2560,	0x1D },
-	{ 3072,	0x1E }, { 3840,	0x1F }
-};
-#endif
 
-/*
- * Calculate and set proper clock divider
- */
-static uint8_t i2c_imx_get_clk(struct s32g_i2c_bus *i2c_bus, unsigned int rate)
+static inline void s32g_i2c_disable(struct s32g_i2c_bus *bus)
 {
-	unsigned int i2c_clk_rate;
-	unsigned int div;
-	uint8_t clk_div;
-
-	/* Divider value calculation */
-	i2c_clk_rate = I2C_CLK_FREQ;
-	div = (i2c_clk_rate + rate - 1) / rate;
-	if (div < i2c_clk_div[0][0])
-		clk_div = 0;
-	else if (div > i2c_clk_div[ARRAY_SIZE(i2c_clk_div) - 1][0])
-		clk_div = ARRAY_SIZE(i2c_clk_div) - 1;
-	else
-		for (clk_div = 0; i2c_clk_div[clk_div][0] < div; clk_div++)
-			;
+	mmio_write_8(bus->base + IBCR, IBCR_MDIS_DIS);
+	mmio_write_8(bus->base + IBSR, 0);
+}
 
-	/* Store divider value */
-	return clk_div;
+static inline void s32g_i2c_enable(struct s32g_i2c_bus *bus)
+{
+	mmio_write_8(bus->base + IBCR, IBCR_MDIS_EN);
+	/* Clear interrupt flag */
+	mmio_write_8(bus->base + IBSR, IBSR_IBIF_CLEAR);
 }
 
 /*
- * Set I2C Bus speed
+ * Configure bus speed
  */
-static int bus_i2c_set_bus_speed(struct s32g_i2c_bus *i2c_bus, int speed)
+static int s32g_i2c_set_bus_speed(struct s32g_i2c_bus *bus, int speed)
 {
-	unsigned long base = i2c_bus->base;
-	bool quirk = i2c_bus->driver_data & I2C_QUIRK_FLAG ? true : false;
-	uint8_t clk_idx = i2c_imx_get_clk(i2c_bus, speed);
-	uint8_t idx = i2c_clk_div[clk_idx][1];
-	int reg_shift = quirk ? VF610_I2C_REGSHIFT : IMX_I2C_REGSHIFT;
+	int i;
 
-	if (!base)
+	if (!bus || !bus->base)
 		return -EINVAL;
 
-	/* Store divider value */
-	mmio_write_8(base + (IFDR << reg_shift), idx);
+	for (i = 0; ARRAY_SIZE(s32g_clk_div) - 1; i++)
+		if ((I2C_CLK_FREQ / s32g_clk_div[i]) <= speed)
+			break;
+
+	/* Write divider value */
+	mmio_write_8(bus->base + IBFD, i);
 
-	/* Reset module */
-	mmio_write_8(base + (I2CR << reg_shift), I2CR_IDIS);
-	mmio_write_8(base + (I2SR << reg_shift), 0);
+	/* Module reset */
+	s32g_i2c_disable(bus);
 	return 0;
 }
 
-#define ST_BUS_IDLE (0 | (I2SR_IBB << 8))
-#define ST_BUS_BUSY (I2SR_IBB | (I2SR_IBB << 8))
-#define ST_IIF (I2SR_IIF | (I2SR_IIF << 8))
-
-static int wait_for_sr_state(struct s32g_i2c_bus *i2c_bus, unsigned int state)
+/*
+ * Wait until the bus enters a specified state or timeout occurs.
+ */
+static uint8_t s32g_i2c_wait(struct s32g_i2c_bus *bus, unsigned int state)
 {
-	unsigned int sr;
-	bool quirk = i2c_bus->driver_data & I2C_QUIRK_FLAG ? true : false;
-	int reg_shift = quirk ? VF610_I2C_REGSHIFT : IMX_I2C_REGSHIFT;
-	unsigned long base = i2c_bus->base;
-	uint32_t wait_cnt = 100000; /* .1 seconds */
-
-	for (;;) {
-		sr = mmio_read_8(base + (I2SR << reg_shift));
-		if (sr & I2SR_IAL) {
-			if (quirk)
-				mmio_write_8(base + (I2SR << reg_shift),
-						sr | I2SR_IAL);
-			else
-				mmio_write_8(base + (I2SR << reg_shift),
-						sr & ~I2SR_IAL);
-			INFO("%s: Arbitration lost sr=%x cr=%x state=%x\n",
-					__func__, sr,
-					mmio_read_8(base + (I2CR << reg_shift)),
-					state);
-			return -EINTR;
+	uint8_t ibsr;
+	uint32_t wait_cnt = 1000;
+
+	while (wait_cnt--) {
+		ibsr = mmio_read_8(bus->base + IBSR);
+
+		switch(state) {
+		case I2C_IDLE:
+			if (!(ibsr & IBSR_IBB))
+				return 0;
+			break;
+		case I2C_TRANSMISSION_COMPLETE:
+			if (ibsr & IBSR_IBIF) {
+				/* Clear interrupt flag */
+				mmio_write_8(bus->base + IBSR,
+					     IBSR_IBIF_CLEAR);
+				return 0;
+			}
 		}
-		if ((sr & (state >> 8)) == (unsigned char)state)
-			return sr;
+
 		udelay(1);
-		wait_cnt--;
-		if (!wait_cnt)
-			break;
 	}
-	INFO("%s: failed sr=%x cr=%x state=%x\n", __func__,
-			sr, mmio_read_8(base + (I2CR << reg_shift)), state);
+
+	INFO("%s: timeout state=%x\n", __func__, state);
 	return -ETIMEDOUT;
 }
 
-static int tx_byte(struct s32g_i2c_bus *i2c_bus, uint8_t byte)
+static uint8_t s32g_i2c_write_byte(struct s32g_i2c_bus *bus, uint8_t byte)
 {
+	uint8_t ibsr;
 	int ret;
-	int reg_shift = i2c_bus->driver_data & I2C_QUIRK_FLAG ?
-		VF610_I2C_REGSHIFT : IMX_I2C_REGSHIFT;
-	unsigned long base = i2c_bus->base;
 
-	mmio_write_8(base + (I2SR << reg_shift), I2SR_IIF_CLEAR);
-	mmio_write_8(base + (I2DR << reg_shift), byte);
+	if (!bus || !bus->base)
+		return -EINVAL;
+
+	/* Write data */
+	mmio_write_8(bus->base + IBDR, byte);
 
-	ret = wait_for_sr_state(i2c_bus, ST_IIF);
+	/* Wait for transfer complete */
+	ret = s32g_i2c_wait(bus, I2C_TRANSMISSION_COMPLETE);
 	if (ret < 0)
 		return ret;
-	if (ret & I2SR_RX_NO_AK)
-		return -EIO;
+
+	/* Examine IBSR[RXAK] for an acknowledgment from the slave. */
+	ibsr = mmio_read_8(bus->base + IBSR);
+	return ibsr & IBSR_RXAK ? -EIO : 0;
+}
+
+static uint8_t s32g_i2c_chip_setup(struct s32g_i2c_bus *bus,
+				   uint8_t chip, int mode)
+{
+	/* The master transmits the seven-bit slave address.
+	 * The master transmits the R/W bit.
+	 */
+	return s32g_i2c_write_byte(bus, (chip << 1) | mode);
+}
+
+static uint8_t s32g_i2c_address_setup(struct s32g_i2c_bus *bus,
+				      uint32_t addr, int addr_len)
+{
+	uint8_t reg;
+	int ret;
+
+	while (addr_len--) {
+		/* Write data to I2C Bus Data I/O Register (IBDR) */
+		reg = (addr >> (addr_len * 8)) & 0xff;
+		ret = s32g_i2c_write_byte(bus, reg);
+		if (ret < 0)
+			return ret;
+	}
+
 	return 0;
 }
 
 /*
- * Stop I2C transaction
+ * Stop sequence
  */
-static void i2c_imx_stop(struct s32g_i2c_bus *i2c_bus)
+static uint8_t s32g_i2c_stop(struct s32g_i2c_bus *bus)
 {
+	uint8_t ibcr;
 	int ret;
-	int reg_shift = i2c_bus->driver_data & I2C_QUIRK_FLAG ?
-		VF610_I2C_REGSHIFT : IMX_I2C_REGSHIFT;
-	unsigned long base = i2c_bus->base;
-	unsigned int temp = mmio_read_8(base + (I2CR << reg_shift));
-
-	temp &= ~(I2CR_MSTA | I2CR_MTX);
-	mmio_write_8(base + (I2CR << reg_shift), temp);
-	ret = wait_for_sr_state(i2c_bus, ST_BUS_IDLE);
-	if (ret < 0)
-		INFO("%s:trigger stop failed\n", __func__);
+
+	if (!bus || !bus->base)
+		return -EINVAL;
+
+	/* Clear IBCR */
+	ibcr = mmio_read_8(bus->base + IBCR) & ~IBCR_MSSL;
+	mmio_write_8(bus->base + IBCR, ibcr);
+
+	/* Wait for idle state */
+	ret = s32g_i2c_wait(bus, I2C_IDLE);
+	if (ret == -ETIMEDOUT)
+		s32g_i2c_disable(bus);
+	return ret;
 }
 
 /*
- * Send start signal, chip address and
- * write register address
+ * Prepare the transfer by sending: start signal, chip and write
+ * register address
  */
-static int i2c_init_transfer_(struct s32g_i2c_bus *i2c_bus, uint8_t chip,
-		uint32_t addr, int alen)
+static uint8_t s32g_i2c_try_start(struct s32g_i2c_bus *bus,
+		uint8_t chip, uint32_t addr, int addr_len)
 {
-	unsigned int temp;
-	int ret;
-	bool quirk = i2c_bus->driver_data & I2C_QUIRK_FLAG ? true : false;
-	unsigned long base = i2c_bus->base;
-	int reg_shift = quirk ? VF610_I2C_REGSHIFT : IMX_I2C_REGSHIFT;
+	uint8_t reg, ret;
 
-	/* Enable I2C controller */
-	if (quirk)
-		ret = mmio_read_8(base + (I2CR << reg_shift)) & I2CR_IDIS;
-	else
-		ret = !(mmio_read_8(base + (I2CR << reg_shift)) & I2CR_IEN);
+	if (!bus || !bus->base)
+		return -EINVAL;
 
-	if (ret) {
-		mmio_write_8(base + (I2CR << reg_shift), I2CR_IEN);
-		/* Wait for controller to be stable */
-		udelay(50);
-	}
+	/* Clear the MDIS field to enable the I2C interface system */
+	s32g_i2c_disable(bus);
+	s32g_i2c_enable(bus);
 
-	if (mmio_read_8(base + (IADR << reg_shift)) == (chip << 1))
-		mmio_write_8(base + (IADR << reg_shift), (chip << 1) ^ 2);
-	mmio_write_8(base + (I2SR << reg_shift), I2SR_IIF_CLEAR);
-	ret = wait_for_sr_state(i2c_bus, ST_BUS_IDLE);
+	/* Wait in loop for IBB flag to clear. */
+	ret = s32g_i2c_wait(bus, I2C_IDLE);
 	if (ret < 0)
 		return ret;
 
-	/* Start I2C transaction */
-	temp = mmio_read_8(base + (I2CR << reg_shift));
-	temp |= I2CR_MSTA;
-	mmio_write_8(base + (I2CR << reg_shift), temp);
+	/* Set as master */
+	reg = mmio_read_8(bus->base + IBCR) | IBCR_MSSL;
+	mmio_write_8(bus->base + IBCR, reg);
+
+	/* Set transmission and noack */
+	reg |= IBCR_TX | IBCR_NOACK;
+	mmio_write_8(bus->base + IBCR, reg);
 
-	ret = wait_for_sr_state(i2c_bus, ST_BUS_BUSY);
+	/* Send chip and address */
+	ret = s32g_i2c_chip_setup(bus, chip, I2C_WRITE);
 	if (ret < 0)
 		return ret;
 
-	temp |= I2CR_MTX | I2CR_TX_NO_AK;
-	mmio_write_8(base + (I2CR << reg_shift), temp);
-
-	if (alen >= 0)	{
-		/* write slave address */
-		ret = tx_byte(i2c_bus, chip << 1);
-		if (ret < 0)
-			return ret;
-
-		while (alen--) {
-			ret = tx_byte(i2c_bus, (addr >> (alen * 8)) & 0xff);
-			if (ret < 0)
-				return ret;
-		}
-	}
+	return s32g_i2c_address_setup(bus, addr, addr_len);
 
 	return 0;
 }
 
-static int i2c_init_transfer(struct s32g_i2c_bus *i2c_bus, uint8_t chip,
-		uint32_t addr, int alen)
+/*
+ * Start sequence
+ */
+static uint8_t s32g_i2c_start(struct s32g_i2c_bus *bus, uint8_t chip,
+		uint32_t addr, int addr_len)
 {
-	int retry;
-	int ret;
-	int reg_shift = i2c_bus->driver_data & I2C_QUIRK_FLAG ?
-		VF610_I2C_REGSHIFT : IMX_I2C_REGSHIFT;
+	int counter = 0;
+	uint8_t ret = 0;
 
-	if (!i2c_bus->base)
+	if (!bus || !bus->base)
 		return -EINVAL;
 
-	for (retry = 0; retry < 3; retry++) {
-		ret = i2c_init_transfer_(i2c_bus, chip, addr, alen);
+	do {
+		if (counter++ > 0)
+			udelay(100);
+
+		ret = s32g_i2c_try_start(bus, chip, addr, addr_len);
 		if (ret >= 0)
 			return 0;
-		i2c_imx_stop(i2c_bus);
-		if (ret == -EIO)
-			return ret;
-
-		INFO("%s: failed for chip 0x%x retry=%d\n", __func__, chip,
-				retry);
-		if (ret != -EINTR)
-			/* Disable controller */
-			mmio_write_8(i2c_bus->base + (I2CR << reg_shift),
-					I2CR_IDIS);
-		udelay(100);
-	}
-	INFO("%s: give up i2c_regs=0x%lx\n", __func__, i2c_bus->base);
-	return ret;
-}
-
-
-static int i2c_write_data(struct s32g_i2c_bus *i2c_bus, uint8_t chip,
-		const uint8_t *buf, int len)
-{
-	int i, ret = 0;
 
-	VERBOSE("%s : chip=0x%x, len=0x%x\n", __func__, chip, len);
-	VERBOSE("%s: ", __func__);
-	/* use rc for counter */
-#if LOG_LEVEL >= LOG_LEVEL_VERBOSE
-	for (i = 0; i < len; ++i)
-		printf(" 0x%02x", buf[i]);
-	printf("\n");
-#endif
-
-	for (i = 0; i < len; i++) {
-		ret = tx_byte(i2c_bus, buf[i]);
-		if (ret < 0) {
-			VERBOSE("%s: rc=%d\n", __func__, ret);
-			break;
-		}
-	}
+		s32g_i2c_stop(bus);
+	} while ((ret == -EAGAIN) && (counter < I2C_MAX_RETRY_CNT));
 
+	INFO("%s: failed\n", __func__);
 	return ret;
 }
 
-static int i2c_read_data(struct s32g_i2c_bus *i2c_bus, unsigned char chip,
+static uint8_t s32g_i2c_read_buffer(struct s32g_i2c_bus *bus, unsigned char chip,
 		unsigned char *buf, int len)
 {
-	int ret;
-	unsigned int temp;
 	int i;
-	int reg_shift = i2c_bus->driver_data & I2C_QUIRK_FLAG ?
-		VF610_I2C_REGSHIFT : IMX_I2C_REGSHIFT;
-	unsigned long base = i2c_bus->base;
+	uint8_t reg, ret;
 
-	VERBOSE("%s: chip=0x%x, len=0x%x\n", __func__, chip, len);
+	if (!bus || !bus->base || !buf)
+		return -EINVAL;
 
-	/* setup bus to read data */
-	temp = mmio_read_8(base + (I2CR << reg_shift));
-	temp &= ~(I2CR_MTX | I2CR_TX_NO_AK);
-	if (len == 1)
-		temp |= I2CR_TX_NO_AK;
-	mmio_write_8(base + (I2CR << reg_shift), temp);
-	mmio_write_8(base + (I2SR << reg_shift), I2SR_IIF_CLEAR);
+	if (!len)
+		return 0;
 
-	/* dummy read to clear ICF */
-	mmio_read_8(base + (I2DR << reg_shift));
+	/* Perform a dummy read of IBDR to initiate the receive operation */
+	mmio_read_8(bus->base + IBDR);
 
-	/* read data */
+	/* Read data */
 	for (i = 0; i < len; i++) {
-		ret = wait_for_sr_state(i2c_bus, ST_IIF);
-		if (ret < 0) {
-			VERBOSE("%s: ret=%d\n", __func__, ret);
-			i2c_imx_stop(i2c_bus);
+		/* Wait for transfer complete. */
+		ret = s32g_i2c_wait(bus, I2C_TRANSMISSION_COMPLETE);
+		if (ret < 0)
 			return ret;
-		}
 
-		/*
-		 * It must generate STOP before read I2DR to prevent
-		 * controller from generating another clock cycle
-		 */
-		if (i == (len - 1)) {
-			i2c_imx_stop(i2c_bus);
-		} else if (i == (len - 2)) {
-			temp = mmio_read_8(base + (I2CR << reg_shift));
-			temp |= I2CR_TX_NO_AK;
-			mmio_write_8(base + (I2CR << reg_shift), temp);
+		if (i == (len - 2)) {
+			/* Disable ACK */
+			reg = mmio_read_8(bus->base + IBCR) | IBCR_NOACK;
+			mmio_write_8(bus->base + IBCR, reg);
+		} else if (i == (len - 1)) {
+			/* Generate STOP condition */
+			reg = mmio_read_8(bus->base + IBCR) & ~IBCR_MSSL;
+			mmio_write_8(bus->base + IBCR, reg);
 		}
-		mmio_write_8(base + (I2SR << reg_shift), I2SR_IIF_CLEAR);
-		buf[i] = mmio_read_8(base + (I2DR << reg_shift));
+
+		/* Read data */
+		buf[i] = mmio_read_8(bus->base + IBDR);
 	}
 
-#if LOG_LEVEL >= LOG_LEVEL_VERBOSE
-	/* reuse ret for counter*/
-	for (ret = 0; ret < len; ++ret)
-		printf(" 0x%02x", buf[ret]);
-	printf("\n");
-#endif
-	i2c_imx_stop(i2c_bus);
 	return 0;
 }
 
 /*
- * Read data from I2C device
+ * I2C read
+ * @bus:	I2C bus
+ * @chip:	chip
+ * @addr:	address
+ * @addr_len:	data address length. This can be 1 or 2 bytes long.
+ *		Some day it might be 3 bytes long.
+ * @buffer:	buffer where data will be returned
+ * @len:	number of objects
  */
-static int bus_i2c_read(struct s32g_i2c_bus *i2c_bus, uint8_t chip,
-		uint32_t addr, int alen, uint8_t *buf, int len)
+uint8_t s32g_i2c_read(struct s32g_i2c_bus *bus, uint8_t chip,
+		unsigned int addr, int addr_len, uint8_t *buffer,
+		int len)
 {
-	int ret = 0;
-	uint32_t temp;
-	int reg_shift = i2c_bus->driver_data & I2C_QUIRK_FLAG ?
-		VF610_I2C_REGSHIFT : IMX_I2C_REGSHIFT;
-	unsigned long base = i2c_bus->base;
+	uint8_t reg, ret = 0;
+
+	if (!bus || !bus->base || !buffer) {
+		ERROR("%s: Invalid parameter\n", __func__);
+		return -EINVAL;
+	}
+	if (addr_len > 3 || addr_len <= 0) {
+		ERROR("%s: Invalid parameter addr_len\n", __func__);
+		return -EINVAL;
+	}
 
-	ret = i2c_init_transfer(i2c_bus, chip, addr, alen);
+	ret = s32g_i2c_start(bus, chip, addr, addr_len);
 	if (ret < 0)
 		return ret;
 
-	if (alen >= 0) {
-		temp = mmio_read_8(base + (I2CR << reg_shift));
-		temp |= I2CR_RSTA;
-		mmio_write_8(base + (I2CR << reg_shift), temp);
-	}
+	/* Generate repeat start condition */
+	reg = mmio_read_8(bus->base + IBCR) | IBCR_RSTA;
+	mmio_write_8(bus->base + IBCR, reg);
 
-	ret = tx_byte(i2c_bus, (chip << 1) | 1);
+	/* Setup in read mode. */
+	ret = s32g_i2c_chip_setup(bus, chip, I2C_READ);
 	if (ret < 0) {
-		i2c_imx_stop(i2c_bus);
+		s32g_i2c_stop(bus);
 		return ret;
 	}
 
-	ret = i2c_read_data(i2c_bus, chip, buf, len);
-
-	i2c_imx_stop(i2c_bus);
-	return ret;
-}
-
-/*
- * Write data to I2C device
- */
-static int bus_i2c_write(struct s32g_i2c_bus *i2c_bus, uint8_t chip,
-		uint32_t addr, int alen, const uint8_t *buf, int len)
-{
-	int ret = 0;
+	/* Select Receive mode */
+	reg = mmio_read_8(bus->base + IBCR) & ~IBCR_TX;
 
-	ret = i2c_init_transfer(i2c_bus, chip, addr, alen);
-	if (ret < 0)
-		return ret;
+	/* No ack necessary if only one byte is sent */
+	if (len == 1)
+		reg |= IBCR_NOACK;
+	else
+		reg &= ~IBCR_NOACK;
 
-	ret = i2c_write_data(i2c_bus, chip, buf, len);
+	mmio_write_8(bus->base + IBCR, reg);
 
-	i2c_imx_stop(i2c_bus);
+	ret = s32g_i2c_read_buffer(bus, chip, buffer, len);
 
+	s32g_i2c_stop(bus);
 	return ret;
 }
 
 /*
- * I2C read
+ * I2C write
  * @bus:	I2C bus
  * @chip:	chip
  * @addr:	address
- * @alen:	data address length. This can be 1 or 2 bytes long.
+ * @addr_len:	data address length. This can be 1 or 2 bytes long.
  *		Some day it might be 3 bytes long.
  * @buffer:	buffer where data will be returned
  * @len:	number of objects
  */
-int s32g_i2c_read(struct s32g_i2c_bus *bus, uint8_t chip,
-		unsigned int addr, int alen, uint8_t *buffer,
+uint8_t s32g_i2c_write(struct s32g_i2c_bus *bus, uint8_t chip,
+		unsigned int addr, int addr_len, uint8_t *buffer,
 		int len)
 {
-	if (!bus) {
-		ERROR("bus_i2c_init: Invalid parameter bus\n");
+	uint8_t ret = 0;
+	int i;
+
+	if (!bus || !bus->base || !buffer) {
+		ERROR("%s: Invalid parameter\n", __func__);
 		return -EINVAL;
 	}
-	if (alen > 3 || alen < 0) {
-		ERROR("bus_i2c_init: Invalid parameter alen\n");
+	if (addr_len > 3 || addr_len <= 0) {
+		ERROR("%s: Invalid parameter addr_len\n", __func__);
 		return -EINVAL;
 	}
 
-	return bus_i2c_read(bus, chip, addr, alen, buffer, len);
-}
+	ret = s32g_i2c_start(bus, chip, addr, addr_len);
+	if (ret < 0)
+		return ret;
 
-/*
- * I2C write
- * @bus:	I2C bus
- * @chip:	chip
- * @addr:	address
- * @alen:	data address length. This can be 1 or 2 bytes long.
- *		Some day it might be 3 bytes long.
- * @buffer:	buffer where data will be returned
- * @len:	number of objects
- */
-int s32g_i2c_write(struct s32g_i2c_bus *bus, uint8_t chip,
-		unsigned int addr, int alen, uint8_t *buffer,
-		int len)
-{
-	if (!bus) {
-		ERROR("bus_i2c_init: Invalid parameter\n");
-		return -EINVAL;
-	}
-	if (alen > 3 || alen < 0) {
-		ERROR("bus_i2c_init: Invalid parameter alen\n");
-		return -EINVAL;
+	/* Start the transfer */
+	for (i = 0; i < len; i++) {
+		ret = s32g_i2c_write_byte(bus, buffer[i]);
+		if (ret < 0)
+			break;
 	}
 
-	return bus_i2c_write(bus, chip, addr, alen, buffer, len);
+	s32g_i2c_stop(bus);
+	return ret;
 }
 
 /*
@@ -500,13 +394,11 @@ int s32g_i2c_write(struct s32g_i2c_bus *bus, uint8_t chip,
 int s32g_i2c_init(struct s32g_i2c_bus *bus)
 {
 	if (!bus) {
-		ERROR("bus_i2c_init: Invalid parameter\n");
+		ERROR("%s: Invalid parameter\n", __func__);
 		return -EINVAL;
 	}
 
-	bus->driver_data = I2C_QUIRK_FLAG;
-	bus->slaveaddr = S32G_DEFAULT_SLAVE;
-	return bus_i2c_set_bus_speed(bus, bus->speed);
+	return s32g_i2c_set_bus_speed(bus, bus->speed);
 }
 
 /*
diff --git a/include/drivers/nxp/s32g/i2c/s32g_i2c.h b/include/drivers/nxp/s32g/i2c/s32g_i2c.h
index 3e1f23e2e..31c0a5535 100644
--- a/include/drivers/nxp/s32g/i2c/s32g_i2c.h
+++ b/include/drivers/nxp/s32g/i2c/s32g_i2c.h
@@ -1,7 +1,6 @@
+// SPDX-License-Identifier: BSD-3-Clause
 /*
  * Copyright 2020 NXP
- *
- * SPDX-License-Identifier: BSD-3-Clause
  */
 
 #ifndef S32G274A_I2C_H
@@ -17,29 +16,22 @@
 #define S32G_DEFAULT_SLAVE 0
 
 /*
- * Information about i2c controller
- * struct s32g_i2c_bus - information about the i2c bus
- * @index: i2c bus index
- * @base: Address of I2C bus controller
- * @driver_data: Flags for different platforms, such as I2C_QUIRK_FLAG.
- * @speed: Speed of I2C bus
- * @idle_bus_fn: function to force bus idle
- * @idle_bus_data: parameter for idle_bus_fun
+ * I2C bus description
+ * @base: I2C bus controller address
+ * @speed: I2C bus speed
  */
 struct s32g_i2c_bus {
 	unsigned long	base;
-	unsigned long	driver_data;
 	int             speed;
-	int             slaveaddr;
 };
 
 void s32g_i2c_get_setup_from_fdt(void *fdt, int node, struct s32g_i2c_bus *bus);
 int s32g_i2c_init(struct s32g_i2c_bus *bus);
-int s32g_i2c_read(struct s32g_i2c_bus *bus, uint8_t chip,
-		unsigned int addr, int alen, uint8_t *buffer,
+uint8_t s32g_i2c_read(struct s32g_i2c_bus *bus, uint8_t chip,
+		unsigned int addr, int addr_len, uint8_t *buffer,
 		int len);
-int s32g_i2c_write(struct s32g_i2c_bus *bus, uint8_t chip,
-		unsigned int addr, int alen, uint8_t *buffer,
+uint8_t s32g_i2c_write(struct s32g_i2c_bus *bus, uint8_t chip,
+		unsigned int addr, int addr_len, uint8_t *buffer,
 		int len);
 
 #endif
-- 
2.17.1

