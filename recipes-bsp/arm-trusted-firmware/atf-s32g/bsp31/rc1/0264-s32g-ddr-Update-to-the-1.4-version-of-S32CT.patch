From d54292df0c0e4793beaa7d81c4f5e28a537792b5 Mon Sep 17 00:00:00 2001
From: Dan Nica <dan.nica@nxp.com>
Date: Tue, 11 May 2021 15:19:57 +0300
Subject: [PATCH 264/269] s32g: ddr: Update to the 1.4 version of S32CT

Notable changes include replacing the code in 'ddrss.c' with generated
one in 'ddr_lp_csr.c' and 'ddr_lp_mmio.c', and moving 'ssram_mailbox.h'
to 'include/plat/nxp/s32g/bl31_ssram/' as it was needed to be
included from 'ddr_utils.h'.

Issue: ALB-7042
Upstream-Status: Pending 

Signed-off-by: Dan Nica <dan.nica@nxp.com>
Signed-off-by: Zhantao Tang <zhantao.tang@windriver.com>
---
 drivers/nxp/s32g/ddr/ddr_init.c               |  31 +-
 drivers/nxp/s32g/ddr/ddr_lp_csr.c             | 371 +++++++++++
 drivers/nxp/s32g/ddr/ddr_lp_mmio.c            | 198 ++++++
 drivers/nxp/s32g/ddr/ddr_utils_mmio.c         | 250 +++++---
 drivers/nxp/s32g/ddr/ddrc_cfg.c               | 270 ++++----
 drivers/nxp/s32g/ddr/ddrss.c                  | 598 ------------------
 drivers/nxp/s32g/ddr/ddrss_cfg.c              |   6 +-
 drivers/nxp/s32g/ddr/dmem_cfg.c               |  22 +-
 drivers/nxp/s32g/ddr/dq_swap_cfg.c            |   4 +-
 drivers/nxp/s32g/ddr/imem_cfg.c               |   6 +-
 drivers/nxp/s32g/ddr/phy_cfg.c                |  10 +-
 drivers/nxp/s32g/ddr/pie_cfg.c                |   6 +-
 drivers/nxp/s32g/ddr/rev2/ddrc_cfg_rev2.c     | 260 ++++----
 drivers/nxp/s32g/ddr/rev2/dmem_cfg_rev2.c     |  22 +-
 drivers/nxp/s32g/ddr/rev2/phy_cfg_rev2.c      |  10 +-
 drivers/nxp/s32g/ddr/rev2/pie_cfg_rev2.c      |   4 +-
 include/drivers/nxp/s32g/ddr/ddr_init.h       |  78 ++-
 include/drivers/nxp/s32g/ddr/ddr_lp.h         |  65 ++
 include/drivers/nxp/s32g/ddr/ddr_utils.h      | 193 +++---
 include/drivers/nxp/s32g/ddr/ddrss.h          |  18 -
 .../plat/nxp/s32g/bl31_ssram}/ssram_mailbox.h |   0
 plat/nxp/s32g/bl31_sram/bl31_sram.mk          |   2 +-
 plat/nxp/s32g/bl31_sram/bl31sram_main.c       |   6 +-
 plat/nxp/s32g/bl31_ssram/bl31ssram_main.c     |   4 +-
 plat/nxp/s32g/s32g_bl2_el3.c                  |   4 +-
 plat/nxp/s32g/s32g_common.mk                  |   3 +-
 plat/nxp/s32g/s32g_psci.c                     |   4 +-
 27 files changed, 1299 insertions(+), 1146 deletions(-)
 create mode 100755 drivers/nxp/s32g/ddr/ddr_lp_csr.c
 create mode 100755 drivers/nxp/s32g/ddr/ddr_lp_mmio.c
 delete mode 100644 drivers/nxp/s32g/ddr/ddrss.c
 create mode 100755 include/drivers/nxp/s32g/ddr/ddr_lp.h
 delete mode 100644 include/drivers/nxp/s32g/ddr/ddrss.h
 rename {plat/nxp/s32g/bl31_ssram/include => include/plat/nxp/s32g/bl31_ssram}/ssram_mailbox.h (100%)

diff --git a/drivers/nxp/s32g/ddr/ddr_init.c b/drivers/nxp/s32g/ddr/ddr_init.c
index 2c3d0782e..fd48c4fc3 100644
--- a/drivers/nxp/s32g/ddr/ddr_init.c
+++ b/drivers/nxp/s32g/ddr/ddr_init.c
@@ -29,12 +29,10 @@
  */
 
 #include <ddr/ddr_init.h>
+#include <lib/mmio.h>
 
-#include <ddr/ddrss.h>
-#include <ssram_mailbox.h>
-
+static uint32_t ddrc_init_cfg(struct ddrss_config *config);
 static uint32_t execute_training(struct ddrss_config *config);
-static void set_optimal_pll(void);
 static uint32_t load_phy_image(uint32_t start_addr, size_t size,
 			       uint16_t image[]);
 
@@ -63,7 +61,7 @@ uint32_t ddr_init(void)
 			return ret;
 
 		/* Execute post training setup */
-		ret = post_train_setup(true);
+		ret = post_train_setup(STORE_CSR_MASK | INIT_MEM_MASK);
 		if (ret != NO_ERR)
 			return ret;
 	}
@@ -71,7 +69,7 @@ uint32_t ddr_init(void)
 }
 
 /* Initialize ddr controller with given settings. */
-uint32_t ddrc_init_cfg(struct ddrss_config *config)
+static uint32_t ddrc_init_cfg(struct ddrss_config *config)
 {
 	uint32_t ret = NO_ERR;
 
@@ -89,7 +87,7 @@ static uint32_t execute_training(struct ddrss_config *config)
 		return ret;
 
 	/* Initialize phy module */
-	ret = load_register_cfg(config->phy_cfg_size, config->phy_cfg);
+	ret = load_register_cfg_16(config->phy_cfg_size, config->phy_cfg);
 	if (ret != NO_ERR)
 		return ret;
 
@@ -156,15 +154,24 @@ static uint32_t execute_training(struct ddrss_config *config)
 			return ret;
 	}
 
-	store_csr(BL31SSRAM_CSR_BASE);
-
 	mmio_write_32(MICROCONT_MUX_SEL, UNLOCK_CSR_ACCESS);
 	/*  Load pie image after training has executed */
-	ret = load_register_cfg(config->pie_cfg_size, config->pie_cfg);
+	ret = load_register_cfg_16(config->pie_cfg_size, config->pie_cfg);
 	mmio_write_32(MICROCONT_MUX_SEL, LOCK_CSR_ACCESS);
 	return ret;
 }
 
+/* Load register array into memory. */
+uint32_t load_register_cfg_16(size_t size, struct regconf_16 cfg[])
+{
+	size_t i;
+
+	for (i = 0; i < size; i++)
+		write_16(cfg[i].data, (uintptr_t)cfg[i].addr);
+
+	return NO_ERR;
+}
+
 /* Load register array into memory. */
 uint32_t load_register_cfg(size_t size, struct regconf cfg[])
 {
@@ -172,6 +179,7 @@ uint32_t load_register_cfg(size_t size, struct regconf cfg[])
 
 	for (i = 0; i < size; i++)
 		mmio_write_32((uintptr_t)cfg[i].addr, cfg[i].data);
+
 	return NO_ERR;
 }
 
@@ -182,6 +190,7 @@ uint32_t load_dq_cfg(size_t size, struct dqconf cfg[])
 
 	for (i = 0; i < size; i++)
 		mmio_write_32((uintptr_t)cfg[i].addr, cfg[i].data);
+
 	return NO_ERR;
 }
 
@@ -199,7 +208,7 @@ static uint32_t load_phy_image(uint32_t start_addr, size_t size,
 }
 
 /* Ensure optimal phy pll settings. */
-static void set_optimal_pll(void)
+void set_optimal_pll(void)
 {
 	/* Configure phy pll for 3200MTS data rate */
 	mmio_write_32(MASTER_PLLCTRL1, 0x00000021);
diff --git a/drivers/nxp/s32g/ddr/ddr_lp_csr.c b/drivers/nxp/s32g/ddr/ddr_lp_csr.c
new file mode 100755
index 000000000..0d8540060
--- /dev/null
+++ b/drivers/nxp/s32g/ddr/ddr_lp_csr.c
@@ -0,0 +1,371 @@
+/*
+ * Copyright 2021 NXP
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ * this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ * this list of conditions and the following disclaimer in the documentation
+ * and/or other materials provided with the distribution.
+ *
+ * 3. Neither the name of the copyright holder nor the names of its
+ * contributors may be used to endorse or promote products derived from this
+ * software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include <ddr/ddr_lp.h>
+#include <ddr/ddr_init.h>
+
+/* DDR PHY Configuration and Status registers */
+const uint32_t csr_to_store[] = {
+	0x00001690,
+	0x00001718,
+	0x0001451c,
+	0x0001651c,
+	0x0001851c,
+	0x0001a51c,
+	0x00014520,
+	0x00016520,
+	0x00018520,
+	0x0001a520,
+	0x000003f0,
+	0x000023f0,
+	0x000043f0,
+	0x000063f0,
+	0x000146b0,
+	0x000166b0,
+	0x000186b0,
+	0x0001a6b0,
+	0x000146b4,
+	0x000166b4,
+	0x000186b4,
+	0x0001a6b4,
+	0x000146d0,
+	0x000166d0,
+	0x000186d0,
+	0x0001a6d0,
+	0x000146d4,
+	0x000166d4,
+	0x000186d4,
+	0x0001a6d4,
+	0x00014b50,
+	0x00016b50,
+	0x00018b50,
+	0x0001ab50,
+	0x00014b4c,
+	0x00016b4c,
+	0x00018b4c,
+	0x0001ab4c,
+	0x00014b70,
+	0x00016b70,
+	0x00018b70,
+	0x0001ab70,
+	0x00014b6c,
+	0x00016b6c,
+	0x00018b6c,
+	0x0001ab6c,
+	0x00014640,
+	0x00016640,
+	0x00018640,
+	0x0001a640,
+	0x0001463c,
+	0x0001663c,
+	0x0001863c,
+	0x0001a63c,
+	0x00014638,
+	0x00016638,
+	0x00018638,
+	0x0001a638,
+	0x00014634,
+	0x00016634,
+	0x00018634,
+	0x0001a634,
+	0x00014630,
+	0x00016630,
+	0x00018630,
+	0x0001a630,
+	0x0001462c,
+	0x0001662c,
+	0x0001862c,
+	0x0001a62c,
+	0x00014628,
+	0x00016628,
+	0x00018628,
+	0x0001a628,
+	0x00014624,
+	0x00016624,
+	0x00018624,
+	0x0001a624,
+	0x00014620,
+	0x00016620,
+	0x00018620,
+	0x0001a620,
+	0x00014664,
+	0x00016664,
+	0x00018664,
+	0x0001a664,
+	0x00014660,
+	0x00016660,
+	0x00018660,
+	0x0001a660,
+	0x0001465c,
+	0x0001665c,
+	0x0001865c,
+	0x0001a65c,
+	0x00014658,
+	0x00016658,
+	0x00018658,
+	0x0001a658,
+	0x00014654,
+	0x00016654,
+	0x00018654,
+	0x0001a654,
+	0x00014650,
+	0x00016650,
+	0x00018650,
+	0x0001a650,
+	0x0001464c,
+	0x0001664c,
+	0x0001864c,
+	0x0001a64c,
+	0x00014648,
+	0x00016648,
+	0x00018648,
+	0x0001a648,
+	0x00014644,
+	0x00016644,
+	0x00018644,
+	0x0001a644,
+	0x00014730,
+	0x00016730,
+	0x00018730,
+	0x0001a730,
+	0x00014734,
+	0x00016734,
+	0x00018734,
+	0x0001a734,
+	0x00014750,
+	0x00016750,
+	0x00018750,
+	0x0001a750,
+	0x00014754,
+	0x00016754,
+	0x00018754,
+	0x0001a754,
+	0x0001492c,
+	0x0001692c,
+	0x0001892c,
+	0x0001a92c,
+	0x00014928,
+	0x00016928,
+	0x00018928,
+	0x0001a928,
+	0x00014924,
+	0x00016924,
+	0x00018924,
+	0x0001a924,
+	0x00014920,
+	0x00016920,
+	0x00018920,
+	0x0001a920,
+	0x0001491c,
+	0x0001691c,
+	0x0001891c,
+	0x0001a91c,
+	0x00014918,
+	0x00016918,
+	0x00018918,
+	0x0001a918,
+	0x00014914,
+	0x00016914,
+	0x00018914,
+	0x0001a914,
+	0x00014910,
+	0x00016910,
+	0x00018910,
+	0x0001a910,
+	0x0001490c,
+	0x0001690c,
+	0x0001890c,
+	0x0001a90c,
+	0x000149bc,
+	0x000169bc,
+	0x000189bc,
+	0x0001a9bc,
+	0x000149b8,
+	0x000169b8,
+	0x000189b8,
+	0x0001a9b8,
+	0x000149b4,
+	0x000169b4,
+	0x000189b4,
+	0x0001a9b4,
+	0x000149b0,
+	0x000169b0,
+	0x000189b0,
+	0x0001a9b0,
+	0x000149ac,
+	0x000169ac,
+	0x000189ac,
+	0x0001a9ac,
+	0x000149a8,
+	0x000169a8,
+	0x000189a8,
+	0x0001a9a8,
+	0x000149a4,
+	0x000169a4,
+	0x000189a4,
+	0x0001a9a4,
+	0x000149a0,
+	0x000169a0,
+	0x000189a0,
+	0x0001a9a0,
+	0x0001499c,
+	0x0001699c,
+	0x0001899c,
+	0x0001a99c,
+	0x0001446c,
+	0x0001646c,
+	0x0001846c,
+	0x0001a46c,
+	0x000015e0,
+	0x000015e4,
+	0x00014850,
+	0x00016850,
+	0x00018850,
+	0x0001a850,
+	0x00001374,
+	0x00001388,
+	0x00014860,
+	0x00016860,
+	0x00018860,
+	0x0001a860,
+	0x00014870,
+	0x00016870,
+	0x00018870,
+	0x0001a870,
+	0x0000140c,
+	0x00001608,
+	0x00001618,
+	0x000003c8,
+	0x00000308,
+	0x00000c10,
+	0x00000c28,
+	0x00000c40,
+	0x00000c58,
+	0x00000c70,
+	0x00000c88,
+	0x00000ca0,
+	0x00000cb8,
+	0x000145fc,
+	0x000165fc,
+	0x000185fc,
+	0x0001a5fc,
+	0x00014600,
+	0x00016600,
+	0x00018600,
+	0x0001a600,
+	0x00014604,
+	0x00016604,
+	0x00018604,
+	0x0001a604,
+	0x00014608,
+	0x00016608,
+	0x00018608,
+	0x0001a608,
+	0x0001460c,
+	0x0001660c,
+	0x0001860c,
+	0x0001a60c,
+	0x00014610,
+	0x00016610,
+	0x00018610,
+	0x0001a610,
+	0x00014614,
+	0x00016614,
+	0x00018614,
+	0x0001a614,
+	0x00014618,
+	0x00016618,
+	0x00018618,
+	0x0001a618,
+	0x0001461c,
+	0x0001661c,
+	0x0001861c,
+	0x0001a61c,
+	0x000015f4,
+	0x00014430,
+	0x00016430,
+	0x00018430,
+	0x0001a430,
+	/* 2D training */
+	0x00014730,
+	0x00016730,
+	0x00018730,
+	0x0001a730,
+	0x00014734,
+	0x00016734,
+	0x00018734,
+	0x0001a734,
+	0x00014750,
+	0x00016750,
+	0x00018750,
+	0x0001a750,
+	0x00014754,
+	0x00016754,
+	0x00018754,
+	0x0001a754,
+	0x000144f8,
+	0x000164f8,
+	0x000184f8,
+	0x0001a4f8,
+	0x000144f4,
+	0x000164f4,
+	0x000184f4,
+	0x0001a4f4,
+	0x000144f0,
+	0x000164f0,
+	0x000184f0,
+	0x0001a4f0,
+	0x000144ec,
+	0x000164ec,
+	0x000184ec,
+	0x0001a4ec,
+	0x000144e8,
+	0x000164e8,
+	0x000184e8,
+	0x0001a4e8,
+	0x000144e4,
+	0x000164e4,
+	0x000184e4,
+	0x0001a4e4,
+	0x000144e0,
+	0x000164e0,
+	0x000184e0,
+	0x0001a4e0,
+	0x000144dc,
+	0x000164dc,
+	0x000184dc,
+	0x0001a4dc,
+	0x000144d8,
+	0x000164d8,
+	0x000184d8,
+	0x0001a4d8,
+};
+
+size_t csr_to_store_size = ARRAY_SIZE(csr_to_store);
diff --git a/drivers/nxp/s32g/ddr/ddr_lp_mmio.c b/drivers/nxp/s32g/ddr/ddr_lp_mmio.c
new file mode 100755
index 000000000..f06f9d629
--- /dev/null
+++ b/drivers/nxp/s32g/ddr/ddr_lp_mmio.c
@@ -0,0 +1,198 @@
+/*
+ * Copyright 2021 NXP
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ * this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ * this list of conditions and the following disclaimer in the documentation
+ * and/or other materials provided with the distribution.
+ *
+ * 3. Neither the name of the copyright holder nor the names of its
+ * contributors may be used to endorse or promote products derived from this
+ * software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include <ddr/ddr_lp.h>
+#include <ddr/ddr_init.h>
+#include <lib/mmio.h>
+
+/* Store Configuration Status Registers. */
+void store_csr(uintptr_t store_at)
+{
+	size_t i;
+	uint16_t csr;
+
+	mmio_write_32(MICROCONT_MUX_SEL, UNLOCK_CSR_ACCESS);
+	mmio_write_32(DDR_PHYA_UCCLKHCLKENABLES, HCLKEN_MASK | UCCLKEN_MASK);
+
+	for (i = 0; i < csr_to_store_size; i++) {
+		csr = mmio_read_16(DDRSS_BASE_ADDR + csr_to_store[i]);
+		mmio_write_16(store_at, csr);
+		store_at += sizeof(uint16_t);
+	}
+
+	mmio_write_32(DDR_PHYA_UCCLKHCLKENABLES, HCLKEN_MASK);
+	mmio_write_32(MICROCONT_MUX_SEL, LOCK_CSR_ACCESS);
+}
+
+/* Load Configuration Status Registers. */
+void load_csr(uintptr_t load_from)
+{
+	size_t i;
+	uint16_t csr;
+
+	for (i = 0; i < csr_to_store_size; i++) {
+		csr = mmio_read_16(load_from);
+		load_from += sizeof(uint16_t);
+		mmio_write_16(DDRSS_BASE_ADDR + csr_to_store[i], csr);
+	}
+}
+
+/* Transition the DDR SubSystem from normal mode to retention mode. */
+void ddrss_to_io_retention_mode(void)
+{
+	uint32_t sbrctl, pwrctl, swctl, dfimisc, tmp32;
+
+	/* Disable AXI Ports */
+	mmio_write_32(DDRC_UMCTL2_MP_BASE_ADDR + OFFSET_DDRC_PCTRL_0, 0);
+	mmio_write_32(DDRC_UMCTL2_MP_BASE_ADDR + OFFSET_DDRC_PCTRL_1, 0);
+	mmio_write_32(DDRC_UMCTL2_MP_BASE_ADDR + OFFSET_DDRC_PCTRL_2, 0);
+
+	do {
+		tmp32 = mmio_read_32(DDRC_UMCTL2_MP_BASE_ADDR +
+				     OFFSET_DDRC_STAT);
+	} while (tmp32 != 0);
+
+	/* Disable Scrubber */
+	sbrctl = mmio_read_32(DDRC_BASE_ADDR + OFFSET_DDRC_SBRCTL);
+	mmio_write_32(DDRC_BASE_ADDR + OFFSET_DDRC_SBRCTL, sbrctl &
+		      (~SCRUB_EN_MASK));
+	do {
+		tmp32 = mmio_read_32(DDRC_BASE_ADDR + OFFSET_DDRC_SBRSTAT);
+	} while ((tmp32 & SCRUB_BUSY_MASK) != 0);
+
+	/* Move to Self Refresh */
+	pwrctl = mmio_read_32(DDRC_BASE_ADDR + OFFSET_DDRC_PWRCTL);
+	mmio_write_32(DDRC_BASE_ADDR + OFFSET_DDRC_PWRCTL, pwrctl |
+		      SELFREF_SW_MASK);
+
+	do {
+		tmp32 = mmio_read_32(DDRC_BASE_ADDR + OFFSET_DDRC_STAT);
+	} while ((tmp32 & OPERATING_MODE_MASK) != OPERATING_MODE_SELF_REFRESH);
+
+	do {
+		tmp32 = mmio_read_32(DDRC_BASE_ADDR + OFFSET_DDRC_STAT);
+	} while ((tmp32 & SELFREF_TYPE_MASK) != SELFREF_TYPE_NOT_AUTO_SR_CTRL);
+
+	do {
+		tmp32 = mmio_read_32(DDRC_BASE_ADDR + OFFSET_DDRC_STAT);
+	} while ((tmp32 & SELFREF_STATE_MASK) != SELFREF_STATE_SRPD);
+
+	/* Transition Phy to LP3 */
+	mmio_write_32(DDRC_BASE_ADDR + OFFSET_DDRC_DFIMISC, 0);
+	swctl = mmio_read_32(DDRC_BASE_ADDR + OFFSET_DDRC_SWCTL);
+	mmio_write_32(DDRC_BASE_ADDR + OFFSET_DDRC_SWCTL, swctl &
+		      (~SW_DONE_MASK));
+
+	dfimisc = mmio_read_32(DDRC_BASE_ADDR + OFFSET_DDRC_DFIMISC);
+	mmio_write_32(DDRC_BASE_ADDR + OFFSET_DDRC_DFIMISC, dfimisc |
+		      DFI_FREQUENCY(0x1f));
+
+	dfimisc = mmio_read_32(DDRC_BASE_ADDR + OFFSET_DDRC_DFIMISC);
+	mmio_write_32(DDRC_BASE_ADDR + OFFSET_DDRC_DFIMISC, dfimisc |
+		      DFI_INIT_START_MASK);
+	do {
+		tmp32 = mmio_read_32(DDRC_BASE_ADDR + OFFSET_DDRC_DFISTAT);
+	} while ((tmp32 & DFI_INIT_COMPLETE_MASK) != 0);
+
+	dfimisc = mmio_read_32(DDRC_BASE_ADDR + OFFSET_DDRC_DFIMISC);
+	mmio_write_32(DDRC_BASE_ADDR + OFFSET_DDRC_DFIMISC, dfimisc |
+		      DFI_FREQUENCY(0x1f));
+	dfimisc = mmio_read_32(DDRC_BASE_ADDR + OFFSET_DDRC_DFIMISC);
+	mmio_write_32(DDRC_BASE_ADDR + OFFSET_DDRC_DFIMISC, dfimisc &
+		      (~DFI_INIT_START_MASK));
+	do {
+		tmp32 = mmio_read_32(DDRC_BASE_ADDR + OFFSET_DDRC_DFISTAT);
+	} while ((tmp32 & DFI_INIT_COMPLETE_MASK) == 0);
+
+	swctl = mmio_read_32(DDRC_BASE_ADDR + OFFSET_DDRC_SWCTL);
+	mmio_write_32(DDRC_BASE_ADDR + OFFSET_DDRC_SWCTL, swctl |
+		      SW_DONE_MASK);
+	do {
+		tmp32 = mmio_read_32(DDRC_BASE_ADDR + OFFSET_DDRC_SWSTAT);
+	} while ((tmp32 & SW_DONE_ACK_MASK) == 0);
+
+	/* Set PwrOkIn to 0 */
+	tmp32 = mmio_read_32(DDR_RET_CONTROL_REG);
+	mmio_write_32(DDR_RET_CONTROL_REG, tmp32 & (~DDR_RET_CONTROL_MASK));
+
+	tmp32 = mmio_read_32(DDR_CONFIG_0_REG);
+	mmio_write_32(DDR_CONFIG_0_REG, tmp32 | DDR_CONFIG_0_MEM_RET);
+}
+
+/* Transition the DDR SubSystem from retention mode to normal mode. */
+uint32_t ddrss_to_normal_mode(uintptr_t csr_array)
+{
+	uint32_t pwrctl, init0, ret;
+
+	ret = load_register_cfg(ddrc_cfg_size, ddrc_cfg);
+	if (ret != 0)
+		return ret;
+
+	mmio_write_32(MICROCONT_MUX_SEL, UNLOCK_CSR_ACCESS);
+	ret = load_dq_cfg(dq_swap_cfg_size, dq_swap_cfg);
+	if (ret != 0)
+		return ret;
+
+	mmio_write_32(MICROCONT_MUX_SEL, LOCK_CSR_ACCESS);
+
+	init0 = mmio_read_32(DDRC_BASE_ADDR + OFFSET_DDRC_INIT0);
+	init0 |= SKIP_DRAM_INIT_MASK;
+	mmio_write_32(DDRC_BASE_ADDR + OFFSET_DDRC_INIT0, init0);
+
+	pwrctl = mmio_read_32(DDRC_BASE_ADDR + OFFSET_DDRC_PWRCTL);
+	mmio_write_32(DDRC_BASE_ADDR + OFFSET_DDRC_PWRCTL, pwrctl |
+		      SELFREF_SW_MASK);
+
+	/* Setup AXI ports parity */
+	ret = set_axi_parity();
+	if (ret != NO_ERR)
+		return ret;
+
+	mmio_write_32(MICROCONT_MUX_SEL, UNLOCK_CSR_ACCESS);
+	ret = load_register_cfg_16(phy_cfg_size, phy_cfg);
+	if (ret != 0)
+		return ret;
+
+	mmio_write_32(MICROCONT_MUX_SEL, LOCK_CSR_ACCESS);
+
+	/* Optimal PLL */
+	set_optimal_pll();
+
+	/* Reload saved CSRs */
+	mmio_write_32(MICROCONT_MUX_SEL, UNLOCK_CSR_ACCESS);
+	load_csr(csr_array);
+	ret = load_register_cfg_16(pie_cfg_size, pie_cfg);
+	if (ret != 0)
+		return ret;
+
+	mmio_write_32(MICROCONT_MUX_SEL, LOCK_CSR_ACCESS);
+
+	return post_train_setup(0);
+}
diff --git a/drivers/nxp/s32g/ddr/ddr_utils_mmio.c b/drivers/nxp/s32g/ddr/ddr_utils_mmio.c
index 919ac4a38..5a4b04079 100644
--- a/drivers/nxp/s32g/ddr/ddr_utils_mmio.c
+++ b/drivers/nxp/s32g/ddr/ddr_utils_mmio.c
@@ -27,9 +27,14 @@
  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  * POSSIBILITY OF SUCH DAMAGE.
  */
+
 #include <ddr/ddr_utils.h>
-#include <ddr/ddrss.h>
-#include <ssram_mailbox.h>
+#include <lib/mmio.h>
+
+#ifdef STORE_CSR_ENABLE
+/* Store Configuration Status Registers. */
+void store_csr(uintptr_t store_at);
+#endif
 
 static uint32_t enable_axi_ports(void);
 static uint32_t get_mail(uint32_t *mail);
@@ -38,11 +43,10 @@ static uint32_t ack_mail(void);
 uint8_t polling_needed = 2;
 
 /* Modify bitfield value with delta, given bitfield position and mask */
-static inline bool update_bf(uint32_t *v, uint8_t pos, uint32_t mask,
-			     int delta)
+bool update_bf(uint32_t *v, uint8_t pos, uint32_t mask, int32_t delta)
 {
 	if (mask >= (((*v >> pos) & mask) + delta)) {
-		*v = (*v & ~(mask << pos)) | ((((*v >> pos)
+		*v = (*v & ~(mask << pos)) | ((((*v >> pos) 
 			& mask) + delta) << pos);
 		return true;
 	} else {
@@ -61,38 +65,38 @@ bool sel_clk_src(uint32_t clk_src)
 
 	/* Check if the clock source is already set to clk_src*/
 	tmp32 = mmio_read_32(MC_CGM5_BASE_ADDR + OFFSET_MUX_0_CSS);
-	if (((tmp32 & 0x3fffffff) >> 24) == clk_src)
+	if (((tmp32 & 0x3fffffffU) >> 24) == clk_src)
 		return false;
 
 	/* To wait till clock switching is completed */
 	do {
 		tmp32 = mmio_read_32(MC_CGM5_BASE_ADDR + OFFSET_MUX_0_CSS);
-	} while (((tmp32 >> 16) & 0x1) != 0x0);
+	} while (((tmp32 >> 16) & 0x1U) != 0x0);
 
 	/* Set DDR_CLK source on src_clk */
 	tmp32 = mmio_read_32(MC_CGM5_BASE_ADDR + OFFSET_MUX_0_CSC);
 	mmio_write_32(MC_CGM5_BASE_ADDR + OFFSET_MUX_0_CSC,
-		      (0xc0ffffff & tmp32) | (clk_src << 24));
+		      (0xc0ffffffU & tmp32) | (clk_src << 24));
 
 	 /* Request clock switch */
 	tmp32 = mmio_read_32(MC_CGM5_BASE_ADDR + OFFSET_MUX_0_CSC);
 	mmio_write_32(MC_CGM5_BASE_ADDR + OFFSET_MUX_0_CSC,
-		      (0x1 << 2) | tmp32);
+		      (0x1U << 2) | tmp32);
 
 	/* To wait till clock switching is completed */
 	do {
 		tmp32 = mmio_read_32(MC_CGM5_BASE_ADDR + OFFSET_MUX_0_CSS);
-	} while (((tmp32 >> 16) & 0x1) != 0x0);
+	} while (((tmp32 >> 16) & 0x1U) != 0x0);
 
 	/* To wait till Switch after request is succeeded */
 	do {
 		tmp32 = mmio_read_32(MC_CGM5_BASE_ADDR + OFFSET_MUX_0_CSS);
-	} while (((tmp32 >> 17) & 0x1) != 0x1);
+	} while (((tmp32 >> 17) & 0x1U) != 0x1);
 
 	/* Make sure correct clock source is selected */
 	do {
 		tmp32 = mmio_read_32(MC_CGM5_BASE_ADDR + OFFSET_MUX_0_CSS);
-	} while (((tmp32 & 0x3fffffff) >> 24) != clk_src);
+	} while (((tmp32 & 0x3fffffffU) >> 24) != clk_src);
 
 	return true;
 }
@@ -104,13 +108,19 @@ uint32_t set_axi_parity(void)
 	bool switched_to_firc;
 
 	/* Enable Parity For All AXI Interfaces */
-	mmio_write_32(DDR_SS_REG, mmio_read_32(DDR_SS_REG) | 0x1ff0);
+	tmp32 = mmio_read_32(DDR_SS_REG);
+	mmio_write_32(DDR_SS_REG, tmp32 | 0x1ff0U);
 
 	/* Set AXI_PARITY_TYPE to 0x1ff;   0-even, 1-odd */
-	mmio_write_32(DDR_SS_REG, mmio_read_32(DDR_SS_REG) | 0x1ff0000);
-
-	/* Set DFI1_ENABLED to 0x1 */
-	mmio_write_32(DDR_SS_REG, mmio_read_32(DDR_SS_REG) | 0x1);
+	tmp32 = mmio_read_32(DDR_SS_REG);
+	mmio_write_32(DDR_SS_REG, tmp32 | 0x1ff0000U);
+
+	/* For LPDDR4 Set DFI1_ENABLED to 0x1 */
+	tmp32 = mmio_read_32(DDRC_BASE_ADDR);
+	if ((tmp32 & MSTR_LPDDR4_MASK) == MSTR_LPDDR4_VAL) {
+		tmp32 = mmio_read_32(DDR_SS_REG);
+		mmio_write_32(DDR_SS_REG, tmp32 | 0x1U);
+	}
 
 	/*
 	 * Set ddr clock source on FIRC_CLK.
@@ -120,11 +130,11 @@ uint32_t set_axi_parity(void)
 
 	/* De-assert Reset To Controller and AXI Ports */
 	tmp32 = mmio_read_32(MC_RGM_PRST_0);
-	mmio_write_32(MC_RGM_PRST_0, ~(0x1 << 3) & tmp32);
+	mmio_write_32(MC_RGM_PRST_0, ~(0x1U << 3) & tmp32);
 
 	/* Check if the initial clock source was not on FIRC */
 	if (switched_to_firc)
-		sel_clk_src(DDR_PHI0_PLL);
+		switched_to_firc = sel_clk_src(DDR_PHI0_PLL);
 
 	/* Enable HIF, CAM Queueing */
 	mmio_write_32(DDRC_BASE_ADDR + OFFSET_DDRC_DBG1, 0x0);
@@ -132,17 +142,17 @@ uint32_t set_axi_parity(void)
 	/* Disable auto-refresh: RFSHCTL3.dis_auto_refresh = 1 */
 	tmp32 = mmio_read_32(DDRC_BASE_ADDR + OFFSET_DDRC_RFSHCTL3);
 	mmio_write_32(DDRC_BASE_ADDR + OFFSET_DDRC_RFSHCTL3,
-		      (1 | tmp32));
+		      (0x1U | tmp32));
 
 	/* Disable power down: PWRCTL.powerdown_en = 0 */
 	tmp32 = mmio_read_32(DDRC_BASE_ADDR + OFFSET_DDRC_PWRCTL);
 	mmio_write_32(DDRC_BASE_ADDR + OFFSET_DDRC_PWRCTL,
-		      ((~0x00000002) & tmp32));
+		      ((~0x00000002U) & tmp32));
 
 	/* Disable self-refresh: PWRCTL.selfref_en = 0 */
 	tmp32 = mmio_read_32(DDRC_BASE_ADDR + OFFSET_DDRC_PWRCTL);
 	mmio_write_32(DDRC_BASE_ADDR + OFFSET_DDRC_PWRCTL,
-		      ((~0x00000001) & tmp32));
+		      ((~0x00000001U) & tmp32));
 
 	/*
 	 * Disable assertion of dfi_dram_clk_disable:
@@ -150,7 +160,7 @@ uint32_t set_axi_parity(void)
 	 */
 	tmp32 = mmio_read_32(DDRC_BASE_ADDR + OFFSET_DDRC_PWRCTL);
 	mmio_write_32(DDRC_BASE_ADDR + OFFSET_DDRC_PWRCTL,
-		      ((~0x00000008) & tmp32));
+		      ((~0x00000008U) & tmp32));
 
 	/* Enable Quasi-Dynamic Programming */
 	mmio_write_32(DDRC_BASE_ADDR + OFFSET_DDRC_SWCTL,
@@ -163,7 +173,7 @@ uint32_t set_axi_parity(void)
 
 	/* DFI_INIT_COMPLETE_EN set to 0 */
 	tmp32 = mmio_read_32(DDRC_BASE_ADDR + OFFSET_DDRC_DFIMISC);
-	mmio_write_32(DDRC_BASE_ADDR + OFFSET_DDRC_DFIMISC, (~0x1) & tmp32);
+	mmio_write_32(DDRC_BASE_ADDR + OFFSET_DDRC_DFIMISC, (~0x1U) & tmp32);
 
 	/* Set SWCTL.sw_done to 1 */
 	mmio_write_32(DDRC_BASE_ADDR + OFFSET_DDRC_SWCTL,
@@ -177,7 +187,7 @@ uint32_t set_axi_parity(void)
 }
 
 /* Enables AXI port n. Programming Mode: Dynamic */
-uint32_t enable_axi_ports(void)
+static uint32_t enable_axi_ports(void)
 {
 	/* Port 0 Control Register*/
 	mmio_write_32(DDRC_UMCTL2_MP_BASE_ADDR + OFFSET_DDRC_PCTRL_0,
@@ -195,8 +205,10 @@ uint32_t enable_axi_ports(void)
 /*
  * Post PHY training setup - complementary settings that need to be
  * performed after running the firmware.
+ *  @param options - various flags controlling post training actions
+ * (whether to init memory with ECC scrubber / whether to store CSR)
  */
-uint32_t post_train_setup(bool init_mem)
+uint32_t post_train_setup(uint8_t options)
 {
 	uint32_t ret = NO_ERR;
 	uint32_t tmp32;
@@ -207,7 +219,12 @@ uint32_t post_train_setup(bool init_mem)
 	 */
 	do {
 		tmp32 = mmio_read_32(DDR_PHYA_MASTER0_CALBUSY);
-	} while ((tmp32 & 0x1) != 0);
+	} while ((tmp32 & 0x1u) != 0);
+
+#ifdef STORE_CSR_ENABLE
+	if ((options & STORE_CSR_MASK) != 0)
+		store_csr(RETENTION_ADDR);
+#endif
 
 	/* Set SWCTL.sw_done to 0 */
 	mmio_write_32(DDRC_BASE_ADDR + OFFSET_DDRC_SWCTL,
@@ -219,7 +236,7 @@ uint32_t post_train_setup(bool init_mem)
 	/* Set DFIMISC.dfi_init_start to 1*/
 	tmp32 = mmio_read_32(DDRC_BASE_ADDR + OFFSET_DDRC_DFIMISC);
 	mmio_write_32(DDRC_BASE_ADDR + OFFSET_DDRC_DFIMISC,
-		      (0x00000020 | tmp32));
+		      (0x00000020U | tmp32));
 
 	/* Set SWCTL.sw_done to 1 */
 	mmio_write_32(DDRC_BASE_ADDR + OFFSET_DDRC_SWCTL,
@@ -232,29 +249,29 @@ uint32_t post_train_setup(bool init_mem)
 	/* Wait DFISTAT.dfi_init_complete to 1 */
 	do {
 		tmp32 = mmio_read_32(DDRC_BASE_ADDR + OFFSET_DDRC_DFISTAT);
-	} while ((tmp32 & 0x1) == 0);
+	} while ((tmp32 & 0x1U) == 0);
 
 	/* Set SWCTL.sw_done to 0 */
 	mmio_write_32(DDRC_BASE_ADDR + OFFSET_DDRC_SWCTL,
 		      DDRC_SWCTL_SWDONE_ENABLE);
 	do {
 		tmp32 = mmio_read_32(DDRC_BASE_ADDR + OFFSET_DDRC_SWSTAT);
-	} while ((tmp32 & DDRC_SWSTAT_SWDONE_ACK_MASK));
+	} while ((tmp32 & DDRC_SWSTAT_SWDONE_ACK_MASK) != 0);
 
 	/* Set dfi_init_start to 0 */
 	tmp32 = mmio_read_32(DDRC_BASE_ADDR + OFFSET_DDRC_DFIMISC);
 	mmio_write_32(DDRC_BASE_ADDR + OFFSET_DDRC_DFIMISC,
-		      (~0x00000020) & tmp32);
+		      (~0x00000020U) & tmp32);
 
 	/* Set dfi_complete_en to 1 */
 	tmp32 = mmio_read_32(DDRC_BASE_ADDR + OFFSET_DDRC_DFIMISC);
 	mmio_write_32(DDRC_BASE_ADDR + OFFSET_DDRC_DFIMISC,
-		      0x00000001 | tmp32);
+		      0x00000001U | tmp32);
 
 	/* Set PWRCTL.selfref_sw to 0 */
 	tmp32 = mmio_read_32(DDRC_BASE_ADDR + OFFSET_DDRC_PWRCTL);
 	mmio_write_32(DDRC_BASE_ADDR + OFFSET_DDRC_PWRCTL,
-		      ((~0x00000020) & tmp32));
+		      ((~0x00000020U) & tmp32));
 
 	/* Set SWCTL.sw_done to 1 */
 	mmio_write_32(DDRC_BASE_ADDR + OFFSET_DDRC_SWCTL,
@@ -266,19 +283,19 @@ uint32_t post_train_setup(bool init_mem)
 	/* Wait for DWC_ddr_umctl2 to move to normal operating mode */
 	do {
 		tmp32 = mmio_read_32(DDRC_BASE_ADDR + OFFSET_DDRC_STAT);
-	} while ((tmp32 & 0x7) == 0);
+	} while ((tmp32 & 0x7U) == 0);
 
 	/* Enable auto-refresh: RFSHCTL3.dis_auto_refresh = 0 */
 	tmp32 = mmio_read_32(DDRC_BASE_ADDR + OFFSET_DDRC_RFSHCTL3);
 	mmio_write_32(DDRC_BASE_ADDR + OFFSET_DDRC_RFSHCTL3,
-		      (~0x00000001) & tmp32);
+		      (~0x00000001U) & tmp32);
 
 	/*
 	 * If ECC feature is enabled (ECCCFG0[ecc_mode] > 0)
 	 * initialize memory with the ecc scrubber
 	 */
-	if ((mmio_read_32(DDRC_BASE_ADDR + OFFSET_DDRC_ECCCFG0) & 0x7) > 0 &&
-	    init_mem) {
+	tmp32 = mmio_read_32(DDRC_BASE_ADDR + OFFSET_DDRC_ECCCFG0);
+	if (((tmp32 & 0x7U) > 0) && ((options & INIT_MEM_MASK) != 0)) {
 		ret = init_memory_ecc_scrubber();
 		if (ret != NO_ERR)
 			return ret;
@@ -286,18 +303,21 @@ uint32_t post_train_setup(bool init_mem)
 
 	/* Enable power down: PWRCTL.powerdown_en = 1 */
 	tmp32 = mmio_read_32(DDRC_BASE_ADDR + OFFSET_DDRC_PWRCTL);
-	mmio_write_32(DDRC_BASE_ADDR + OFFSET_DDRC_PWRCTL, 0x00000002 | tmp32);
+	mmio_write_32(DDRC_BASE_ADDR + OFFSET_DDRC_PWRCTL,
+		      0x00000002U | tmp32);
 
 	/* Enable self-refresh: PWRCTL.selfref_en = 1*/
 	tmp32 = mmio_read_32(DDRC_BASE_ADDR + OFFSET_DDRC_PWRCTL);
-	mmio_write_32(DDRC_BASE_ADDR + OFFSET_DDRC_PWRCTL, 0x00000001 | tmp32);
+	mmio_write_32(DDRC_BASE_ADDR + OFFSET_DDRC_PWRCTL,
+		      0x00000001U | tmp32);
 
 	/*
 	 * Enable assertion of dfi_dram_clk_disable:
 	 * PWRTL.en_dfi_dram_clk_disable = 1
 	 */
 	tmp32 = mmio_read_32(DDRC_BASE_ADDR + OFFSET_DDRC_PWRCTL);
-	mmio_write_32(DDRC_BASE_ADDR + OFFSET_DDRC_PWRCTL, 0x00000008 | tmp32);
+	mmio_write_32(DDRC_BASE_ADDR + OFFSET_DDRC_PWRCTL,
+		      0x00000008U | tmp32);
 
 	ret |= enable_derating_temp_errata();
 
@@ -313,40 +333,43 @@ uint32_t post_train_setup(bool init_mem)
 uint32_t wait_firmware_execution(void)
 {
 	uint32_t mail = 0;
+	uint32_t ret;
 
-	while (mail == 0) {
+	while (true) {
 		/* Obtain message from PHY (major message) */
-		uint32_t ret = get_mail(&mail);
+		ret = get_mail(&mail);
 
 		if (ret != NO_ERR)
-			return ret;
+			break;
 
 		/* 0x07 means OK, 0xFF means failure */
 		if (mail == 0x07)
-			return NO_ERR;
-		if (mail == 0xff)
-			/* Training stage failed */
-			return TRAINING_FAILED;
+			break;
 
-		/* No error. Keep querying for mails */
-		mail = 0;
+		if (mail == 0xff) {
+			/* Training stage failed */
+			ret = TRAINING_FAILED;
+			break;
+		}
 	}
-	return TIMEOUT_ERR;
+
+	return ret;
 }
 
 /* Acknowledge received message */
-uint32_t ack_mail(void)
+static uint32_t ack_mail(void)
 {
 	uint32_t timeout = DEFAULT_TIMEOUT;
 	/* ACK message */
 	mmio_write_32(DDR_PHYA_APBONLY_DCTWRITEPROT, 0);
+	uint32_t tmp32 = mmio_read_32(DDR_PHYA_APBONLY_UCTSHSADOWREGS);
 
 	/* Wait firmware to respond to ACK (UctWriteProtShadow to be set) */
-	while (--timeout && !(mmio_read_32(DDR_PHYA_APBONLY_UCTSHSADOWREGS) &
-			      UCT_WRITE_PROT_SHADOW_MASK))
-		;
+	while ((--timeout != 0) &&
+	       ((tmp32 & UCT_WRITE_PROT_SHADOW_MASK) == 0))
+		tmp32 = mmio_read_32(DDR_PHYA_APBONLY_UCTSHSADOWREGS);
 
-	if (!timeout)
+	if (timeout == 0)
 		return TIMEOUT_ERR;
 
 	mmio_write_32(DDR_PHYA_APBONLY_DCTWRITEPROT, 1);
@@ -355,15 +378,16 @@ uint32_t ack_mail(void)
 }
 
 /* Read available message from DDR PHY microcontroller */
-uint32_t get_mail(uint32_t *mail)
+static uint32_t get_mail(uint32_t *mail)
 {
 	uint32_t timeout = DEFAULT_TIMEOUT;
+	uint32_t tmp32 = mmio_read_32(DDR_PHYA_APBONLY_UCTSHSADOWREGS);
 
-	while (--timeout && (mmio_read_32(DDR_PHYA_APBONLY_UCTSHSADOWREGS) &
-			     UCT_WRITE_PROT_SHADOW_MASK))
-		;
+	while ((--timeout != 0) &&
+	       ((tmp32 & UCT_WRITE_PROT_SHADOW_MASK) != 0))
+		tmp32 = mmio_read_32(DDR_PHYA_APBONLY_UCTSHSADOWREGS);
 
-	if (!timeout)
+	if (timeout == 0)
 		return TIMEOUT_ERR;
 
 	*mail = mmio_read_32(DDR_PHYA_APBONLY_UCTWRITEONLYSHADOW);
@@ -376,36 +400,38 @@ uint32_t get_mail(uint32_t *mail)
 uint32_t init_memory_ecc_scrubber(void)
 {
 	uint8_t region_lock;
-	uint32_t tmp32, pattern = 0x12345678;
+	uint32_t tmp32, pattern = 0x00000000U;
 
 	/* Save previous ecc region parity locked state. */
 	region_lock = mmio_read_32(DDRC_BASE_ADDR + OFFSET_DDRC_ECCCFG1)
-				   & (0x1 << 4);
+				   & (0x1UL << 4);
 
 	/* Enable ecc region lock. */
 	tmp32 = mmio_read_32(DDRC_BASE_ADDR + OFFSET_DDRC_ECCCFG1);
 	mmio_write_32(DDRC_BASE_ADDR + OFFSET_DDRC_ECCCFG1,
-		      (0x1 << 4) | tmp32);
+		      (0x1UL << 4) | tmp32);
 
 	/* Set SBRCTL.scrub_mode = 1. */
 	tmp32 = mmio_read_32(DDRC_BASE_ADDR + OFFSET_DDRC_SBRCTL);
-	mmio_write_32(DDRC_BASE_ADDR + OFFSET_DDRC_SBRCTL, (0x1 << 2) | tmp32);
+	mmio_write_32(DDRC_BASE_ADDR + OFFSET_DDRC_SBRCTL,
+		      (0x1U << 2) | tmp32);
 
 	/* Set SBRCTL.scrub_during_lowpower = 1. */
 	tmp32 = mmio_read_32(DDRC_BASE_ADDR + OFFSET_DDRC_SBRCTL);
-	mmio_write_32(DDRC_BASE_ADDR + OFFSET_DDRC_SBRCTL, (0x1 << 1) | tmp32);
+	mmio_write_32(DDRC_BASE_ADDR + OFFSET_DDRC_SBRCTL,
+		      (0x1U << 1) | tmp32);
 
 	/* Set SBRCTL.scrub_interval = 0. */
 	tmp32 = mmio_read_32(DDRC_BASE_ADDR + OFFSET_DDRC_SBRCTL);
 	mmio_write_32(DDRC_BASE_ADDR + OFFSET_DDRC_SBRCTL,
-		      ~(0x1fff << 8) & tmp32);
+		      ~(0x1fffU << 8) & tmp32);
 
 	/* Set the desired pattern through SBRWDATA0 register. */
 	mmio_write_32(DDRC_BASE_ADDR + OFFSET_DDRC_SBRWDATA0, pattern);
 
 	/* Enable the SBR by programming SBRCTL.scrub_en = 1. */
 	tmp32 = mmio_read_32(DDRC_BASE_ADDR + OFFSET_DDRC_SBRCTL);
-	mmio_write_32(DDRC_BASE_ADDR + OFFSET_DDRC_SBRCTL, 0x1 | tmp32);
+	mmio_write_32(DDRC_BASE_ADDR + OFFSET_DDRC_SBRCTL, 0x1U | tmp32);
 
 	/*
 	 * Poll until SBRSTAT.scrub_done = 1
@@ -413,7 +439,7 @@ uint32_t init_memory_ecc_scrubber(void)
 	 */
 	do {
 		tmp32 = mmio_read_32(DDRC_BASE_ADDR + OFFSET_DDRC_SBRSTAT);
-	} while ((tmp32 & 0x2) == 0);
+	} while ((tmp32 & 0x2U) == 0);
 
 	/*
 	 * Poll until SBRSTAT.scrub_busy = 0
@@ -421,29 +447,30 @@ uint32_t init_memory_ecc_scrubber(void)
 	 */
 	do {
 		tmp32 = mmio_read_32(DDRC_BASE_ADDR + OFFSET_DDRC_SBRSTAT);
-	} while (tmp32 & 0x1);
+	} while ((tmp32 & 0x1U) != 0);
 
 	/* Disable SBR by programming SBRCTL.scrub_en = 0. */
 	tmp32 = mmio_read_32(DDRC_BASE_ADDR + OFFSET_DDRC_SBRCTL);
-	mmio_write_32(DDRC_BASE_ADDR + OFFSET_DDRC_SBRCTL, ~(0x1) & tmp32);
+	mmio_write_32(DDRC_BASE_ADDR + OFFSET_DDRC_SBRCTL, ~(0x1U) & tmp32);
 
 	/* Enter normal scrub operation (Reads): SBRCTL.scrub_mode = 0. */
 	tmp32 = mmio_read_32(DDRC_BASE_ADDR + OFFSET_DDRC_SBRCTL);
 	mmio_write_32(DDRC_BASE_ADDR + OFFSET_DDRC_SBRCTL,
-		      ~(0x1 << 2) & tmp32);
+		      ~(0x1U << 2) & tmp32);
 
 	/* Set SBRCTL.scrub_interval = 1. */
 	tmp32 = mmio_read_32(DDRC_BASE_ADDR + OFFSET_DDRC_SBRCTL);
-	tmp32 = ~(0x1fff << 8) & tmp32;
-	mmio_write_32(DDRC_BASE_ADDR + OFFSET_DDRC_SBRCTL, (0x1 << 8) | tmp32);
+	tmp32 = ~(0x1fffU << 8) & tmp32;
+	mmio_write_32(DDRC_BASE_ADDR + OFFSET_DDRC_SBRCTL,
+		      (0x1UL << 8) | tmp32);
 
 	/* Enable the SBR by programming SBRCTL.scrub_en = 1. */
 	tmp32 = mmio_read_32(DDRC_BASE_ADDR + OFFSET_DDRC_SBRCTL);
-	mmio_write_32(DDRC_BASE_ADDR + OFFSET_DDRC_SBRCTL, 0x1 | tmp32);
+	mmio_write_32(DDRC_BASE_ADDR + OFFSET_DDRC_SBRCTL, 0x1U | tmp32);
 
 	/* Restore locked state of ecc region. */
 	tmp32 = mmio_read_32(DDRC_BASE_ADDR + OFFSET_DDRC_ECCCFG1);
-	tmp32 = (tmp32 & ~(0x1 << 4)) | (region_lock << 4);
+	tmp32 = (tmp32 & ~(0x1UL << 4)) | (region_lock << 4);
 	mmio_write_32(DDRC_BASE_ADDR + OFFSET_DDRC_ECCCFG1, tmp32);
 
 	return NO_ERR;
@@ -453,11 +480,12 @@ uint32_t init_memory_ecc_scrubber(void)
 uint32_t read_lpddr4_mr(uint8_t mr_index)
 {
 	uint32_t tmp32;
+	uint8_t succesive_reads = 0;
 
 	/* Set MRR_DDR_SEL_REG to 0x1 to enable LPDDR4 mode */
 	tmp32 = mmio_read_32(PERF_BASE_ADDR + OFFSET_MRR_0_DATA_REG_ADDR);
 	mmio_write_32(PERF_BASE_ADDR + OFFSET_MRR_0_DATA_REG_ADDR,
-		      (tmp32 | 0x1));
+		      (tmp32 | 0x1U));
 
 	/*
 	 * Ensure no MR transaction is in progress:
@@ -465,31 +493,40 @@ uint32_t read_lpddr4_mr(uint8_t mr_index)
 	 */
 	do {
 		tmp32 = mmio_read_32(DDRC_BASE_ADDR + OFFSET_DDRC_MRSTAT);
-	} while ((tmp32 & 0x1) != 0);
+		if ((tmp32 & 0x1U) == 0)
+			succesive_reads++;
+		else
+			succesive_reads = 0;
+	} while (succesive_reads != REQUIRED_MRSTAT_READS);
 
 	/* Set MR_TYPE = 0x1 (Read) and MR_RANK = 0x1 (Rank 0) */
 	tmp32 = mmio_read_32(DDRC_BASE_ADDR + OFFSET_DDRC_MRCTRL0);
-	tmp32 |= 0x1;
-	tmp32 = (tmp32 & ~(0xf << 4)) | (0x1 << 4);
+	tmp32 |= 0x1U;
+	tmp32 = (tmp32 & ~(0xfUL << 4)) | (0x1UL << 4);
 	mmio_write_32(DDRC_BASE_ADDR + OFFSET_DDRC_MRCTRL0, tmp32);
 
 	/* Configure MR address: MRCTRL1[8:15] */
 	tmp32 = mmio_read_32(DDRC_BASE_ADDR + OFFSET_DDRC_MRCTRL1);
-	tmp32 = (tmp32 & ~(0xff << 8)) | (mr_index << 8);
+	tmp32 = (tmp32 & ~(0xffUL << 8)) | ((uint16_t)mr_index << 8);
 	mmio_write_32(DDRC_BASE_ADDR + OFFSET_DDRC_MRCTRL1,
 		      tmp32);
 
-	__asm__("DSB SY");
+	dsb();
 
 	/* Initiate MR transaction: MR_WR = 0x1 */
 	tmp32 = mmio_read_32(DDRC_BASE_ADDR + OFFSET_DDRC_MRCTRL0);
 	mmio_write_32(DDRC_BASE_ADDR + OFFSET_DDRC_MRCTRL0,
-		      tmp32 | (0x1u << 31));
+		      tmp32 | (0x1UL << 31));
 
 	/* Wait until MR transaction completed */
+	succesive_reads = 0;
 	do {
 		tmp32 = mmio_read_32(DDRC_BASE_ADDR + OFFSET_DDRC_MRSTAT);
-	} while ((tmp32 & 0x1) != 0);
+		if ((tmp32 & 0x1U) == 0)
+			succesive_reads++;
+		else
+			succesive_reads = 0;
+	} while (succesive_reads != REQUIRED_MRSTAT_READS);
 
 	return mmio_read_32(PERF_BASE_ADDR + OFFSET_MRR_1_DATA_REG_ADDR);
 }
@@ -498,11 +535,12 @@ uint32_t read_lpddr4_mr(uint8_t mr_index)
 uint32_t write_lpddr4_mr(uint8_t mr_index, uint8_t mr_data)
 {
 	uint32_t tmp32;
+	uint8_t succesive_reads = 0;
 
 	/* Set MRR_DDR_SEL_REG to 0x1 to enable LPDDR4 mode */
 	tmp32 = mmio_read_32(PERF_BASE_ADDR + OFFSET_MRR_0_DATA_REG_ADDR);
 	mmio_write_32(PERF_BASE_ADDR + OFFSET_MRR_0_DATA_REG_ADDR,
-		      tmp32 | 0x1);
+		      tmp32 | 0x1U);
 
 	/*
 	 * Ensure no MR transaction is in progress:
@@ -510,30 +548,40 @@ uint32_t write_lpddr4_mr(uint8_t mr_index, uint8_t mr_data)
 	 */
 	do {
 		tmp32 = mmio_read_32(DDRC_BASE_ADDR + OFFSET_DDRC_MRSTAT);
-	} while ((tmp32 & 0x1) != 0);
+		if ((tmp32 & 0x1U) == 0)
+			succesive_reads++;
+		else
+			succesive_reads = 0;
+	} while (succesive_reads != REQUIRED_MRSTAT_READS);
 
 	/* Set MR_TYPE = 0x0 (Write) and MR_RANK = 0x1 (Rank 0) */
 	tmp32 = mmio_read_32(DDRC_BASE_ADDR + OFFSET_DDRC_MRCTRL0);
-	tmp32 &= ~(0x1);
-	tmp32 = (tmp32 & ~(0xf << 4)) | (0x1 << 4);
+	tmp32 &= ~(0x1U);
+	tmp32 = (tmp32 & ~(0xfUL << 4)) | (0x1UL << 4);
 	mmio_write_32(DDRC_BASE_ADDR + OFFSET_DDRC_MRCTRL0, tmp32);
 
 	/* Configure MR address: MRCTRL1[8:15] and MR data: MRCTRL1[0:7]*/
 	tmp32 = mmio_read_32(DDRC_BASE_ADDR + OFFSET_DDRC_MRCTRL1);
-	tmp32 = (tmp32 & (0xffffu << 16)) | (mr_index << 8) | mr_data;
+	tmp32 = (tmp32 & (0xffffUL << 16)) | ((uint16_t)mr_index << 8) |
+		mr_data;
 	mmio_write_32(DDRC_BASE_ADDR + OFFSET_DDRC_MRCTRL1, tmp32);
 
-	__asm__("DSB SY");
+	dsb();
 
 	/* Initiate MR transaction: MR_WR = 0x1 */
 	tmp32 = mmio_read_32(DDRC_BASE_ADDR + OFFSET_DDRC_MRCTRL0);
 	mmio_write_32(DDRC_BASE_ADDR + OFFSET_DDRC_MRCTRL0,
-		      tmp32 | (0x1u << 31));
+		      tmp32 | (0x1UL << 31));
 
 	/* Wait until MR transaction completed */
+	succesive_reads = 0;
 	do {
 		tmp32 = mmio_read_32(DDRC_BASE_ADDR + OFFSET_DDRC_MRSTAT);
-	} while ((tmp32 & 0x1) != 0);
+		if ((tmp32 & 0x1U) == 0)
+			succesive_reads++;
+		else
+			succesive_reads = 0;
+	} while (succesive_reads != REQUIRED_MRSTAT_READS);
 
 	return NO_ERR;
 }
@@ -544,11 +592,11 @@ uint8_t read_tuf(void)
 	uint32_t mr4_val;
 	uint8_t mr4_die_1, mr4_die_2;
 
-	mr4_val = read_lpddr4_mr(MR4);
-	mr4_die_1 = mr4_val & 0x7;
-	mr4_die_2 = (mr4_val >> 16) & 0x7;
+	mr4_val = read_lpddr4_mr(MR4_IDX);
+	mr4_die_1 = mr4_val & 0x7U;
+	mr4_die_2 = (mr4_val >> 16) & 0x7U;
 
-	return mr4_die_1 > mr4_die_2 ? mr4_die_1 : mr4_die_2;
+	return (mr4_die_1 > mr4_die_2) ? mr4_die_1 : mr4_die_2;
 }
 
 /*
@@ -587,7 +635,7 @@ uint32_t enable_derating_temp_errata(void)
 		tmp32 = mmio_read_32(DDRC_BASE_ADDR + OFFSET_DDRC_RFSHCTL3);
 		bf_val = (tmp32 >> DDRC_RFSHCTL3_UPDATE_SHIFT) &
 			 DDRC_RFSHCTL3_AUTO_REFRESH_VAL;
-		bf_val = bf_val ^ 1;
+		bf_val = bf_val ^ 0x1U;
 		tmp32 = (tmp32 & ~DDRC_RFSHCTL3_MASK) |
 			(bf_val << DDRC_RFSHCTL3_UPDATE_SHIFT);
 		mmio_write_32(DDRC_BASE_ADDR + OFFSET_DDRC_RFSHCTL3,
@@ -597,11 +645,12 @@ uint32_t enable_derating_temp_errata(void)
 		mmio_write_32(DDRC_BASE_ADDR + OFFSET_DDRC_SWCTL,
 			      DDRC_SWCTL_SWDONE_ENABLE);
 		do {
-			tmp32 = mmio_read_32(DDRC_BASE_ADDR +
+			tmp32 = mmio_read_32(DDRC_BASE_ADDR + 
 					     OFFSET_DDRC_SWSTAT);
 		} while ((tmp32 & DDRC_SWSTAT_SWDONE_ACK_MASK) != 0);
 
 		tmp32 = mmio_read_32(DDRC_BASE_ADDR + OFFSET_DDRC_DRAMTMG4);
+
 		/*
 		 * Set minimum time from activate to read/write command to same
 		 * bank: DRAMTMG4.T_RCD += 2
@@ -609,6 +658,7 @@ uint32_t enable_derating_temp_errata(void)
 		if (!update_bf(&tmp32, DDRC_DRAMTMG4_TRCD_POS,
 			       DDRC_DRAMTMG5_TRCD_MASK, 2))
 			return BITFIELD_EXCEEDED;
+
 		/*
 		 * Set minimum time between activates from bank "a" to bank "b"
 		 * DRAMTMG4.T_RRD += 2
@@ -616,6 +666,7 @@ uint32_t enable_derating_temp_errata(void)
 		if (!update_bf(&tmp32, DDRC_DRAMTMG4_TRRD_POS,
 			       DDRC_DRAMTMG5_TRRD_MASK, 2))
 			return BITFIELD_EXCEEDED;
+
 		mmio_write_32(DDRC_BASE_ADDR + OFFSET_DDRC_DRAMTMG4, tmp32);
 
 		/*
@@ -626,6 +677,7 @@ uint32_t enable_derating_temp_errata(void)
 		if (!update_bf(&tmp32, DDRC_DRAMTMG0_TRAS_POS,
 			       DDRC_DRAMTMG0_TRAS_MASK, 2))
 			return BITFIELD_EXCEEDED;
+
 		mmio_write_32(DDRC_BASE_ADDR + OFFSET_DDRC_DRAMTMG0, tmp32);
 
 		/*
@@ -636,6 +688,7 @@ uint32_t enable_derating_temp_errata(void)
 		if (!update_bf(&tmp32, DDRC_DRAMTMG4_TRP_POS,
 			       DDRC_DRAMTMG4_TRP_MASK, 2))
 			return BITFIELD_EXCEEDED;
+
 		mmio_write_32(DDRC_BASE_ADDR + OFFSET_DDRC_DRAMTMG4, tmp32);
 
 		/*
@@ -646,13 +699,14 @@ uint32_t enable_derating_temp_errata(void)
 		if (!update_bf(&tmp32, DDRC_DRAMTMG1_TRC_POS,
 			       DDRC_DRAMTMG1_TRC_MASK, 3))
 			return BITFIELD_EXCEEDED;
+
 		mmio_write_32(DDRC_BASE_ADDR + OFFSET_DDRC_DRAMTMG1, tmp32);
 
 		/* Set SWCTL.sw_done to 1 */
 		mmio_write_32(DDRC_BASE_ADDR + OFFSET_DDRC_SWCTL,
 			      DDRC_SWCTL_SWDONE_DONE);
 		do {
-			tmp32 = mmio_read_32(DDRC_BASE_ADDR +
+			tmp32 = mmio_read_32(DDRC_BASE_ADDR + 
 					     OFFSET_DDRC_SWSTAT);
 		} while ((tmp32 & DDRC_SWSTAT_SWDONE_ACK_MASK) == 0);
 
diff --git a/drivers/nxp/s32g/ddr/ddrc_cfg.c b/drivers/nxp/s32g/ddr/ddrc_cfg.c
index 1e6a2938b..b231ee7f8 100644
--- a/drivers/nxp/s32g/ddr/ddrc_cfg.c
+++ b/drivers/nxp/s32g/ddr/ddrc_cfg.c
@@ -31,150 +31,150 @@
 #include <ddr/ddr_init.h>
 
 struct regconf ddrc_cfg[] = {
-	{0x4007c604, 0x00000000},
-#ifdef S32GEN1_DRAM_INLINE_ECC
-	{0x4007c608, 0x37ffffff},
+	{0x4007c604, 0x00000000U},
+#if (S32G_DRAM_INLINE_ECC == 1)
+	{0x4007c608, 0x37ffffffU},
 #else
-	{0x4007c608, 0x00000000},
+	{0x4007c608, 0x00000000U},
 #endif
-	{0x403c0000, 0x83080020},
-	{0x403c0010, 0x00000030},
-	{0x403c0014, 0x00000000},
-	{0x403c001c, 0x00000000},
-	{0x403c0020, 0x00000202},
-	{0x403c0024, 0x01457080},
-	{0x403c002c, 0x00000001},
-	{0x403c0030, 0x00000020},
-	{0x403c0034, 0x00402010},
-	{0x403c0038, 0x00000000},
-	{0x403c0050, 0x00210070},
-	{0x403c0054, 0x00000000},
-	{0x403c0060, 0x00000000},
-	{0x403c0064, 0x005100bb},
-	{0x403c0068, 0x008c0000},
-#ifdef S32GEN1_DRAM_INLINE_ECC
-	{0x403c0070, 0x033f7f54},
-	{0x403c0074, 0x00000780},
+	{0x403c0000, 0x83080020U},
+	{0x403c0010, 0x00000030U},
+	{0x403c0014, 0x00000000U},
+	{0x403c001c, 0x00000000U},
+	{0x403c0020, 0x00000202U},
+	{0x403c0024, 0x01457080U},
+	{0x403c002c, 0x00000001U},
+	{0x403c0030, 0x00000020U},
+	{0x403c0034, 0x00402010U},
+	{0x403c0038, 0x00000000U},
+	{0x403c0050, 0x00210000U},
+	{0x403c0054, 0x00000000U},
+	{0x403c0060, 0x00000000U},
+	{0x403c0064, 0x005100bbU},
+	{0x403c0068, 0x008c0000U},
+#if (S32G_DRAM_INLINE_ECC == 1)
+	{0x403c0070, 0x033f7f54U},
+	{0x403c0074, 0x00000780U},
 #else
-	{0x403c0070, 0x033f7f40},
-	{0x403c0074, 0x000007b0},
+	{0x403c0070, 0x033f7f40U},
+	{0x403c0074, 0x000007b0U},
 #endif
-	{0x403c007c, 0x00000700},
-	{0x403c00b8, 0x00000000},
-	{0x403c00bc, 0x00000000},
-	{0x403c00c0, 0x00000000},
-	{0x403c00c4, 0x00001000},
-	{0x403c00d0, 0xc0030517},
-	{0x403c00d4, 0x00840000},
-	{0x403c00d8, 0x00000d05},
-	{0x403c00dc, 0x0054002d},
-	{0x403c00e0, 0x00330008},
-	{0x403c00e4, 0x00100004},
-	{0x403c00e8, 0x0066004d},
-	{0x403c00ec, 0x0006004f},
-	{0x403c00f0, 0x00000000},
-	{0x403c00f4, 0x00000779},
-	{0x403c0100, 0x181b161c},
-	{0x403c0104, 0x0005052a},
-	{0x403c0108, 0x070e1516},
-	{0x403c010c, 0x00a0a000},
-	{0x403c0110, 0x0c04070c},
-	{0x403c0114, 0x02040a0a},
-	{0x403c0118, 0x01010006},
-	{0x403c011c, 0x00000401},
-	{0x403c0120, 0x03034405},
-	{0x403c0124, 0x0004040d},
-	{0x403c0128, 0x001c180a},
-	{0x403c012c, 0x440c021c},
-	{0x403c0130, 0x00020000},
-	{0x403c0134, 0x0c100002},
-	{0x403c0138, 0x000000c0},
-	{0x403c013c, 0x00000000},
-	{0x403c0180, 0xc29b0014},
-	{0x403c0184, 0x0220515d},
-	{0x403c0188, 0x00000000},
-	{0x403c0190, 0x0497820a},
-	{0x403c0194, 0x00080303},
-	{0x403c0198, 0x07000000},
-	{0x403c019c, 0x00000000},
-	{0x403c01a0, 0xe0400018},
-	{0x403c01a4, 0x00df00e4},
-	{0x403c01a8, 0x80000000},
-	{0x403c01b0, 0x00000051},
-	{0x403c01b4, 0x0000170a},
-	{0x403c01b8, 0x00000000},
-	{0x403c01c0, 0x00000001},
-	{0x403c01c4, 0x00000001},
-#ifdef S32GEN1_DRAM_INLINE_ECC
-	{0x403c0200, 0x00000014},
-	{0x403c0204, 0x00050505},
+	{0x403c007c, 0x00000700U},
+	{0x403c00b8, 0x00000000U},
+	{0x403c00bc, 0x00000000U},
+	{0x403c00c0, 0x00000000U},
+	{0x403c00c4, 0x00001000U},
+	{0x403c00d0, 0xc0030517U},
+	{0x403c00d4, 0x00840000U},
+	{0x403c00d8, 0x00000d05U},
+	{0x403c00dc, 0x0054002dU},
+	{0x403c00e0, 0x00330008U},
+	{0x403c00e4, 0x00100004U},
+	{0x403c00e8, 0x0066004dU},
+	{0x403c00ec, 0x0004004fU},
+	{0x403c00f0, 0x00000000U},
+	{0x403c00f4, 0x00000779U},
+	{0x403c0100, 0x181b161cU},
+	{0x403c0104, 0x0005052aU},
+	{0x403c0108, 0x070e1516U},
+	{0x403c010c, 0x00a0a000U},
+	{0x403c0110, 0x0c04070cU},
+	{0x403c0114, 0x02040a0aU},
+	{0x403c0118, 0x01010006U},
+	{0x403c011c, 0x00000401U},
+	{0x403c0120, 0x03034405U},
+	{0x403c0124, 0x0004040dU},
+	{0x403c0128, 0x001c180aU},
+	{0x403c012c, 0x440c021cU},
+	{0x403c0130, 0x00020000U},
+	{0x403c0134, 0x0c100002U},
+	{0x403c0138, 0x000000c0U},
+	{0x403c013c, 0x00000000U},
+	{0x403c0180, 0x029b0014U},
+	{0x403c0184, 0x0220515dU},
+	{0x403c0188, 0x00000000U},
+	{0x403c0190, 0x0497820aU},
+	{0x403c0194, 0x00080303U},
+	{0x403c0198, 0x07000000U},
+	{0x403c019c, 0x00000000U},
+	{0x403c01a0, 0xe0400018U},
+	{0x403c01a4, 0x00df00e4U},
+	{0x403c01a8, 0x80000000U},
+	{0x403c01b0, 0x00000051U},
+	{0x403c01b4, 0x0000170aU},
+	{0x403c01b8, 0x00000000U},
+	{0x403c01c0, 0x00000001U},
+	{0x403c01c4, 0x00000001U},
+#if (S32G_DRAM_INLINE_ECC == 1)
+	{0x403c0200, 0x00000014U},
+	{0x403c0204, 0x00050505U},
 #else
-	{0x403c0200, 0x00000017},
-	{0x403c0204, 0x00080808},
+	{0x403c0200, 0x00000017U},
+	{0x403c0204, 0x00080808U},
 #endif
-	{0x403c0208, 0x00000000},
-#ifdef S32GEN1_DRAM_INLINE_ECC
-	{0x403c020c, 0x14141400},
+	{0x403c0208, 0x00000000U},
+#if (S32G_DRAM_INLINE_ECC == 1)
+	{0x403c020c, 0x14141400U},
 #else
-	{0x403c020c, 0x00000000},
+	{0x403c020c, 0x00000000U},
 #endif
-	{0x403c0210, 0x00001f1f},
-#ifdef S32GEN1_DRAM_INLINE_ECC
-	{0x403c0214, 0x04040404},
-	{0x403c0218, 0x04040404},
+	{0x403c0210, 0x00001f1fU},
+#if (S32G_DRAM_INLINE_ECC == 1)
+	{0x403c0214, 0x04040404U},
+	{0x403c0218, 0x04040404U},
 #else
-	{0x403c0214, 0x07070707},
-	{0x403c0218, 0x07070707},
+	{0x403c0214, 0x07070707U},
+	{0x403c0218, 0x07070707U},
 #endif
-	{0x403c021c, 0x0000000f},
-	{0x403c0220, 0x00003f3f},
-	{0x403c0224, 0x00000000},
-	{0x403c0228, 0x00000000},
-	{0x403c022c, 0x00000000},
-	{0x403c0240, 0x04000400},
-	{0x403c0244, 0x00000000},
-	{0x403c0250, 0x29001505},
-	{0x403c0254, 0x0000002c},
-	{0x403c025c, 0x5900575b},
-	{0x403c0264, 0x90000096},
-	{0x403c026c, 0x1000012c},
-	{0x403c0300, 0x00000000},
-	{0x403c0304, 0x00000000},
-	{0x403c030c, 0x00000000},
-	{0x403c0320, 0x00000001},
-	{0x403c0330, 0x00b03033},
-	{0x403c0334, 0x00000000},
-	{0x403c036c, 0x00000011},
-	{0x403c0374, 0x00000000},
-	{0x403c037c, 0x00000000},
-	{0x403c0384, 0x00000000},
-	{0x403c03c0, 0x00000003},
-	{0x403c03e0, 0x00010001},
-	{0x403c03e8, 0x00010001},
-	{0x403c0400, 0x00000111},
-	{0x403c0404, 0x000010f3},
-	{0x403c0408, 0x000072ff},
-	{0x403c0490, 0x00000000},
-	{0x403c0494, 0x00000e00},
-	{0x403c0498, 0x006207ff},
-	{0x403c049c, 0x01010e07},
-	{0x403c04a0, 0x034b07ff},
-	{0x403c04b4, 0x00000000},
-	{0x403c04b8, 0x00004000},
-	{0x403c0540, 0x00000000},
-	{0x403c0544, 0x02000e00},
-	{0x403c0548, 0x00000000},
-	{0x403c054c, 0x00000e00},
-	{0x403c0550, 0x00000000},
-	{0x403c0564, 0x00000000},
-	{0x403c0568, 0x00004000},
-	{0x403c05f0, 0x00000000},
-	{0x403c05f4, 0x02000e00},
-	{0x403c05f8, 0x00000000},
-	{0x403c05fc, 0x00000e00},
-	{0x403c0600, 0x00000000},
-	{0x403c0f24, 0x0000ff10},
-	{0x403c0f2c, 0x00000000},
+	{0x403c021c, 0x0000000fU},
+	{0x403c0220, 0x00003f3fU},
+	{0x403c0224, 0x00000000U},
+	{0x403c0228, 0x00000000U},
+	{0x403c022c, 0x00000000U},
+	{0x403c0240, 0x04000400U},
+	{0x403c0244, 0x00000000U},
+	{0x403c0250, 0x29001505U},
+	{0x403c0254, 0x00000000U},
+	{0x403c025c, 0x5900575bU},
+	{0x403c0264, 0x90000096U},
+	{0x403c026c, 0x1000012cU},
+	{0x403c0300, 0x00000000U},
+	{0x403c0304, 0x00000000U},
+	{0x403c030c, 0x00000000U},
+	{0x403c0320, 0x00000001U},
+	{0x403c0330, 0x00b03033U},
+	{0x403c0334, 0x00000000U},
+	{0x403c036c, 0x00000011U},
+	{0x403c0374, 0x00000000U},
+	{0x403c037c, 0x00000000U},
+	{0x403c0384, 0x00000000U},
+	{0x403c03c0, 0x00000003U},
+	{0x403c03e0, 0x00010001U},
+	{0x403c03e8, 0x00010001U},
+	{0x403c0400, 0x00000011U},
+	{0x403c0404, 0x000010f3U},
+	{0x403c0408, 0x000072ffU},
+	{0x403c0490, 0x00000000U},
+	{0x403c0494, 0x00000e00U},
+	{0x403c0498, 0x006207ffU},
+	{0x403c049c, 0x01010e07U},
+	{0x403c04a0, 0x034b07ffU},
+	{0x403c04b4, 0x00000000U},
+	{0x403c04b8, 0x00004000U},
+	{0x403c0540, 0x00000000U},
+	{0x403c0544, 0x02000e00U},
+	{0x403c0548, 0x00000000U},
+	{0x403c054c, 0x00000e00U},
+	{0x403c0550, 0x00000000U},
+	{0x403c0564, 0x00000000U},
+	{0x403c0568, 0x00004000U},
+	{0x403c05f0, 0x00000000U},
+	{0x403c05f4, 0x02000e00U},
+	{0x403c05f8, 0x00000000U},
+	{0x403c05fc, 0x00000e00U},
+	{0x403c0600, 0x00000000U},
+	{0x403c0f24, 0x0000ff10U},
+	{0x403c0f2c, 0x00000000U},
 };
 
-size_t ddrc_cfg_size = sizeof(ddrc_cfg) / sizeof(struct regconf);
+size_t ddrc_cfg_size = ARRAY_SIZE(ddrc_cfg);
diff --git a/drivers/nxp/s32g/ddr/ddrss.c b/drivers/nxp/s32g/ddr/ddrss.c
deleted file mode 100644
index 798dca289..000000000
--- a/drivers/nxp/s32g/ddr/ddrss.c
+++ /dev/null
@@ -1,598 +0,0 @@
-/*
- * Copyright 2019-2021 NXP
- *
- * SPDX-License-Identifier: BSD-3-Clause
- */
-#include <common/debug.h>
-#include <ddr/ddr_utils.h>
-#include <ddr/ddr_utils.h>
-#include <lib/utils_def.h>
-#include <nxp/s32g/ddr/ddrss.h>
-#include <platform.h>
-#include <s32g_mc_rgm.h>
-#include <ssram_mailbox.h>
-#include <stdbool.h>
-
-#define OFFSET_DDRC_PSTAT		0x4
-#define SCRUB_EN_MASK			BIT(0)
-#define SCRUB_BUSY_MASK			BIT(0)
-#define OFFSET_DDRC_INIT0		0xd0
-#define SELFREF_SW_MASK			BIT(5)
-#define SELFREF_TYPE_MASK		(BIT(4) | BIT(5))
-#define OPERATING_MODE_MASK		(BIT(0) | BIT(1) | BIT(2))
-#define DFI_INIT_COMPLETE_MASK		BIT(0)
-#define DFI_INIT_START_MASK		BIT(5)
-#define DDRSS_BASE_ADDR			0x40380000
-#define DDR_SUBSYSTEM			(DDRSS_BASE_ADDR + 0x50000)
-#define DWC_DDRPHYA_APBONLY0		(DDRSS_BASE_ADDR + 0x400)
-#define MICROCONTMUXSEL			(DWC_DDRPHYA_APBONLY0 + 0x0)
-#define MICROCONTMUXSEL_MASK		BIT(0)
-#define SW_DONE_ACK_MASK		BIT(0)
-#define SW_DONE_MASK			BIT(0)
-#define SKIP_DRAM_INIT_MASK		(BIT(30) | BIT(31))
-#define DWC_DDRPHYA_DRTUB0		(DDRSS_BASE_ADDR + 0xbd0)
-#define UCCLKHCLKENABLES		(DWC_DDRPHYA_DRTUB0 + 0x1c)
-#define UCCLKEN_MASK			BIT(0)
-#define HCLKEN_MASK			BIT(1)
-#define DDR_GPR				(0x4007c600ul)
-#define DDR_CONFIG_0			(DDR_GPR + 0x00)
-#define DDR_RET_CONTROL			(DDR_GPR + 0x1c)
-#define DDR_RET_CONTROL_MASK		BIT(0)
-#define DDR_CONFIG_0_MEM_RET		BIT(14)
-#define DFI_FREQUENCY(f)		((f) << 8)
-#define SELFREF_STATE_SRPD		(0x2 << 8)
-#define SELFREF_STATE_MASK		(BIT(8) | BIT(9))
-#define SELFREF_TYPE_NOT_UNDER_AUTO_SR_CTRL	(0x2 << 4)
-#define OPERATING_MODE_SELF_REFRESH	(0x3)
-
-/* ECC registers */
-#define    OFFSET_DDRC_ECCCTL               0x7c
-#define    OFFSET_DDRC_ECCPOISONADDR0       0xB8
-#define    OFFSET_DDRC_ECCPOISONADDR1       0xBc
-#define    OFFSET_DDRC_ADDRMAP0             0x200
-#define    OFFSET_DDRC_ADDRMAP1             0x204
-#define    OFFSET_DDRC_ADDRMAP2             0x208
-#define    OFFSET_DDRC_ADDRMAP3             0x20C
-#define    OFFSET_DDRC_ADDRMAP4             0x210
-#define    OFFSET_DDRC_ADDRMAP5             0x214
-#define    OFFSET_DDRC_ADDRMAP6             0x218
-#define    OFFSET_DDRC_ADDRMAP7             0x21C
-
-#define CSR_MEM_SIZE	(ARRAY_SIZE(csr_to_store) * sizeof(uint16_t))
-#define ECC_OFFSET	CSR_MEM_SIZE
-#define ECC_MEM_SIZE	(ARRAY_SIZE(ecc_to_store) * sizeof(uint32_t))
-
-static const uint32_t csr_to_store[] = {
-	0x00001690,	/* DWC_DDRPHYA_MASTER0_VREFINGLOBAL_P0 */
-	0x00001718,	/* DWC_DDRPHYA_MASTER0_PLLCTRL3 */
-	0x0001451c,	/* DWC_DDRPHYA_DBYTE0_DQDQSRCVCNTRL_B0_P0 */
-	0x0001651c,	/* DWC_DDRPHYA_DBYTE1_DQDQSRCVCNTRL_B0_P0 */
-	0x0001851c,	/* DWC_DDRPHYA_DBYTE2_DQDQSRCVCNTRL_B0_P0 */
-	0x0001a51c,	/* DWC_DDRPHYA_DBYTE3_DQDQSRCVCNTRL_B0_P0 */
-	0x00014520,	/* DWC_DDRPHYA_DBYTE0_DQDQSRCVCNTRL_B1_P0 */
-	0x00016520,	/* DWC_DDRPHYA_DBYTE1_DQDQSRCVCNTRL_B1_P0 */
-	0x00018520,	/* DWC_DDRPHYA_DBYTE2_DQDQSRCVCNTRL_B1_P0 */
-	0x0001a520,	/* DWC_DDRPHYA_DBYTE3_DQDQSRCVCNTRL_B1_P0 */
-	0x000003f0,	/* DWC_DDRPHYA_ANIB0_ATXDLY_P0 */
-	0x000023f0,	/* DWC_DDRPHYA_ANIB1_ATXDLY_P0 */
-	0x000043f0,	/* DWC_DDRPHYA_ANIB2_ATXDLY_P0 */
-	0x000063f0,	/* DWC_DDRPHYA_ANIB3_ATXDLY_P0 */
-	0x000146b0,	/* DWC_DDRPHYA_DBYTE0_RXENDLYTG0_U0_P0 */
-	0x000166b0,	/* DWC_DDRPHYA_DBYTE1_RXENDLYTG0_U0_P0 */
-	0x000186b0,	/* DWC_DDRPHYA_DBYTE2_RXENDLYTG0_U0_P0 */
-	0x0001a6b0,	/* DWC_DDRPHYA_DBYTE3_RXENDLYTG0_U0_P0 */
-	0x000146b4,	/* DWC_DDRPHYA_DBYTE0_RXENDLYTG0_U1_P0 */
-	0x000166b4,	/* DWC_DDRPHYA_DBYTE1_RXENDLYTG0_U1_P0 */
-	0x000186b4,	/* DWC_DDRPHYA_DBYTE2_RXENDLYTG0_U1_P0 */
-	0x0001a6b4,	/* DWC_DDRPHYA_DBYTE3_RXENDLYTG0_U1_P0 */
-	0x000146d0,	/* DWC_DDRPHYA_DBYTE0_RXENDLYTG1_U0_P0 */
-	0x000166d0,	/* DWC_DDRPHYA_DBYTE1_RXENDLYTG1_U0_P0 */
-	0x000186d0,	/* DWC_DDRPHYA_DBYTE2_RXENDLYTG1_U0_P0 */
-	0x0001a6d0,	/* DWC_DDRPHYA_DBYTE3_RXENDLYTG1_U0_P0 */
-	0x000146d4,	/* DWC_DDRPHYA_DBYTE0_RXENDLYTG1_U1_P0 */
-	0x000166d4,	/* DWC_DDRPHYA_DBYTE1_RXENDLYTG1_U1_P0 */
-	0x000186d4,	/* DWC_DDRPHYA_DBYTE2_RXENDLYTG1_U1_P0 */
-	0x0001a6d4,	/* DWC_DDRPHYA_DBYTE3_RXENDLYTG1_U1_P0 */
-	0x00014b50,	/* DWC_DDRPHYA_DBYTE0_TXDQSDLYTG0_U1_P0 */
-	0x00016b50,	/* DWC_DDRPHYA_DBYTE1_TXDQSDLYTG0_U1_P0 */
-	0x00018b50,	/* DWC_DDRPHYA_DBYTE2_TXDQSDLYTG0_U1_P0 */
-	0x0001ab50,	/* DWC_DDRPHYA_DBYTE3_TXDQSDLYTG0_U1_P0 */
-	0x00014b4c,	/* DWC_DDRPHYA_DBYTE0_TXDQSDLYTG0_U0_P0 */
-	0x00016b4c,	/* DWC_DDRPHYA_DBYTE1_TXDQSDLYTG0_U0_P0 */
-	0x00018b4c,	/* DWC_DDRPHYA_DBYTE2_TXDQSDLYTG0_U0_P0 */
-	0x0001ab4c,	/* DWC_DDRPHYA_DBYTE3_TXDQSDLYTG0_U0_P0 */
-	0x00014b70,	/* DWC_DDRPHYA_DBYTE0_TXDQSDLYTG1_U1_P0 */
-	0x00016b70,	/* DWC_DDRPHYA_DBYTE1_TXDQSDLYTG1_U1_P0 */
-	0x00018b70,	/* DWC_DDRPHYA_DBYTE2_TXDQSDLYTG1_U1_P0 */
-	0x0001ab70,	/* DWC_DDRPHYA_DBYTE3_TXDQSDLYTG1_U1_P0 */
-	0x00014b6c,	/* DWC_DDRPHYA_DBYTE0_TXDQSDLYTG1_U0_P0 */
-	0x00016b6c,	/* DWC_DDRPHYA_DBYTE1_TXDQSDLYTG1_U0_P0 */
-	0x00018b6c,	/* DWC_DDRPHYA_DBYTE2_TXDQSDLYTG1_U0_P0 */
-	0x0001ab6c,	/* DWC_DDRPHYA_DBYTE3_TXDQSDLYTG1_U0_P0 */
-	0x00014640,	/* DWC_DDRPHYA_DBYTE0_RXPBDLYTG0_R8 */
-	0x00016640,	/* DWC_DDRPHYA_DBYTE1_RXPBDLYTG0_R8 */
-	0x00018640,	/* DWC_DDRPHYA_DBYTE2_RXPBDLYTG0_R8 */
-	0x0001a640,	/* DWC_DDRPHYA_DBYTE3_RXPBDLYTG0_R8 */
-	0x0001463c,	/* DWC_DDRPHYA_DBYTE0_RXPBDLYTG0_R7 */
-	0x0001663c,	/* DWC_DDRPHYA_DBYTE1_RXPBDLYTG0_R7 */
-	0x0001863c,	/* DWC_DDRPHYA_DBYTE2_RXPBDLYTG0_R7 */
-	0x0001a63c,	/* DWC_DDRPHYA_DBYTE3_RXPBDLYTG0_R7 */
-	0x00014638,	/* DWC_DDRPHYA_DBYTE0_RXPBDLYTG0_R6 */
-	0x00016638,	/* DWC_DDRPHYA_DBYTE1_RXPBDLYTG0_R6 */
-	0x00018638,	/* DWC_DDRPHYA_DBYTE2_RXPBDLYTG0_R6 */
-	0x0001a638,	/* DWC_DDRPHYA_DBYTE3_RXPBDLYTG0_R6 */
-	0x00014634,	/* DWC_DDRPHYA_DBYTE0_RXPBDLYTG0_R5 */
-	0x00016634,	/* DWC_DDRPHYA_DBYTE1_RXPBDLYTG0_R5 */
-	0x00018634,	/* DWC_DDRPHYA_DBYTE2_RXPBDLYTG0_R5 */
-	0x0001a634,	/* DWC_DDRPHYA_DBYTE3_RXPBDLYTG0_R5 */
-	0x00014630,	/* DWC_DDRPHYA_DBYTE0_RXPBDLYTG0_R4 */
-	0x00016630,	/* DWC_DDRPHYA_DBYTE1_RXPBDLYTG0_R4 */
-	0x00018630,	/* DWC_DDRPHYA_DBYTE2_RXPBDLYTG0_R4 */
-	0x0001a630,	/* DWC_DDRPHYA_DBYTE3_RXPBDLYTG0_R4 */
-	0x0001462c,	/* DWC_DDRPHYA_DBYTE0_RXPBDLYTG0_R3 */
-	0x0001662c,	/* DWC_DDRPHYA_DBYTE1_RXPBDLYTG0_R3 */
-	0x0001862c,	/* DWC_DDRPHYA_DBYTE2_RXPBDLYTG0_R3 */
-	0x0001a62c,	/* DWC_DDRPHYA_DBYTE3_RXPBDLYTG0_R3 */
-	0x00014628,	/* DWC_DDRPHYA_DBYTE0_RXPBDLYTG0_R2 */
-	0x00016628,	/* DWC_DDRPHYA_DBYTE1_RXPBDLYTG0_R2 */
-	0x00018628,	/* DWC_DDRPHYA_DBYTE2_RXPBDLYTG0_R2 */
-	0x0001a628,	/* DWC_DDRPHYA_DBYTE3_RXPBDLYTG0_R2 */
-	0x00014624,	/* DWC_DDRPHYA_DBYTE0_RXPBDLYTG0_R1 */
-	0x00016624,	/* DWC_DDRPHYA_DBYTE1_RXPBDLYTG0_R1 */
-	0x00018624,	/* DWC_DDRPHYA_DBYTE2_RXPBDLYTG0_R1 */
-	0x0001a624,	/* DWC_DDRPHYA_DBYTE3_RXPBDLYTG0_R1 */
-	0x00014620,	/* DWC_DDRPHYA_DBYTE0_RXPBDLYTG0_R0 */
-	0x00016620,	/* DWC_DDRPHYA_DBYTE1_RXPBDLYTG0_R0 */
-	0x00018620,	/* DWC_DDRPHYA_DBYTE2_RXPBDLYTG0_R0 */
-	0x0001a620,	/* DWC_DDRPHYA_DBYTE3_RXPBDLYTG0_R0 */
-	0x00014664,	/* DWC_DDRPHYA_DBYTE0_RXPBDLYTG1_R8 */
-	0x00016664,	/* DWC_DDRPHYA_DBYTE1_RXPBDLYTG1_R8 */
-	0x00018664,	/* DWC_DDRPHYA_DBYTE2_RXPBDLYTG1_R8 */
-	0x0001a664,	/* DWC_DDRPHYA_DBYTE3_RXPBDLYTG1_R8 */
-	0x00014660,	/* DWC_DDRPHYA_DBYTE0_RXPBDLYTG1_R7 */
-	0x00016660,	/* DWC_DDRPHYA_DBYTE1_RXPBDLYTG1_R7 */
-	0x00018660,	/* DWC_DDRPHYA_DBYTE2_RXPBDLYTG1_R7 */
-	0x0001a660,	/* DWC_DDRPHYA_DBYTE3_RXPBDLYTG1_R7 */
-	0x0001465c,	/* DWC_DDRPHYA_DBYTE0_RXPBDLYTG1_R6 */
-	0x0001665c,	/* DWC_DDRPHYA_DBYTE1_RXPBDLYTG1_R6 */
-	0x0001865c,	/* DWC_DDRPHYA_DBYTE2_RXPBDLYTG1_R6 */
-	0x0001a65c,	/* DWC_DDRPHYA_DBYTE3_RXPBDLYTG1_R6 */
-	0x00014658,	/* DWC_DDRPHYA_DBYTE0_RXPBDLYTG1_R5 */
-	0x00016658,	/* DWC_DDRPHYA_DBYTE1_RXPBDLYTG1_R5 */
-	0x00018658,	/* DWC_DDRPHYA_DBYTE2_RXPBDLYTG1_R5 */
-	0x0001a658,	/* DWC_DDRPHYA_DBYTE3_RXPBDLYTG1_R5 */
-	0x00014654,	/* DWC_DDRPHYA_DBYTE0_RXPBDLYTG1_R4 */
-	0x00016654,	/* DWC_DDRPHYA_DBYTE1_RXPBDLYTG1_R4 */
-	0x00018654,	/* DWC_DDRPHYA_DBYTE2_RXPBDLYTG1_R4 */
-	0x0001a654,	/* DWC_DDRPHYA_DBYTE3_RXPBDLYTG1_R4 */
-	0x00014650,	/* DWC_DDRPHYA_DBYTE0_RXPBDLYTG1_R3 */
-	0x00016650,	/* DWC_DDRPHYA_DBYTE1_RXPBDLYTG1_R3 */
-	0x00018650,	/* DWC_DDRPHYA_DBYTE2_RXPBDLYTG1_R3 */
-	0x0001a650,	/* DWC_DDRPHYA_DBYTE3_RXPBDLYTG1_R3 */
-	0x0001464c,	/* DWC_DDRPHYA_DBYTE0_RXPBDLYTG1_R2 */
-	0x0001664c,	/* DWC_DDRPHYA_DBYTE1_RXPBDLYTG1_R2 */
-	0x0001864c,	/* DWC_DDRPHYA_DBYTE2_RXPBDLYTG1_R2 */
-	0x0001a64c,	/* DWC_DDRPHYA_DBYTE3_RXPBDLYTG1_R2 */
-	0x00014648,	/* DWC_DDRPHYA_DBYTE0_RXPBDLYTG1_R1 */
-	0x00016648,	/* DWC_DDRPHYA_DBYTE1_RXPBDLYTG1_R1 */
-	0x00018648,	/* DWC_DDRPHYA_DBYTE2_RXPBDLYTG1_R1 */
-	0x0001a648,	/* DWC_DDRPHYA_DBYTE3_RXPBDLYTG1_R1 */
-	0x00014644,	/* DWC_DDRPHYA_DBYTE0_RXPBDLYTG1_R0 */
-	0x00016644,	/* DWC_DDRPHYA_DBYTE1_RXPBDLYTG1_R0 */
-	0x00018644,	/* DWC_DDRPHYA_DBYTE2_RXPBDLYTG1_R0 */
-	0x0001a644,	/* DWC_DDRPHYA_DBYTE3_RXPBDLYTG1_R0 */
-	0x00014730,	/* DWC_DDRPHYA_DBYTE0_RXCLKDLYTG0_U0_P0 */
-	0x00016730,	/* DWC_DDRPHYA_DBYTE1_RXCLKDLYTG0_U0_P0 */
-	0x00018730,	/* DWC_DDRPHYA_DBYTE2_RXCLKDLYTG0_U0_P0 */
-	0x0001a730,	/* DWC_DDRPHYA_DBYTE3_RXCLKDLYTG0_U0_P0 */
-	0x00014734,	/* DWC_DDRPHYA_DBYTE0_RXCLKDLYTG0_U1_P0 */
-	0x00016734,	/* DWC_DDRPHYA_DBYTE1_RXCLKDLYTG0_U1_P0 */
-	0x00018734,	/* DWC_DDRPHYA_DBYTE2_RXCLKDLYTG0_U1_P0 */
-	0x0001a734,	/* DWC_DDRPHYA_DBYTE3_RXCLKDLYTG0_U1_P0 */
-	0x00014750,	/* DWC_DDRPHYA_DBYTE0_RXCLKDLYTG1_U0_P0 */
-	0x00016750,	/* DWC_DDRPHYA_DBYTE1_RXCLKDLYTG1_U0_P0 */
-	0x00018750,	/* DWC_DDRPHYA_DBYTE2_RXCLKDLYTG1_U0_P0 */
-	0x0001a750,	/* DWC_DDRPHYA_DBYTE3_RXCLKDLYTG1_U0_P0 */
-	0x00014754,	/* DWC_DDRPHYA_DBYTE0_RXCLKDLYTG1_U1_P0 */
-	0x00016754,	/* DWC_DDRPHYA_DBYTE1_RXCLKDLYTG1_U1_P0 */
-	0x00018754,	/* DWC_DDRPHYA_DBYTE2_RXCLKDLYTG1_U1_P0 */
-	0x0001a754,	/* DWC_DDRPHYA_DBYTE3_RXCLKDLYTG1_U1_P0 */
-	0x0001492c,	/* DWC_DDRPHYA_DBYTE0_TXDQDLYTG0_R8_P0 */
-	0x0001692c,	/* DWC_DDRPHYA_DBYTE1_TXDQDLYTG0_R8_P0 */
-	0x0001892c,	/* DWC_DDRPHYA_DBYTE2_TXDQDLYTG0_R8_P0 */
-	0x0001a92c,	/* DWC_DDRPHYA_DBYTE3_TXDQDLYTG0_R8_P0 */
-	0x00014928,	/* DWC_DDRPHYA_DBYTE0_TXDQDLYTG0_R7_P0 */
-	0x00016928,	/* DWC_DDRPHYA_DBYTE1_TXDQDLYTG0_R7_P0 */
-	0x00018928,	/* DWC_DDRPHYA_DBYTE2_TXDQDLYTG0_R7_P0 */
-	0x0001a928,	/* DWC_DDRPHYA_DBYTE3_TXDQDLYTG0_R7_P0 */
-	0x00014924,	/* DWC_DDRPHYA_DBYTE0_TXDQDLYTG0_R6_P0 */
-	0x00016924,	/* DWC_DDRPHYA_DBYTE1_TXDQDLYTG0_R6_P0 */
-	0x00018924,	/* DWC_DDRPHYA_DBYTE2_TXDQDLYTG0_R6_P0 */
-	0x0001a924,	/* DWC_DDRPHYA_DBYTE3_TXDQDLYTG0_R6_P0 */
-	0x00014920,	/* DWC_DDRPHYA_DBYTE0_TXDQDLYTG0_R5_P0 */
-	0x00016920,	/* DWC_DDRPHYA_DBYTE1_TXDQDLYTG0_R5_P0 */
-	0x00018920,	/* DWC_DDRPHYA_DBYTE2_TXDQDLYTG0_R5_P0 */
-	0x0001a920,	/* DWC_DDRPHYA_DBYTE3_TXDQDLYTG0_R5_P0 */
-	0x0001491c,	/* DWC_DDRPHYA_DBYTE0_TXDQDLYTG0_R4_P0 */
-	0x0001691c,	/* DWC_DDRPHYA_DBYTE1_TXDQDLYTG0_R4_P0 */
-	0x0001891c,	/* DWC_DDRPHYA_DBYTE2_TXDQDLYTG0_R4_P0 */
-	0x0001a91c,	/* DWC_DDRPHYA_DBYTE3_TXDQDLYTG0_R4_P0 */
-	0x00014918,	/* DWC_DDRPHYA_DBYTE0_TXDQDLYTG0_R3_P0 */
-	0x00016918,	/* DWC_DDRPHYA_DBYTE1_TXDQDLYTG0_R3_P0 */
-	0x00018918,	/* DWC_DDRPHYA_DBYTE2_TXDQDLYTG0_R3_P0 */
-	0x0001a918,	/* DWC_DDRPHYA_DBYTE3_TXDQDLYTG0_R3_P0 */
-	0x00014914,	/* DWC_DDRPHYA_DBYTE0_TXDQDLYTG0_R2_P0 */
-	0x00016914,	/* DWC_DDRPHYA_DBYTE1_TXDQDLYTG0_R2_P0 */
-	0x00018914,	/* DWC_DDRPHYA_DBYTE2_TXDQDLYTG0_R2_P0 */
-	0x0001a914,	/* DWC_DDRPHYA_DBYTE3_TXDQDLYTG0_R2_P0 */
-	0x00014910,	/* DWC_DDRPHYA_DBYTE0_TXDQDLYTG0_R1_P0 */
-	0x00016910,	/* DWC_DDRPHYA_DBYTE1_TXDQDLYTG0_R1_P0 */
-	0x00018910,	/* DWC_DDRPHYA_DBYTE2_TXDQDLYTG0_R1_P0 */
-	0x0001a910,	/* DWC_DDRPHYA_DBYTE3_TXDQDLYTG0_R1_P0 */
-	0x0001490c,	/* DWC_DDRPHYA_DBYTE0_TXDQDLYTG0_R0_P0 */
-	0x0001690c,	/* DWC_DDRPHYA_DBYTE1_TXDQDLYTG0_R0_P0 */
-	0x0001890c,	/* DWC_DDRPHYA_DBYTE2_TXDQDLYTG0_R0_P0 */
-	0x0001a90c,	/* DWC_DDRPHYA_DBYTE3_TXDQDLYTG0_R0_P0 */
-	0x000149bc,	/* DWC_DDRPHYA_DBYTE0_TXDQDLYTG1_R8_P0 */
-	0x000169bc,	/* DWC_DDRPHYA_DBYTE1_TXDQDLYTG1_R8_P0 */
-	0x000189bc,	/* DWC_DDRPHYA_DBYTE2_TXDQDLYTG1_R8_P0 */
-	0x0001a9bc,	/* DWC_DDRPHYA_DBYTE3_TXDQDLYTG1_R8_P0 */
-	0x000149b8,	/* DWC_DDRPHYA_DBYTE0_TXDQDLYTG1_R7_P0 */
-	0x000169b8,	/* DWC_DDRPHYA_DBYTE1_TXDQDLYTG1_R7_P0 */
-	0x000189b8,	/* DWC_DDRPHYA_DBYTE2_TXDQDLYTG1_R7_P0 */
-	0x0001a9b8,	/* DWC_DDRPHYA_DBYTE3_TXDQDLYTG1_R7_P0 */
-	0x000149b4,	/* DWC_DDRPHYA_DBYTE0_TXDQDLYTG1_R6_P0 */
-	0x000169b4,	/* DWC_DDRPHYA_DBYTE1_TXDQDLYTG1_R6_P0 */
-	0x000189b4,	/* DWC_DDRPHYA_DBYTE2_TXDQDLYTG1_R6_P0 */
-	0x0001a9b4,	/* DWC_DDRPHYA_DBYTE3_TXDQDLYTG1_R6_P0 */
-	0x000149b0,	/* DWC_DDRPHYA_DBYTE0_TXDQDLYTG1_R5_P0 */
-	0x000169b0,	/* DWC_DDRPHYA_DBYTE1_TXDQDLYTG1_R5_P0 */
-	0x000189b0,	/* DWC_DDRPHYA_DBYTE2_TXDQDLYTG1_R5_P0 */
-	0x0001a9b0,	/* DWC_DDRPHYA_DBYTE3_TXDQDLYTG1_R5_P0 */
-	0x000149ac,	/* DWC_DDRPHYA_DBYTE0_TXDQDLYTG1_R4_P0 */
-	0x000169ac,	/* DWC_DDRPHYA_DBYTE1_TXDQDLYTG1_R4_P0 */
-	0x000189ac,	/* DWC_DDRPHYA_DBYTE2_TXDQDLYTG1_R4_P0 */
-	0x0001a9ac,	/* DWC_DDRPHYA_DBYTE3_TXDQDLYTG1_R4_P0 */
-	0x000149a8,	/* DWC_DDRPHYA_DBYTE0_TXDQDLYTG1_R3_P0 */
-	0x000169a8,	/* DWC_DDRPHYA_DBYTE1_TXDQDLYTG1_R3_P0 */
-	0x000189a8,	/* DWC_DDRPHYA_DBYTE2_TXDQDLYTG1_R3_P0 */
-	0x0001a9a8,	/* DWC_DDRPHYA_DBYTE3_TXDQDLYTG1_R3_P0 */
-	0x000149a4,	/* DWC_DDRPHYA_DBYTE0_TXDQDLYTG1_R2_P0 */
-	0x000169a4,	/* DWC_DDRPHYA_DBYTE1_TXDQDLYTG1_R2_P0 */
-	0x000189a4,	/* DWC_DDRPHYA_DBYTE2_TXDQDLYTG1_R2_P0 */
-	0x0001a9a4,	/* DWC_DDRPHYA_DBYTE3_TXDQDLYTG1_R2_P0 */
-	0x000149a0,	/* DWC_DDRPHYA_DBYTE0_TXDQDLYTG1_R1_P0 */
-	0x000169a0,	/* DWC_DDRPHYA_DBYTE1_TXDQDLYTG1_R1_P0 */
-	0x000189a0,	/* DWC_DDRPHYA_DBYTE2_TXDQDLYTG1_R1_P0 */
-	0x0001a9a0,	/* DWC_DDRPHYA_DBYTE3_TXDQDLYTG1_R1_P0 */
-	0x0001499c,	/* DWC_DDRPHYA_DBYTE0_TXDQDLYTG1_R0_P0 */
-	0x0001699c,	/* DWC_DDRPHYA_DBYTE1_TXDQDLYTG1_R0_P0 */
-	0x0001899c,	/* DWC_DDRPHYA_DBYTE2_TXDQDLYTG1_R0_P0 */
-	0x0001a99c,	/* DWC_DDRPHYA_DBYTE3_TXDQDLYTG1_R0_P0 */
-	0x0001446c,	/* DWC_DDRPHYA_DBYTE0_DFIMRL_P0 */
-	0x0001646c,	/* DWC_DDRPHYA_DBYTE1_DFIMRL_P0 */
-	0x0001846c,	/* DWC_DDRPHYA_DBYTE2_DFIMRL_P0 */
-	0x0001a46c,	/* DWC_DDRPHYA_DBYTE3_DFIMRL_P0 */
-	0x000015e0,	/* DWC_DDRPHYA_MASTER0_HWTLPCSENA */
-	0x000015e4,	/* DWC_DDRPHYA_MASTER0_HWTLPCSENB */
-	0x00014850,	/* DWC_DDRPHYA_DBYTE0_PPTCTLSTATIC */
-	0x00016850,	/* DWC_DDRPHYA_DBYTE1_PPTCTLSTATIC */
-	0x00018850,	/* DWC_DDRPHYA_DBYTE2_PPTCTLSTATIC */
-	0x0001a850,	/* DWC_DDRPHYA_DBYTE3_PPTCTLSTATIC */
-	0x00001374,	/* DWC_DDRPHYA_MASTER0_PPTTRAINSETUP_P0 */
-	0x00001388,	/* DWC_DDRPHYA_MASTER0_PPTTRAINSETUP2_P0 */
-	0x00014860,	/* DWC_DDRPHYA_DBYTE0_PPTDQSCNTINVTRNTG0_P0 */
-	0x00016860,	/* DWC_DDRPHYA_DBYTE1_PPTDQSCNTINVTRNTG0_P0 */
-	0x00018860,	/* DWC_DDRPHYA_DBYTE2_PPTDQSCNTINVTRNTG0_P0 */
-	0x0001a860,	/* DWC_DDRPHYA_DBYTE3_PPTDQSCNTINVTRNTG0_P0 */
-	0x00014870,	/* DWC_DDRPHYA_DBYTE0_PPTDQSCNTINVTRNTG1_P0 */
-	0x00016870,	/* DWC_DDRPHYA_DBYTE1_PPTDQSCNTINVTRNTG1_P0 */
-	0x00018870,	/* DWC_DDRPHYA_DBYTE2_PPTDQSCNTINVTRNTG1_P0 */
-	0x0001a870,	/* DWC_DDRPHYA_DBYTE3_PPTDQSCNTINVTRNTG1_P0 */
-	0x0000140c,	/* DWC_DDRPHYA_MASTER0_HWTMRL_P0 */
-	0x00001608,	/* DWC_DDRPHYA_MASTER0_DLLGAINCTL_P0 */
-	0x00001618,	/* DWC_DDRPHYA_MASTER0_DLLLOCKPARAM_P0 */
-	0x000003c8,	/* DWC_DDRPHYA_ACSM0_ACSMCTRL13 */
-	0x00000308,	/* DWC_DDRPHYA_ACSM0_ACSMCTRL23 */
-	0x00000c10,	/* DWC_DDRPHYA_INITENG0_SEQ0BGPR1_P0 */
-	0x00000c28,	/* DWC_DDRPHYA_INITENG0_SEQ0BGPR2_P0 */
-	0x00000c40,	/* DWC_DDRPHYA_INITENG0_SEQ0BGPR3_P0 */
-	0x00000c58,	/* DWC_DDRPHYA_INITENG0_SEQ0BGPR4_P0 */
-	0x00000c70,	/* DWC_DDRPHYA_INITENG0_SEQ0BGPR5_P0 */
-	0x00000c88,	/* DWC_DDRPHYA_INITENG0_SEQ0BGPR6_P0 */
-	0x00000ca0,	/* DWC_DDRPHYA_INITENG0_SEQ0BGPR7_P0 */
-	0x00000cb8,	/* DWC_DDRPHYA_INITENG0_SEQ0BGPR8_P0 */
-	0x000145fc,	/* DWC_DDRPHYA_DBYTE0_TRAININGINCDECDTSMEN_R0 */
-	0x000165fc,	/* DWC_DDRPHYA_DBYTE1_TRAININGINCDECDTSMEN_R0 */
-	0x000185fc,	/* DWC_DDRPHYA_DBYTE2_TRAININGINCDECDTSMEN_R0 */
-	0x0001a5fc,	/* DWC_DDRPHYA_DBYTE3_TRAININGINCDECDTSMEN_R0 */
-	0x00014600,	/* DWC_DDRPHYA_DBYTE0_TRAININGINCDECDTSMEN_R1 */
-	0x00016600,	/* DWC_DDRPHYA_DBYTE1_TRAININGINCDECDTSMEN_R1 */
-	0x00018600,	/* DWC_DDRPHYA_DBYTE2_TRAININGINCDECDTSMEN_R1 */
-	0x0001a600,	/* DWC_DDRPHYA_DBYTE3_TRAININGINCDECDTSMEN_R1 */
-	0x00014604,	/* DWC_DDRPHYA_DBYTE0_TRAININGINCDECDTSMEN_R2 */
-	0x00016604,	/* DWC_DDRPHYA_DBYTE1_TRAININGINCDECDTSMEN_R2 */
-	0x00018604,	/* DWC_DDRPHYA_DBYTE2_TRAININGINCDECDTSMEN_R2 */
-	0x0001a604,	/* DWC_DDRPHYA_DBYTE3_TRAININGINCDECDTSMEN_R2 */
-	0x00014608,	/* DWC_DDRPHYA_DBYTE0_TRAININGINCDECDTSMEN_R3 */
-	0x00016608,	/* DWC_DDRPHYA_DBYTE1_TRAININGINCDECDTSMEN_R3 */
-	0x00018608,	/* DWC_DDRPHYA_DBYTE2_TRAININGINCDECDTSMEN_R3 */
-	0x0001a608,	/* DWC_DDRPHYA_DBYTE3_TRAININGINCDECDTSMEN_R3 */
-	0x0001460c,	/* DWC_DDRPHYA_DBYTE0_TRAININGINCDECDTSMEN_R4 */
-	0x0001660c,	/* DWC_DDRPHYA_DBYTE1_TRAININGINCDECDTSMEN_R4 */
-	0x0001860c,	/* DWC_DDRPHYA_DBYTE2_TRAININGINCDECDTSMEN_R4 */
-	0x0001a60c,	/* DWC_DDRPHYA_DBYTE3_TRAININGINCDECDTSMEN_R4 */
-	0x00014610,	/* DWC_DDRPHYA_DBYTE0_TRAININGINCDECDTSMEN_R5 */
-	0x00016610,	/* DWC_DDRPHYA_DBYTE1_TRAININGINCDECDTSMEN_R5 */
-	0x00018610,	/* DWC_DDRPHYA_DBYTE2_TRAININGINCDECDTSMEN_R5 */
-	0x0001a610,	/* DWC_DDRPHYA_DBYTE3_TRAININGINCDECDTSMEN_R5 */
-	0x00014614,	/* DWC_DDRPHYA_DBYTE0_TRAININGINCDECDTSMEN_R6 */
-	0x00016614,	/* DWC_DDRPHYA_DBYTE1_TRAININGINCDECDTSMEN_R6 */
-	0x00018614,	/* DWC_DDRPHYA_DBYTE2_TRAININGINCDECDTSMEN_R6 */
-	0x0001a614,	/* DWC_DDRPHYA_DBYTE3_TRAININGINCDECDTSMEN_R6 */
-	0x00014618,	/* DWC_DDRPHYA_DBYTE0_TRAININGINCDECDTSMEN_R7 */
-	0x00016618,	/* DWC_DDRPHYA_DBYTE1_TRAININGINCDECDTSMEN_R7 */
-	0x00018618,	/* DWC_DDRPHYA_DBYTE2_TRAININGINCDECDTSMEN_R7 */
-	0x0001a618,	/* DWC_DDRPHYA_DBYTE3_TRAININGINCDECDTSMEN_R7 */
-	0x0001461c,	/* DWC_DDRPHYA_DBYTE0_TRAININGINCDECDTSMEN_R8 */
-	0x0001661c,	/* DWC_DDRPHYA_DBYTE1_TRAININGINCDECDTSMEN_R8 */
-	0x0001861c,	/* DWC_DDRPHYA_DBYTE2_TRAININGINCDECDTSMEN_R8 */
-	0x0001a61c,	/* DWC_DDRPHYA_DBYTE3_TRAININGINCDECDTSMEN_R8 */
-	0x000015f4,	/* DWC_DDRPHYA_MASTER0_HWTCAMODE */
-	0x00014430,	/* DWC_DDRPHYA_DBYTE0_TSMBYTE0 */
-	0x00016430,	/* DWC_DDRPHYA_DBYTE1_TSMBYTE0 */
-	0x00018430,	/* DWC_DDRPHYA_DBYTE2_TSMBYTE0 */
-	0x0001a430,	/* DWC_DDRPHYA_DBYTE3_TSMBYTE0 */
-	/* 2D training */
-	0x00014730,	/* DWC_DDRPHYA_DBYTE0_RXCLKDLYTG0_U0_P0 */
-	0x00016730,	/* DWC_DDRPHYA_DBYTE1_RXCLKDLYTG0_U0_P0 */
-	0x00018730,	/* DWC_DDRPHYA_DBYTE2_RXCLKDLYTG0_U0_P0 */
-	0x0001a730,	/* DWC_DDRPHYA_DBYTE3_RXCLKDLYTG0_U0_P0 */
-	0x00014734,	/* DWC_DDRPHYA_DBYTE0_RXCLKDLYTG0_U1_P0 */
-	0x00016734,	/* DWC_DDRPHYA_DBYTE1_RXCLKDLYTG0_U1_P0 */
-	0x00018734,	/* DWC_DDRPHYA_DBYTE2_RXCLKDLYTG0_U1_P0 */
-	0x0001a734,	/* DWC_DDRPHYA_DBYTE3_RXCLKDLYTG0_U1_P0 */
-	0x00014750,	/* DWC_DDRPHYA_DBYTE0_RXCLKDLYTG1_U0_P0 */
-	0x00016750,	/* DWC_DDRPHYA_DBYTE1_RXCLKDLYTG1_U0_P0 */
-	0x00018750,	/* DWC_DDRPHYA_DBYTE2_RXCLKDLYTG1_U0_P0 */
-	0x0001a750,	/* DWC_DDRPHYA_DBYTE3_RXCLKDLYTG1_U0_P0 */
-	0x00014754,	/* DWC_DDRPHYA_DBYTE0_RXCLKDLYTG1_U1_P0 */
-	0x00016754,	/* DWC_DDRPHYA_DBYTE1_RXCLKDLYTG1_U1_P0 */
-	0x00018754,	/* DWC_DDRPHYA_DBYTE2_RXCLKDLYTG1_U1_P0 */
-	0x0001a754,	/* DWC_DDRPHYA_DBYTE3_RXCLKDLYTG1_U1_P0 */
-	0x000144f8,	/* DWC_DDRPHYA_DBYTE0_VREFDAC0_R8 */
-	0x000164f8,	/* DWC_DDRPHYA_DBYTE1_VREFDAC0_R8 */
-	0x000184f8,	/* DWC_DDRPHYA_DBYTE2_VREFDAC0_R8 */
-	0x0001a4f8,	/* DWC_DDRPHYA_DBYTE3_VREFDAC0_R8 */
-	0x000144f4,	/* DWC_DDRPHYA_DBYTE0_VREFDAC0_R7 */
-	0x000164f4,	/* DWC_DDRPHYA_DBYTE1_VREFDAC0_R7 */
-	0x000184f4,	/* DWC_DDRPHYA_DBYTE2_VREFDAC0_R7 */
-	0x0001a4f4,	/* DWC_DDRPHYA_DBYTE3_VREFDAC0_R7 */
-	0x000144f0,	/* DWC_DDRPHYA_DBYTE0_VREFDAC0_R6 */
-	0x000164f0,	/* DWC_DDRPHYA_DBYTE1_VREFDAC0_R6 */
-	0x000184f0,	/* DWC_DDRPHYA_DBYTE2_VREFDAC0_R6 */
-	0x0001a4f0,	/* DWC_DDRPHYA_DBYTE3_VREFDAC0_R6 */
-	0x000144ec,	/* DWC_DDRPHYA_DBYTE0_VREFDAC0_R5 */
-	0x000164ec,	/* DWC_DDRPHYA_DBYTE1_VREFDAC0_R5 */
-	0x000184ec,	/* DWC_DDRPHYA_DBYTE2_VREFDAC0_R5 */
-	0x0001a4ec,	/* DWC_DDRPHYA_DBYTE3_VREFDAC0_R5 */
-	0x000144e8,	/* DWC_DDRPHYA_DBYTE0_VREFDAC0_R4 */
-	0x000164e8,	/* DWC_DDRPHYA_DBYTE1_VREFDAC0_R4 */
-	0x000184e8,	/* DWC_DDRPHYA_DBYTE2_VREFDAC0_R4 */
-	0x0001a4e8,	/* DWC_DDRPHYA_DBYTE3_VREFDAC0_R4 */
-	0x000144e4,	/* DWC_DDRPHYA_DBYTE0_VREFDAC0_R3 */
-	0x000164e4,	/* DWC_DDRPHYA_DBYTE1_VREFDAC0_R3 */
-	0x000184e4,	/* DWC_DDRPHYA_DBYTE2_VREFDAC0_R3 */
-	0x0001a4e4,	/* DWC_DDRPHYA_DBYTE3_VREFDAC0_R3 */
-	0x000144e0,	/* DWC_DDRPHYA_DBYTE0_VREFDAC0_R2 */
-	0x000164e0,	/* DWC_DDRPHYA_DBYTE1_VREFDAC0_R2 */
-	0x000184e0,	/* DWC_DDRPHYA_DBYTE2_VREFDAC0_R2 */
-	0x0001a4e0,	/* DWC_DDRPHYA_DBYTE3_VREFDAC0_R2 */
-	0x000144dc,	/* DWC_DDRPHYA_DBYTE0_VREFDAC0_R1 */
-	0x000164dc,	/* DWC_DDRPHYA_DBYTE1_VREFDAC0_R1 */
-	0x000184dc,	/* DWC_DDRPHYA_DBYTE2_VREFDAC0_R1 */
-	0x0001a4dc,	/* DWC_DDRPHYA_DBYTE3_VREFDAC0_R1 */
-	0x000144d8,	/* DWC_DDRPHYA_DBYTE0_VREFDAC0_R0 */
-	0x000164d8,	/* DWC_DDRPHYA_DBYTE1_VREFDAC0_R0 */
-	0x000184d8,	/* DWC_DDRPHYA_DBYTE2_VREFDAC0_R0 */
-	0x0001a4d8,	/* DWC_DDRPHYA_DBYTE3_VREFDAC0_R0 */
-};
-
-static const uint32_t ecc_to_store[] = {
-	DDRC_BASE_ADDR + OFFSET_DDRC_ECCCFG0,
-	DDRC_BASE_ADDR + OFFSET_DDRC_ECCCFG1,
-	DDRC_BASE_ADDR + OFFSET_DDRC_ECCCTL,
-	DDRC_BASE_ADDR + OFFSET_DDRC_ECCPOISONADDR0,
-	DDRC_BASE_ADDR + OFFSET_DDRC_ECCPOISONADDR1,
-	DDRC_BASE_ADDR + OFFSET_DDRC_ADDRMAP0,
-	DDRC_BASE_ADDR + OFFSET_DDRC_ADDRMAP1,
-	DDRC_BASE_ADDR + OFFSET_DDRC_ADDRMAP2,
-	DDRC_BASE_ADDR + OFFSET_DDRC_ADDRMAP3,
-	DDRC_BASE_ADDR + OFFSET_DDRC_ADDRMAP4,
-	DDRC_BASE_ADDR + OFFSET_DDRC_ADDRMAP5,
-	DDRC_BASE_ADDR + OFFSET_DDRC_ADDRMAP6,
-	DDRC_BASE_ADDR + OFFSET_DDRC_ADDRMAP7,
-};
-
-_Static_assert(CSR_MEM_SIZE + ECC_MEM_SIZE == BL31SSRAM_CSR_SIZE,
-	       "Please sync BL31SSRAM_CSR_SIZE with csr_to_store length");
-
-static void load_csr(uintptr_t load_from)
-{
-	int i;
-	uint16_t csr;
-
-	for (i = 0; i < ARRAY_SIZE(csr_to_store); i++) {
-		csr = mmio_read_16(load_from);
-		load_from += sizeof(uint16_t);
-		mmio_write_16(DDRSS_BASE_ADDR + csr_to_store[i], csr);
-	}
-}
-
-static void store_ecc(uintptr_t base)
-{
-	uintptr_t store_at = base + ECC_OFFSET;
-	uint32_t val;
-	int i;
-
-	for (i = 0; i < ARRAY_SIZE(ecc_to_store); i++) {
-		val = mmio_read_32(ecc_to_store[i]);
-		mmio_write_32(store_at, val);
-		store_at += sizeof(uint32_t);
-	}
-}
-
-void store_csr(uintptr_t store_at)
-{
-	int i;
-	uint16_t csr;
-	uintptr_t base = store_at;
-
-	mmio_write_16(MICROCONTMUXSEL, 0);
-	mmio_write_16(UCCLKHCLKENABLES, HCLKEN_MASK | UCCLKEN_MASK);
-
-	for (i = 0; i < ARRAY_SIZE(csr_to_store); i++) {
-		csr = mmio_read_16(DDRSS_BASE_ADDR + csr_to_store[i]);
-		mmio_write_16(store_at, csr);
-		store_at += sizeof(uint16_t);
-	}
-
-	mmio_write_16(UCCLKHCLKENABLES, HCLKEN_MASK);
-	mmio_write_16(MICROCONTMUXSEL, MICROCONTMUXSEL_MASK);
-
-	store_ecc(base);
-}
-
-static void load_ecc(uintptr_t base)
-{
-	uintptr_t load_from = base + ECC_OFFSET;
-	uint32_t val;
-	int i;
-
-	for (i = 0; i < ARRAY_SIZE(ecc_to_store); i++) {
-		val = mmio_read_32(load_from);
-		mmio_write_32(ecc_to_store[i], val);
-		load_from += sizeof(uint32_t);
-	}
-}
-
-void ddrss_to_io_lp3_retention_mode(void)
-{
-	uint32_t sbrctl, pwrctl, swctl, dfimisc;
-
-	/* Disable AXI Ports */
-	mmio_write_16(DDRC_UMCTL2_MP_BASE_ADDR + OFFSET_DDRC_PCTRL_0, 0);
-	mmio_write_16(DDRC_UMCTL2_MP_BASE_ADDR + OFFSET_DDRC_PCTRL_1, 0);
-	mmio_write_16(DDRC_UMCTL2_MP_BASE_ADDR + OFFSET_DDRC_PCTRL_2, 0);
-
-	while (mmio_read_32(DDRC_UMCTL2_MP_BASE_ADDR + OFFSET_DDRC_PSTAT))
-		;
-
-	/* Disable Scrubber */
-	sbrctl = mmio_read_32(DDRC_BASE_ADDR + OFFSET_DDRC_SBRCTL);
-	mmio_write_32(DDRC_BASE_ADDR + OFFSET_DDRC_SBRCTL,
-		      sbrctl & (~SCRUB_EN_MASK));
-	while (mmio_read_32(DDRC_BASE_ADDR + OFFSET_DDRC_SBRSTAT) &
-		SCRUB_BUSY_MASK)
-		;
-
-	/* Move to Self Refresh */
-	pwrctl = mmio_read_32(DDRC_BASE_ADDR + OFFSET_DDRC_PWRCTL);
-	mmio_write_32(DDRC_BASE_ADDR + OFFSET_DDRC_PWRCTL,
-		      pwrctl | SELFREF_SW_MASK);
-	while ((mmio_read_32(DDRC_BASE_ADDR + OFFSET_DDRC_PSTAT) &
-		OPERATING_MODE_MASK) != OPERATING_MODE_SELF_REFRESH)
-		;
-	while ((mmio_read_32(DDRC_BASE_ADDR + OFFSET_DDRC_PSTAT) &
-		SELFREF_TYPE_MASK) != SELFREF_TYPE_NOT_UNDER_AUTO_SR_CTRL)
-		;
-	while ((mmio_read_32(DDRC_BASE_ADDR + OFFSET_DDRC_PSTAT) &
-		SELFREF_STATE_MASK) != SELFREF_STATE_SRPD)
-		;
-
-	/* Transition Phy to LP3 */
-	mmio_write_32(DDRC_BASE_ADDR + OFFSET_DDRC_DFIMISC, 0);
-	swctl = mmio_read_32(DDRC_BASE_ADDR + OFFSET_DDRC_SWCTL);
-	mmio_write_32(DDRC_BASE_ADDR + OFFSET_DDRC_SWCTL,
-		      swctl & (~SW_DONE_MASK));
-	dfimisc = mmio_read_32(DDRC_BASE_ADDR + OFFSET_DDRC_DFIMISC);
-	mmio_write_32(DDRC_BASE_ADDR + OFFSET_DDRC_DFIMISC,
-		      dfimisc | DFI_FREQUENCY(0x1f));
-	dfimisc = mmio_read_32(DDRC_BASE_ADDR + OFFSET_DDRC_DFIMISC);
-	mmio_write_32(DDRC_BASE_ADDR + OFFSET_DDRC_DFIMISC,
-		      dfimisc | DFI_INIT_START_MASK);
-	while (mmio_read_32(DDRC_BASE_ADDR + OFFSET_DDRC_DFISTAT) &
-	       DFI_INIT_COMPLETE_MASK)
-		;
-	dfimisc = mmio_read_32(DDRC_BASE_ADDR + OFFSET_DDRC_DFIMISC);
-	mmio_write_32(DDRC_BASE_ADDR + OFFSET_DDRC_DFIMISC,
-		      dfimisc | DFI_FREQUENCY(0x1f));
-	dfimisc = mmio_read_32(DDRC_BASE_ADDR + OFFSET_DDRC_DFIMISC);
-	mmio_write_32(DDRC_BASE_ADDR + OFFSET_DDRC_DFIMISC,
-		      dfimisc & (~DFI_INIT_START_MASK));
-	while (!(mmio_read_32(DDRC_BASE_ADDR + OFFSET_DDRC_DFISTAT) &
-		 DFI_INIT_COMPLETE_MASK))
-		;
-
-	swctl = mmio_read_32(DDRC_BASE_ADDR + OFFSET_DDRC_SWCTL);
-	mmio_write_32(DDRC_BASE_ADDR + OFFSET_DDRC_SWCTL,
-		      swctl | SW_DONE_MASK);
-	while (!(mmio_read_32(DDRC_BASE_ADDR + OFFSET_DDRC_SWSTAT) &
-		 SW_DONE_ACK_MASK))
-		;
-
-	/* Set PwrOkIn to 0 */
-	mmio_write_32(DDR_RET_CONTROL,
-		      mmio_read_32(DDR_RET_CONTROL) & (~DDR_RET_CONTROL_MASK));
-	mmio_write_32(DDR_CONFIG_0,
-		      mmio_read_32(DDR_CONFIG_0) | DDR_CONFIG_0_MEM_RET);
-}
-
-int ddrss_to_normal_mode(uintptr_t csr_array)
-{
-	int ret;
-	uint32_t pwrctl, init0;
-
-	ret = load_register_cfg(ddrc_cfg_size, ddrc_cfg);
-	if (ret)
-		return ret;
-
-	ret = load_dq_cfg(dq_swap_cfg_size, dq_swap_cfg);
-	if (ret)
-		return ret;
-
-	init0 = mmio_read_32(DDRC_BASE_ADDR + OFFSET_DDRC_INIT0);
-	mmio_write_32(DDRC_BASE_ADDR + OFFSET_DDRC_INIT0,
-		      init0 | SKIP_DRAM_INIT_MASK);
-	pwrctl = mmio_read_32(DDRC_BASE_ADDR + OFFSET_DDRC_PWRCTL);
-	mmio_write_32(DDRC_BASE_ADDR + OFFSET_DDRC_PWRCTL,
-		      pwrctl | SELFREF_SW_MASK);
-
-	/* Load ECC settings */
-	load_ecc(BL31SSRAM_CSR_BASE);
-
-	/* Setup AXI ports parity */
-	ret = set_axi_parity();
-	if (ret != NO_ERR)
-		return ret;
-
-	mmio_write_32(MICROCONT_MUX_SEL, UNLOCK_CSR_ACCESS);
-	ret = load_register_cfg(phy_cfg_size, phy_cfg);
-	if (ret)
-		return ret;
-	mmio_write_32(MICROCONT_MUX_SEL, LOCK_CSR_ACCESS);
-
-	/* Reload saved CSRs */
-	mmio_write_32(MICROCONT_MUX_SEL, UNLOCK_CSR_ACCESS);
-	load_csr(csr_array);
-	mmio_write_32(MICROCONT_MUX_SEL, LOCK_CSR_ACCESS);
-
-	mmio_write_32(MICROCONT_MUX_SEL, UNLOCK_CSR_ACCESS);
-	ret = load_register_cfg(pie_cfg_size, pie_cfg);
-	if (ret)
-		return ret;
-	mmio_write_32(MICROCONT_MUX_SEL, LOCK_CSR_ACCESS);
-
-	return post_train_setup(false);
-}
-
diff --git a/drivers/nxp/s32g/ddr/ddrss_cfg.c b/drivers/nxp/s32g/ddr/ddrss_cfg.c
index 97ebf6071..dd1dfe294 100644
--- a/drivers/nxp/s32g/ddr/ddrss_cfg.c
+++ b/drivers/nxp/s32g/ddr/ddrss_cfg.c
@@ -28,13 +28,13 @@
  * POSSIBILITY OF SUCH DAMAGE.
  */
 
-#include <ddr/ddr_init.h>
 #include <libc/string.h>
 #include <s32g_pinctrl.h>
+#include <ddr/ddr_init.h>
 
 struct ddrss_config configs[] = {
 	{
-		.memory_type = 2,
+		.memory_type = LPDDR4,
 		.ddrc_cfg = &ddrc_cfg[0],
 		.ddrc_cfg_size = 0,
 		.dq_swap_cfg = &dq_swap_cfg[0],
@@ -56,7 +56,7 @@ struct ddrss_config configs[] = {
 
 struct ddrss_config configs_rev2[] = {
 	{
-		.memory_type = 2,
+		.memory_type = LPDDR4,
 		.ddrc_cfg = &ddrc_cfg_rev2[0],
 		.ddrc_cfg_size = 0,
 		.dq_swap_cfg = &dq_swap_cfg[0],
diff --git a/drivers/nxp/s32g/ddr/dmem_cfg.c b/drivers/nxp/s32g/ddr/dmem_cfg.c
index d9f3bbed4..22ab8011b 100644
--- a/drivers/nxp/s32g/ddr/dmem_cfg.c
+++ b/drivers/nxp/s32g/ddr/dmem_cfg.c
@@ -61,13 +61,13 @@ uint16_t dmem_1d[] = {
 	0x4d66,
 	0x4f08,
 	0x0000,
-	0x0006,
+	0x0004,
 	0x2d54,
 	0x0033,
 	0x4d66,
 	0x4f08,
 	0x0000,
-	0x0006,
+	0x0004,
 	0x0000,
 	0x0000,
 	0x0000,
@@ -86,13 +86,13 @@ uint16_t dmem_1d[] = {
 	0x6600,
 	0x084d,
 	0x004f,
-	0x0600,
+	0x0400,
 	0x5400,
 	0x332d,
 	0x6600,
 	0x084d,
 	0x004f,
-	0x0600,
+	0x0400,
 	0x0000,
 	0x0000,
 	0x0000,
@@ -863,7 +863,7 @@ uint16_t dmem_1d[] = {
 	0x0000,
 };
 
-size_t dmem_1d_size = sizeof(dmem_1d) / sizeof(uint16_t);
+size_t dmem_1d_size = ARRAY_SIZE(dmem_1d);
 
 uint16_t dmem_2d[] = {
 	0x0000,
@@ -882,7 +882,7 @@ uint16_t dmem_2d[] = {
 	0x0100,
 	0x0000,
 	0x0100,
-	0x1f7f,
+	0x2080,
 	0x0000,
 	0x0310,
 	0x0000,
@@ -896,13 +896,13 @@ uint16_t dmem_2d[] = {
 	0x4d66,
 	0x4f08,
 	0x0000,
-	0x0006,
+	0x0004,
 	0x2d54,
 	0x0033,
 	0x4d66,
 	0x4f08,
 	0x0000,
-	0x0006,
+	0x0004,
 	0x0000,
 	0x0000,
 	0x0000,
@@ -921,13 +921,13 @@ uint16_t dmem_2d[] = {
 	0x6600,
 	0x084d,
 	0x004f,
-	0x0600,
+	0x0400,
 	0x5400,
 	0x332d,
 	0x6600,
 	0x084d,
 	0x004f,
-	0x0600,
+	0x0400,
 	0x0000,
 	0x0000,
 	0x0000,
@@ -1570,4 +1570,4 @@ uint16_t dmem_2d[] = {
 	0x0000,
 };
 
-size_t dmem_2d_size = sizeof(dmem_2d) / sizeof(uint16_t);
+size_t dmem_2d_size = ARRAY_SIZE(dmem_2d);
diff --git a/drivers/nxp/s32g/ddr/dq_swap_cfg.c b/drivers/nxp/s32g/ddr/dq_swap_cfg.c
index 1efec9a58..36be2cad8 100644
--- a/drivers/nxp/s32g/ddr/dq_swap_cfg.c
+++ b/drivers/nxp/s32g/ddr/dq_swap_cfg.c
@@ -1,5 +1,5 @@
 /*
- * Copyright 2020-2021 NXP
+ * Copyright 2021 NXP
  *
  * Redistribution and use in source and binary forms, with or without
  * modification, are permitted provided that the following conditions are met:
@@ -65,4 +65,4 @@ struct dqconf dq_swap_cfg[] = {
 	{0x4039a84c, 0x07},
 };
 
-size_t dq_swap_cfg_size = sizeof(dq_swap_cfg) / sizeof(struct dqconf);
+size_t dq_swap_cfg_size = ARRAY_SIZE(dq_swap_cfg);
diff --git a/drivers/nxp/s32g/ddr/imem_cfg.c b/drivers/nxp/s32g/ddr/imem_cfg.c
index 30a9b6546..466dba907 100644
--- a/drivers/nxp/s32g/ddr/imem_cfg.c
+++ b/drivers/nxp/s32g/ddr/imem_cfg.c
@@ -1,5 +1,5 @@
 /*
- * Copyright 2020-2021 NXP
+ * Copyright 2021 NXP
  *
  * Redistribution and use in source and binary forms, with or without
  * modification, are permitted provided that the following conditions are met:
@@ -16417,7 +16417,7 @@ uint16_t imem_1d[] = {
 	0x0000,
 };
 
-size_t imem_1d_size = sizeof(imem_1d) / sizeof(uint16_t);
+size_t imem_1d_size = ARRAY_SIZE(imem_1d);
 
 uint16_t imem_2d[] = {
 	0x0204,
@@ -32806,4 +32806,4 @@ uint16_t imem_2d[] = {
 	0x0000,
 };
 
-size_t imem_2d_size = sizeof(imem_2d) / sizeof(uint16_t);
+size_t imem_2d_size = ARRAY_SIZE(imem_2d);
diff --git a/drivers/nxp/s32g/ddr/phy_cfg.c b/drivers/nxp/s32g/ddr/phy_cfg.c
index 4df0667c3..e45ea02b7 100644
--- a/drivers/nxp/s32g/ddr/phy_cfg.c
+++ b/drivers/nxp/s32g/ddr/phy_cfg.c
@@ -1,5 +1,5 @@
 /*
- * Copyright 2020-2021 NXP
+ * Copyright 2021 NXP
  *
  * Redistribution and use in source and binary forms, with or without
  * modification, are permitted provided that the following conditions are met:
@@ -30,7 +30,7 @@
 
 #include <ddr/ddr_init.h>
 
-struct regconf phy_cfg[] = {
+struct regconf_16 phy_cfg[] = {
 	{0x4038040c, 0x00000001},
 	{0x40380bdc, 0x00000001},
 	{0x403945dc, 0x000001ff},
@@ -54,11 +54,11 @@ struct regconf phy_cfg[] = {
 	{0x403816dc, 0x00000019},
 	{0x40381494, 0x00000002},
 	{0x40380c58, 0x00000000},
-	{0x40381438, 0x000000e3},
+	{0x40381438, 0x000001e3},
 	{0x403814fc, 0x00000002},
 	{0x40381618, 0x00000212},
 	{0x40381608, 0x00000061},
-	{0x40381530, 0x00000007},
+	{0x40381530, 0x00000003},
 	{0x403945a0, 0x00000600},
 	{0x403945a4, 0x00000600},
 	{0x403965a0, 0x00000600},
@@ -119,4 +119,4 @@ struct regconf phy_cfg[] = {
 	{0x40381478, 0x00000000},
 };
 
-size_t phy_cfg_size = sizeof(phy_cfg) / sizeof(struct regconf);
+size_t phy_cfg_size = ARRAY_SIZE(phy_cfg);
diff --git a/drivers/nxp/s32g/ddr/pie_cfg.c b/drivers/nxp/s32g/ddr/pie_cfg.c
index a1d7081f7..e265b6487 100644
--- a/drivers/nxp/s32g/ddr/pie_cfg.c
+++ b/drivers/nxp/s32g/ddr/pie_cfg.c
@@ -1,5 +1,5 @@
 /*
- * Copyright 2020-2021 NXP
+ * Copyright 2021 NXP
  *
  * Redistribution and use in source and binary forms, with or without
  * modification, are permitted provided that the following conditions are met:
@@ -30,7 +30,7 @@
 
 #include <ddr/ddr_init.h>
 
-struct regconf pie_cfg[] = {
+struct regconf_16 pie_cfg[] = {
 	{0x40380c04, 0x00000010},
 	{0x40380c0c, 0x00000400},
 	{0x40380c24, 0x0000010e},
@@ -591,4 +591,4 @@ struct regconf pie_cfg[] = {
 	{0x40380bec, 0x00000002},
 };
 
-size_t pie_cfg_size = sizeof(pie_cfg) / sizeof(struct regconf);
+size_t pie_cfg_size = ARRAY_SIZE(pie_cfg);
diff --git a/drivers/nxp/s32g/ddr/rev2/ddrc_cfg_rev2.c b/drivers/nxp/s32g/ddr/rev2/ddrc_cfg_rev2.c
index ad9e4d25e..db9b29cf8 100644
--- a/drivers/nxp/s32g/ddr/rev2/ddrc_cfg_rev2.c
+++ b/drivers/nxp/s32g/ddr/rev2/ddrc_cfg_rev2.c
@@ -32,150 +32,150 @@
 #include <ddr/ddr_init.h>
 
 struct regconf ddrc_cfg_rev2[] = {
-	{0x4007c604, 0x00000000},
+	{0x4007c604, 0x00000000U},
 #if (S32G_DRAM_INLINE_ECC == 1)
-	{0x4007c608, 0x37ffffff},
+	{0x4007c608, 0x37ffffffU},
 #else
-	{0x4007c608, 0x00000000},
+	{0x4007c608, 0x00000000U},
 #endif
-	{0x403c0000, 0x83080020},
-	{0x403c0010, 0x00000030},
-	{0x403c0014, 0x00000000},
-	{0x403c001c, 0x00000000},
-	{0x403c0020, 0x00000202},
-	{0x403c0024, 0x0186a000},
-	{0x403c002c, 0x00000001},
-	{0x403c0030, 0x00000020},
-	{0x403c0034, 0x00402010},
-	{0x403c0038, 0x00000000},
-	{0x403c0050, 0x00210070},
-	{0x403c0054, 0x00000000},
-	{0x403c0060, 0x00000000},
-	{0x403c0064, 0x006100e0},
-	{0x403c0068, 0x008c0000},
+	{0x403c0000, 0x83080020U},
+	{0x403c0010, 0x00000030U},
+	{0x403c0014, 0x00000000U},
+	{0x403c001c, 0x00000000U},
+	{0x403c0020, 0x00000202U},
+	{0x403c0024, 0x0186a000U},
+	{0x403c002c, 0x00000001U},
+	{0x403c0030, 0x00000020U},
+	{0x403c0034, 0x00402010U},
+	{0x403c0038, 0x00000000U},
+	{0x403c0050, 0x00210000U},
+	{0x403c0054, 0x00000000U},
+	{0x403c0060, 0x00000000U},
+	{0x403c0064, 0x006100e0U},
+	{0x403c0068, 0x008c0000U},
 #if (S32G_DRAM_INLINE_ECC == 1)
-	{0x403c0070, 0x033f7f54},
-	{0x403c0074, 0x00000780},
+	{0x403c0070, 0x033f7f54U},
+	{0x403c0074, 0x00000780U},
 #else
-	{0x403c0070, 0x033f7f40},
-	{0x403c0074, 0x000007b0},
+	{0x403c0070, 0x033f7f40U},
+	{0x403c0074, 0x000007b0U},
 #endif
-	{0x403c007c, 0x00000700},
-	{0x403c00b8, 0x00000000},
-	{0x403c00bc, 0x00000000},
-	{0x403c00c0, 0x00000000},
-	{0x403c00c4, 0x00001000},
-	{0x403c00d0, 0xc003061c},
-	{0x403c00d4, 0x009e0000},
-	{0x403c00d8, 0x00000d05},
-	{0x403c00dc, 0x0054002d},
-	{0x403c00e0, 0x00330008},
-	{0x403c00e4, 0x00100004},
-	{0x403c00e8, 0x0066004d},
-	{0x403c00ec, 0x0006004f},
-	{0x403c00f0, 0x00000000},
-	{0x403c00f4, 0x00000779},
-	{0x403c0100, 0x1a201b22},
-	{0x403c0104, 0x00060633},
-	{0x403c0108, 0x070e1517},
-	{0x403c010c, 0x00c0c000},
-	{0x403c0110, 0x0f04080f},
-	{0x403c0114, 0x02040c0c},
-	{0x403c0118, 0x01010007},
-	{0x403c011c, 0x00000401},
-	{0x403c0120, 0x03034405},
-	{0x403c0124, 0x0004040d},
-	{0x403c0128, 0x001c180a},
-	{0x403c012c, 0x440c021c},
-	{0x403c0130, 0x00020000},
-	{0x403c0134, 0x0c100002},
-	{0x403c0138, 0x000000e6},
-	{0x403c013c, 0x00000000},
-	{0x403c0180, 0xc3200018},
-	{0x403c0184, 0x028061a8},
-	{0x403c0188, 0x00000000},
-	{0x403c0190, 0x0497820a},
-	{0x403c0194, 0x00080303},
-	{0x403c0198, 0x07000000},
-	{0x403c019c, 0x00000000},
-	{0x403c01a0, 0xe0400018},
-	{0x403c01a4, 0x00df00e4},
-	{0x403c01a8, 0x80000000},
-	{0x403c01b0, 0x00000051},
-	{0x403c01b4, 0x0000170a},
-	{0x403c01b8, 0x00000000},
-	{0x403c01c0, 0x00000001},
-	{0x403c01c4, 0x00000001},
+	{0x403c007c, 0x00000700U},
+	{0x403c00b8, 0x00000000U},
+	{0x403c00bc, 0x00000000U},
+	{0x403c00c0, 0x00000000U},
+	{0x403c00c4, 0x00001000U},
+	{0x403c00d0, 0xc003061cU},
+	{0x403c00d4, 0x009e0000U},
+	{0x403c00d8, 0x00000d05U},
+	{0x403c00dc, 0x0054002dU},
+	{0x403c00e0, 0x00330008U},
+	{0x403c00e4, 0x00100004U},
+	{0x403c00e8, 0x0066004dU},
+	{0x403c00ec, 0x0004004fU},
+	{0x403c00f0, 0x00000000U},
+	{0x403c00f4, 0x00000779U},
+	{0x403c0100, 0x1a201b22U},
+	{0x403c0104, 0x00060633U},
+	{0x403c0108, 0x070e1517U},
+	{0x403c010c, 0x00c0c000U},
+	{0x403c0110, 0x0f04080fU},
+	{0x403c0114, 0x02040c0cU},
+	{0x403c0118, 0x01010007U},
+	{0x403c011c, 0x00000401U},
+	{0x403c0120, 0x03034405U},
+	{0x403c0124, 0x0004040dU},
+	{0x403c0128, 0x001c180aU},
+	{0x403c012c, 0x440c021cU},
+	{0x403c0130, 0x00020000U},
+	{0x403c0134, 0x0c100002U},
+	{0x403c0138, 0x000000e6U},
+	{0x403c013c, 0x00000000U},
+	{0x403c0180, 0x03200018U},
+	{0x403c0184, 0x028061a8U},
+	{0x403c0188, 0x00000000U},
+	{0x403c0190, 0x0497820aU},
+	{0x403c0194, 0x00080303U},
+	{0x403c0198, 0x07000000U},
+	{0x403c019c, 0x00000000U},
+	{0x403c01a0, 0xe0400018U},
+	{0x403c01a4, 0x00df00e4U},
+	{0x403c01a8, 0x80000000U},
+	{0x403c01b0, 0x00000051U},
+	{0x403c01b4, 0x0000170aU},
+	{0x403c01b8, 0x00000000U},
+	{0x403c01c0, 0x00000001U},
+	{0x403c01c4, 0x00000001U},
 #if (S32G_DRAM_INLINE_ECC == 1)
-	{0x403c0200, 0x00000014},
-	{0x403c0204, 0x00050505},
+	{0x403c0200, 0x00000014U},
+	{0x403c0204, 0x00050505U},
 #else
-	{0x403c0200, 0x00000017},
-	{0x403c0204, 0x00080808},
+	{0x403c0200, 0x00000017U},
+	{0x403c0204, 0x00080808U},
 #endif
-	{0x403c0208, 0x00000000},
+	{0x403c0208, 0x00000000U},
 #if (S32G_DRAM_INLINE_ECC == 1)
-	{0x403c020c, 0x14141400},
+	{0x403c020c, 0x14141400U},
 #else
-	{0x403c020c, 0x00000000},
+	{0x403c020c, 0x00000000U},
 #endif
-	{0x403c0210, 0x00001f1f},
+	{0x403c0210, 0x00001f1fU},
 #if (S32G_DRAM_INLINE_ECC == 1)
-	{0x403c0214, 0x04040404},
-	{0x403c0218, 0x04040404},
+	{0x403c0214, 0x04040404U},
+	{0x403c0218, 0x04040404U},
 #else
-	{0x403c0214, 0x07070707},
-	{0x403c0218, 0x07070707},
+	{0x403c0214, 0x07070707U},
+	{0x403c0218, 0x07070707U},
 #endif
-	{0x403c021c, 0x0000000f},
-	{0x403c0220, 0x00003f3f},
-	{0x403c0224, 0x00000000},
-	{0x403c0228, 0x00000000},
-	{0x403c022c, 0x00000000},
-	{0x403c0240, 0x04000400},
-	{0x403c0244, 0x00000000},
-	{0x403c0250, 0x29001505},
-	{0x403c0254, 0x0000002c},
-	{0x403c025c, 0x5900575b},
-	{0x403c0264, 0x90000096},
-	{0x403c026c, 0x1000012c},
-	{0x403c0300, 0x00000000},
-	{0x403c0304, 0x00000000},
-	{0x403c030c, 0x00000000},
-	{0x403c0320, 0x00000001},
-	{0x403c0330, 0x00b03033},
-	{0x403c0334, 0x00000000},
-	{0x403c036c, 0x00000011},
-	{0x403c0374, 0x00000000},
-	{0x403c037c, 0x00000000},
-	{0x403c0384, 0x00000000},
-	{0x403c03c0, 0x00000003},
-	{0x403c03e0, 0x00010001},
-	{0x403c03e8, 0x00010001},
-	{0x403c0400, 0x00000111},
-	{0x403c0404, 0x000010f3},
-	{0x403c0408, 0x000072ff},
-	{0x403c0490, 0x00000000},
-	{0x403c0494, 0x00000e00},
-	{0x403c0498, 0x006207ff},
-	{0x403c049c, 0x01010e07},
-	{0x403c04a0, 0x034b07ff},
-	{0x403c04b4, 0x00000000},
-	{0x403c04b8, 0x00004000},
-	{0x403c0540, 0x00000000},
-	{0x403c0544, 0x02000e00},
-	{0x403c0548, 0x00000000},
-	{0x403c054c, 0x00000e00},
-	{0x403c0550, 0x00000000},
-	{0x403c0564, 0x00000000},
-	{0x403c0568, 0x00004000},
-	{0x403c05f0, 0x00000000},
-	{0x403c05f4, 0x02000e00},
-	{0x403c05f8, 0x00000000},
-	{0x403c05fc, 0x00000e00},
-	{0x403c0600, 0x00000000},
-	{0x403c0f24, 0x0000ff10},
-	{0x403c0f2c, 0x00000000},
+	{0x403c021c, 0x0000000fU},
+	{0x403c0220, 0x00003f3fU},
+	{0x403c0224, 0x00000000U},
+	{0x403c0228, 0x00000000U},
+	{0x403c022c, 0x00000000U},
+	{0x403c0240, 0x04000400U},
+	{0x403c0244, 0x00000000U},
+	{0x403c0250, 0x29001505U},
+	{0x403c0254, 0x00000000U},
+	{0x403c025c, 0x5900575bU},
+	{0x403c0264, 0x90000096U},
+	{0x403c026c, 0x1000012cU},
+	{0x403c0300, 0x00000000U},
+	{0x403c0304, 0x00000000U},
+	{0x403c030c, 0x00000000U},
+	{0x403c0320, 0x00000001U},
+	{0x403c0330, 0x00b03033U},
+	{0x403c0334, 0x00000000U},
+	{0x403c036c, 0x00000011U},
+	{0x403c0374, 0x00000000U},
+	{0x403c037c, 0x00000000U},
+	{0x403c0384, 0x00000000U},
+	{0x403c03c0, 0x00000003U},
+	{0x403c03e0, 0x00010001U},
+	{0x403c03e8, 0x00010001U},
+	{0x403c0400, 0x00000011U},
+	{0x403c0404, 0x000010f3U},
+	{0x403c0408, 0x000072ffU},
+	{0x403c0490, 0x00000000U},
+	{0x403c0494, 0x00000e00U},
+	{0x403c0498, 0x006207ffU},
+	{0x403c049c, 0x01010e07U},
+	{0x403c04a0, 0x034b07ffU},
+	{0x403c04b4, 0x00000000U},
+	{0x403c04b8, 0x00004000U},
+	{0x403c0540, 0x00000000U},
+	{0x403c0544, 0x02000e00U},
+	{0x403c0548, 0x00000000U},
+	{0x403c054c, 0x00000e00U},
+	{0x403c0550, 0x00000000U},
+	{0x403c0564, 0x00000000U},
+	{0x403c0568, 0x00004000U},
+	{0x403c05f0, 0x00000000U},
+	{0x403c05f4, 0x02000e00U},
+	{0x403c05f8, 0x00000000U},
+	{0x403c05fc, 0x00000e00U},
+	{0x403c0600, 0x00000000U},
+	{0x403c0f24, 0x0000ff10U},
+	{0x403c0f2c, 0x00000000U},
 };
 
-size_t ddrc_cfg_size_rev2 = sizeof(ddrc_cfg_rev2) / sizeof(struct regconf);
+size_t ddrc_cfg_size_rev2 = ARRAY_SIZE(ddrc_cfg_rev2);
diff --git a/drivers/nxp/s32g/ddr/rev2/dmem_cfg_rev2.c b/drivers/nxp/s32g/ddr/rev2/dmem_cfg_rev2.c
index 7d051b473..fb4343ea3 100644
--- a/drivers/nxp/s32g/ddr/rev2/dmem_cfg_rev2.c
+++ b/drivers/nxp/s32g/ddr/rev2/dmem_cfg_rev2.c
@@ -62,13 +62,13 @@ uint16_t dmem_1d_rev2[] = {
 	0x4d66,
 	0x4f08,
 	0x0000,
-	0x0006,
+	0x0004,
 	0x2d54,
 	0x0033,
 	0x4d66,
 	0x4f08,
 	0x0000,
-	0x0006,
+	0x0004,
 	0x0000,
 	0x0000,
 	0x0000,
@@ -87,13 +87,13 @@ uint16_t dmem_1d_rev2[] = {
 	0x6600,
 	0x084d,
 	0x004f,
-	0x0600,
+	0x0400,
 	0x5400,
 	0x332d,
 	0x6600,
 	0x084d,
 	0x004f,
-	0x0600,
+	0x0400,
 	0x0000,
 	0x0000,
 	0x0000,
@@ -864,7 +864,7 @@ uint16_t dmem_1d_rev2[] = {
 	0x0000,
 };
 
-size_t dmem_1d_size_rev2 = sizeof(dmem_1d_rev2) / sizeof(uint16_t);
+size_t dmem_1d_size_rev2 = ARRAY_SIZE(dmem_1d_rev2);
 
 uint16_t dmem_2d_rev2[] = {
 	0x0000,
@@ -883,7 +883,7 @@ uint16_t dmem_2d_rev2[] = {
 	0x0100,
 	0x0000,
 	0x0100,
-	0x1f7f,
+	0x2080,
 	0x0000,
 	0x0310,
 	0x0000,
@@ -897,13 +897,13 @@ uint16_t dmem_2d_rev2[] = {
 	0x4d66,
 	0x4f08,
 	0x0000,
-	0x0006,
+	0x0004,
 	0x2d54,
 	0x0033,
 	0x4d66,
 	0x4f08,
 	0x0000,
-	0x0006,
+	0x0004,
 	0x0000,
 	0x0000,
 	0x0000,
@@ -922,13 +922,13 @@ uint16_t dmem_2d_rev2[] = {
 	0x6600,
 	0x084d,
 	0x004f,
-	0x0600,
+	0x0400,
 	0x5400,
 	0x332d,
 	0x6600,
 	0x084d,
 	0x004f,
-	0x0600,
+	0x0400,
 	0x0000,
 	0x0000,
 	0x0000,
@@ -1571,4 +1571,4 @@ uint16_t dmem_2d_rev2[] = {
 	0x0000,
 };
 
-size_t dmem_2d_size_rev2 = sizeof(dmem_2d_rev2) / sizeof(uint16_t);
+size_t dmem_2d_size_rev2 = ARRAY_SIZE(dmem_2d_rev2);
diff --git a/drivers/nxp/s32g/ddr/rev2/phy_cfg_rev2.c b/drivers/nxp/s32g/ddr/rev2/phy_cfg_rev2.c
index ed6b947f7..94b1a5bd1 100644
--- a/drivers/nxp/s32g/ddr/rev2/phy_cfg_rev2.c
+++ b/drivers/nxp/s32g/ddr/rev2/phy_cfg_rev2.c
@@ -1,5 +1,5 @@
 /*
- * Copyright 2020-2021 NXP
+ * Copyright 2021 NXP
  *
  * Redistribution and use in source and binary forms, with or without
  * modification, are permitted provided that the following conditions are met:
@@ -30,7 +30,7 @@
 
 #include <ddr/ddr_init.h>
 
-struct regconf phy_cfg_rev2[] = {
+struct regconf_16 phy_cfg_rev2[] = {
 	{0x4038040c, 0x00000001},
 	{0x40380bdc, 0x00000001},
 	{0x403945dc, 0x000001ff},
@@ -54,11 +54,11 @@ struct regconf phy_cfg_rev2[] = {
 	{0x403816dc, 0x00000019},
 	{0x40381494, 0x00000002},
 	{0x40380c58, 0x00000000},
-	{0x40381438, 0x000000e3},
+	{0x40381438, 0x000001e3},
 	{0x403814fc, 0x00000002},
 	{0x40381618, 0x00000212},
 	{0x40381608, 0x00000061},
-	{0x40381530, 0x00000007},
+	{0x40381530, 0x00000003},
 	{0x403945a0, 0x00000600},
 	{0x403945a4, 0x00000600},
 	{0x403965a0, 0x00000600},
@@ -119,4 +119,4 @@ struct regconf phy_cfg_rev2[] = {
 	{0x40381478, 0x00000000},
 };
 
-size_t phy_cfg_size_rev2 = sizeof(phy_cfg_rev2) / sizeof(struct regconf);
+size_t phy_cfg_size_rev2 = ARRAY_SIZE(phy_cfg_rev2);
diff --git a/drivers/nxp/s32g/ddr/rev2/pie_cfg_rev2.c b/drivers/nxp/s32g/ddr/rev2/pie_cfg_rev2.c
index 86f84275b..f7307e242 100644
--- a/drivers/nxp/s32g/ddr/rev2/pie_cfg_rev2.c
+++ b/drivers/nxp/s32g/ddr/rev2/pie_cfg_rev2.c
@@ -30,7 +30,7 @@
 
 #include <ddr/ddr_init.h>
 
-struct regconf pie_cfg_rev2[] = {
+struct regconf_16 pie_cfg_rev2[] = {
 	{0x40380c04, 0x00000010},
 	{0x40380c0c, 0x00000400},
 	{0x40380c24, 0x0000010e},
@@ -591,4 +591,4 @@ struct regconf pie_cfg_rev2[] = {
 	{0x40380bec, 0x00000002},
 };
 
-size_t pie_cfg_size_rev2 = sizeof(pie_cfg_rev2) / sizeof(struct regconf);
+size_t pie_cfg_size_rev2 = ARRAY_SIZE(pie_cfg_rev2);
diff --git a/include/drivers/nxp/s32g/ddr/ddr_init.h b/include/drivers/nxp/s32g/ddr/ddr_init.h
index eb1f280a4..bc669cf5c 100644
--- a/include/drivers/nxp/s32g/ddr/ddr_init.h
+++ b/include/drivers/nxp/s32g/ddr/ddr_init.h
@@ -32,7 +32,7 @@
 #define DDR_INIT_H_
 
 #include <stdlib.h>
-#include <ddr/ddr_utils.h>
+#include "ddr_utils.h"
 
 #define APBONLY_MICRORESET   0x40380420
 #define MASTER_PLLCTRL1      0x403816f0
@@ -44,13 +44,15 @@
 #define LOCK_CSR_ACCESS   0x00000001
 #define UNLOCK_CSR_ACCESS 0x00000000
 
+/* Compute the number of elements in the given array */
+#define ARRAY_SIZE(a) (sizeof(a) / sizeof((a)[0]))
+
+#define FIRMWARE_VERSION "2020_06"
+
 /* Enum for DRAM Type */
 enum dram_type {
-	DDR4,
-	DDR3,
-	LPDDR4,
-	LPDDR3,
-	DDR5
+	DDR3L = 1,
+	LPDDR4
 };
 
 struct regconf {
@@ -58,6 +60,11 @@ struct regconf {
 	uint32_t data;
 };
 
+struct regconf_16 {
+	uint32_t addr;
+	uint16_t data;
+};
+
 struct dqconf {
 	uint32_t addr;
 	uint8_t data;
@@ -69,7 +76,7 @@ struct ddrss_config {
 	size_t ddrc_cfg_size;
 	struct dqconf *dq_swap_cfg;
 	size_t dq_swap_cfg_size;
-	struct regconf *phy_cfg;
+	struct regconf_16 *phy_cfg;
 	size_t phy_cfg_size;
 	uint16_t *imem_1d;
 	size_t imem_1d_size;
@@ -79,7 +86,7 @@ struct ddrss_config {
 	size_t imem_2d_size;
 	uint16_t *dmem_2d;
 	size_t dmem_2d_size;
-	struct regconf *pie_cfg;
+	struct regconf_16 *pie_cfg;
 	size_t pie_cfg_size;
 };
 
@@ -87,7 +94,7 @@ extern struct regconf ddrc_cfg[];
 extern size_t ddrc_cfg_size;
 extern struct dqconf dq_swap_cfg[];
 extern size_t dq_swap_cfg_size;
-extern struct regconf phy_cfg[];
+extern struct regconf_16 phy_cfg[];
 extern size_t phy_cfg_size;
 extern uint16_t imem_1d[];
 extern size_t imem_1d_size;
@@ -97,34 +104,63 @@ extern uint16_t imem_2d[];
 extern size_t imem_2d_size;
 extern uint16_t dmem_2d[];
 extern size_t dmem_2d_size;
-extern struct regconf pie_cfg[];
+extern struct regconf_16 pie_cfg[];
 extern size_t pie_cfg_size;
 extern struct ddrss_config configs[];
 extern size_t ddrss_config_size;
 
 extern struct regconf ddrc_cfg_rev2[];
 extern size_t ddrc_cfg_size_rev2;
-extern struct dqconf dq_swap_cfg_rev2[];
-extern size_t dq_swap_cfg_size_rev2;
-extern struct regconf phy_cfg_rev2[];
+extern struct regconf_16 phy_cfg_rev2[];
 extern size_t phy_cfg_size_rev2;
-extern uint16_t imem_1d_rev2[];
-extern size_t imem_1d_size_rev2;
 extern uint16_t dmem_1d_rev2[];
 extern size_t dmem_1d_size_rev2;
-extern uint16_t imem_2d_rev2[];
-extern size_t imem_2d_size_rev2;
 extern uint16_t dmem_2d_rev2[];
 extern size_t dmem_2d_size_rev2;
-extern struct regconf pie_cfg_rev2[];
+extern struct regconf_16 pie_cfg_rev2[];
 extern size_t pie_cfg_size_rev2;
-extern struct ddrss_config configs_rev2[];
-extern size_t ddrss_config_size_rev2;
 
+/*
+ * Full initialization of DDR SubSystem.
+ * @return - error code, 0 if init succeeds, non-zero on error.
+ */
 uint32_t ddr_init(void);
+
+/* Set initial sizes for all configuration images. */
 void init_image_sizes(void);
+
+/*
+ * Writes the data associated for each address.
+ *
+ * @param size - size of the array, number of elements
+ * @param cfg - array of configuration elements
+ * @return - error code, 0 if init succeeds, non-zero on error.
+ */
 uint32_t load_register_cfg(size_t size, struct regconf cfg[]);
-uint32_t ddrc_init_cfg(struct ddrss_config *config);
+
+/*
+ * Writes the data associated for each address. Similar to
+ * @load_register_cfg but uses 16bit data elements for memory
+ * usage optimization.
+ *
+ * @param size - size of the array, number of elements
+ * @param cfg - array of configuration elements
+ * @return - error code, 0 if init succeeds, non-zero on error.
+ */
+uint32_t load_register_cfg_16(size_t size, struct regconf_16 cfg[]);
+
+/*
+ * Writes the data associated for each address. Similar to
+ * @load_register_cfg but uses 8bit data elements for memory
+ * usage optimization.
+ *
+ * @param size - size of the array, number of elements
+ * @param cfg - array of configuration elements
+ * @return - error code, 0 if init succeeds, non-zero on error.
+ */
 uint32_t load_dq_cfg(size_t size, struct dqconf cfg[]);
 
+/* Updates PHY internal PLL settings. */
+void set_optimal_pll(void);
+
 #endif /* DDR_INIT_H */
diff --git a/include/drivers/nxp/s32g/ddr/ddr_lp.h b/include/drivers/nxp/s32g/ddr/ddr_lp.h
new file mode 100755
index 000000000..d7ad40f6a
--- /dev/null
+++ b/include/drivers/nxp/s32g/ddr/ddr_lp.h
@@ -0,0 +1,65 @@
+/*
+ * Copyright 2021 NXP
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ * this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ * this list of conditions and the following disclaimer in the documentation
+ * and/or other materials provided with the distribution.
+ *
+ * 3. Neither the name of the copyright holder nor the names of its
+ * contributors may be used to endorse or promote products derived from this
+ * software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef LP_DDR_LP_H_
+#define LP_DDR_LP_H_
+
+#include "ddr_init.h"
+
+#define DDRSS_BASE_ADDR                 0x40380000
+
+#define DDR_GPR_OFFSET                  (0x4007c600UL)
+#define DDR_CONFIG_0_REG                (DDR_GPR_OFFSET + 0x00)
+#define DDR_RET_CONTROL_REG             (DDR_GPR_OFFSET + 0x1c)
+#define DDR_RET_CONTROL_MASK            SHIFT_BIT(0)
+#define DDR_CONFIG_0_MEM_RET            SHIFT_BIT(14)
+
+#define DFI_FREQUENCY(f)                ((f) << 8)
+#define SELFREF_STATE_SRPD              (0x2UL << 8)
+#define SELFREF_STATE_MASK              (SHIFT_BIT(8) | SHIFT_BIT(9))
+#define SELFREF_TYPE_NOT_AUTO_SR_CTRL   (0x2UL << 4)
+#define OPERATING_MODE_SELF_REFRESH     (0x3)
+
+extern const uint32_t csr_to_store[];
+extern size_t csr_to_store_size;
+
+/* Transition the DDR SubSystem from normal mode to retention mode. */
+void ddrss_to_io_retention_mode(void);
+
+/* Transition the DDR SubSystem from retention mode to normal mode. */
+uint32_t ddrss_to_normal_mode(uintptr_t csr_array);
+
+/* Store Configuration Status Registers. */
+void store_csr(uintptr_t store_at);
+
+/* Load Configuration Status Registers. */
+void load_csr(uintptr_t load_from);
+
+#endif /* LP_DDR_LP_H_ */
diff --git a/include/drivers/nxp/s32g/ddr/ddr_utils.h b/include/drivers/nxp/s32g/ddr/ddr_utils.h
index c21d760af..86bd2c812 100644
--- a/include/drivers/nxp/s32g/ddr/ddr_utils.h
+++ b/include/drivers/nxp/s32g/ddr/ddr_utils.h
@@ -31,98 +31,127 @@
 #ifndef DDR_UTILS_H_
 #define DDR_UTILS_H_
 
-#include <lib/mmio.h>
 #include <stdbool.h>
+#include <plat/nxp/s32g/bl31_ssram/ssram_mailbox.h>
+
+/* Uncomment to store the CSR registers after executing DDR training */
+#define STORE_CSR_ENABLE
+
+#ifndef dsb
+#define dsb()	__asm__("DSB SY")
+#endif
 
 /* Possible errors */
 #define NO_ERR              0x00000000
-#define UNSUPPORTED_ERR     0x00000001
 #define TIMEOUT_ERR         0x00000002
 #define TRAINING_FAILED     0x00000003
 #define BITFIELD_EXCEEDED   0x00000004
 
 /* DDRC related */
-#define    DDRC_BASE_ADDR                   0x403C0000
-#define    OFFSET_DDRC_SWCTL                0x320
-#define    OFFSET_DDRC_DFIMISC              0x1b0
-#define    OFFSET_DDRC_DFISTAT              0x1bc
-#define    OFFSET_DDRC_PWRCTL               0x30
-#define    OFFSET_DDRC_SWSTAT               0x324
-#define    OFFSET_DDRC_STAT                 0x04
-#define    OFFSET_DDRC_DBG1                 0x304
-#define    OFFSET_DDRC_ECCCFG0              0x70
-#define    OFFSET_DDRC_ECCCFG1              0x74
-#define    OFFSET_DDRC_SBRCTL               0xf24
-#define    OFFSET_DDRC_SBRSTAT              0xf28
-#define    OFFSET_DDRC_SBRWDATA0            0xf2c
-#define    OFFSET_DDRC_MRSTAT               0x18
-#define    OFFSET_DDRC_MRCTRL0              0x10
-#define    OFFSET_DDRC_MRCTRL1              0x14
-#define    OFFSET_DDRC_DERATEEN             0x20
-#define    OFFSET_DDRC_RFSHTMG              0x64
-#define    OFFSET_DDRC_DRAMTMG0             0x100
-#define    OFFSET_DDRC_DRAMTMG1             0x104
-#define    OFFSET_DDRC_DRAMTMG4             0x110
+#define DDRC_BASE_ADDR                   0x403C0000
+#define OFFSET_DDRC_SWCTL                0x320
+#define OFFSET_DDRC_DFIMISC              0x1b0
+#define OFFSET_DDRC_DFISTAT              0x1bc
+#define OFFSET_DDRC_PWRCTL               0x30
+#define OFFSET_DDRC_SWSTAT               0x324
+#define OFFSET_DDRC_STAT                 0x04
+#define OFFSET_DDRC_DBG1                 0x304
+#define OFFSET_DDRC_ECCCFG0              0x70
+#define OFFSET_DDRC_ECCCFG1              0x74
+#define OFFSET_DDRC_SBRCTL               0xf24
+#define OFFSET_DDRC_SBRSTAT              0xf28
+#define OFFSET_DDRC_SBRWDATA0            0xf2c
+#define OFFSET_DDRC_MRSTAT               0x18
+#define OFFSET_DDRC_MRCTRL0              0x10
+#define OFFSET_DDRC_MRCTRL1              0x14
+#define OFFSET_DDRC_DERATEEN             0x20
+#define OFFSET_DDRC_RFSHTMG              0x64
+#define OFFSET_DDRC_DRAMTMG0             0x100
+#define OFFSET_DDRC_DRAMTMG1             0x104
+#define OFFSET_DDRC_DRAMTMG4             0x110
 
 /* DDRC masks and values */
-#define    DDRC_RFSHTMG_VAL_SHIFT           16
-#define    DDRC_RFSHTMG_VAL                 0xfff
-#define    DDRC_RFSHTMG_MASK                (DDRC_RFSHTMG_VAL << \
-	   DDRC_RFSHTMG_VAL_SHIFT)
-#define    DDRC_RFSHCTL3_UPDATE_SHIFT       1
-#define    DDRC_RFSHCTL3_AUTO_REFRESH_VAL   0x1
-#define    DDRC_RFSHCTL3_MASK               (DDRC_RFSHCTL3_AUTO_REFRESH_VAL \
+#define DDRC_RFSHTMG_VAL_SHIFT           16
+#define DDRC_RFSHTMG_VAL                 0xfffU
+#define DDRC_RFSHTMG_MASK                (DDRC_RFSHTMG_VAL << \
+	DDRC_RFSHTMG_VAL_SHIFT)
+#define DDRC_RFSHCTL3_UPDATE_SHIFT       1
+#define DDRC_RFSHCTL3_AUTO_REFRESH_VAL   0x1U
+#define DDRC_RFSHCTL3_MASK               (DDRC_RFSHCTL3_AUTO_REFRESH_VAL \
 	<< DDRC_RFSHCTL3_UPDATE_SHIFT)
-#define    DDRC_DERATEEN_ENABLE             0x1
-#define    DDRC_SWCTL_SWDONE_ENABLE         0x0
-#define    DDRC_SWSTAT_SWDONE_ACK_MASK      0x1
-#define    DDRC_DRAMTMG4_TRCD_POS           24
-#define    DDRC_DRAMTMG5_TRCD_MASK          0x1f
-#define    DDRC_DRAMTMG4_TRRD_POS           8
-#define    DDRC_DRAMTMG5_TRRD_MASK          0xf
-#define    DDRC_DRAMTMG0_TRAS_POS           0
-#define    DDRC_DRAMTMG0_TRAS_MASK          0x3f
-#define    DDRC_DRAMTMG4_TRP_POS            0
-#define    DDRC_DRAMTMG4_TRP_MASK           0x1f
-#define    DDRC_DRAMTMG1_TRC_POS            0
-#define    DDRC_DRAMTMG1_TRC_MASK           0x7f
-#define    DDRC_SWCTL_SWDONE_DONE           0x1
-#define    SUCCESSIVE_READ                  2
-#define    DDRC_DERATEEN_MASK_DISABLE       0x1
+#define DDRC_DERATEEN_ENABLE             0x1U
+#define DDRC_SWCTL_SWDONE_ENABLE         0x0
+#define DDRC_SWSTAT_SWDONE_ACK_MASK      0x1U
+#define DDRC_DRAMTMG4_TRCD_POS           24
+#define DDRC_DRAMTMG5_TRCD_MASK          0x1f
+#define DDRC_DRAMTMG4_TRRD_POS           8
+#define DDRC_DRAMTMG5_TRRD_MASK          0xf
+#define DDRC_DRAMTMG0_TRAS_POS           0
+#define DDRC_DRAMTMG0_TRAS_MASK          0x3f
+#define DDRC_DRAMTMG4_TRP_POS            0
+#define DDRC_DRAMTMG4_TRP_MASK           0x1f
+#define DDRC_DRAMTMG1_TRC_POS            0
+#define DDRC_DRAMTMG1_TRC_MASK           0x7f
+#define DDRC_SWCTL_SWDONE_DONE           0x1
+#define SUCCESSIVE_READ                  2
+#define DDRC_DERATEEN_MASK_DISABLE       0x1U
+#define MSTR_LPDDR4_MASK                 0x20U
+#define MSTR_LPDDR4_VAL                  0x20U
 
 /* Performance monitoring registers */
-#define    PERF_BASE_ADDR                   0x403E0000
-#define    OFFSET_MRR_0_DATA_REG_ADDR       0x40
-#define    OFFSET_MRR_1_DATA_REG_ADDR       0x44
+#define PERF_BASE_ADDR                   0x403E0000
+#define OFFSET_MRR_0_DATA_REG_ADDR       0x40
+#define OFFSET_MRR_1_DATA_REG_ADDR       0x44
 
 /* uMCTL2 Multi-Port Registers */
-#define	   DDRC_UMCTL2_MP_BASE_ADDR         0x403C03F8
-#define    OFFSET_DDRC_PCTRL_0              0x98
-#define    OFFSET_DDRC_PCTRL_1              0x148
-#define    OFFSET_DDRC_PCTRL_2              0x1f8
+#define DDRC_UMCTL2_MP_BASE_ADDR         0x403C03F8
+#define OFFSET_DDRC_PCTRL_0              0x98
+#define OFFSET_DDRC_PCTRL_1              0x148
+#define OFFSET_DDRC_PCTRL_2              0x1f8
 
 /* PHY related */
-#define    DDR_PHYA_MASTER0_CALBUSY                 0x4038165C
-#define    DDR_PHYA_APBONLY_UCTSHSADOWREGS          0x40380404
-#define    DDR_PHYA_MASTER_PUBMODE                  0x403815d0
-#define    UCT_WRITE_PROT_SHADOW_MASK               0x1
-#define    DDR_PHYA_APBONLY_DCTWRITEPROT            0x4038040C
-#define    DDR_PHYA_APBONLY_UCTWRITEONLYSHADOW      0x40380410
-#define    OFFSET_DDRC_RFSHCTL3                     0x60
+#define DDR_PHYA_MASTER0_CALBUSY                 0x4038165C
+#define DDR_PHYA_APBONLY_UCTSHSADOWREGS          0x40380404U
+#define UCT_WRITE_PROT_SHADOW_MASK               0x1U
+#define DDR_PHYA_APBONLY_DCTWRITEPROT            0x4038040C
+#define DDR_PHYA_APBONLY_UCTWRITEONLYSHADOW      0x40380410
+#define OFFSET_DDRC_RFSHCTL3                     0x60
+#define DDR_PHYA_UCCLKHCLKENABLES                0x40380BEC
+
+#define SHIFT_BIT(nr)             ((1UL) << (nr))
+#define UCCLKEN_MASK              SHIFT_BIT(0)
+#define HCLKEN_MASK               SHIFT_BIT(1)
+#define OFFSET_DDRC_INIT0         0xd0
+
+#define STORE_CSR_MASK            SHIFT_BIT(0)
+#define INIT_MEM_MASK             SHIFT_BIT(1)
+#define SCRUB_EN_MASK             SHIFT_BIT(0)
+#define SCRUB_BUSY_MASK           SHIFT_BIT(0)
+#define SELFREF_SW_MASK           SHIFT_BIT(5)
+#define SELFREF_TYPE_MASK         (SHIFT_BIT(4) | SHIFT_BIT(5))
+#define OPERATING_MODE_MASK       (SHIFT_BIT(0) | SHIFT_BIT(1) | SHIFT_BIT(2))
+#define DFI_INIT_COMPLETE_MASK    SHIFT_BIT(0)
+#define DFI_INIT_START_MASK       SHIFT_BIT(5)
+#define SW_DONE_ACK_MASK          SHIFT_BIT(0)
+#define SW_DONE_MASK              SHIFT_BIT(0)
+#define SKIP_DRAM_INIT_MASK       (SHIFT_BIT(30) | SHIFT_BIT(31))
+
+/* Standby SRAM */
+#define STNDBY_RAM_BASE           0x24000000
+#define RETENTION_ADDR            BL31SSRAM_CSR_BASE
 
 /* DDR Subsystem */
-#define    DDR_SS_REG                    0x403D0000
+#define DDR_SS_REG                0x403D0000
 
 /* Reset Generation Module */
-#define    MC_RGM_PRST_0                 0x40078040
+#define MC_RGM_PRST_0             0x40078040
 #ifndef MC_CGM5_BASE_ADDR
-#define    MC_CGM5_BASE_ADDR             0x40068000
+#define MC_CGM5_BASE_ADDR         0x40068000
 #endif
-#define    OFFSET_MUX_0_CSS              0x304
-#define    OFFSET_MUX_0_CSC              0x300
-#define    MC_CGM_MUX_0_DIV_UPD_STAT     0x33C
-#define    FIRC_CLK_SRC                  0x0
-#define    DDR_PHI0_PLL                  0x24
+#define OFFSET_MUX_0_CSS          0x304
+#define OFFSET_MUX_0_CSC          0x300
+#define FIRC_CLK_SRC              0x0
+#define DDR_PHI0_PLL              0x24
 
 /* Default timeout for DDR PHY operations */
 #define DEFAULT_TIMEOUT 1000000
@@ -132,26 +161,29 @@
 #define DMEM_START_ADDR 0x403B0000
 
 /* ERR050543 related defines */
-#define MR4 4
+#define MR4_IDX 4
 #define TUF_THRESHOLD 3
 #define REQUIRED_OK_CHECKS 3
 
-/**
- * @brief Set default AXI parity.
- */
+/* ERR050760 related defines */
+#define REQUIRED_MRSTAT_READS 2
+
+extern uint8_t polling_needed;
+
+/* Set default AXI parity. */
 uint32_t set_axi_parity(void);
 
-/**
- * @brief Post PHY train setup - complementary settings
+/*
+ * Post PHY train setup - complementary settings
  * that needs to be performed after running the firmware.
+ * @param options - various flags controlling post training actions
+ * (whether to init memory with ECC scrubber / whether to store CSR)
  */
-uint32_t post_train_setup(bool init_mem);
+uint32_t post_train_setup(uint8_t options);
 
+/* Wait until firmware finishes execution and return training result */
 uint32_t wait_firmware_execution(void);
 
-uint32_t load_register_array(uint32_t reg_writes,
-			     uint32_t array[][2]);
-
 /* Initialize memory with the ecc scrubber */
 uint32_t init_memory_ecc_scrubber(void);
 
@@ -194,6 +226,9 @@ uint32_t enable_derating_temp_errata(void);
  * parameters
  * @return - Returns 1, if the errata changes are reverted, 0 otherwise
  */
-int poll_derating_temp_errata(bool traffic_halted);
+uint32_t poll_derating_temp_errata(bool traffic_halted);
+
+/* Modify bitfield value with delta, given bitfield position and mask */
+bool update_bf(uint32_t *v, uint8_t pos, uint32_t mask, int32_t delta);
 
 #endif /* DDR_UTILS_H_ */
diff --git a/include/drivers/nxp/s32g/ddr/ddrss.h b/include/drivers/nxp/s32g/ddr/ddrss.h
deleted file mode 100644
index a12297caf..000000000
--- a/include/drivers/nxp/s32g/ddr/ddrss.h
+++ /dev/null
@@ -1,18 +0,0 @@
-/*
- * Copyright 2019-2021 NXP
- *
- * SPDX-License-Identifier: BSD-3-Clause
- */
-
-#ifndef DDRSS_H
-#define DDRSS_H
-
-#include <ddr/ddr_init.h>
-#include <lib/mmio.h>
-#include <stddef.h>
-
-void store_csr(uintptr_t store_at);
-void ddrss_to_io_lp3_retention_mode(void);
-int ddrss_to_normal_mode(uintptr_t csr_array);
-
-#endif
diff --git a/plat/nxp/s32g/bl31_ssram/include/ssram_mailbox.h b/include/plat/nxp/s32g/bl31_ssram/ssram_mailbox.h
similarity index 100%
rename from plat/nxp/s32g/bl31_ssram/include/ssram_mailbox.h
rename to include/plat/nxp/s32g/bl31_ssram/ssram_mailbox.h
diff --git a/plat/nxp/s32g/bl31_sram/bl31_sram.mk b/plat/nxp/s32g/bl31_sram/bl31_sram.mk
index eb5bf04f3..71bb15e08 100644
--- a/plat/nxp/s32g/bl31_sram/bl31_sram.mk
+++ b/plat/nxp/s32g/bl31_sram/bl31_sram.mk
@@ -13,7 +13,7 @@ BL31SRAM_SOURCES = plat/common/aarch64/platform_up_stack.S \
 		   plat/nxp/s32g/s32g_linflexuart.c \
 		   plat/nxp/s32g/s32g_linflexuart_crash.S \
 		   drivers/nxp/uart/linflexuart.c \
-		   ${DDR_DRV}/ddrss.c \
+		   ${DDR_DRV}/ddr_lp_mmio.c \
 
 BL31SRAM_ARRAY_NAME ?= bl31sram
 BL31SRAM_ARRAY_LEN  ?= bl31sram_len
diff --git a/plat/nxp/s32g/bl31_sram/bl31sram_main.c b/plat/nxp/s32g/bl31_sram/bl31sram_main.c
index a330df3e2..2df5e575c 100644
--- a/plat/nxp/s32g/bl31_sram/bl31sram_main.c
+++ b/plat/nxp/s32g/bl31_sram/bl31sram_main.c
@@ -1,5 +1,5 @@
 /*
- * Copyright 2020 NXP
+ * Copyright 2020-2021 NXP
  *
  * SPDX-License-Identifier: BSD-3-Clause
  */
@@ -7,7 +7,7 @@
 #include <plat/common/platform.h>
 
 #include "bl31_sram.h"
-#include "ddr/ddrss.h"
+#include "ddr/ddr_lp.h"
 #include "s32g_clocks.h"
 #include "s32g_mc_me.h"
 
@@ -21,7 +21,7 @@ static void disable_ddr_clk(void)
 void bl31sram_main(void)
 {
 	disable_mmu_el3();
-	ddrss_to_io_lp3_retention_mode();
+	ddrss_to_io_retention_mode();
 	disable_ddr_clk();
 
 	s32g_disable_fxosc();
diff --git a/plat/nxp/s32g/bl31_ssram/bl31ssram_main.c b/plat/nxp/s32g/bl31_ssram/bl31ssram_main.c
index 78e3f26ac..14bbb6506 100644
--- a/plat/nxp/s32g/bl31_ssram/bl31ssram_main.c
+++ b/plat/nxp/s32g/bl31_ssram/bl31ssram_main.c
@@ -4,11 +4,11 @@
  * SPDX-License-Identifier: BSD-3-Clause
  */
 #include <common/debug.h>
-#include <drivers/nxp/s32g/ddr/ddrss.h>
 #include <plat/common/platform.h>
+#include <drivers/nxp/s32g/ddr/ddr_lp.h>
 #include <platform_def.h>
 #include <s32g_clocks.h>
-#include <ssram_mailbox.h>
+#include <plat/nxp/s32g/bl31_ssram/ssram_mailbox.h>
 #include <s32g_ivt.h>
 
 #include "bl31_ssram.h"
diff --git a/plat/nxp/s32g/s32g_bl2_el3.c b/plat/nxp/s32g/s32g_bl2_el3.c
index 8beac0527..c57da23a2 100644
--- a/plat/nxp/s32g/s32g_bl2_el3.c
+++ b/plat/nxp/s32g/s32g_bl2_el3.c
@@ -24,12 +24,12 @@
 #include "s32g_bl_common.h"
 #include <ddr/ddr_init.h>
 #include <drivers/generic_delay_timer.h>
-#include <ssram_mailbox.h>
+#include <plat/nxp/s32g/bl31_ssram/ssram_mailbox.h>
 #include "s32g_sramc.h"
 #include <lib/libfdt/libfdt.h>
 #include <drivers/io/io_storage.h>
-#include <drivers/nxp/s32g/ddr/ddrss.h>
 #include <tools_share/firmware_image_package.h>
+#include <drivers/nxp/s32g/ddr/ddr_lp.h>
 
 #define S32G_FDT_UPDATES_SPACE		100U
 
diff --git a/plat/nxp/s32g/s32g_common.mk b/plat/nxp/s32g/s32g_common.mk
index 437a0a9ad..c913fe0dd 100644
--- a/plat/nxp/s32g/s32g_common.mk
+++ b/plat/nxp/s32g/s32g_common.mk
@@ -23,7 +23,8 @@ DDR_DRV_SRCS = \
 	${DDR_DRV}/ddr_init.c \
 	${DDR_DRV}/ddr_utils_mmio.c \
 	${DDR_DRV}/ddrc_cfg.c \
-	${DDR_DRV}/ddrss.c \
+	${DDR_DRV}/ddr_lp_mmio.c \
+	${DDR_DRV}/ddr_lp_csr.c \
 	${DDR_DRV}/ddrss_cfg.c \
 	${DDR_DRV}/dmem_cfg.c \
 	${DDR_DRV}/dq_swap_cfg.c \
diff --git a/plat/nxp/s32g/s32g_psci.c b/plat/nxp/s32g/s32g_psci.c
index ce5654965..cbda2a96b 100644
--- a/plat/nxp/s32g/s32g_psci.c
+++ b/plat/nxp/s32g/s32g_psci.c
@@ -1,5 +1,5 @@
 /*
- * Copyright 2019-2020 NXP
+ * Copyright 2019-2021 NXP
  *
  * SPDX-License-Identifier: BSD-3-Clause
  */
@@ -9,7 +9,7 @@
 #include "s32g_lowlevel.h"
 #include "s32g_mc_me.h"
 #include "s32g_ncore.h"
-#include "ssram_mailbox.h"
+#include <plat/nxp/s32g/bl31_ssram/ssram_mailbox.h>
 #include "s32g_resume.h"
 #include "s32g_bl_common.h"
 #include "s32g_sramc.h"
-- 
2.17.1

