From a030044d9c702085853dec0348334513319332de Mon Sep 17 00:00:00 2001
From: Larisa <larisa.grigore@nxp.com>
Date: Tue, 14 Apr 2020 16:15:02 +0300
Subject: [PATCH 088/269] i2c: Add i2c clock

Issue: ALB-4871
Upstream-Status: Pending 

Signed-off-by: Larisa Grigore <larisa.grigore@nxp.com>
Signed-off-by: Zhantao Tang <zhantao.tang@windriver.com>
---
 plat/s32g/include/s32g_clocks.h | 14 +++++++++++++-
 plat/s32g/s32g_clocks.c         | 30 +++++++++++++++++++++++++++++-
 2 files changed, 42 insertions(+), 2 deletions(-)

diff --git a/plat/s32g/include/s32g_clocks.h b/plat/s32g/include/s32g_clocks.h
index c98175be8..32ba76147 100644
--- a/plat/s32g/include/s32g_clocks.h
+++ b/plat/s32g/include/s32g_clocks.h
@@ -6,7 +6,6 @@
 #ifndef _S32G_CLOCKS_H_
 #define _S32G_CLOCKS_H_
 
-
 #define S32G_FXOSC_FREQ		(40000000ul)
 #define S32G_FIRC_FREQ		(48000000ul)
 #define S32G_ERR_CLK_FREQ	(0ul)
@@ -227,6 +226,7 @@ s32g_periph_dfs_params[S32G_DFS_PORTS_NR][DFS_PARAMS_NR] = {
  * as it cannot be determined at run-time.
  */
 #define SDHC_CLK_FREQ		(200 * 1000 * 1000)
+#define I2C_CLK_FREQ		(133 * 1000 * 1000)
 
 /*
  * Platform reference clocks
@@ -282,10 +282,21 @@ enum s32g_mc_cgm {
 
 #define CGM_MUXn_CSC(cgm_addr, mux)	(((cgm_addr) + 0x300 + (mux) * 0x40))
 #define CGM_MUXn_CSS(cgm_addr, mux)	(((cgm_addr) + 0x304 + (mux) * 0x40))
+
 #define CGM_MUXn_DCn(cgm_addr, mux, dc)		\
 			(((cgm_addr) + 0x308 + (mux) * 0x40 + (dc) * 0x4))
+#define MC_CGM_MUXn_DCn_DIV(val)	(MC_CGM_MUXn_DCn_DIV_MASK & ((val) \
+			<< MC_CGM_MUXn_DCn_DIV_OFFSET))
+#define MC_CGM_MUXn_DCn_DIV_MASK	(0x00070000)
+#define MC_CGM_MUXn_DCn_DIV_OFFSET	(16)
+
 #define CGM_MUXn_DIV_UPD_STAT(cgm_addr, mux)	\
 			(((cgm_addr) + 0x33c + (mux) * 0x40))
+#define MC_CGM_MUXn_DIV_UPD_STAT_DIVSTAT(css)	\
+			((MC_CGM_MUXn_DIV_UPD_STAT_DIVSTAT_MASK & (css)) \
+			>> MC_CGM_MUXn_DIV_UPD_STAT_DIVSTAT_OFFSET)
+#define MC_CGM_MUXn_DIV_UPD_STAT_DIVSTAT_MASK	(0x00000001)
+#define MC_CGM_MUXn_DIV_UPD_STAT_DIVSTAT_OFFSET	(0)
 
 #define CGM0_MUXn_CSC(mux)	(CGM_MUXn_CSC(MC_CGM0_BASE_ADDR, mux))
 #define CGM0_MUXn_DCn(mux, dc)	(CGM_MUXn_DCn(MC_CGM0_BASE_ADDR, mux, dc))
@@ -303,6 +314,7 @@ enum s32g_mc_cgm {
 
 #define MC_CGM_MUXn_CSC_SEL_CORE_PLL_FIRC	0
 #define MC_CGM_MUXn_CSC_SEL_CORE_PLL_PHI0	4
+#define MC_CGM_MUXn_CSC_SEL_CORE_PLL_DFS1	12
 #define MC_CGM_MUXn_CSC_SEL_PERIPH_PLL_PHI3	21
 #define MC_CGM_MUXn_CSC_SEL_DDR_PLL_PHI0	36
 #define MC_CGM_MUXn_CSC_SEL_PERIPH_PLL_PHI0	18
diff --git a/plat/s32g/s32g_clocks.c b/plat/s32g/s32g_clocks.c
index d1ef9205b..ee89edc8c 100644
--- a/plat/s32g/s32g_clocks.c
+++ b/plat/s32g/s32g_clocks.c
@@ -1,5 +1,5 @@
 /*
- * Copyright 2019 NXP
+ * Copyright 2019-2020 NXP
  *
  * SPDX-License-Identifier: BSD-3-Clause
  */
@@ -275,6 +275,31 @@ int sw_mux_clk_config(uint8_t cgm, uint8_t mux, uint8_t source)
 	return -EIO;
 }
 
+/* Program a software-controlled clock divider as per chapter
+ * "Clock Generation Module (MC_CGM)::
+ *    Functional description::
+ *      Clock dividers"
+ */
+int sw_mux_div_clk_config(uint8_t cgm, uint8_t mux, uint8_t dc, uint8_t divider)
+{
+	uintptr_t cgm_addr;
+
+	cgm_addr = mc_cgm_addr(cgm);
+	if (cgm_addr == S32G_ERR_PTR)
+		return -EINVAL;
+
+	/* set the divider */
+	mmio_write_32(CGM_MUXn_DCn(cgm_addr, mux, dc),
+			MUXn_DCn_DE | MC_CGM_MUXn_DCn_DIV(divider));
+
+	/* Wait for divider gets updated */
+	while (MC_CGM_MUXn_DIV_UPD_STAT_DIVSTAT
+			(mmio_read_32(CGM_MUXn_DIV_UPD_STAT(cgm_addr, mux))))
+		;
+
+	return 0;
+}
+
 static bool is_a53_core_clk_supported(uint64_t clk)
 {
 	int i;
@@ -357,6 +382,9 @@ void s32g_plat_clock_init(void)
 	program_dfs(S32G_CORE_DFS, s32g_core_dfs_params);
 	/* Configure the core CGM mux */
 	sw_mux_clk_config(MC_CGM1, 0, MC_CGM_MUXn_CSC_SEL_CORE_PLL_PHI0);
+	/* Configure the XBAR CGM mux and div */
+	sw_mux_clk_config(MC_CGM0, 0, MC_CGM_MUXn_CSC_SEL_CORE_PLL_DFS1);
+	sw_mux_div_clk_config(MC_CGM0, 0, 0, 1);
 
 	/* Configure the PERIPH_PLL */
 	program_pll(S32G_PERIPH_PLL, S32G_REFCLK_FXOSC,
-- 
2.17.1

