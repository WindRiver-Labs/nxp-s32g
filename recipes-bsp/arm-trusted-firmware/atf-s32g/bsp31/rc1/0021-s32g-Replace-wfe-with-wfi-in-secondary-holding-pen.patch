From ef297e7e700e3b2a42e3c6a678500909ff8a302b Mon Sep 17 00:00:00 2001
From: Bogdan Hamciuc <bogdan.hamciuc@nxp.com>
Date: Mon, 1 Jul 2019 12:10:01 +0300
Subject: [PATCH 021/269] s32g: Replace wfe with wfi in secondary holding pen

Set up GICv3 for the secondary cores such that we can wake them up from
'wfi' using an SGI sent from the primary core during Linux kernel boot.
The Awakening happens upon a PSCI_CPU_ON call initiated by the kernel.

Upstream-Status: Pending 

Signed-off-by: Bogdan Hamciuc <bogdan.hamciuc@nxp.com>
Signed-off-by: Zhantao Tang <zhantao.tang@windriver.com>
Issue: ALB-3892
---
 plat/s32g/include/platform_def.h |   2 +
 plat/s32g/s32g275_bl31.c         |  14 ++--
 plat/s32g/s32g_helpers.S         | 112 ++++++++++++++++++++++++++++---
 plat/s32g/s32g_psci.c            |  40 +++++++++--
 4 files changed, 147 insertions(+), 21 deletions(-)

diff --git a/plat/s32g/include/platform_def.h b/plat/s32g/include/platform_def.h
index 37e4412f7..aec34ceda 100644
--- a/plat/s32g/include/platform_def.h
+++ b/plat/s32g/include/platform_def.h
@@ -57,6 +57,8 @@
 #define PLAT_GICD_BASE		S32G275_GIC_BASE
 #define PLAT_GICR_BASE		(S32G275_GIC_BASE + 0x80000)
 #define S32G275_GIC_SIZE	0x100000
+/* SGI to use for kicking the secondary cores out of wfi */
+#define S32G_SECONDARY_WAKE_SGI	15
 
 /*
  * Platform memory map
diff --git a/plat/s32g/s32g275_bl31.c b/plat/s32g/s32g275_bl31.c
index 65303fba5..94beca9fe 100644
--- a/plat/s32g/s32g275_bl31.c
+++ b/plat/s32g/s32g275_bl31.c
@@ -10,6 +10,7 @@
 #include <psci.h>
 #include <drivers/arm/gicv3.h>
 #include <lib/xlat_tables/xlat_tables_v2.h>
+#include <lib/mmio.h>
 
 #include "platform_def.h"
 #include "s32g_psci.h"
@@ -38,7 +39,10 @@ static entry_point_info_t bl33_image_ep_info;
 
 static uintptr_t rdistif_base_addrs[PLATFORM_CORE_COUNT];
 
-static const interrupt_prop_t interrupt_props[] = {};
+static const interrupt_prop_t interrupt_props[] = {
+	INTR_PROP_DESC(S32G_SECONDARY_WAKE_SGI, GIC_HIGHEST_SEC_PRIORITY,
+		       INTR_GROUP0, GIC_INTR_CFG_EDGE),
+};
 
 static unsigned int plat_s32g275_mpidr_to_core_pos(unsigned long mpidr);
 /* Declare it here to avoid including plat/common/platform.h */
@@ -151,12 +155,10 @@ static void s32g_el3_mmu_fixup(void)
 
 void s32g_gic_setup(void)
 {
-	if (plat_is_my_cpu_primary()) {
 #if IMAGE_BL31
-		gicv3_driver_init(&s32g275_gic_data);
+	gicv3_driver_init(&s32g275_gic_data);
 #endif
-		gicv3_distif_init();
-	}
+	gicv3_distif_init();
 	gicv3_rdistif_init(plat_my_core_pos());
 	gicv3_cpuif_enable(plat_my_core_pos());
 }
@@ -165,7 +167,7 @@ void bl31_plat_arch_setup(void)
 {
 	s32g_smp_fixup();
 	s32g_el3_mmu_fixup();
-	/* kick secondary cores out of reset (but will leave them in wfe) */
+	/* kick secondary cores out of reset (but will leave them in wfi) */
 	s32g_kick_secondary_ca53_cores();
 }
 
diff --git a/plat/s32g/s32g_helpers.S b/plat/s32g/s32g_helpers.S
index c0110d62a..28433369b 100644
--- a/plat/s32g/s32g_helpers.S
+++ b/plat/s32g/s32g_helpers.S
@@ -6,6 +6,7 @@
 
 #include <asm_macros.S>
 #include <console_macros.S>
+#include <drivers/arm/gicv3.h>
 #include "platform_def.h"
 
 .globl plat_is_my_cpu_primary
@@ -20,7 +21,7 @@
 
 .globl s32g_smp_fixup
 
-.globl s32g_core_release_var;
+.globl s32g_core_release_var
 
 /* Set SMPEN bit on u-boot's behalf */
 func s32g_smp_fixup
@@ -54,22 +55,117 @@ func plat_my_core_pos
 	ret
 endfunc plat_my_core_pos
 
+/* Clear GICR_WAKER[ProcessorSleep] bit.
+ * Returns in x8 the base address of the current Redistributor.
+ *
+ * Clobber list: x7,x8,x9,x10,x11
+ */
+func gicr_waker_wake
+	mov	x11, x30
+	mov	x7, x0
+	bl	plat_my_core_pos
+
+	/* Find offset of our Redistributor */
+	mov	x8, #PLAT_GICR_BASE
+dec:
+	cbz	x0, clear_ps
+	mov	x9, #2
+	add	x8, x8, x9, lsl #16
+	mov	x9, #1
+	sub	x0, x0, x9
+	b	dec
+clear_ps:
+	/* Clear the PS bit */
+	ldr	w9, [x8, #GICR_WAKER]
+	movz	w10, #1
+	mvn	w10, w10, lsl #WAKER_PS_SHIFT
+	and	w9, w9, w10
+	str	w9, [x8, #GICR_WAKER]
+	dsb	st
+	isb
+	/* Wait for hw confirmation */
+children_asleep:
+	ldr	w9, [x8, #GICR_WAKER]
+	tbnz	w9, #WAKER_CA_SHIFT, children_asleep
+
+	mov	x0, x7
+	mov	x30, x11
+	ret
+endfunc gicr_waker_wake
+
+/* GICR and GICC initializations for the secondary core.
+ *
+ * This is a close equivalent of gicv3_cpuif_enable() that we need to make
+ * ourselves here, because:
+ *   a) GICR_WAKER must be cleared before accessing most of the ICC_* regs;
+ *   b) the ICC_* registers are not memory-mapped, so the primary core cannot
+ *   do these initializations on our behalf.
+ *
+ * Clobber list: x7,x8,x9,x10,x11,x13
+ */
+func s32g_gic_fixups_for_secondary
+	mov	x13, x30
+	bl	gicr_waker_wake
+
+	/* Clear any pending interrupts before we go into wfi */
+	mov	x7, #0x1
+	lsl	x7, x7, #16	/* #GICR_SGIBASE_OFFSET */
+	add	x7, x7, #0x280	/* partial offset of #GICR_ICPENDR0 */
+	mov	x9, xzr
+	mvn	x9, x9
+	str	w9, [x8, x7] /* x8 was set by gicr_waker_wake */
+	dsb	sy
+
+	/* SRE */
+	mrs	x8, ICC_SRE_EL3
+	orr	x8, x8, #0xf
+	msr	ICC_SRE_EL3, x8
+	isb
+	/* Switch to NS state to write non secure ICC_SRE_EL2 and ICC_SRE_EL1 */
+	mov	x8, xzr
+	msr	SCR_EL3, x8
+	isb
+	/* ICC_SRE_EL2 and ICC_SRE_EL1 are left to the lower levels */
+
+	/* Revert to secure state and set up the rest of SCR_EL3 */
+	mov	x8, xzr
+	orr	x8, x8, #SCR_RW_BIT
+	/* Leave IRQ, FIQ, EA bits cleared */
+	msr	SCR_EL3, x8
+	isb
+
+	/* Set interrupt priority filter */
+	movz	x8, #0xff
+	msr	ICC_PMR_EL1, x8
+	isb
+
+	msr	ICC_CTLR_EL3, xzr
+	msr	ICC_CTLR_EL1, xzr
+
+	/* Enable Group 0 (must come after ICC_PMR_EL1) */
+	movz	x8, #0x1
+	msr	ICC_IGRPEN0_EL1, x8
+
+	isb
+
+	mov	x30, x13
+	ret
+endfunc s32g_gic_fixups_for_secondary
+
 /*
- * Clobber list: x7, x8
+ * Clobber list: x0,x7,x8,x9,x10,x11,x13
  */
 func plat_secondary_cold_boot_setup
-	dsb	sy
-	ldr	x7, =s32g_core_release_var
+	bl	s32g_gic_fixups_for_secondary
 	bl	plat_my_core_pos
 	lsl	x0, x0, #2	/* array elements are of size 32-bit*/
+	ldr	x7, =s32g_core_release_var
 pen:
+	dsb	sy
 	/* index with current core id */
 	ldr	w8, [x7, x0]
 	cbnz	w8, wfi_done
-	/* TODO: replace these with a wfi and use an SGI to wake the core */
-	sevl
-	wfe
-	wfe
+	wfi
 	b	pen
 wfi_done:
 	/* reset condition variable */
diff --git a/plat/s32g/s32g_psci.c b/plat/s32g/s32g_psci.c
index 46a9e0d5d..03bc3f4fe 100644
--- a/plat/s32g/s32g_psci.c
+++ b/plat/s32g/s32g_psci.c
@@ -5,10 +5,12 @@
  */
 #include <arch_helpers.h>
 #include <bl31/bl31.h>		/* for bl31_warm_entrypoint() */
+#include <bl31/interrupt_mgmt.h>
 #include <string.h>
 #include <assert.h>
 #include <common/debug.h>	/* printing macros such as INFO() */
 #include <plat/common/platform.h>
+#include <drivers/arm/gicv3.h>
 
 #include "platform_def.h"
 
@@ -28,26 +30,50 @@ static const unsigned char s32g_power_domain_tree_desc[] = {
 	PLATFORM_CORE_COUNT / 2
 };
 
+/** Executed by the running (primary) core as part of the PSCI_CPU_ON
+ *  call, e.g. during Linux kernel boot.
+ */
 static int s32g_pwr_domain_on(u_register_t mpidr)
 {
 	int pos;
 
 	pos = plat_core_pos_by_mpidr(mpidr);
-	NOTICE("S32G TF-A: %s: booting up core %d\n", __func__, pos);
-
 	s32g_core_release_var[pos] = 1;
 	dsbsy();
-	sev();
+
+	/* Do some chores on behalf of the secondary core. ICC setup must be
+	 * done by the secondaries, because the interface is not memory-mapped.
+	 */
+	gicv3_rdistif_init(pos);
+	/* GICR_IGROUPR0, GICR_IGRPMOD0 */
+	gicv3_set_interrupt_type(S32G_SECONDARY_WAKE_SGI, pos, INTR_GROUP0);
+	/* GICR_ISENABLER0 */
+	gicv3_enable_interrupt(S32G_SECONDARY_WAKE_SGI, pos);
+
+	/* Kick the secondary core out of wfi */
+	NOTICE("S32G TF-A: %s: booting up core %d\n", __func__, pos);
+	plat_ic_raise_el3_sgi(S32G_SECONDARY_WAKE_SGI, mpidr);
 
 	return PSCI_E_SUCCESS;
 }
 
+/** Executed by the woken (secondary) core after it exits the wfi holding pen.
+ */
 static void s32g_pwr_domain_on_finish(const psci_power_state_t *target_state)
 {
-	NOTICE("S32G TF-A: %s\n", __func__);
-	/* At cold boot, the primary core has already done this. */
-	s32g_smp_fixup();
-	s32g_gic_setup();
+	int pos;
+	unsigned int intid;
+
+	NOTICE("S32G TF-A: %s: cpu %d running\n", __func__, plat_my_core_pos());
+
+	/* Clear pending interrupt */
+	pos = plat_my_core_pos();
+	while ((intid = gicv3_get_pending_interrupt_id()) <= MAX_SPI_ID) {
+		if (intid != S32G_SECONDARY_WAKE_SGI)
+			WARN("%s(): Interrupt %d found pending instead of the expected %d\n",
+			     __func__, intid, S32G_SECONDARY_WAKE_SGI);
+		gicv3_clear_interrupt_pending(intid, pos);
+	}
 }
 
 /* Temp fixups to work around the fact that we are not really powering down
-- 
2.17.1

