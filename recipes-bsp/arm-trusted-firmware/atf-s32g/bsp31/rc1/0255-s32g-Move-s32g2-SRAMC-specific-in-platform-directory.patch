From 28c729564be8d3c5b4fc64efd567dd2de9e32fa8 Mon Sep 17 00:00:00 2001
From: Larisa Grigore <larisa.grigore@nxp.com>
Date: Thu, 1 Jul 2021 11:57:30 +0300
Subject: [PATCH 255/269] s32g: Move s32g2 SRAMC specific in platform directory

Issue: ALB-7394
Upstream-Status: Pending 

Signed-off-by: Larisa Grigore <larisa.grigore@nxp.com>
Signed-off-by: Zhantao Tang <zhantao.tang@windriver.com>
---
 plat/nxp/s32g/include/s32g_sramc.h   |  16 +-
 plat/nxp/s32g/s32g2/platform.mk      |   1 +
 plat/nxp/s32g/s32g2/s32g2_sramc.S    | 264 +++++++++++++++++++++++++++
 plat/nxp/s32g/s32g2/s32g2_sramc.h    |  19 ++
 plat/nxp/s32g/s32g_lowlevel_common.S | 253 -------------------------
 5 files changed, 289 insertions(+), 264 deletions(-)
 create mode 100644 plat/nxp/s32g/s32g2/s32g2_sramc.S
 create mode 100644 plat/nxp/s32g/s32g2/s32g2_sramc.h

diff --git a/plat/nxp/s32g/include/s32g_sramc.h b/plat/nxp/s32g/include/s32g_sramc.h
index 03d57aff2..63ff3ad08 100644
--- a/plat/nxp/s32g/include/s32g_sramc.h
+++ b/plat/nxp/s32g/include/s32g_sramc.h
@@ -1,5 +1,5 @@
 /*
- * Copyright 2020 NXP
+ * Copyright 2020-2021 NXP
  *
  * SPDX-License-Identifier: BSD-3-Clause
  */
@@ -14,20 +14,14 @@
 #define SRAM_INV_BLOCK_MASK	(~(SRAM_BLOCK_MASK))
 
 #define SRAMC0_BASE_ADDR	0x4019C000
-#define SRAMC0_BASE_ADDD_H	(SRAMC0_BASE_ADDR >> 16)
-#define SRAMC0_BASE_ADDD_L	((SRAMC0_BASE_ADDR & 0xFFFF))
+#define SRAMC0_BASE_ADDR_H	(SRAMC0_BASE_ADDR >> 16)
+#define SRAMC0_BASE_ADDR_L	((SRAMC0_BASE_ADDR & 0xFFFF))
 #define SRAMC1_BASE_ADDR	0x401A0000
-#define SRAMC1_BASE_ADDD_H	(SRAMC1_BASE_ADDR >> 16)
-#define SRAMC1_BASE_ADDD_L	((SRAMC1_BASE_ADDR & 0xFFFF))
+#define SRAMC1_BASE_ADDR_H	(SRAMC1_BASE_ADDR >> 16)
+#define SRAMC1_BASE_ADDR_L	((SRAMC1_BASE_ADDR & 0xFFFF))
 #define SSRAMC_BASE_ADDR	0x44028000
 #define SRAMC_SIZE		0x3000
 
-/* Block ranges */
-#define SRAMC0_MIN_ADDR		(0x0)
-#define SRAMC0_MAX_ADDR		(0x7FFF)
-#define SRAMC1_MIN_ADDR		(SRAMC0_MAX_ADDR + 1)
-#define SRAMC1_MAX_ADDR		(0x10000)
-
 #define SRAMC_PRAMCR_OFFSET	0x0
 #define SRAMC_PRAMCR_INITREQ	BIT(0)
 #define SRAMC_PRAMIAS_OFFSET	0x4
diff --git a/plat/nxp/s32g/s32g2/platform.mk b/plat/nxp/s32g/s32g2/platform.mk
index a3ec9faf8..283239059 100644
--- a/plat/nxp/s32g/s32g2/platform.mk
+++ b/plat/nxp/s32g/s32g2/platform.mk
@@ -7,6 +7,7 @@
 include plat/nxp/s32g/s32g_common.mk
 
 PLAT_BL_COMMON_SOURCES	+= drivers/nxp/s32g/clk/s32g274a_clk.c \
+			   plat/nxp/s32g/s32g2/s32g2_sramc.S \
 
 # Device tree
 DTB_FILE_NAME		?= fsl-s32g274a-rdb.dtb
diff --git a/plat/nxp/s32g/s32g2/s32g2_sramc.S b/plat/nxp/s32g/s32g2/s32g2_sramc.S
new file mode 100644
index 000000000..9d853a34e
--- /dev/null
+++ b/plat/nxp/s32g/s32g2/s32g2_sramc.S
@@ -0,0 +1,264 @@
+/*
+ * Copyright 2019-2021 NXP
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ */
+
+#include <asm_macros.S>
+#include <console_macros.S>
+#include "platform_def.h"
+#include "s32g2_sramc.h"
+#include <lib/utils_def.h>
+
+.globl _s32g_sram_clr
+
+/*
+ * Translate a bus address in SRAM controller initialization address based on:
+ * mem_addr[16:0] = {bus_addr[23:9], bus_addr[5:4]}
+ *
+ * addr := ((addr >> 9) << 2) | ((addr >> 4) & 0x3);
+ *
+ * x0: SRAM bus address
+ * ret: x0: Initialization address
+ *
+ * Clobber list: x0,x4,x5
+ */
+func calc_sramc_addr
+	lsr	x4, x0, #9
+	lsl	x4, x4, #2
+	lsr	x5, x0, #4
+	and	x5, x5, #3
+	orr	x0, x4, x5
+	ret
+endfunc calc_sramc_addr
+
+/**
+ * Check if two intervals are in overlap
+ *
+ * x0: start index of the first interval
+ * x1: end index of the first interval
+ * x2: start index of the second interval
+ * x3: end index of the second interval
+ *
+ * x0: return 0 if the intervals do not overlap and 1 otherwise
+ * Clobber list: x0,x1,x2,x3,x4,x5,x6
+ */
+func in_overlap
+	/* x4 = max */
+	cmp	x1, x3
+	b.gt	1f
+	mov	x4, x3
+	b	2f
+1:
+	mov	x4, x1
+2:
+	/* x5 = min */
+	cmp	x0, x2
+	b.lt	3f
+	mov	x5, x2
+	b	4f
+3:
+	mov	x5, x0
+4:
+	/* x5 = max - min */
+	sub	x5, x4, x5
+	/* x4 = first interval size */
+	sub	x4, x1, x0
+	/* x6 = second interval size */
+	sub	x6, x3, x2
+	/* x4 = len1 + len2 */
+	add	x4, x4, x6
+	cmp	x4, x5
+	bgt	overlap
+	mov	x0, #0
+	ret
+overlap:
+	mov	x0, #1
+	ret
+endfunc in_overlap
+
+/**
+ * Clear SRAM range using SRAM controller
+ *
+ * x0: SRAM controller address
+ * x1: Initialization Start Address
+ * x2: Initialization End Address
+ *
+ * Clobber list: x0,x1,x2,x3
+ */
+func clear_sramc_range
+	/* Disable the module */
+	mov	x3, #0
+	str	w3, [x0, #SRAMC_PRAMCR_OFFSET]
+
+	/* Address range */
+	str	w1, [x0, #SRAMC_PRAMIAS_OFFSET]
+	str	w2, [x0, #SRAMC_PRAMIAE_OFFSET]
+
+	/* Request initialization */
+	mov	x3, #SRAMC_PRAMCR_INITREQ
+	str	w3, [x0, #SRAMC_PRAMCR_OFFSET]
+
+wait_init:
+	ldr	w3, [x0, #SRAMC_PRAMSR_OFFSET]
+	and	w3, w3, #SRAMC_PRAMSR_IDONE
+	cbz	w3, wait_init
+
+	/* Clear status */
+	mov	w3, #SRAMC_PRAMSR_IDONE
+	str	w3, [x0, #SRAMC_PRAMSR_OFFSET]
+
+	ret
+endfunc clear_sramc_range
+
+/* x0: start address of memory area to clear
+ * x1: end address of memory area to clear
+ *
+ * Clobber list: x0,x1,x9,x10
+ */
+func a53_sram_clr
+	mov	x10, #0x0
+	cmp	x1, x0
+	bgt	pos_step
+	mov	x9, #-8
+	b	clr_loop
+pos_step:
+	mov	x9, #8
+clr_loop:
+	cmp	x1, x0
+	beq	finish
+	str	x10, [x0]
+	add	x0, x0, x9
+	b	clr_loop
+finish:
+	ret
+endfunc a53_sram_clr
+
+func clear_unaligned_ends
+	/* Save x30 */
+	mov	x12, x30
+	/*
+	 * Obtain SRAM addresses
+	 */
+	mov	x9, #S32G_SRAM_BASE
+	add	x11, x1, x9
+	add	x9, x0, x9
+
+	and	x1, x9, #SRAM_INV_BLOCK_MASK
+	cmp	x1, x9
+	beq	clear_end
+	add	x1, x1, SRAM_BLOCK
+	mov	x0, x9
+	bl	a53_sram_clr
+
+clear_end:
+	and	x0, x11, #SRAM_INV_BLOCK_MASK
+	cmp	x0, x11
+	beq	clr_exit
+	mov	x1, x11
+	bl	a53_sram_clr
+clr_exit:
+	mov	x30, x12
+	ret
+endfunc clear_unaligned_ends
+
+/* x0: start address of memory area to clear
+ * x1: end address of memory area to clear
+ * x0: return 0 on error or size of memory cleared on success
+ *
+ * Clobber list: x0,x1,x2,x3,x4,x5,x6,x7,x8,x9,x11,x12,x13,x14,x15
+ */
+func _s32g_sram_clr
+	/* Save x30 */
+	mov	x15, x30
+
+	mov	x13, x0
+	mov	x14, x1
+	bl	clear_unaligned_ends
+	mov	x0, x13
+	mov	x1, x14
+
+	/* Align to SRAM blocks */
+	and	x9, x0, #SRAM_INV_BLOCK_MASK
+	cmp	x0, x9
+	beq	align_high_addr
+	add	x0, x9, SRAM_BLOCK
+
+align_high_addr:
+	and	x1, x1, #SRAM_INV_BLOCK_MASK
+
+	sub	x1, x1, #1
+	/* Low address */
+	bl	calc_sramc_addr
+	mov	x7, x0
+	mov	x0, x1
+
+	/* High address */
+	bl	calc_sramc_addr
+
+	/**
+	 * x7 - Low initialization address
+	 * x8 - High initialization address
+	 */
+	mov	x8, x0
+	mov	x9, #SRAMC1_MAX_ADDR
+	cmp	x8, x9
+	bgt	error
+
+	mov	x0, #SRAMC0_MIN_ADDR
+	mov	x1, #SRAMC0_MAX_ADDR
+	mov	x2, x7
+	mov	x3, x8
+	bl	in_overlap
+	cbnz	x0, init_sramc0
+
+check_sramc1:
+	mov	x0, #SRAMC1_MIN_ADDR
+	mov	x1, #SRAMC1_MAX_ADDR
+	mov	x2, x7
+	mov	x3, x8
+	bl	in_overlap
+	cbnz	x0, init_sramc1
+	b	sram_exit
+
+init_sramc0:
+	mov	x0, #SRAMC0_BASE_ADDR_L
+	movk	x0, #SRAMC0_BASE_ADDR_H, lsl #16
+	mov	x1, x7
+	mov	x2, x8
+	mov	x9, #SRAMC0_MAX_ADDR
+	cmp	x2, x9
+	b.gt	1f
+	b	2f
+1:
+	mov	x2, #SRAMC0_MAX_ADDR
+2:
+	bl	clear_sramc_range
+	b	check_sramc1
+
+init_sramc1:
+	mov	x0, #SRAMC1_BASE_ADDR_L
+	movk	x0, #SRAMC1_BASE_ADDR_H, lsl #16
+	cmp	x7, #SRAMC1_MIN_ADDR
+	b.lt	3f
+	sub	x1, x7, #SRAMC1_MIN_ADDR
+	b	4f
+3:
+	mov	x1, #0
+4:
+	sub	x2, x8, #SRAMC1_MIN_ADDR
+	bl	clear_sramc_range
+
+	mov	x0, #0
+
+sram_exit:
+	/* Restore x30 */
+	mov	x30, x15
+	ret
+
+error:
+	/* Restore x30 */
+	mov	x30, x15
+	mov	x0, #-1
+	ret
+endfunc _s32g_sram_clr
diff --git a/plat/nxp/s32g/s32g2/s32g2_sramc.h b/plat/nxp/s32g/s32g2/s32g2_sramc.h
new file mode 100644
index 000000000..5c7289480
--- /dev/null
+++ b/plat/nxp/s32g/s32g2/s32g2_sramc.h
@@ -0,0 +1,19 @@
+/*
+ * Copyright 2020-2021 NXP
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ */
+#ifndef S32G2_SRAMC_H
+#define S32G2_SRAMC_H
+
+#include <lib/utils_def.h>
+#include <s32g_sramc.h>
+
+/* Block ranges */
+#define SRAMC0_MIN_ADDR		(0x0)
+#define SRAMC0_MAX_ADDR		(0x7FFF)
+#define SRAMC1_MIN_ADDR		(SRAMC0_MAX_ADDR + 1)
+#define SRAMC1_MAX_ADDR		(0x10000)
+
+#endif
+
diff --git a/plat/nxp/s32g/s32g_lowlevel_common.S b/plat/nxp/s32g/s32g_lowlevel_common.S
index 4df4a9be1..b305d4374 100644
--- a/plat/nxp/s32g/s32g_lowlevel_common.S
+++ b/plat/nxp/s32g/s32g_lowlevel_common.S
@@ -7,14 +7,12 @@
 #include <asm_macros.S>
 #include <console_macros.S>
 #include "platform_def.h"
-#include "s32g_sramc.h"
 #include <lib/utils_def.h>
 
 .globl plat_is_my_cpu_primary
 .globl plat_my_core_pos
 .globl plat_core_pos_by_mpidr
 .globl plat_panic_handler
-.globl _s32g_sram_clr
 .globl s32g_ncore_isol_cluster0
 .globl reset_registers_for_lockstep
 
@@ -40,257 +38,6 @@ func s32g_ncore_isol_cluster0
 	ret
 endfunc s32g_ncore_isol_cluster0
 
-/*
- * Translate a bus address in SRAM controller initialization address based on:
- * mem_addr[16:0] = {bus_addr[23:9], bus_addr[5:4]}
- *
- * addr := ((addr >> 9) << 2) | ((addr >> 4) & 0x3);
- *
- * x0: SRAM bus address
- * ret: x0: Initialization address
- *
- * Clobber list: x0,x4,x5
- */
-func calc_sramc_addr
-	lsr	x4, x0, #9
-	lsl	x4, x4, #2
-	lsr	x5, x0, #4
-	and	x5, x5, #3
-	orr	x0, x4, x5
-	ret
-endfunc calc_sramc_addr
-
-/**
- * Check if two intervals are in overlap
- *
- * x0: start index of the first interval
- * x1: end index of the first interval
- * x2: start index of the second interval
- * x3: end index of the second interval
- *
- * x0: return 0 if the intervals do not overlap and 1 otherwise
- * Clobber list: x0,x1,x2,x3,x4,x5,x6
- */
-func in_overlap
-	/* x4 = max */
-	cmp	x1, x3
-	b.gt	1f
-	mov	x4, x3
-	b	2f
-1:
-	mov	x4, x1
-2:
-	/* x5 = min */
-	cmp	x0, x2
-	b.lt	3f
-	mov	x5, x2
-	b	4f
-3:
-	mov	x5, x0
-4:
-	/* x5 = max - min */
-	sub	x5, x4, x5
-	/* x4 = first interval size */
-	sub	x4, x1, x0
-	/* x6 = second interval size */
-	sub	x6, x3, x2
-	/* x4 = len1 + len2 */
-	add	x4, x4, x6
-	cmp	x4, x5
-	bgt	overlap
-	mov	x0, #0
-	ret
-overlap:
-	mov	x0, #1
-	ret
-endfunc in_overlap
-
-/**
- * Clear SRAM range using SRAM controller
- *
- * x0: SRAM controller address
- * x1: Initialization Start Address
- * x2: Initialization End Address
- *
- * Clobber list: x0,x1,x2,x3
- */
-func clear_sramc_range
-	/* Disable the module */
-	mov	x3, #0
-	str	w3, [x0, #SRAMC_PRAMCR_OFFSET]
-
-	/* Address range */
-	str	w1, [x0, #SRAMC_PRAMIAS_OFFSET]
-	str	w2, [x0, #SRAMC_PRAMIAE_OFFSET]
-
-	/* Request initialization */
-	mov	x3, #SRAMC_PRAMCR_INITREQ
-	str	w3, [x0, #SRAMC_PRAMCR_OFFSET]
-
-wait_init:
-	ldr	w3, [x0, #SRAMC_PRAMSR_OFFSET]
-	and	w3, w3, #SRAMC_PRAMSR_IDONE
-	cbz	w3, wait_init
-
-	/* Clear status */
-	mov	w3, #SRAMC_PRAMSR_IDONE
-	str	w3, [x0, #SRAMC_PRAMSR_OFFSET]
-
-	ret
-endfunc clear_sramc_range
-
-/* x0: start address of memory area to clear
- * x1: end address of memory area to clear
- *
- * Clobber list: x0,x1,x9,x10
- */
-func a53_sram_clr
-	mov	x10, #0x0
-	cmp	x1, x0
-	bgt	pos_step
-	mov	x9, #-8
-	b	clr_loop
-pos_step:
-	mov	x9, #8
-clr_loop:
-	cmp	x1, x0
-	beq	finish
-	str	x10, [x0]
-	add	x0, x0, x9
-	b	clr_loop
-finish:
-	ret
-endfunc a53_sram_clr
-
-func clear_unaligned_ends
-	/* Save x30 */
-	mov	x12, x30
-	/*
-	 * Obtain SRAM addresses
-	 */
-	mov	x9, #S32G_SRAM_BASE
-	add	x11, x1, x9
-	add	x9, x0, x9
-
-	and	x1, x9, #SRAM_INV_BLOCK_MASK
-	cmp	x1, x9
-	beq	clear_end
-	add	x1, x1, SRAM_BLOCK
-	mov	x0, x9
-	bl	a53_sram_clr
-
-clear_end:
-	and	x0, x11, #SRAM_INV_BLOCK_MASK
-	cmp	x0, x11
-	beq	clr_exit
-	mov	x1, x11
-	bl	a53_sram_clr
-clr_exit:
-	mov	x30, x12
-	ret
-endfunc clear_unaligned_ends
-
-/* x0: start address of memory area to clear
- * x1: end address of memory area to clear
- * x0: return 0 on error or size of memory cleared on success
- *
- * Clobber list: x0,x1,x2,x3,x4,x5,x6,x7,x8,x9,x11,x12,x13,x14,x15
- */
-func _s32g_sram_clr
-	/* Save x30 */
-	mov	x15, x30
-
-	mov	x13, x0
-	mov	x14, x1
-	bl	clear_unaligned_ends
-	mov	x0, x13
-	mov	x1, x14
-
-	/* Align to SRAM blocks */
-	and	x9, x0, #SRAM_INV_BLOCK_MASK
-	cmp	x0, x9
-	beq	align_high_addr
-	add	x0, x9, SRAM_BLOCK
-
-align_high_addr:
-	and	x1, x1, #SRAM_INV_BLOCK_MASK
-
-	sub	x1, x1, #1
-	/* Low address */
-	bl	calc_sramc_addr
-	mov	x7, x0
-	mov	x0, x1
-
-	/* High address */
-	bl	calc_sramc_addr
-
-	/**
-	 * x7 - Low initialization address
-	 * x8 - High initialization address
-	 */
-	mov	x8, x0
-	mov	x9, #SRAMC1_MAX_ADDR
-	cmp	x8, x9
-	bgt	error
-
-	mov	x0, #SRAMC0_MIN_ADDR
-	mov	x1, #SRAMC0_MAX_ADDR
-	mov	x2, x7
-	mov	x3, x8
-	bl	in_overlap
-	cbnz	x0, init_sramc0
-
-check_sramc1:
-	mov	x0, #SRAMC1_MIN_ADDR
-	mov	x1, #SRAMC1_MAX_ADDR
-	mov	x2, x7
-	mov	x3, x8
-	bl	in_overlap
-	cbnz	x0, init_sramc1
-	b	sram_exit
-
-init_sramc0:
-	mov	x0, #SRAMC0_BASE_ADDD_L
-	movk	x0, #SRAMC0_BASE_ADDD_H, lsl #16
-	mov	x1, x7
-	mov	x2, x8
-	mov	x9, #SRAMC0_MAX_ADDR
-	cmp	x2, x9
-	b.gt	1f
-	b	2f
-1:
-	mov	x2, #SRAMC0_MAX_ADDR
-2:
-	bl	clear_sramc_range
-	b	check_sramc1
-
-init_sramc1:
-	mov	x0, #SRAMC1_BASE_ADDD_L
-	movk	x0, #SRAMC1_BASE_ADDD_H, lsl #16
-	cmp	x7, #SRAMC1_MIN_ADDR
-	b.lt	3f
-	sub	x1, x7, #SRAMC1_MIN_ADDR
-	b	4f
-3:
-	mov	x1, #0
-4:
-	sub	x2, x8, #SRAMC1_MIN_ADDR
-	bl	clear_sramc_range
-
-	mov	x0, #0
-
-sram_exit:
-	/* Restore x30 */
-	mov	x30, x15
-	ret
-
-error:
-	/* Restore x30 */
-	mov	x30, x15
-	mov	x0, #-1
-	ret
-endfunc _s32g_sram_clr
-
 /* Clobber list: x0,x1,x7,x8
  */
 func plat_is_my_cpu_primary
-- 
2.17.1

