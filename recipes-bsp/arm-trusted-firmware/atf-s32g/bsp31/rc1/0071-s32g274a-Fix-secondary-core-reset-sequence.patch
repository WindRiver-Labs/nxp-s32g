From 67be292e2efcf3a74a4c9c683fb353638418c8fb Mon Sep 17 00:00:00 2001
From: Bogdan Hamciuc <bogdan.hamciuc@nxp.com>
Date: Thu, 16 Jan 2020 15:40:40 +0200
Subject: [PATCH 071/269] s32g274a: Fix secondary core reset sequence

Some bits used in the core reset sequence are only defined for the first
core of each cluster. Make sure we operate that part of the reset
sequence only on cores 0 and 2.

Upstream-Status: Pending 

Signed-off-by: Bogdan Hamciuc <bogdan.hamciuc@nxp.com>
Signed-off-by: Zhantao Tang <zhantao.tang@windriver.com>
Issue: ALB-4497
---
 plat/s32g/s32g_mc_me.c | 43 +++++++++++++++++++++++-------------------
 1 file changed, 24 insertions(+), 19 deletions(-)

diff --git a/plat/s32g/s32g_mc_me.c b/plat/s32g/s32g_mc_me.c
index 2a3aff77f..35338ea13 100644
--- a/plat/s32g/s32g_mc_me.c
+++ b/plat/s32g/s32g_mc_me.c
@@ -156,35 +156,40 @@ static void core_high_addr_write(uintptr_t addr, uint32_t core)
 static void s32g_kick_secondary_ca53_core(uint32_t part, uint32_t core)
 {
 	uintptr_t core_start_addr = (uintptr_t)&plat_secondary_cold_boot_setup;
-	uint32_t reset;
-	uint32_t status = 0;
+	uint32_t rst;
+	uint32_t stat;
 
 	/* GPR09 provides the 8 high-order bits for the core's start addr */
 	core_high_addr_write(core_start_addr, core);
-
 	/* The MC_ME provides the 32 low-order bits for the core's
 	 * start address
 	 */
 	mc_me_part_core_addr_write(core_start_addr, part, core);
 
-	/* Reset the requested secondary core */
-	/* TODO: shouldn't this come last, after configuring the reset addr? */
-	reset = mmio_read_32(S32G_MC_RGM_PRST(S32G_MC_RGM_RST_DOMAIN_CA53));
-	reset &= ~(S32G_MC_RGM_RST_CA53_BIT(core));
-	mmio_write_32(S32G_MC_RGM_PRST(S32G_MC_RGM_RST_DOMAIN_CA53), reset);
-
+	/* When in performance (i.e., not in lockstep) mode, the following
+	 * bits from the reset sequence are only defined for the first core
+	 * of each CA53 cluster. Make sure this part of the sequence only runs
+	 * on even-numbered cores.
+	 */
 	/* Enable clock and make changes effective */
-	mc_me_part_core_pconf_write_cce(1, part,
-			core & S32G_MC_ME_SECONDARY_CORE_MASK);
-	mc_me_part_core_pupd_write_ccupd(1, part,
-			core & S32G_MC_ME_SECONDARY_CORE_MASK);
+	mc_me_part_core_pconf_write_cce(1, part, core & ~1);
+	mc_me_part_core_pupd_write_ccupd(1, part, core & ~1);
 	mc_me_apply_hw_changes();
-
-	/* Wait for the hardware to update state */
-	while ((status & S32G_MC_ME_PRTN_N_CORE_M_STAT_CCS_MASK) == 0) {
-		status = mmio_read_32(S32G_MC_ME_PRTN_N_CORE_M_STAT(part,
-					core & S32G_MC_ME_SECONDARY_CORE_MASK));
-	}
+	/* Wait for the core clock to become active */
+	do {
+		stat = mmio_read_32(S32G_MC_ME_PRTN_N_CORE_M_STAT(part,
+								  core & ~1));
+	} while ((stat & S32G_MC_ME_PRTN_N_CORE_M_STAT_CCS_MASK) == 0);
+
+	/* Release the core reset */
+	rst = mmio_read_32(S32G_MC_RGM_PRST(S32G_MC_RGM_RST_DOMAIN_CA53));
+	rst &= ~(S32G_MC_RGM_RST_CA53_BIT(core));
+	mmio_write_32(S32G_MC_RGM_PRST(S32G_MC_RGM_RST_DOMAIN_CA53), rst);
+	/* Wait for reset bit to deassert */
+	do {
+		stat = mmio_read_32(S32G_MC_RGM_PSTAT(
+						S32G_MC_RGM_RST_DOMAIN_CA53));
+	} while (stat != rst);
 }
 
 
-- 
2.17.1

