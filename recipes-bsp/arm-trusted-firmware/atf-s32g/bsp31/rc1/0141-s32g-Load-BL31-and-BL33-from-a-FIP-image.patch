From 22699a6da9ba3616a6080649e96bb3b714999185 Mon Sep 17 00:00:00 2001
From: Dan Nica <dan.nica@nxp.com>
Date: Sat, 23 May 2020 21:11:02 +0300
Subject: [PATCH 141/269] s32g: Load BL31 and BL33 from a FIP image

Issue: ALB-4935
Upstream-Status: Pending 

Signed-off-by: Dan Nica <dan.nica@nxp.com>
Signed-off-by: Zhantao Tang <zhantao.tang@windriver.com>
---
 plat/s32g/include/platform_def.h | 20 +++-----
 plat/s32g/include/s32g_storage.h |  1 +
 plat/s32g/platform.mk            |  1 +
 plat/s32g/s32g274a_bl2_el3.c     | 14 +++++-
 plat/s32g/s32g274a_bl31.c        |  4 +-
 plat/s32g/s32g274a_storage.c     | 81 ++++++++++++++++++++++++--------
 6 files changed, 86 insertions(+), 35 deletions(-)

diff --git a/plat/s32g/include/platform_def.h b/plat/s32g/include/platform_def.h
index be936305c..112cadced 100644
--- a/plat/s32g/include/platform_def.h
+++ b/plat/s32g/include/platform_def.h
@@ -156,28 +156,22 @@
 
 /* U-boot address in SRAM */
 #define S32G_BL33_OFF_IN_SRAM	0x00020000
-#define BL33_ENTRYPOINT		(S32G_SRAM_BASE + S32G_BL33_OFF_IN_SRAM)
-/* The image found on sdcard at BL33_MMC_OFFSET also includes an Application
- * Boot Code image header. Therefore, we'll load it all at BL33_ENTRYPOINT
- * minus the header size such that the actual BL33 code ends up at the
- * expected address.
- */
-#define APP_BOOT_CODE_IMG_HDR_SIZE	(0x40)
-#define S32G_BL33_IMAGE_BASE	(BL33_ENTRYPOINT - APP_BOOT_CODE_IMG_HDR_SIZE)
+#define S32G_BL33_IMAGE_BASE	(S32G_SRAM_BASE + S32G_BL33_OFF_IN_SRAM)
 #define S32G_BL33_LIMIT		(S32G_SRAM_END)
 #define S32G_BL33_IMAGE_SIZE	(S32G_BL33_LIMIT - S32G_BL33_IMAGE_BASE)
 
-#define BL33_MMC_OFFSET		(0x2000)
-#define BL33_MMC_SIZE		(0x100000)
-
 /* BL31 location in DDR - physical addresses only, as the MMU is not
  * configured at that point yet
  */
 #define BL31_BASE		(S32G_PMEM_START)
 #define BL31_LIMIT		(S32G_PMEM_END)
 
-#define BL31_MMC_OFFSET		(0x1f2000)
-#define BL31_MMC_SIZE		(0x20000)
+#define FIP_MAXIMUM_SIZE	(0x400000)
+#define FIP_BASE		(S32G_SRAM_END - FIP_MAXIMUM_SIZE)
+/* Must be placed by mkimage starting with AppBootCode:Code, but
+ * aligned to the block size of 512 bytes
+ */
+#define FIP_MMC_OFFSET		(0x2400)
 
 /* FIXME value randomly chosen; should probably be revisited */
 #define PLATFORM_STACK_SIZE		0x4000
diff --git a/plat/s32g/include/s32g_storage.h b/plat/s32g/include/s32g_storage.h
index eb833201c..2ec9401d8 100644
--- a/plat/s32g/include/s32g_storage.h
+++ b/plat/s32g/include/s32g_storage.h
@@ -8,6 +8,7 @@
 
 enum s32g_boot_source {
 	S32G_MMC_BOOT,
+	S32G_FIP_BOOT,
 	/* TODO add FIP, QSPI, SD/MMC */
 };
 
diff --git a/plat/s32g/platform.mk b/plat/s32g/platform.mk
index 4cc46fa7c..9991b2eae 100644
--- a/plat/s32g/platform.mk
+++ b/plat/s32g/platform.mk
@@ -51,6 +51,7 @@ BL2_SOURCES		+= plat/s32g/s32g_lowlevel_bl2.S \
 			   drivers/mmc/mmc.c \
 			   drivers/nxp/s32g/io/io_mmc.c \
 			   drivers/nxp/s32g/io/io_memmap.c \
+			   drivers/io/io_fip.c \
 			   drivers/nxp/s32g/mmc/s32g274a_mmc.c \
 			   ${DDR_DRV}/ddrss.c \
 			   ${DDR_DRV}/ddrss_firmware.c \
diff --git a/plat/s32g/s32g274a_bl2_el3.c b/plat/s32g/s32g274a_bl2_el3.c
index 9d4a05a2d..e69435252 100644
--- a/plat/s32g/s32g274a_bl2_el3.c
+++ b/plat/s32g/s32g274a_bl2_el3.c
@@ -23,6 +23,19 @@
 #include <ssram_mailbox.h>
 
 static bl_mem_params_node_t s32g_bl2_mem_params_descs[] = {
+	{
+		.image_id = FIP_IMAGE_ID,
+
+		SET_STATIC_PARAM_HEAD(ep_info, PARAM_EP, VERSION_2,
+				      entry_point_info_t,
+				      NON_SECURE | EXECUTABLE),
+
+		SET_STATIC_PARAM_HEAD(image_info, PARAM_EP, VERSION_2,
+				      image_info_t, IMAGE_ATTRIB_PLAT_SETUP),
+		.image_info.image_max_size = FIP_MAXIMUM_SIZE,
+		.image_info.image_base = FIP_BASE,
+		.next_handoff_image_id = BL31_IMAGE_ID,
+	},
 	{
 		.image_id = BL31_IMAGE_ID,
 
@@ -39,7 +52,6 @@ static bl_mem_params_node_t s32g_bl2_mem_params_descs[] = {
 		.image_info.image_base = BL31_BASE,
 		.next_handoff_image_id = BL33_IMAGE_ID,
 	},
-
 	{
 		.image_id = BL33_IMAGE_ID,
 
diff --git a/plat/s32g/s32g274a_bl31.c b/plat/s32g/s32g274a_bl31.c
index c861c44d3..5e03f3038 100644
--- a/plat/s32g/s32g274a_bl31.c
+++ b/plat/s32g/s32g274a_bl31.c
@@ -67,7 +67,7 @@ static const mmap_region_t s32g_mmap[] = {
 	MAP_REGION_FLAT(NCORE_BASE_ADDR, S32G_NCORE_SIZE,
 			MT_DEVICE | MT_RW),
 	/* This will be replaced by BL31SRAM */
-	MAP_REGION2(BL33_ENTRYPOINT, BL33_ENTRYPOINT,
+	MAP_REGION2(S32G_BL33_IMAGE_BASE, S32G_BL33_IMAGE_BASE,
 			MMU_ROUND_UP_TO_4K(S32G_BL33_IMAGE_SIZE),
 			MT_MEMORY | MT_RW, PAGE_SIZE),
 	MAP_REGION_FLAT(S32G_PMEM_START, S32G_PMEM_LEN,
@@ -130,7 +130,7 @@ void bl31_early_platform_setup2(u_register_t arg0, u_register_t arg1,
 		u_register_t arg2, u_register_t arg3)
 {
 	SET_PARAM_HEAD(&bl33_image_ep_info, PARAM_EP, VERSION_1, 0);
-	bl33_image_ep_info.pc = BL33_ENTRYPOINT;
+	bl33_image_ep_info.pc = S32G_BL33_IMAGE_BASE;
 	bl33_image_ep_info.spsr = s32g_get_spsr_for_bl33_entry();
 	SET_SECURITY_STATE(bl33_image_ep_info.h.attr, NON_SECURE);
 }
diff --git a/plat/s32g/s32g274a_storage.c b/plat/s32g/s32g274a_storage.c
index 674adafa6..bf8e053ca 100644
--- a/plat/s32g/s32g274a_storage.c
+++ b/plat/s32g/s32g274a_storage.c
@@ -7,7 +7,7 @@
 #include <drivers/io/io_driver.h>
 #include <drivers/mmc.h>
 #include <drivers/nxp/s32g/io/io_mmc.h>
-#include <drivers/io/io_memmap.h>
+#include <drivers/io/io_fip.h>
 #include <drivers/nxp/s32g/mmc/s32g274a_mmc.h>
 #include <assert.h>
 #include <tools_share/firmware_image_package.h>
@@ -17,40 +17,66 @@
 	(((x) & ~(MMC_BLOCK_MASK)) == (x) ? (x) : \
 	 ((x) & ~(MMC_BLOCK_MASK)) + (MMC_BLOCK_SIZE))
 
+static const io_dev_connector_t *s32g_fip_io_dev;
+static uintptr_t s32g_fip_dev_handle;
+
 static const io_dev_connector_t *s32g_mmc_io_dev;
-static uintptr_t s32g_mmc_boot_dev_handle;
+static uintptr_t s32g_mmc_dev_handle;
 
+static int s32g_check_fip_dev(const uintptr_t spec);
 static int s32g_check_mmc_dev(const uintptr_t spec);
 
-static const io_block_spec_t bl31_mmc_spec = {
-	.offset = BL31_MMC_OFFSET,
-	.length = ROUND_TO_MMC_BLOCK_SIZE(BL31_MMC_SIZE),
+static const io_block_spec_t fip_mmc_spec = {
+	.offset = FIP_MMC_OFFSET,
+	.length = ROUND_TO_MMC_BLOCK_SIZE(FIP_MAXIMUM_SIZE),
+};
+
+static const io_uuid_spec_t bl31_uuid_spec = {
+	.uuid = UUID_EL3_RUNTIME_FIRMWARE_BL31,
 };
 
-static const io_block_spec_t bl33_mmc_spec = {
-	.offset = BL33_MMC_OFFSET,
-	.length = ROUND_TO_MMC_BLOCK_SIZE(BL33_MMC_SIZE),
+static const io_uuid_spec_t bl33_uuid_spec = {
+	.uuid = UUID_NON_TRUSTED_FIRMWARE_BL33,
 };
 
 static const struct plat_io_policy s32g_policies[] = {
-	[BL31_IMAGE_ID] = {
-		&s32g_mmc_boot_dev_handle,
-		(uintptr_t)&bl31_mmc_spec,
+	[FIP_IMAGE_ID] = {
+		&s32g_mmc_dev_handle,
+		(uintptr_t)&fip_mmc_spec,
 		s32g_check_mmc_dev
 	},
+	[BL31_IMAGE_ID] = {
+		&s32g_fip_dev_handle,
+		(uintptr_t)&bl31_uuid_spec,
+		s32g_check_fip_dev
+	},
 	[BL33_IMAGE_ID] = {
-		&s32g_mmc_boot_dev_handle,
-		(uintptr_t)&bl33_mmc_spec,
-		s32g_check_mmc_dev
+		&s32g_fip_dev_handle,
+		(uintptr_t)&bl33_uuid_spec,
+		s32g_check_fip_dev
 	},
 };
 
+static int s32g_check_fip_dev(const uintptr_t spec)
+{
+	int result;
+	uintptr_t local_image_handle;
+
+	result = io_dev_init(s32g_fip_dev_handle, (uintptr_t)FIP_IMAGE_ID);
+	if (!result) {
+		result = io_open(s32g_fip_dev_handle, spec, &local_image_handle);
+		if (!result)
+			io_close(local_image_handle);
+	}
+	return result;
+}
+
 static int s32g_check_mmc_dev(const uintptr_t spec)
 {
 	uintptr_t local_handle;
 	int ret;
 
-	ret = io_open(s32g_mmc_boot_dev_handle, spec, &local_handle);
+	ret = io_open(s32g_mmc_dev_handle, spec, &local_handle);
 	if (ret)
 		return ret;
 	/* must be closed, as load_image() will do another io_open() */
@@ -88,7 +114,7 @@ static void plat_s32g_io_setup(enum s32g_boot_source boot_source)
 
 	switch (boot_source) {
 	case S32G_MMC_BOOT:
-		handle = s32g_mmc_boot_dev_handle;
+		handle = s32g_mmc_dev_handle;
 
 		if (s32g274a_mmc_register())
 			goto err_register;
@@ -97,11 +123,27 @@ static void plat_s32g_io_setup(enum s32g_boot_source boot_source)
 			goto err_register;
 
 		if (io_dev_open(s32g_mmc_io_dev,
-				(uintptr_t)&bl31_mmc_spec,
-				&s32g_mmc_boot_dev_handle))
+				(uintptr_t)&fip_mmc_spec,
+				&s32g_mmc_dev_handle))
+			goto err_io_dev_open;
+
+		if (io_dev_init(s32g_mmc_dev_handle, 0))
+			goto err_io_dev_init;
+
+		break;
+
+	case S32G_FIP_BOOT:
+		handle = s32g_fip_dev_handle;
+
+		if (register_io_dev_fip(&s32g_fip_io_dev))
+			goto err_register;
+
+		if (io_dev_open(s32g_fip_io_dev,
+				(uintptr_t)&bl31_uuid_spec,
+				&s32g_fip_dev_handle))
 			goto err_io_dev_open;
 
-		if (io_dev_init(s32g_mmc_boot_dev_handle, 0))
+		if (io_dev_init(s32g_fip_dev_handle, 0))
 			goto err_io_dev_init;
 
 		break;
@@ -124,4 +166,5 @@ err_register:
 void s32g_io_setup(void)
 {
 	plat_s32g_io_setup(S32G_MMC_BOOT);
+	plat_s32g_io_setup(S32G_FIP_BOOT);
 }
-- 
2.17.1

