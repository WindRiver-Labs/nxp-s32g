From 5a3ba2ef26d272ee545f2175472838c2b6532795 Mon Sep 17 00:00:00 2001
From: Ghennadi Procopciuc <Ghennadi.Procopciuc@nxp.com>
Date: Thu, 16 Jul 2020 08:20:16 +0300
Subject: [PATCH 162/269] s32g: Initialize SRAM using SRAM controller

Avoid DMA initialization of SRAM due to performance reasons.

Issue: ALB-5277
Upstream-Status: Pending 

Signed-off-by: Ghennadi Procopciuc <Ghennadi.Procopciuc@nxp.com>
Signed-off-by: Zhantao Tang <zhantao.tang@windriver.com>
---
 plat/nxp/s32g/include/platform_def.h |   2 +-
 plat/nxp/s32g/include/s32g_sramc.h   |  47 ++++
 plat/nxp/s32g/platform.mk            |   3 +
 plat/nxp/s32g/s32g_bl2_el3.c         |   6 +-
 plat/nxp/s32g/s32g_bl31.c            |   5 +
 plat/nxp/s32g/s32g_lowlevel_bl2.S    |  22 +-
 plat/nxp/s32g/s32g_lowlevel_common.S | 323 ++++++++++++++-------------
 plat/nxp/s32g/s32g_psci.c            |  28 ++-
 plat/nxp/s32g/s32g_sramc.c           |  61 +++++
 9 files changed, 330 insertions(+), 167 deletions(-)
 create mode 100644 plat/nxp/s32g/include/s32g_sramc.h
 create mode 100644 plat/nxp/s32g/s32g_sramc.c

diff --git a/plat/nxp/s32g/include/platform_def.h b/plat/nxp/s32g/include/platform_def.h
index 2945c3768..25863e92a 100644
--- a/plat/nxp/s32g/include/platform_def.h
+++ b/plat/nxp/s32g/include/platform_def.h
@@ -190,7 +190,7 @@
 #if defined IMAGE_BL31
 #define FIRMWARE_WELCOME_STR_S32G_BL31	"This is S32G BL31\n"
 /* To limit usage, keep these in sync with sizeof(s32g_mmap) */
-#define MAX_MMAP_REGIONS		12
+#define MAX_MMAP_REGIONS		14
 #define MAX_XLAT_TABLES			(MAX_MMAP_REGIONS + BL31SRAM_MAX_PAGES)
 #endif
 #if defined IMAGE_BL33
diff --git a/plat/nxp/s32g/include/s32g_sramc.h b/plat/nxp/s32g/include/s32g_sramc.h
new file mode 100644
index 000000000..ebb784def
--- /dev/null
+++ b/plat/nxp/s32g/include/s32g_sramc.h
@@ -0,0 +1,47 @@
+/*
+ * Copyright 2020 NXP
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ */
+#ifndef S32G_SRAMC_H
+#define S32G_SRAMC_H
+
+#include <lib/utils_def.h>
+
+/* SRAM controller is able to erase 64 bits at once */
+#define SRAM_BLOCK		512
+#define SRAM_BLOCK_MASK		(SRAM_BLOCK - 1)
+
+#define SRAMC0_BASE_ADDR	0x4019C000
+#define SRAMC0_BASE_ADDD_H	(SRAMC0_BASE_ADDR >> 16)
+#define SRAMC0_BASE_ADDD_L	((SRAMC0_BASE_ADDR & 0xFFFF))
+#define SRAMC1_BASE_ADDR	0x401A0000
+#define SRAMC1_BASE_ADDD_H	(SRAMC1_BASE_ADDR >> 16)
+#define SRAMC1_BASE_ADDD_L	((SRAMC1_BASE_ADDR & 0xFFFF))
+#define SSRAMC_BASE_ADDR	0x44028000
+#define SRAMC_SIZE		0x3000
+
+/* Block ranges */
+#define SRAMC0_MIN_ADDR		(0x0)
+#define SRAMC0_MAX_ADDR		(0x7FFF)
+#define SRAMC1_MIN_ADDR		(SRAMC0_MAX_ADDR + 1)
+#define SRAMC1_MAX_ADDR		(0x10000)
+
+#define SRAMC_PRAMCR_OFFSET	0x0
+#define SRAMC_PRAMCR_INITREQ	BIT(0)
+#define SRAMC_PRAMIAS_OFFSET	0x4
+#define SRAMC_PRAMIAE_OFFSET	0x8
+#define SRAMC_PRAMSR_OFFSET	0xC
+#define SRAMC_PRAMSR_IDONE	BIT(0)
+
+#define SSRAM_MAX_ADDR		0x7FF
+
+#ifndef __ASSEMBLY__
+#include <stdint.h>
+
+int s32g_sram_clear(uintptr_t start, uintptr_t end);
+void s32g_ssram_clear(void);
+#endif
+
+#endif
+
diff --git a/plat/nxp/s32g/platform.mk b/plat/nxp/s32g/platform.mk
index daaf61866..f824e5dad 100644
--- a/plat/nxp/s32g/platform.mk
+++ b/plat/nxp/s32g/platform.mk
@@ -35,6 +35,7 @@ PLAT_BL_COMMON_SOURCES	+= plat/nxp/s32g/s32g_lowlevel_common.S \
 			   plat/nxp/s32g/s32g_dt.c \
 			   plat/nxp/s32g/s32g_pinctrl.c \
 			   plat/nxp/s32g/s32g_clocks.c \
+			   plat/nxp/s32g/s32g_sramc.c \
 			   drivers/nxp/s32g/i2c/s32g_i2c.c \
 			   drivers/delay_timer/delay_timer.c \
 			   drivers/delay_timer/generic_delay_timer.c \
@@ -156,6 +157,8 @@ $(eval $(call add_define_val,S32G_LINFLEX_MODULE,$(S32G_LINFLEX_MODULE)))
 S32G_HAS_HV		:= 0
 $(eval $(call add_define_val,S32G_HAS_HV,$(S32G_HAS_HV)))
 
+BL2_EL3_STACK_ALIGNMENT :=	512
+$(eval $(call add_define_val,BL2_EL3_STACK_ALIGNMENT,$(BL2_EL3_STACK_ALIGNMENT)))
 
 ### Devel & Debug options ###
 CFLAGS			+= -O0
diff --git a/plat/nxp/s32g/s32g_bl2_el3.c b/plat/nxp/s32g/s32g_bl2_el3.c
index b3c4c485a..451e5ef89 100644
--- a/plat/nxp/s32g/s32g_bl2_el3.c
+++ b/plat/nxp/s32g/s32g_bl2_el3.c
@@ -20,6 +20,7 @@
 #include <nxp/s32g/ddr/ddrss.h>
 #include <drivers/generic_delay_timer.h>
 #include <ssram_mailbox.h>
+#include "s32g_sramc.h"
 
 static bl_mem_params_node_t s32g_bl2_mem_params_descs[] = {
 	{
@@ -134,16 +135,15 @@ static void copy_bl31ssram_image(void)
 void bl2_el3_plat_arch_setup(void)
 {
 	static struct console_s32g console;
-	void sram_clr(uintptr_t start, size_t size);
 	extern struct ddrss_conf ddrss_conf;
 	extern struct ddrss_firmware ddrss_firmware;
 
 	console_s32g_register(S32G_UART_BASE, S32G_UART_CLOCK_HZ,
 			      S32G_UART_BAUDRATE, &console);
 
-	sram_clr(S32G_BL33_IMAGE_BASE, BL2_BASE - S32G_BL33_IMAGE_BASE);
+	s32g_sram_clear(S32G_BL33_IMAGE_BASE, DTB_BASE);
+	s32g_ssram_clear();
 
-	sram_clr(S32G_SSRAM_BASE, S32G_SSRAM_LIMIT - S32G_SSRAM_BASE);
 	copy_bl31ssram_image();
 	/* This will also populate CSR section from bl31ssram */
 	ddrss_init(&ddrss_conf, &ddrss_firmware, BL31SSRAM_CSR_BASE);
diff --git a/plat/nxp/s32g/s32g_bl31.c b/plat/nxp/s32g/s32g_bl31.c
index e0b875c2a..179824297 100644
--- a/plat/nxp/s32g/s32g_bl31.c
+++ b/plat/nxp/s32g/s32g_bl31.c
@@ -28,6 +28,7 @@
 #include "s32g_xrdc.h"
 #include "s32gen1-wkpu.h"
 #include "s32g_bl_common.h"
+#include "s32g_sramc.h"
 
 #define MMU_ROUND_UP_TO_4K(x)	\
 			(((x) & ~0xfff) == (x) ? (x) : ((x) & ~0xfff) + 0x1000)
@@ -62,6 +63,10 @@ static const mmap_region_t s32g_mmap[] = {
 	 */
 	MAP_REGION_FLAT(NCORE_BASE_ADDR, S32G_NCORE_SIZE,
 			MT_DEVICE | MT_RW),
+	MAP_REGION_FLAT(SRAMC0_BASE_ADDR, SRAMC_SIZE,
+			MT_DEVICE | MT_RW),
+	MAP_REGION_FLAT(SSRAMC_BASE_ADDR, SRAMC_SIZE,
+			MT_DEVICE | MT_RW),
 	/* This will be replaced by BL31SRAM */
 	MAP_REGION2(S32G_BL33_IMAGE_BASE, S32G_BL33_IMAGE_BASE,
 			MMU_ROUND_UP_TO_4K(S32G_BL33_IMAGE_SIZE),
diff --git a/plat/nxp/s32g/s32g_lowlevel_bl2.S b/plat/nxp/s32g/s32g_lowlevel_bl2.S
index 1ce35897d..1dd6c35e2 100644
--- a/plat/nxp/s32g/s32g_lowlevel_bl2.S
+++ b/plat/nxp/s32g/s32g_lowlevel_bl2.S
@@ -7,16 +7,17 @@
 #include <asm_macros.S>
 #include <console_macros.S>
 #include "platform_def.h"
+#include "s32g_sramc.h"
 
 .globl platform_mem_init
 .globl plat_reset_handler
-.globl sram_clr
+.globl _s32g_sram_clr
 .globl plat_secondary_cold_boot_setup
 .globl s32g_ncore_isol_cluster0
 
-/* Clobber list: x0,x1,x7,x8,x9,x10,x11 */
+/* Clobber list: x0,x1,x2,x3,x4,x5,x6,x7,x8,x9,x10,x11,x12 */
 func plat_reset_handler
-	mov	x7, x30
+	mov	x12, x30
 
 	/* Ncore quirks */
 	bl	s32g_ncore_isol_cluster0
@@ -27,10 +28,19 @@ func plat_reset_handler
 	/* Some BL2 sections need to be initialized */
 	ldr	x0,=__STACKS_START__
 	ldr	x1,=__BL2_END__
-	sub	x1, x1, x0
-	bl	sram_clr
 
-	mov	x30, x7
+	/* Roundup to first multiple of 512 */
+	orr	x1, x1, #SRAM_BLOCK_MASK
+	add	x1, x1, #1
+
+	/* To bus addresses */
+	mov	x2, #S32G_SRAM_BASE
+	sub	x0, x0, x2
+	sub	x1, x1, x2
+
+	bl	_s32g_sram_clr
+
+	mov	x30, x12
 	ret
 endfunc plat_reset_handler
 
diff --git a/plat/nxp/s32g/s32g_lowlevel_common.S b/plat/nxp/s32g/s32g_lowlevel_common.S
index 51232d68a..61e5cd465 100644
--- a/plat/nxp/s32g/s32g_lowlevel_common.S
+++ b/plat/nxp/s32g/s32g_lowlevel_common.S
@@ -7,14 +7,14 @@
 #include <asm_macros.S>
 #include <console_macros.S>
 #include "platform_def.h"
-#include "s32g_edma.h"
+#include "s32g_sramc.h"
+#include <lib/utils_def.h>
 
 .globl plat_is_my_cpu_primary
 .globl plat_my_core_pos
 .globl plat_core_pos_by_mpidr
 .globl plat_panic_handler
-.globl dma_mem_clr
-.globl sram_clr
+.globl _s32g_sram_clr
 .globl s32g_ncore_isol_cluster0
 
 func plat_panic_handler
@@ -39,155 +39,190 @@ func s32g_ncore_isol_cluster0
 	ret
 endfunc s32g_ncore_isol_cluster0
 
-/* x0: start address of memory area to clear
- * x1: size of memory area to clear
- * x0: return 0 on error or size of memory cleared on success
- * Clobber list: x0,x9,x12,x13
+/*
+ * Translate a bus address in SRAM controller initialization address based on:
+ * mem_addr[16:0] = {bus_addr[23:9], bus_addr[5:4]}
+ *
+ * addr := ((addr >> 9) << 2) | ((addr >> 4) & 0x3);
+ *
+ * x0: SRAM bus address
+ * ret: x0: Initialization address
+ *
+ * Clobber list: x0,x4,x5
  */
+func calc_sramc_addr
+	lsr	x4, x0, #9
+	lsl	x4, x4, #2
+	lsr	x5, x0, #4
+	and	x5, x5, #3
+	orr	x0, x4, x5
+	ret
+endfunc calc_sramc_addr
 
-func dma_mem_clr
-	orr	x12, x0, x1
-	and 	x12, x12, #0x3f
-	cbz 	x12, transfer_size_64bytes
-	and 	x12, x12, #0x7
-	cbz 	x12, transfer_size_8bytes
-	/* Assert that the addresses are aligned on at least a 64bit
-	 * boundary, otherwise the transfer to an unitialized
-	 * sram would fail anyway.
-	 */
-	bl	plat_panic_handler
-
-transfer_size_8bytes:
-	ldr	x9, =EDMA0_TCDn_ATTR(DMA_CHANNEL_1)
-	mov	w12, #0x0303 /* 8bytes transfer size */
-	strh	w12, [x9]
-
-	ldr	x9, =EDMA0_TCDn_DOFF(DMA_CHANNEL_1)
-	mov	w12, #0x0008 /* increment by 8bytes */
-	strh	w12, [x9]
-	b	transfer_size_determined
-
-transfer_size_64bytes:
-	ldr	x9, =EDMA0_TCDn_ATTR(DMA_CHANNEL_1)
-	mov	w12, #0x0606 /* 64bytes transfer size */
-	strh	w12, [x9]
-
-	ldr	x9, =EDMA0_TCDn_DOFF(DMA_CHANNEL_1)
-	mov	w12, #0x0040 /* increment by 64bytes */
-	strh	w12, [x9]
-transfer_size_determined:
-
-	ldr	x9, =EDMA0_TCDn_DADDR(DMA_CHANNEL_1)
-	str 	w0, [x9]
-
-	ldr	x9, =EDMA0_TCDn_SOFF(DMA_CHANNEL_1)
-	strh	wzr, [x9]
-
-	ldr	x9, =EDMA0_TCDn_SADDR(DMA_CHANNEL_1)
-	ldr	x12, =initvar
-	str	w12, [x9]
-
-	ldr	x9, =EDMA0_TCDn_NBYTES_MLOFFNO(DMA_CHANNEL_1)
-	str 	w1, [x9]
-
-	mov	w12, #0x0001
-	ldr	x9, =EDMA0_TCDn_CITER_ELINKNO(DMA_CHANNEL_1)
-	strh	w12, [x9]
-	ldr	x9, =EDMA0_TCDn_BITER_ELINKNO(DMA_CHANNEL_1)
-	strh	w12, [x9]
-
-	ldr	x9, =EDMA0_TCDn_CSR(DMA_CHANNEL_1)
-	mov	w12, #0x0001
-	strb	w12, [x9]
-
-check_status:
-	/* Check error status */
-	ldr	x9, =EDMA0_MP_ES
-	ldr	w12, [x9]
-	and	w12, w12, #0x80000000
-	movz	w13, #0x8000, lsl #16
-	sub	w12, w12, w13
-	cbz	w12, transfer_error
-
-	/* Check transfer done */
-	ldr	x9, =EDMA0_CHn_CSR(DMA_CHANNEL_1)
-	ldr 	w12, [x9]
-	and 	w12, w12, #0x40000000
-	movz	w13, #0x4000, lsl #16
-	sub	w12, w12, w13
-	cbnz	w12, check_status
-
-	/* Clear EDMA0_CHn_CSR:DONE bit */
-	ldr	x9, =EDMA0_CHn_CSR(DMA_CHANNEL_1)
-	movz	w12, #0x4000, lsl #16
-	str	w12, [x9]
-
-	mov	x0, x1
+/**
+ * Check if two intervals are in overlap
+ *
+ * x0: start index of the first interval
+ * x1: end index of the first interval
+ * x2: start index of the second interval
+ * x3: end index of the second interval
+ *
+ * x0: return 0 if the intervals do not overlap and 1 otherwise
+ * Clobber list: x0,x1,x2,x3,x4,x5,x6
+ */
+func in_overlap
+	/* x4 = max */
+	cmp	x1, x3
+	b.gt	1f
+	mov	x4, x3
+	b	2f
+1:
+	mov	x4, x1
+2:
+	/* x5 = min */
+	cmp	x0, x2
+	b.lt	3f
+	mov	x5, x2
+	b	4f
+3:
+	mov	x5, x0
+4:
+	/* x5 = max - min */
+	sub	x5, x4, x5
+	/* x4 = first interval size */
+	sub	x4, x1, x0
+	/* x6 = second interval size */
+	sub	x6, x3, x2
+	/* x4 = len1 + len2 */
+	add	x4, x4, x6
+	cmp	x4, x5
+	bgt	overlap
+	mov	x0, #0
 	ret
+overlap:
+	mov	x0, #1
+	ret
+endfunc in_overlap
 
-transfer_error:
-	ldr	x9, =EDMA0_CHn_ES(DMA_CHANNEL_1)
-	movz	w10, #0x8000, lsl #16
-	str	w10, [x9]
+/**
+ * Clear SRAM range using SRAM controller
+ *
+ * x0: SRAM controller address
+ * x1: Initialization Start Address
+ * x2: Initialization End Address
+ *
+ * Clobber list: x0,x1,x2,x3
+ */
+func clear_sramc_range
+	/* Disable the module */
+	mov	x3, #0
+	str	w3, [x0, #SRAMC_PRAMCR_OFFSET]
+
+	/* Address range */
+	str	w1, [x0, #SRAMC_PRAMIAS_OFFSET]
+	str	w2, [x0, #SRAMC_PRAMIAE_OFFSET]
+
+	/* Request initialization */
+	mov	x3, #SRAMC_PRAMCR_INITREQ
+	str	w3, [x0, #SRAMC_PRAMCR_OFFSET]
+
+wait_init:
+	ldr	w3, [x0, #SRAMC_PRAMSR_OFFSET]
+	and	w3, w3, #SRAMC_PRAMSR_IDONE
+	cbz	w3, wait_init
+
+	/* Clear status */
+	mov	w3, #SRAMC_PRAMSR_IDONE
+	str	w3, [x0, #SRAMC_PRAMSR_OFFSET]
 
-	mov	x0, #0x0
 	ret
-endfunc dma_mem_clr
+endfunc clear_sramc_range
 
 /* x0: start address of memory area to clear
  * x1: size of memory area to clear
  * x0: return 0 on error or size of memory cleared on success
- * Clobber list: x0,x1,x10,x11,x15
+ *
+ * Clobber list: x0,x1,x2,x3,x4,x5,x6,x7,x8,x9,x11
  */
+func _s32g_sram_clr
+	/* Save x30 */
+	mov	x11, x30
+
+	sub	x1, x1, #1
+	/* Low address */
+	bl	calc_sramc_addr
+	mov	x7, x0
+	mov	x0, x1
 
-func sram_clr
-	add	x1, x0, x1
-
-	/* save registers that are clobbered by dma_mem_clr */
-	mov	x15, x30
-	mov	x10, x0
-	mov	x11, x1
+	/* High address */
+	bl	calc_sramc_addr
 
-	/* If the start address is not aligned to 64bytes, the ideal
-	 * transfer size for edma, perform a suboptimal edma transfer
-	 * on the region until the first 64byte boundary.
-	 */
-	and	x1, x10, #0x3f
-	cbz	x1, unaligned_start_done
-	mov 	x1, x10, lsr #6
-	mov 	x1, x1, lsl #6
-	add 	x1, x1, #0x40
-	mov	x10, x1
-	sub	x1, x1, x0
-	bl	dma_mem_clr
-unaligned_start_done:
-
-	/* Forcefully align the end address on a 64byte boundary
-	 * and request an edma transfer.
+	/**
+	 * x7 - Low initialization address
+	 * x8 - High initialization address
 	 */
-	mov	x0, x10
-	mov 	x1, x11
-	mov 	x1, x1, lsr #6
-	mov 	x1, x1, lsl #6
-	sub 	x1, x1, x0
-	bl	dma_mem_clr
-
-	/* Perform another suboptimal edma transfer if there is an
-	 * unaligned leftover region at the end after we forcefully
-	 * aligned the address above.
-	 */
-	mov	x0, x11
-	mov 	x0, x0, lsr #6
-	mov 	x0, x0, lsl #6
-	mov 	x1, x11
-	sub 	x1, x1, x0
-	cbz 	x1, unaligned_end_done
-	bl	dma_mem_clr
-unaligned_end_done:
-
-	mov	x30, x15
+	mov	x8, x0
+	mov	x9, #SRAMC1_MAX_ADDR
+	cmp	x8, x9
+	bgt	error
+
+	mov	x0, #SRAMC0_MIN_ADDR
+	mov	x1, #SRAMC0_MAX_ADDR
+	mov	x2, x7
+	mov	x3, x8
+	bl	in_overlap
+	cbnz	x0, init_sramc0
+
+check_sramc1:
+	mov	x0, #SRAMC1_MIN_ADDR
+	mov	x1, #SRAMC1_MAX_ADDR
+	mov	x2, x7
+	mov	x3, x8
+	bl	in_overlap
+	cbnz	x0, init_sramc1
+	b	exit
+
+init_sramc0:
+	mov	x0, #SRAMC0_BASE_ADDD_L
+	movk	x0, #SRAMC0_BASE_ADDD_H, lsl #16
+	mov	x1, x7
+	mov	x2, x8
+	mov	x9, #SRAMC0_MAX_ADDR
+	cmp	x2, x9
+	b.gt	1f
+	b	2f
+1:
+	mov	x2, #SRAMC0_MAX_ADDR
+2:
+	bl	clear_sramc_range
+	b	check_sramc1
+
+init_sramc1:
+	mov	x0, #SRAMC1_BASE_ADDD_L
+	movk	x0, #SRAMC1_BASE_ADDD_H, lsl #16
+	cmp	x7, #SRAMC1_MIN_ADDR
+	b.lt	3f
+	sub	x1, x7, #SRAMC1_MIN_ADDR
+	b	4f
+3:
+	mov	x1, #0
+4:
+	sub	x2, x8, #SRAMC1_MIN_ADDR
+	bl	clear_sramc_range
+
+	mov	x0, #0
+
+exit:
+	/* Restore x30 */
+	mov	x30, x11
 	ret
-endfunc sram_clr
+
+error:
+	/* Restore x30 */
+	mov	x30, x11
+	mov	x0, #-1
+	ret
+endfunc _s32g_sram_clr
 
 /* Clobber list: x0,x1,x7,x8
  */
@@ -234,17 +269,3 @@ func plat_core_pos_by_mpidr
 	mov	x30, x7
 	ret
 endfunc plat_core_pos_by_mpidr
-
-/* Used by 'dma_mem_clr' and required to be aligned to
- * edma's maximum transfer size, which is 64bytes.
- */
-.align 6
-initvar:
-	.quad 0x0
-	.quad 0x0
-	.quad 0x0
-	.quad 0x0
-	.quad 0x0
-	.quad 0x0
-	.quad 0x0
-	.quad 0x0
diff --git a/plat/nxp/s32g/s32g_psci.c b/plat/nxp/s32g/s32g_psci.c
index 3a9d63083..e7b1532f8 100644
--- a/plat/nxp/s32g/s32g_psci.c
+++ b/plat/nxp/s32g/s32g_psci.c
@@ -12,6 +12,7 @@
 #include "ssram_mailbox.h"
 #include "s32g_resume.h"
 #include "s32g_bl_common.h"
+#include "s32g_sramc.h"
 
 #include <arch_helpers.h>
 #include <assert.h>
@@ -38,6 +39,8 @@ static const unsigned char s32g_power_domain_tree_desc[] = {
 	PLATFORM_CORE_COUNT / 2
 };
 
+static bool copied_bl31sram;
+
 static bool is_core_in_secondary_cluster(int pos)
 {
 	return (pos == 2 || pos == 3);
@@ -108,23 +111,35 @@ static void copy_bl31sram_image(void)
 {
 	uint32_t npages;
 	int ret;
-	static bool copied;
 
-	if (copied)
+	if (copied_bl31sram)
 		return;
 
-	/* Copy bl31 sram stage */
-	memcpy((void *)BL31SRAM_BASE, bl31sram, bl31sram_len);
+	/* Clear all BL31SRAM sections */
+	ret = s32g_sram_clear(BL31SRAM_BASE, BL31SRAM_LIMIT);
+	if (ret)
+		ERROR("Failed to initialize SRAM from BL31SRAM stage\n");
+
+
 	npages = bl31sram_len / PAGE_SIZE;
 	if (bl31sram_len % PAGE_SIZE)
 		npages++;
 
-	ret = xlat_change_mem_attributes(BL31SRAM_BASE, npages * PAGE_SIZE,
+	ret = xlat_change_mem_attributes(BL31SRAM_BASE,
+					 npages * PAGE_SIZE,
+					 MT_MEMORY | MT_RW | MT_EXECUTE_NEVER);
+	if (ret)
+		ERROR("Failed to change the attributes of BL31 SRAM memory\n");
+
+	/* Copy bl31 sram stage */
+	memcpy((void *)BL31SRAM_BASE, bl31sram, bl31sram_len);
+	ret = xlat_change_mem_attributes(BL31SRAM_BASE,
+			npages * PAGE_SIZE,
 			MT_CODE | MT_SECURE);
 	if (ret)
 		ERROR("Failed to change the attributes of BL31 SRAM memory\n");
 
-	copied = true;
+	copied_bl31sram = true;
 }
 
 static void bl31sram_entry(void)
@@ -209,6 +224,7 @@ static void __dead2 s32g_pwr_domain_pwr_down_wfi(
 		plat_secondary_cold_boot_setup();
 	}
 
+	copied_bl31sram = false;
 	platform_suspend();
 
 	/* Unreachable code */
diff --git a/plat/nxp/s32g/s32g_sramc.c b/plat/nxp/s32g/s32g_sramc.c
new file mode 100644
index 000000000..d641b1d46
--- /dev/null
+++ b/plat/nxp/s32g/s32g_sramc.c
@@ -0,0 +1,61 @@
+/*
+ * Copyright 2020 NXP
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ */
+#include <lib/mmio.h>
+#include <errno.h>
+#include <platform_def.h>
+#include "s32g_sramc.h"
+
+int _s32g_sram_clr(uintptr_t start, uintptr_t end);
+
+void s32g_ssram_clear(void)
+{
+	uintptr_t base = SSRAMC_BASE_ADDR;
+
+	/* Disable the controller */
+	mmio_write_32(base + SRAMC_PRAMCR_OFFSET, 0x0);
+
+	/* Max range */
+	mmio_write_32(base + SRAMC_PRAMIAS_OFFSET, 0x0);
+	mmio_write_32(base + SRAMC_PRAMIAE_OFFSET, SSRAM_MAX_ADDR);
+
+	/* Initialization request */
+	mmio_write_32(base + SRAMC_PRAMCR_OFFSET, SRAMC_PRAMCR_INITREQ);
+
+	while (!(mmio_read_32(base + SRAMC_PRAMSR_OFFSET) & SRAMC_PRAMSR_IDONE))
+		;
+	mmio_write_32(base + SRAMC_PRAMSR_OFFSET, SRAMC_PRAMSR_IDONE);
+}
+
+int s32g_sram_clear(uintptr_t start, uintptr_t end)
+{
+	uintptr_t low, high;
+	int ret;
+
+	if (start == end)
+		return 0;
+
+	if (end < start)
+		return -EINVAL;
+
+	start = round_down(start, SRAM_BLOCK);
+	end = round_up(end, SRAM_BLOCK);
+
+	if (start < S32G_SRAM_BASE)
+		return -EINVAL;
+
+	if (end > S32G_SRAM_END)
+		return -EINVAL;
+
+	/* Bus addresses */
+	low = (start - S32G_SRAM_BASE);
+	high = (end - S32G_SRAM_BASE);
+
+	ret = _s32g_sram_clr(low, high);
+	if (ret)
+		return ret;
+
+	return 0;
+}
-- 
2.17.1

