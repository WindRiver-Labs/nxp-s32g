From aefa45eef24b68f1e173a94f39cfa017de42b1cf Mon Sep 17 00:00:00 2001
From: Bogdan Hamciuc <bogdan.hamciuc@nxp.com>
Date: Tue, 17 Dec 2019 09:54:50 +0200
Subject: [PATCH 041/269] s32g: Enable DDR clock

Add support for enabling DDR clock in MC_ME, MC_CGM and PLLDIG.

Upstream-Status: Pending 

Signed-off-by: Bogdan Hamciuc <bogdan.hamciuc@nxp.com>
Signed-off-by: Zhantao Tang <zhantao.tang@windriver.com>
Issue: ALB-4277
---
 plat/s32g/include/s32g_clocks.h |  1 +
 plat/s32g/include/s32g_mc_me.h  | 16 ++++++++---
 plat/s32g/platform.mk           |  2 +-
 plat/s32g/s32g_clocks.c         | 16 ++++++++---
 plat/s32g/s32g_mc_me.c          | 48 ++++++++++++++++++++++++++++++---
 5 files changed, 71 insertions(+), 12 deletions(-)

diff --git a/plat/s32g/include/s32g_clocks.h b/plat/s32g/include/s32g_clocks.h
index 838720f98..271133057 100644
--- a/plat/s32g/include/s32g_clocks.h
+++ b/plat/s32g/include/s32g_clocks.h
@@ -279,6 +279,7 @@ enum s32g_mc_cgm {
 
 #define MC_CGM_MUXn_CSC_SEL_ARM_PLL_PHI0	4
 #define MC_CGM_MUXn_CSC_SEL_PERIPH_PLL_PHI3	21
+#define MC_CGM_MUXn_CSC_SEL_DDR_PLL_PHI0	36
 
 void s32g_plat_clock_init(void);
 
diff --git a/plat/s32g/include/s32g_mc_me.h b/plat/s32g/include/s32g_mc_me.h
index cda632595..533292694 100644
--- a/plat/s32g/include/s32g_mc_me.h
+++ b/plat/s32g/include/s32g_mc_me.h
@@ -21,7 +21,7 @@
 #define S32G_MC_ME_SECONDARY_CORE_MASK	(~S32G_MC_ME_PRIMARY_CORE_MASK & 0xF)
 
 /* CTL_KEY register */
-#define S32G_MC_ME_CTL_KEY		S32G_MC_ME_BASE_ADDR
+#define S32G_MC_ME_CTL_KEY		(S32G_MC_ME_BASE_ADDR)
 #define S32G_MC_ME_CTL_KEY_KEY		0x00005AF0
 #define S32G_MC_ME_CTL_KEY_INVERTEDKEY	0x0000A50F
 
@@ -29,9 +29,9 @@
 #define S32G_MC_ME_PRTN_N_BASE(n) \
 	(S32G_MC_ME_BASE_ADDR + 0x100 + (n) * 0x200)
 #define S32G_MC_ME_PRTN_N_PCONF(n) \
-	(S32G_MC_ME_PRTN_N_BASE(n) + 0x4)
+	(S32G_MC_ME_PRTN_N_BASE(n) + 0x0)
 #define S32G_MC_ME_PRTN_N_PUPD(n) \
-	(S32G_MC_ME_PRTN_N_BASE(n) + 0x8)
+	(S32G_MC_ME_PRTN_N_BASE(n) + 0x4)
 /* PRTNn_PCONF[PCE] mask */
 #define S32G_MC_ME_PRTN_N_PCONF_PCE_MASK	0x1ul
 /* PRTNn_PUPD[PCUD] mask */
@@ -55,7 +55,16 @@
 /* PRTNn_COREm_STAT[CCS] mask */
 #define S32G_MC_ME_PRTN_N_CORE_M_STAT_CCS_MASK		0x1ul
 
+/* PRTNn_COFBm registers */
+
+#define S32G_MC_ME_PRTN_N_COFB_0_CLKEN(n) \
+	(S32G_MC_ME_PRTN_N_BASE(n) + 0x30)
+
+
 #define S32G_MC_ME_CA53_PART	1
+#define S32G_MC_ME_DDR_0_PART	0
+#define S32G_MC_ME_DDR_0_REQ	1
+
 
 /*
  * MC Reset Generation Module
@@ -76,6 +85,7 @@
 #define S32G_MC_RGM_RST_CA53_PART_BIT	BIT(0)
 
 void s32g_kick_secondary_ca53_cores(void);
+void mc_me_enable_partition_block(uint32_t part, uint32_t block);
 
 
 #endif /* __S32G_MC_ME_H__ */
diff --git a/plat/s32g/platform.mk b/plat/s32g/platform.mk
index b2a8c0b65..207007919 100644
--- a/plat/s32g/platform.mk
+++ b/plat/s32g/platform.mk
@@ -20,6 +20,7 @@ BL2_AT_EL3		:= 1
 
 PLAT_BL_COMMON_SOURCES	+= plat/s32g/s32g_lowlevel_common.S \
 			   plat/s32g/s32g_linflexuart.S \
+			   plat/s32g/s32g_mc_me.c \
 			   lib/cpus/aarch64/cortex_a53.S
 
 BL2_SOURCES		+= plat/s32g/s32g_lowlevel_bl2.S \
@@ -34,7 +35,6 @@ BL2_SOURCES		+= plat/s32g/s32g_lowlevel_bl2.S \
 
 BL31_SOURCES		+= plat/s32g/s32g275_bl31.c \
 			   plat/s32g/s32g_psci.c \
-			   plat/s32g/s32g_mc_me.c \
 			   plat/common/plat_psci_common.c \
 			   plat/common/plat_gicv3.c \
 			   drivers/arm/gic/v3/gicv3_main.c \
diff --git a/plat/s32g/s32g_clocks.c b/plat/s32g/s32g_clocks.c
index 8c5fa9205..0216dcaa8 100644
--- a/plat/s32g/s32g_clocks.c
+++ b/plat/s32g/s32g_clocks.c
@@ -7,6 +7,7 @@
 #include <errno.h>
 #include <assert.h>
 #include "s32g_clocks.h"
+#include "s32g_mc_me.h"
 
 
 static uint64_t plldig_set_refclk(enum s32g_pll_type pll,
@@ -287,6 +288,9 @@ void s32g_plat_clock_init(void)
 
 	/* Prepare FXOSC to run on */
 	start_fxosc();
+	/* Enable partition clock for the DDR */
+	mc_me_enable_partition_block(S32G_MC_ME_DDR_0_PART,
+				     S32G_MC_ME_DDR_0_REQ);
 
 	/* Configure the CORE_PLL */
 	program_pll(S32G_CORE_PLL, S32G_REFCLK_FXOSC, s32g_core_pll_phi_freq,
@@ -295,8 +299,7 @@ void s32g_plat_clock_init(void)
 	/* Configure the CORE_DFS) */
 	program_dfs(S32G_CORE_DFS, s32g_core_dfs_params);
 	/* Configure the core CGM mux */
-	sw_mux_clk_config(MC_CGM1, 0,
-			  MC_CGM_MUXn_CSC_SEL_ARM_PLL_PHI0);
+	sw_mux_clk_config(MC_CGM1, 0, MC_CGM_MUXn_CSC_SEL_ARM_PLL_PHI0);
 
 	/* Configure the PERIPH_PLL */
 	program_pll(S32G_PERIPH_PLL, S32G_REFCLK_FXOSC,
@@ -306,6 +309,11 @@ void s32g_plat_clock_init(void)
 	/* Configure the PERIPH_DFS */
 	program_dfs(S32G_PERIPH_DFS, s32g_periph_dfs_params);
 	/* Configure the LinFlexD CGM mux */
-	sw_mux_clk_config(MC_CGM0, 8,
-			  MC_CGM_MUXn_CSC_SEL_PERIPH_PLL_PHI3);
+	sw_mux_clk_config(MC_CGM0, 8, MC_CGM_MUXn_CSC_SEL_PERIPH_PLL_PHI3);
+
+	/* Configure the DDR_PLL */
+	program_pll(S32G_DDR_PLL, S32G_REFCLK_FXOSC, s32g_ddr_pll_phi_freq,
+		    s32g_pll_rdiv[S32G_DDR_PLL], s32g_pll_mfi[S32G_DDR_PLL],
+		    s32g_pll_mfn[S32G_DDR_PLL]);
+	sw_mux_clk_config(MC_CGM5, 0, MC_CGM_MUXn_CSC_SEL_DDR_PLL_PHI0);
 }
diff --git a/plat/s32g/s32g_mc_me.c b/plat/s32g/s32g_mc_me.c
index 7555272a2..a5f7d9f08 100644
--- a/plat/s32g/s32g_mc_me.c
+++ b/plat/s32g/s32g_mc_me.c
@@ -10,9 +10,10 @@
 
 void plat_secondary_cold_boot_setup(void);
 
-/**
- * PRTNn_COREm accessors for less finger-twitching
+/*
+ * PART<n>_CORE<m> register accessors
  */
+
 static void mc_me_part_core_addr_write(uint32_t val, uint32_t part,
 				       uint32_t core)
 {
@@ -41,6 +42,10 @@ static void mc_me_part_core_pupd_write_ccupd(uint32_t ccupd_bit, uint32_t p,
 	mmio_write_32(S32G_MC_ME_PRTN_N_CORE_M_PUPD(p, c), pupd);
 }
 
+/*
+ * PART<n>_[XYZ] register accessors
+ */
+
 static void mc_me_part_pconf_write_pce(uint32_t pce_bit, uint32_t p)
 {
 	uint32_t pconf;
@@ -55,18 +60,53 @@ static void mc_me_part_pupd_write_pcud(uint32_t pcud_bit, uint32_t p)
 {
 	uint32_t pupd;
 
-	pupd = mmio_read_32(S32G_MC_ME_PRTN_N_PCONF(p) &
+	pupd = mmio_read_32(S32G_MC_ME_PRTN_N_PUPD(p) &
 			~S32G_MC_ME_PRTN_N_PUPD_PCUD_MASK);
 	pupd |= (pcud_bit & S32G_MC_ME_PRTN_N_PUPD_PCUD_MASK);
-	mmio_write_32(S32G_MC_ME_PRTN_N_PCONF(p), pupd);
+	mmio_write_32(S32G_MC_ME_PRTN_N_PUPD(p), pupd);
+}
+
+/*
+ * PART<n>_COFB<m> register accessors
+ */
+
+static void mc_me_part_cofb_clken_write_req(uint32_t req, uint32_t val,
+					    uint32_t part)
+{
+	uint32_t clken;
+
+	clken = mmio_read_32(S32G_MC_ME_PRTN_N_COFB_0_CLKEN(part));
+	clken |= ((val & 0x1) << req);
+	mmio_write_32(S32G_MC_ME_PRTN_N_COFB_0_CLKEN(part), clken);
 }
 
+
+/* Apply changes to MC_ME partitions */
 static void mc_me_apply_hw_changes(void)
 {
 	mmio_write_32(S32G_MC_ME_CTL_KEY, S32G_MC_ME_CTL_KEY_KEY);
 	mmio_write_32(S32G_MC_ME_CTL_KEY, S32G_MC_ME_CTL_KEY_INVERTEDKEY);
 }
 
+/*
+ * Higher-level constructs
+ */
+
+void mc_me_enable_partition_block(uint32_t part, uint32_t block)
+{
+	uint32_t pcud;
+
+	mc_me_part_pconf_write_pce(1, part);
+	mc_me_part_cofb_clken_write_req(block, 1, part);
+	mc_me_part_pupd_write_pcud(1, part);
+	mc_me_apply_hw_changes();
+
+	do {
+		pcud = mmio_read_32(S32G_MC_ME_PRTN_N_PUPD(part)) &
+			S32G_MC_ME_PRTN_N_PUPD_PCUD_MASK;
+	} while (pcud);
+}
+
 /** Reset and initialize secondary A53 core identified by its number
  *  in one of the MC_ME partitions
  */
-- 
2.17.1

