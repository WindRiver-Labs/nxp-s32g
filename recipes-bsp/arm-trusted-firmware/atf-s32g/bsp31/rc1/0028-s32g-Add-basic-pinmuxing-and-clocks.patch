From b2fa6a1bd92f18705d4f1c1553bf7c6d8b5abad5 Mon Sep 17 00:00:00 2001
From: Bogdan Hamciuc <bogdan.hamciuc@nxp.com>
Date: Fri, 15 Nov 2019 14:22:11 +0200
Subject: [PATCH 028/269] s32g: Add basic pinmuxing and clocks

Add pinmuxing and clocks to support mainly LinFlexD and the A53 core.
While the rest of the blocks - most notably DDR - are also supported by
the current clocks definitions, they are not yet configured.

Also resolve a number of warnings-turned-errors resulted after the
latest rebase.

Upstream-Status: Pending 

Signed-off-by: Bogdan Hamciuc <bogdan.hamciuc@nxp.com>
Signed-off-by: Zhantao Tang <zhantao.tang@windriver.com>
Issue: ALB-4275
Issue: ALB-4276
---
 plat/s32g/include/platform_def.h |  17 +-
 plat/s32g/include/s32g_clocks.h  | 285 ++++++++++++++++++++++++++++
 plat/s32g/include/s32g_pinctrl.h |  53 ++++++
 plat/s32g/platform.mk            |   8 +
 plat/s32g/s32g275_bl31.c         |   6 +
 plat/s32g/s32g_clocks.c          | 310 +++++++++++++++++++++++++++++++
 plat/s32g/s32g_pinctrl.c         |  29 +++
 7 files changed, 703 insertions(+), 5 deletions(-)
 create mode 100644 plat/s32g/include/s32g_clocks.h
 create mode 100644 plat/s32g/include/s32g_pinctrl.h
 create mode 100644 plat/s32g/s32g_clocks.c
 create mode 100644 plat/s32g/s32g_pinctrl.c

diff --git a/plat/s32g/include/platform_def.h b/plat/s32g/include/platform_def.h
index c2bcc9f93..3d9d9230b 100644
--- a/plat/s32g/include/platform_def.h
+++ b/plat/s32g/include/platform_def.h
@@ -54,15 +54,18 @@
  * We suspect the sim incorrectly further divides the clock signal, so we
  * manually (and approximately) adjust for that.
  */
-#define COUNTER_FREQUENCY		0xC0000
+#define COUNTER_FREQUENCY	0xC0000
 #else
 /* 5MHz; this is based on the assumption that GPR00[CA53_COUNTER_CLK_DIV_VAL]
  * contains the reset value of 0x7, hence producing a divider value of 8,
  * applied to the FXOSC frequency of 40MHz
  */
-#define COUNTER_FREQUENCY		0x004C4B40
+#define COUNTER_FREQUENCY	0x004C4B40
 #endif
 
+#define SIUL2_0_BASE_ADDR	0x4009C000UL
+#define SIUL2_1_BASE_ADDR	0x44010000UL
+
 /* GIC (re)definitions */
 #define S32G275_GIC_BASE	0x50800000
 #define PLAT_GICD_BASE		S32G275_GIC_BASE
@@ -71,11 +74,9 @@
 /* SGI to use for kicking the secondary cores out of wfi */
 #define S32G_SECONDARY_WAKE_SGI	15
 
-/*
- * Platform memory map
- */
 #define S32G_XRDC_BASE		0x401A4000
 #define S32G_XRDC_SIZE		0x10000
+
 /* SRAM is actually at 0x3400_0000; we are just mirroring it in the
  * Virtual Code RAM
  */
@@ -97,6 +98,12 @@
  * Memory layout macros
  */
 
+/* Physical address 0x0 is actually mapped; to increase our
+ * chances of detecting a 'null pointer access', use a location
+ * that is currently not mapped to anything
+ */
+#define S32G_ERR_PTR		(0x44000000ul)
+
 /* Note: depending on the compiler optimization level, this may or may not be
  * enough to prevent overflowing onto the adjacent SRAM image. Handle with care,
  * wear a helmet and compile with -Os.
diff --git a/plat/s32g/include/s32g_clocks.h b/plat/s32g/include/s32g_clocks.h
new file mode 100644
index 000000000..838720f98
--- /dev/null
+++ b/plat/s32g/include/s32g_clocks.h
@@ -0,0 +1,285 @@
+/*
+ * Copyright 2019 NXP
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ */
+#ifndef _S32G_CLOCKS_H_
+#define _S32G_CLOCKS_H_
+
+
+#define S32G_FXOSC_FREQ		(40000000ul)
+#define S32G_FIRC_FREQ		(48000000ul)
+#define S32G_ERR_CLK_FREQ	(0ul)
+
+/*
+ * PLL configuration
+ */
+
+#define CORE_PLL_BASE_ADDR	0x40038000ul
+#define PLL_ADDR(pll)		(CORE_PLL_BASE_ADDR + (pll) * 0x4000)
+
+#define PLL_MIN_FREQ		(1300000000ull)
+#define PLL_MAX_FREQ		(5000000000ull)
+
+#define PLLCLKMUX_OFFSET	0x20
+#define PLLDIG_PLLCLKMUX(pll)	((PLL_ADDR(pll)) + PLLCLKMUX_OFFSET)
+#define PLLDIG_PLLCLKMUX_REFCLK_FIRC	(0x0ul)
+#define PLLDIG_PLLCLKMUX_REFCLK_FXOSC	(0x1ul)
+
+#define PLLDIG_PLLCR_PLLPD	BIT(31)
+#define PLLDIG_PLLCR(pll)	(PLL_ADDR(pll))
+
+#define PLLDIG_PLLODIV(pll, n)		((PLL_ADDR(pll)) + 0x00000080 + n * 0x4)
+#define PLLDIG_PLLODIV_DIV_MASK		(0x00FF0000)
+#define PLLDIG_PLLODIV_DIV_OFFSET	(16)
+#define PLLDIG_PLLODIV_DIV_SET(val) \
+	(PLLDIG_PLLODIV_DIV_MASK & ((val) << PLLDIG_PLLODIV_DIV_OFFSET))
+#define PLLDIG_PLLODIV_DE		BIT(31)
+
+#define PLLDIG_PLLDV(pll)	((PLL_ADDR(pll)) + 0x00000008)
+#define PLLDIG_PLLDV_MFI_MASK	(0x000000FF)
+#define PLLDIG_PLLDV_MFI(div)	(PLLDIG_PLLDV_MFI_MASK & (div))
+#define PLLDIG_PLLDV_RDIV_MASK		(0x00007000)
+#define PLLDIG_PLLDV_RDIV_MAXVALUE	(0x7)
+#define PLLDIG_PLLDV_RDIV_OFFSET	(12)
+#define PLLDIG_PLLDV_RDIV_SET(val)	(PLLDIG_PLLDV_RDIV_MASK & \
+	(((val) & PLLDIG_PLLDV_RDIV_MAXVALUE) << PLLDIG_PLLDV_RDIV_OFFSET))
+
+#define PLLDIG_PLLFD(pll)		((PLL_ADDR(pll)) + 0x00000010)
+#define PLLDIG_PLLFD_SMDEN		BIT(30)
+#define PLLDIG_PLLFD_MFN_MASK		(0x00007FFF)
+#define PLLDIG_PLLFD_MFN_SET(val)	(PLLDIG_PLLFD_MFN_MASK & (val))
+
+#define PLLDIG_PLLSR_LOCK	BIT(2)
+#define PLLDIG_PLLSR(pll)	((PLL_ADDR(pll)) + 0x00000004)
+
+enum s32g_pll_type {
+	S32G_CORE_PLL = 0,
+	S32G_PERIPH_PLL,
+	S32G_ACCEL_PLL,
+	S32G_DDR_PLL,
+	S32G_PLL_NR	/* sentinel */
+};
+
+/* Number of dividers for each PLL */
+static const uint32_t s32g_pll_phi_nr[S32G_PLL_NR] = {2, 8, 2, 1};
+
+/* Array of parameters for each PLL */
+static const uint32_t s32g_pll_rdiv[S32G_PLL_NR] = {1, 1, 1, 1};
+static const uint32_t s32g_pll_mfi[S32G_PLL_NR] = {50, 50, 60, 40};
+static const uint32_t s32g_pll_mfn[S32G_PLL_NR] = {0, 0, 1, 0};
+
+/*
+ * Arrays of PHI frequencies
+ */
+#define CORE_PLL_PHI0_FREQ	(1000000000ull)
+#define CORE_PLL_PHI1_FREQ	(500000000ull)
+static const uint64_t s32g_core_pll_phi_freq[] = {
+	CORE_PLL_PHI0_FREQ,
+	CORE_PLL_PHI1_FREQ,
+};
+#define PERIPH_PLL_PHI0_FREQ	(100000000ull)
+#define PERIPH_PLL_PHI1_FREQ	(80000000ull)
+#define PERIPH_PLL_PHI2_FREQ	(80000000ull)
+#define PERIPH_PLL_PHI3_FREQ	(125000000ull)
+#define PERIPH_PLL_PHI4_FREQ	(200000000ull)
+#define PERIPH_PLL_PHI5_FREQ	(125000000ull)
+#define PERIPH_PLL_PHI6_FREQ	(100000000ull)
+#define PERIPH_PLL_PHI7_FREQ	(100000000ull)
+static const uint64_t s32g_periph_pll_phi_freq[] = {
+	PERIPH_PLL_PHI0_FREQ,
+	PERIPH_PLL_PHI1_FREQ,
+	PERIPH_PLL_PHI2_FREQ,
+	PERIPH_PLL_PHI3_FREQ,
+	PERIPH_PLL_PHI4_FREQ,
+	PERIPH_PLL_PHI5_FREQ,
+	PERIPH_PLL_PHI6_FREQ,
+	PERIPH_PLL_PHI7_FREQ,
+};
+#define ACCEL_PLL_PHI0_FREQ	(600000000ull)
+#define ACCEL_PLL_PHI1_FREQ	(600000000ull)
+static const uint64_t s32g_accel_pll_phi_freq[] = {
+	ACCEL_PLL_PHI0_FREQ,
+	ACCEL_PLL_PHI1_FREQ,
+};
+#define DDR_PLL_PHI0_FREQ	(400000000ull)
+static const uint64_t s32g_ddr_pll_phi_freq[] = {
+	DDR_PLL_PHI0_FREQ,
+};
+
+/*
+ * DFS configuration
+ */
+
+/* Number of ports for each DFS  */
+#define S32G_DFS_PORTS_NR	6
+
+enum s32g_dfs_type {
+	S32G_CORE_DFS = 0,
+	S32G_PERIPH_DFS,
+	S32G_DFS_NR	/* sentinel */
+};
+
+#define S32G_DFS_BASE_ADDR	0x40054000ul
+/* @dfs - One of the enum s32g_dfs_type values */
+#define S32G_DFS_ADDR(dfs) (S32G_DFS_BASE_ADDR + (dfs) * 0x4000)
+/* DFS register offsets */
+#define DFS_PORTRESET_OFF	0X14ul
+#define DFS_PORTRESET(dfs)	((S32G_DFS_ADDR(dfs)) + DFS_PORTRESET_OFF)
+#define DFS_PORTSR_OFF		0xCul
+#define DFS_PORTSR(dfs)		((S32G_DFS_ADDR(dfs)) + DFS_PORTSR_OFF)
+#define DFS_CTL_OFF		0x18ul
+#define DFS_CTL(dfs)		((S32G_DFS_ADDR(dfs)) + DFS_CTL_OFF)
+#define DFS_DVPORT0_OFF		0x1Cul
+#define DFS_DVPORTn(dfs, port)	((S32G_DFS_ADDR(dfs)) + DFS_DVPORT0_OFF + \
+					(port) * 0x4)
+/* DFS register fields */
+#define DFS_PORTRESET_RESET_MASK	(0x3F)
+#define DFS_PORTSR_PORTSTAT_MASK	DFS_PORTRESET_RESET_MASK
+#define DFS_CTL_RESET			(1 << 1)
+#define DFS_DVPORTn_MFI_MASK		(0xFF)
+#define DFS_DVPORTn_MFI_SHIFT		(8)
+#define DFS_DVPORTn_MFN_MASK		(0x3F)
+#define DFS_DVPORTn_MFN_SHIFT		(0)
+#define DFS_DVPORTn_MFI(mfi)	\
+	(((mfi) & DFS_DVPORTn_MFI_MASK) << DFS_DVPORTn_MFI_SHIFT)
+#define DFS_DVPORTn_MFN(mfn)	\
+	(((mfn) & DFS_DVPORTn_MFN_MASK) << DFS_DVPORTn_MFN_SHIFT)
+
+enum S32G_DFS_PARAMS {
+	DFS_PORT_EN = 0,
+	DFS_DVPORT_MFN,
+	DFS_DVPORT_MFI,
+	DFS_PARAMS_NR	/* sentinel */
+};
+
+/* Core DFS configuration params */
+#define CORE_DFS1_EN	(1)
+#define CORE_DFS2_EN	(1)
+#define CORE_DFS3_EN	(1)
+#define CORE_DFS4_EN	(1)
+#define CORE_DFS5_EN	(1)
+#define CORE_DFS6_EN	(1)
+
+#define CORE_DFS1_MFN	(9)
+#define CORE_DFS2_MFN	(9)
+#define CORE_DFS3_MFN	(0)
+#define CORE_DFS4_MFN	(12)
+#define CORE_DFS5_MFN	(24)
+#define CORE_DFS6_MFN	(24)
+
+#define CORE_DFS1_MFI	(1)
+#define CORE_DFS2_MFI	(1)
+#define CORE_DFS3_MFI	(2)
+#define CORE_DFS4_MFI	(3)
+#define CORE_DFS5_MFI	(1)
+#define CORE_DFS6_MFI	(1)
+
+static const uint32_t s32g_core_dfs_params[S32G_DFS_PORTS_NR][DFS_PARAMS_NR] = {
+	{CORE_DFS1_EN, CORE_DFS1_MFN, CORE_DFS1_MFI},
+	{CORE_DFS2_EN, CORE_DFS2_MFN, CORE_DFS2_MFI},
+	{CORE_DFS3_EN, CORE_DFS3_MFN, CORE_DFS3_MFI},
+	{CORE_DFS4_EN, CORE_DFS4_MFN, CORE_DFS4_MFI},
+	{CORE_DFS5_EN, CORE_DFS5_MFN, CORE_DFS5_MFI},
+	{CORE_DFS6_EN, CORE_DFS6_MFN, CORE_DFS6_MFI}
+};
+
+/* Periph DFS configuration params */
+#define PERIPH_DFS1_EN	(1)
+#define PERIPH_DFS2_EN	(1)
+#define PERIPH_DFS3_EN	(1)
+#define PERIPH_DFS4_EN	(1)
+#define PERIPH_DFS5_EN	(1)
+#define PERIPH_DFS6_EN	(1)
+
+#define PERIPH_DFS1_MFN (9)
+#define PERIPH_DFS2_MFN (21)
+#define PERIPH_DFS3_MFN (9)
+#define PERIPH_DFS4_MFN (24)
+#define PERIPH_DFS5_MFN (1)
+#define PERIPH_DFS6_MFN (0)
+
+#define PERIPH_DFS1_MFI (1)
+#define PERIPH_DFS2_MFI (1)
+#define PERIPH_DFS3_MFI (1)
+#define PERIPH_DFS4_MFI (1)
+#define PERIPH_DFS5_MFI (3)
+#define PERIPH_DFS6_MFI (2)
+
+static const uint32_t
+s32g_periph_dfs_params[S32G_DFS_PORTS_NR][DFS_PARAMS_NR] = {
+	{PERIPH_DFS1_EN, PERIPH_DFS1_MFN, PERIPH_DFS1_MFI},
+	{PERIPH_DFS2_EN, PERIPH_DFS2_MFN, PERIPH_DFS2_MFI},
+	{PERIPH_DFS3_EN, PERIPH_DFS3_MFN, PERIPH_DFS3_MFI},
+	{PERIPH_DFS4_EN, PERIPH_DFS4_MFN, PERIPH_DFS4_MFI},
+	{PERIPH_DFS5_EN, PERIPH_DFS5_MFN, PERIPH_DFS5_MFI},
+	{PERIPH_DFS6_EN, PERIPH_DFS6_MFN, PERIPH_DFS6_MFI}
+};
+
+/*
+ * Platform reference clocks
+ */
+
+enum s32g_refclk {
+	S32G_REFCLK_FIRC,
+	S32G_REFCLK_FXOSC,
+};
+
+#define S32G_FXOSC_BASE_ADDR	0x40050000ul
+/* FXOSC registers */
+#define FXOSC_CTRL		(S32G_FXOSC_BASE_ADDR)
+#define FXOSC_STAT		(S32G_FXOSC_BASE_ADDR + 0x4ul)
+/* FXOSC register fields */
+#define FXOSC_CTRL_OSC_BYP	BIT(31)
+#define FXOSC_CTRL_COMP_EN	BIT(24)
+#define FXOSC_CTRL_EOCV_SHIFT	(16)
+#define FXOSC_CTRL_EOCV_MASK	(0xFF)
+#define FXOSC_CTRL_EOCV(eocv)	\
+	(((eocv) & FXOSC_CTRL_EOCV_MASK) << FXOSC_CTRL_EOCV_SHIFT)
+#define FXOSC_CTRL_GM_SEL_SHIFT	(4)
+#define FXOSC_CTRL_GM_SEL_MASK	(0xF)
+#define FXOSC_CTRL_GM_SEL(sel)	\
+	(((sel) & FXOSC_CTRL_GM_SEL_MASK) << FXOSC_CTRL_GM_SEL_SHIFT)
+#define FXOSC_CTRL_OSCON	BIT(0)
+#define FXOSC_STAT_OSC_STAT	BIT(31)
+
+/*
+ * MC_CGM configuration
+ */
+enum s32g_mc_cgm {
+	MC_CGM0,
+	MC_CGM1,
+	MC_CGM2,
+	MC_CGM5
+};
+
+#define MC_CGM0_BASE_ADDR		(0x40030000ul)
+#define MC_CGM1_BASE_ADDR		(0x40034000ul)
+#define MC_CGM2_BASE_ADDR		(0x44018000ul)
+#define MC_CGM5_BASE_ADDR		(0x40068000ul)
+
+#define MC_CGM_MUXn_CSS_SWIP		BIT(16)
+#define MC_CGM_MUXn_CSC_SELCTL_MASK	(0x3F000000)
+#define MC_CGM_MUXn_CSC_SELCTL_OFFSET	(24)
+#define MC_CGM_MUXn_CSC_CLK_SW		BIT(2)
+#define MC_CGM_MUXn_CSS_SWTRG_SUCCESS	(0x1)
+#define MC_CGM_MUXn_CSS_SWTRG_MASK	(0x000E0000)
+#define MC_CGM_MUXn_CSS_SWTRG_OFFSET	(17)
+#define MC_CGM_MUXn_CSS_SELSTAT_MASK	(0x3F000000)
+#define MC_CGM_MUXn_CSS_SELSTAT_OFFSET	(24)
+
+#define CGM_MUXn_CSC(cgm_addr, mux)	(((cgm_addr) + 0x300 + (mux) * 0x40))
+#define CGM_MUXn_CSS(cgm_addr, mux)	(((cgm_addr) + 0x304 + (mux) * 0x40))
+#define MC_CGM_MUXn_CSC_SELCTL(val)	\
+	(MC_CGM_MUXn_CSC_SELCTL_MASK & ((val) << MC_CGM_MUXn_CSC_SELCTL_OFFSET))
+#define MC_CGM_MUXn_CSS_SWTRG(css)	\
+	((MC_CGM_MUXn_CSS_SWTRG_MASK & (css)) >> MC_CGM_MUXn_CSS_SWTRG_OFFSET)
+#define MC_CGM_MUXn_CSS_SELSTAT(css)	((MC_CGM_MUXn_CSS_SELSTAT_MASK & (css))\
+					>> MC_CGM_MUXn_CSS_SELSTAT_OFFSET)
+
+#define MC_CGM_MUXn_CSC_SEL_ARM_PLL_PHI0	4
+#define MC_CGM_MUXn_CSC_SEL_PERIPH_PLL_PHI3	21
+
+void s32g_plat_clock_init(void);
+
+#endif /* _S32G_CLOCKS_H_ */
diff --git a/plat/s32g/include/s32g_pinctrl.h b/plat/s32g/include/s32g_pinctrl.h
new file mode 100644
index 000000000..d940c6145
--- /dev/null
+++ b/plat/s32g/include/s32g_pinctrl.h
@@ -0,0 +1,53 @@
+/*
+ * Copyright 2019 NXP
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ */
+#ifndef _S32G_PINCTRL_H_
+#define _S32G_PINCTRL_H_
+
+#include "platform_def.h"
+
+#define SIUL2_0_MSCR_BASE	(SIUL2_0_BASE_ADDR + 0x00000240)
+#define SIUL2_0_IMCR_BASE	(SIUL2_0_BASE_ADDR + 0x00000A40)
+#define SIUL2_1_MSCR_BASE	(SIUL2_1_BASE_ADDR + 0x00000400)
+#define SIUL2_1_IMCR_BASE	(SIUL2_1_BASE_ADDR + 0x00000C1C)
+
+/* MSCR 0-101 */
+#define SIUL2_0_MSCRn(i)	(SIUL2_0_MSCR_BASE + 4 * (i))
+/* MSCR 112-190 */
+#define SIUL2_1_MSCRn(i)	(SIUL2_1_MSCR_BASE + 4 * (i - 112))
+/* IMCR 0-83 */
+#define SIUL2_0_IMCRn(i)	(SIUL2_0_IMCR_BASE +  4 * (i))
+/* IMCR 119-495 */
+#define SIUL2_1_IMCRn(i)	(SIUL2_1_IMCR_BASE +  4 * (i - 119))
+
+#define SIUL2_MSCR_S32_G1_SRC_100MHz            (5 << 14)
+#define SIUL2_MSCR_S32_G1_OBE_EN		BIT(21)
+#define SIUL2_MSCR_S32_G1_IBE_EN		BIT(19)
+#define SIUL2_MSCR_MUX_MODE_ALT0		(0x0)
+#define SIUL2_MSCR_MUX_MODE_ALT1		(0x1)
+#define SIUL2_MSCR_MUX_MODE_ALT2		(0x2)
+
+
+#define SIUL2_MSCR_S32G_G1_PORT_CTRL_UART0_TXD	\
+	(SIUL2_MSCR_S32_G1_SRC_100MHz |		\
+	 SIUL2_MSCR_S32_G1_OBE_EN |		\
+	 SIUL2_MSCR_MUX_MODE_ALT1)
+
+#define SIUL2_MSCR_S32G_G1_PORT_CTRL_UART_RXD	\
+	(SIUL2_MSCR_S32_G1_SRC_100MHz |		\
+	 SIUL2_MSCR_S32_G1_IBE_EN |		\
+	 SIUL2_MSCR_MUX_MODE_ALT0)
+
+#define SIUL2_IMCR_S32G_G1_UART0_RXD_to_pad	\
+	(SIUL2_MSCR_MUX_MODE_ALT2)
+
+#define SIUL2_PC09_MSCR_S32_G1_UART0		41
+#define SIUL2_PC10_MSCR_S32_G1_UART0		42
+#define SIUL2_PC10_IMCR_S32_G1_UART0		(512 - 512)
+
+
+void s32g_plat_config_pinctrl(void);
+
+#endif
diff --git a/plat/s32g/platform.mk b/plat/s32g/platform.mk
index 215977b74..ff27ce3de 100644
--- a/plat/s32g/platform.mk
+++ b/plat/s32g/platform.mk
@@ -23,6 +23,8 @@ PLAT_BL_COMMON_SOURCES	+= ${XLAT_TABLES_LIB_SRCS}
 BL31_SOURCES		+= plat/s32g/s32g275_bl31.c \
 			   plat/s32g/s32g_psci.c \
 			   plat/s32g/s32g_mc_me.c \
+			   plat/s32g/s32g_clocks.c \
+			   plat/s32g/s32g_pinctrl.c \
 			   plat/common/plat_psci_common.c \
 			   plat/common/plat_gicv3.c \
 			   drivers/arm/gic/v3/gicv3_main.c \
@@ -43,6 +45,12 @@ PROGRAMMABLE_RESET_ADDRESS	:= 1
 RESET_TO_BL31			:= 1
 COLD_BOOT_SINGLE_CPU		:= 0
 
+### Platform-specific defines ###
+# Which LinFlexD to use as a UART device
+S32G_LINFLEX_MODULE	:= 0
+$(eval $(call add_define_val,S32G_LINFLEX_MODULE,$(S32G_LINFLEX_MODULE)))
+
+
 ### Devel & Debug options ###
 CFLAGS			+= -O0
 # Enable dump of processor register state upon exceptions while running BL31
diff --git a/plat/s32g/s32g275_bl31.c b/plat/s32g/s32g275_bl31.c
index e33770c2d..c0dc2fb8b 100644
--- a/plat/s32g/s32g275_bl31.c
+++ b/plat/s32g/s32g275_bl31.c
@@ -18,6 +18,8 @@
 #include "s32g_linflexuart.h"
 #include "s32g_lowlevel.h"
 #include "s32g_xrdc.h"
+#include "s32g_clocks.h"
+#include "s32g_pinctrl.h"
 
 IMPORT_SYM(uintptr_t, __RW_START__, BL31_RW_START);
 IMPORT_SYM(uintptr_t, __RW_END__, BL31_RW_END);
@@ -101,6 +103,9 @@ void bl31_early_platform_setup2(u_register_t arg0, u_register_t arg1,
 	assert((void *)arg1 == NULL); /* plat params from bl2 */
 #endif
 
+	s32g_plat_config_pinctrl();
+	s32g_plat_clock_init();
+
 	SET_PARAM_HEAD(&bl33_image_ep_info, PARAM_EP, VERSION_1, 0);
 	bl33_image_ep_info.pc = S32G_BL33_IMAGE_BASE;
 	bl33_image_ep_info.spsr = s32g_get_spsr_for_bl33_entry();
@@ -170,6 +175,7 @@ void bl31_plat_arch_setup(void)
 {
 	s32g_smp_fixup();
 	s32g_el3_mmu_fixup();
+
 	/* kick secondary cores out of reset (but will leave them in wfi) */
 	s32g_kick_secondary_ca53_cores();
 }
diff --git a/plat/s32g/s32g_clocks.c b/plat/s32g/s32g_clocks.c
new file mode 100644
index 000000000..39fb18849
--- /dev/null
+++ b/plat/s32g/s32g_clocks.c
@@ -0,0 +1,310 @@
+/*
+ * Copyright 2019 NXP
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ */
+#include <lib/mmio.h>
+#include <errno.h>
+#include <assert.h>
+#include "s32g_clocks.h"
+
+
+static uint64_t plldig_set_refclk(enum s32g_pll_type pll,
+				  enum s32g_refclk refclk)
+{
+	uint64_t refclk_freq = S32G_ERR_CLK_FREQ;
+	uint32_t pllclkmux;
+
+	switch (refclk) {
+	case S32G_REFCLK_FIRC:
+		pllclkmux = PLLDIG_PLLCLKMUX_REFCLK_FIRC;
+		refclk_freq = S32G_FIRC_FREQ;
+		break;
+	case S32G_REFCLK_FXOSC:
+		pllclkmux = PLLDIG_PLLCLKMUX_REFCLK_FXOSC;
+		refclk_freq = S32G_FXOSC_FREQ;
+		break;
+	default:
+		assert(0);
+		break;
+	}
+	mmio_write_32(PLLDIG_PLLCLKMUX(pll), pllclkmux);
+
+	return refclk_freq;
+}
+
+/*
+ * Program the pll for various blocks
+ *
+ * @pll: Type of PLL to program
+ * @refclk: Input reference clock to the PLL block
+ * @freq: Array of PHI frequencies for each type of PLL
+ * @plldv_rdiv: Divider of clkfreq_ref
+ * @plldv_mfi: Loop multiplication factor divider
+ * @pllfd_mfn: Numerator loop multiplication factor divider
+ *
+ * For details, please consult the "PLL Digital Interface (PLLDIG)" chapter
+ * of the S32G Reference Manual.
+ */
+static int program_pll(enum s32g_pll_type pll, enum s32g_refclk refclk,
+		       const uint64_t freq[], uint32_t plldv_rdiv,
+		       uint32_t plldv_mfi, uint32_t pllfd_mfn)
+{
+	uint32_t i, phi_nr;
+	uint64_t refclk_freq;
+
+	phi_nr = s32g_pll_phi_nr[pll];
+
+	/* Disable dividers */
+	for (i = 0; i < phi_nr; i++)
+		mmio_write_32(PLLDIG_PLLODIV(pll, i), 0x0);
+
+	/* Disable PLL */
+	mmio_write_32(PLLDIG_PLLCR(pll), PLLDIG_PLLCR_PLLPD);
+
+	refclk_freq = plldig_set_refclk(pll, refclk);
+	if (refclk_freq == S32G_ERR_CLK_FREQ)
+		return -1;
+
+	/* See chapter:
+	 *   PLL Digital Interface (PLLDIG)::Modes of operation
+	 * from the S32G Reference Manual.
+	 *
+	 * If we were allowed to build with floating-point support, we
+	 * should have:
+	 * fvco = refclk_freq * (plldv_mfi + (pllfd_mfn/(float)18432)) /
+	 *                       (float)plldv_rdiv
+	 * i.e.:
+	 * fvco * rdiv * 18432 = refclk * (mfi * 18432 + mfn)
+	 * odiv = (refclk * (mfi * 18432 + mfn)) / (freq[i] * rdiv * 18432) - 1
+	 */
+
+	/*
+	 * VCO should have value in [PLL_MIN_FREQ, PLL_MAX_FREQ].
+	 * Please consult the platform DataSheet in order to determine
+	 * the allowed values.
+	 */
+	assert(refclk_freq * (plldv_mfi * 18432 + pllfd_mfn) >=
+	       PLL_MIN_FREQ * plldv_rdiv * 18432);
+	assert(refclk_freq * (plldv_mfi * 18432 + pllfd_mfn) <=
+	       PLL_MAX_FREQ * plldv_rdiv * 18432);
+
+	mmio_write_32(PLLDIG_PLLDV(pll), PLLDIG_PLLDV_RDIV_SET(plldv_rdiv) |
+					 PLLDIG_PLLDV_MFI(plldv_mfi));
+	mmio_write_32(PLLDIG_PLLFD(pll), PLLDIG_PLLFD_MFN_SET(pllfd_mfn) |
+					 PLLDIG_PLLFD_SMDEN);
+
+	/* Calculate divider output frequency for required PHIn outputs */
+	for (i = 0; i < phi_nr; i++) {
+		uint32_t tmp;
+		uint32_t odiv;
+
+		assert(freq[i]);
+		/* Also, because MFN must be less than 18432 according to the
+		 * refman, the following inequality must hold:
+		 *    (refclk_freq * (MFI + 1) / (freq[i] * RDIV)) > 1
+		 */
+		assert(refclk_freq * (plldv_mfi + 1) > freq[i] * plldv_rdiv);
+
+		odiv = (uint32_t)((refclk_freq *
+				  (plldv_mfi * 18432 + pllfd_mfn)) /
+				  (freq[i] * plldv_rdiv * 18432) - 1);
+
+		tmp = mmio_read_32(PLLDIG_PLLODIV(pll, i));
+		mmio_write_32(PLLDIG_PLLODIV(pll, i),
+			      tmp | PLLDIG_PLLODIV_DIV_SET(odiv));
+	}
+
+	/* Enable the PLL */
+	mmio_write_32(PLLDIG_PLLCR(pll), 0x0);
+
+	/* Poll until PLL acquires lock */
+	while (!(mmio_read_32(PLLDIG_PLLSR(pll)) & PLLDIG_PLLSR_LOCK))
+		;
+
+	/* Enable dividers */
+	for (i = 0; i < phi_nr; i++) {
+		uint32_t tmp;
+
+		tmp = mmio_read_32(PLLDIG_PLLODIV(pll, i));
+		mmio_write_32(PLLDIG_PLLODIV(pll, i), PLLDIG_PLLODIV_DE | tmp);
+	}
+
+	return 0;
+}
+
+static void start_fxosc(void)
+{
+	uint32_t ctrl;
+
+	/* If FXOSC is already running, do nothing */
+	if (mmio_read_32(FXOSC_CTRL) & FXOSC_CTRL_OSCON)
+		return;
+
+	ctrl = FXOSC_CTRL_COMP_EN;
+	ctrl &= ~FXOSC_CTRL_OSC_BYP;
+	ctrl |= FXOSC_CTRL_EOCV(0x1);
+	ctrl |= FXOSC_CTRL_GM_SEL(0x7);
+	mmio_write_32(FXOSC_CTRL, ctrl);
+
+	/* Switch on the crystal oscillator */
+	mmio_write_32(FXOSC_CTRL, FXOSC_CTRL_OSCON | mmio_read_32(FXOSC_CTRL));
+
+	/* Wait until the clock is stable */
+	while (!(mmio_read_32(FXOSC_STAT) & FXOSC_STAT_OSC_STAT))
+		;
+}
+
+static void disable_dfs(enum s32g_dfs_type dfs)
+{
+	mmio_write_32(DFS_PORTRESET(dfs), DFS_PORTRESET_RESET_MASK);
+	while ((mmio_read_32(DFS_PORTSR(dfs)) & DFS_PORTSR_PORTSTAT_MASK))
+		;
+	mmio_write_32(DFS_CTL(dfs), DFS_CTL_RESET);
+}
+
+/* DFS enablement, according to chapter
+ *    "Digital Frequency Synthesizer (DFS)::Initialization information"
+ * from the S32G Reference Manual.
+ *
+ * Any port settings (MFI, MFN) must be applied _before_ calling this function.
+ */
+static void enable_dfs(enum s32g_dfs_type dfs,
+		       const uint32_t params[][DFS_PARAMS_NR])
+{
+	uint32_t port, reset = 0;
+
+	/* deassert the master reset */
+	mmio_write_32(DFS_CTL(dfs), ~DFS_CTL_RESET);
+	/* deassert individual ports */
+	for (port = 0; port < S32G_DFS_PORTS_NR; port++)
+		reset |= (params[port][DFS_PORT_EN] << port);
+
+	/* wait until all configured ports are locked */
+	while ((mmio_read_32(DFS_PORTSR(dfs)) & reset) != reset)
+		;
+}
+
+/* DFS init & config, according to chapter
+ *    "Digital Frequency Synthesizer (DFS)::Initialization information"
+ * from the S32G Reference Manual.
+ *
+ * DFS must be disabled before calling this function.
+ */
+static int program_dfs(enum s32g_dfs_type dfs,
+		       const uint32_t params[][DFS_PARAMS_NR])
+{
+	uint32_t port = 0;
+
+	disable_dfs(dfs);
+
+	for (port = 0; port < S32G_DFS_PORTS_NR; port++) {
+		if (!(params[port][DFS_PORT_EN]))
+			continue;
+		mmio_write_32(DFS_DVPORTn(dfs, port),
+			      DFS_DVPORTn_MFI(params[port][DFS_DVPORT_MFI]) |
+			      DFS_DVPORTn_MFN(params[port][DFS_DVPORT_MFN]));
+	}
+
+	enable_dfs(dfs, params);
+
+	return 0;
+}
+
+static uintptr_t mc_cgm_addr(enum s32g_mc_cgm mc_cgm)
+{
+	switch (mc_cgm)	{
+	case MC_CGM0:
+		return (uintptr_t)MC_CGM0_BASE_ADDR;
+	case MC_CGM1:
+		return (uintptr_t)MC_CGM1_BASE_ADDR;
+	case MC_CGM2:
+		return (uintptr_t)MC_CGM2_BASE_ADDR;
+	case MC_CGM5:
+		return (uintptr_t)MC_CGM5_BASE_ADDR;
+	default:
+		return (uintptr_t)S32G_ERR_PTR;
+
+	}
+}
+
+/* Program a software-controlled clock multiplexer as per chapter
+ * "Clock Generation Module (MC_CGM)::
+ *    Functional description::
+ *      Clock selection multiplexer::
+ *        Software-controlled clock multiplexer"
+ */
+int sw_mux_clk_config(uint8_t cgm, uint8_t mux, uint8_t source)
+{
+	uint32_t css, csc;
+	uintptr_t cgm_addr;
+
+	cgm_addr = mc_cgm_addr(cgm);
+	if (cgm_addr == S32G_ERR_PTR)
+		return -EINVAL;
+
+	/* Ongoing clock switch? */
+	while (mmio_read_32(CGM_MUXn_CSS(cgm_addr, mux)) & MC_CGM_MUXn_CSS_SWIP)
+		;
+
+	csc = mmio_read_32(CGM_MUXn_CSC(cgm_addr, mux));
+	/* Clear previous source. */
+	csc &= ~(MC_CGM_MUXn_CSC_SELCTL_MASK);
+	/* select the clock source and trigger the clock switch. */
+	mmio_write_32(CGM_MUXn_CSC(cgm_addr, mux),
+		csc | MC_CGM_MUXn_CSC_SELCTL(source) | MC_CGM_MUXn_CSC_CLK_SW);
+	/* Wait for configuration bit to auto-clear. */
+	while (mmio_read_32(CGM_MUXn_CSC(cgm_addr, mux))
+		& MC_CGM_MUXn_CSC_CLK_SW)
+		;
+
+	/* Is the clock switch completed? */
+	while (mmio_read_32(CGM_MUXn_CSS(cgm_addr, mux)) & MC_CGM_MUXn_CSS_SWIP)
+		;
+
+	/* Chech if the switch succeeded.
+	 * Check switch trigger cause and the source.
+	 */
+	css = mmio_read_32(CGM_MUXn_CSS(cgm_addr, mux));
+	if ((MC_CGM_MUXn_CSS_SWTRG(css) == MC_CGM_MUXn_CSS_SWTRG_SUCCESS) &&
+		(MC_CGM_MUXn_CSS_SELSTAT(css) == source))
+		return 0;
+
+	return -EIO;
+}
+
+void s32g_plat_clock_init(void)
+{
+	assert(ARRAY_SIZE(s32g_core_pll_phi_freq) ==
+	       s32g_pll_phi_nr[S32G_CORE_PLL]);
+	assert(ARRAY_SIZE(s32g_periph_pll_phi_freq) ==
+	       s32g_pll_phi_nr[S32G_PERIPH_PLL]);
+	assert(ARRAY_SIZE(s32g_accel_pll_phi_freq) ==
+	       s32g_pll_phi_nr[S32G_ACCEL_PLL]);
+	assert(ARRAY_SIZE(s32g_ddr_pll_phi_freq) ==
+	       s32g_pll_phi_nr[S32G_DDR_PLL]);
+
+	/* Prepare FXOSC to run on */
+	start_fxosc();
+
+	/* Configure the CORE_PLL */
+	program_pll(S32G_CORE_PLL, S32G_REFCLK_FXOSC, s32g_core_pll_phi_freq,
+		    s32g_pll_rdiv[S32G_CORE_PLL], s32g_pll_mfi[S32G_CORE_PLL],
+		    s32g_pll_mfn[S32G_CORE_PLL]);
+	/* Configure the CORE_DFS) */
+	program_dfs(S32G_CORE_DFS, s32g_core_dfs_params);
+	/* Configure the core CGM mux */
+	sw_mux_clk_config(MC_CGM1, 0,
+			  MC_CGM_MUXn_CSC_SEL_ARM_PLL_PHI0);
+
+	/* Configure the PERIPH_PLL */
+	program_pll(S32G_PERIPH_PLL, S32G_REFCLK_FXOSC,
+		    s32g_periph_pll_phi_freq, s32g_pll_rdiv[S32G_PERIPH_PLL],
+		    s32g_pll_mfi[S32G_PERIPH_PLL],
+		    s32g_pll_mfn[S32G_PERIPH_PLL]);
+	/* Configure the PERIPH_DFS */
+	program_dfs(S32G_PERIPH_DFS, s32g_periph_dfs_params);
+	/* Configure the LinFlexD CGM mux */
+	sw_mux_clk_config(MC_CGM0, 8,
+			  MC_CGM_MUXn_CSC_SEL_PERIPH_PLL_PHI3);
+}
diff --git a/plat/s32g/s32g_pinctrl.c b/plat/s32g/s32g_pinctrl.c
new file mode 100644
index 000000000..66103db3d
--- /dev/null
+++ b/plat/s32g/s32g_pinctrl.c
@@ -0,0 +1,29 @@
+/*
+ * Copyright 2019 NXP
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ */
+#include <lib/mmio.h>
+#include <assert.h>
+#include "s32g_pinctrl.h"
+
+
+static void linflex_config_pinctrl(int lf)
+{
+	assert(lf == 0);
+
+	/* set PC09 - MSCR[41] - for UART0 TXD */
+	mmio_write_32(SIUL2_0_MSCRn(SIUL2_PC09_MSCR_S32_G1_UART0),
+		      SIUL2_MSCR_S32G_G1_PORT_CTRL_UART0_TXD);
+	/* set PC10 - MSCR[42] - for UART0 RXD */
+	mmio_write_32(SIUL2_0_MSCRn(SIUL2_PC10_MSCR_S32_G1_UART0),
+		      SIUL2_MSCR_S32G_G1_PORT_CTRL_UART_RXD);
+	/* set PC10 - MSCR[512]/IMCR[0] - for UART0 RXD */
+	mmio_write_32(SIUL2_0_IMCRn(SIUL2_PC10_IMCR_S32_G1_UART0),
+		      SIUL2_IMCR_S32G_G1_UART0_RXD_to_pad);
+}
+
+void s32g_plat_config_pinctrl(void)
+{
+	linflex_config_pinctrl(S32G_LINFLEX_MODULE);
+}
-- 
2.17.1

