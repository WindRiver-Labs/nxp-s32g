From 77dcaae3cbc77ae1fbe30021eee6206ff50e39d8 Mon Sep 17 00:00:00 2001
From: Bogdan Hamciuc <bogdan.hamciuc@nxp.com>
Date: Mon, 9 Dec 2019 09:40:08 +0200
Subject: [PATCH 037/269] s32g: Load BL31 from BL2

Link the newly-added BL2 to the remnants of BL31.

Upstream-Status: Pending 

Signed-off-by: Bogdan Hamciuc <bogdan.hamciuc@nxp.com>
Signed-off-by: Zhantao Tang <zhantao.tang@windriver.com>
Issue: ALB-4277
---
 plat/s32g/include/s32g_storage.h |  23 +++++++
 plat/s32g/platform.mk            |   7 ++-
 plat/s32g/s32g274a_bl2_el3.c     |  46 ++++++++++----
 plat/s32g/s32g274a_storage.c     | 101 +++++++++++++++++++++++++++++++
 4 files changed, 163 insertions(+), 14 deletions(-)
 create mode 100644 plat/s32g/include/s32g_storage.h
 create mode 100644 plat/s32g/s32g274a_storage.c

diff --git a/plat/s32g/include/s32g_storage.h b/plat/s32g/include/s32g_storage.h
new file mode 100644
index 000000000..5a25e50ad
--- /dev/null
+++ b/plat/s32g/include/s32g_storage.h
@@ -0,0 +1,23 @@
+/*
+ * Copyright 2019 NXP
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ */
+#ifndef S32G_STORAGE_H
+#define S32G_STORAGE_H
+
+#define TEMP_S32G_BL31_READ_ADDR_IN_SRAM	0x34200000ull
+enum s32g_boot_source {
+	S32G_SRAM_BOOT,
+	/* TODO add FIP, QSPI, SD/MMC */
+};
+
+struct plat_io_policy {
+	uintptr_t *dev_handle;
+	uintptr_t image_spec;
+	int (*check)(const uintptr_t spec);
+};
+
+void s32g_io_setup(void);
+
+#endif /* S32G_STORAGE_H */
diff --git a/plat/s32g/platform.mk b/plat/s32g/platform.mk
index 77e9e1bd3..b2a8c0b65 100644
--- a/plat/s32g/platform.mk
+++ b/plat/s32g/platform.mk
@@ -24,10 +24,13 @@ PLAT_BL_COMMON_SOURCES	+= plat/s32g/s32g_lowlevel_common.S \
 
 BL2_SOURCES		+= plat/s32g/s32g_lowlevel_bl2.S \
 			   plat/s32g/s32g274a_bl2_el3.c \
-			   drivers/io/io_storage.c \
 			   plat/s32g/s32g_ncore.c \
 			   plat/s32g/s32g_clocks.c \
-			   plat/s32g/s32g_pinctrl.c
+			   plat/s32g/s32g_pinctrl.c \
+			   plat/s32g/s32g274a_storage.c \
+			   drivers/io/io_storage.c \
+			   drivers/io/io_memmap.c \
+			   common/desc_image_load.c
 
 BL31_SOURCES		+= plat/s32g/s32g275_bl31.c \
 			   plat/s32g/s32g_psci.c \
diff --git a/plat/s32g/s32g274a_bl2_el3.c b/plat/s32g/s32g274a_bl2_el3.c
index e30082727..8f0e2fa50 100644
--- a/plat/s32g/s32g274a_bl2_el3.c
+++ b/plat/s32g/s32g274a_bl2_el3.c
@@ -6,13 +6,40 @@
 
 #include <platform.h>
 #include <common/bl_common.h>
-#include <s32g_ncore.h>
+#include <common/desc_image_load.h>
 #include <drivers/console.h>
+#include "s32g_ncore.h"
 #include "s32g_pinctrl.h"
 #include "s32g_clocks.h"
 #include "s32g_linflexuart.h"
+#include "s32g_storage.h"
 
 
+static bl_mem_params_node_t s32g_bl2_mem_params_descs[] = {
+	{
+		.image_id = BL31_IMAGE_ID,
+
+		SET_STATIC_PARAM_HEAD(ep_info, PARAM_EP, VERSION_2,
+				      entry_point_info_t,
+				      SECURE | EXECUTABLE | EP_FIRST_EXE),
+		.ep_info.spsr = SPSR_64(MODE_EL3, MODE_SP_ELX,
+					DISABLE_ALL_EXCEPTIONS),
+		.ep_info.pc = BL31_BASE,
+
+		SET_STATIC_PARAM_HEAD(image_info, PARAM_EP, VERSION_2,
+				      image_info_t, IMAGE_ATTRIB_PLAT_SETUP),
+		.image_info.image_max_size = BL31_LIMIT - BL31_BASE,
+		.image_info.image_base = BL31_BASE,
+		.next_handoff_image_id = INVALID_IMAGE_ID,
+	},
+
+	{
+		.image_id = INVALID_IMAGE_ID,
+		SET_STATIC_PARAM_HEAD(image_info, PARAM_EP, VERSION_2,
+				      image_info_t, IMAGE_ATTRIB_SKIP_LOADING),
+	}
+};
+
 void bl2_platform_setup(void)
 {
 	return;
@@ -20,19 +47,17 @@ void bl2_platform_setup(void)
 
 struct bl_params *plat_get_next_bl_params(void)
 {
-	/* TODO */
-	return NULL;
+	return get_next_bl_params_from_mem_params_desc();
 }
 
 void plat_flush_next_bl_params(void)
 {
-	/* TODO */
+	flush_bl_params_desc();
 }
 
 struct bl_load_info *plat_get_bl_image_load_info(void)
 {
-	/* TODO */
-	return NULL;
+	return get_bl_load_info_from_mem_params_desc();
 }
 
 void bl2_el3_early_platform_setup(u_register_t arg0, u_register_t arg1,
@@ -43,6 +68,8 @@ void bl2_el3_early_platform_setup(u_register_t arg0, u_register_t arg1,
 
 	ncore_init();
 	ncore_caiu_online(A53_CLUSTER0_CAIU);
+
+	s32g_io_setup();
 }
 
 void bl2_el3_plat_arch_setup(void)
@@ -54,9 +81,4 @@ void bl2_el3_plat_arch_setup(void)
 
 }
 
-int plat_get_image_source(unsigned int image_id, uintptr_t *dev_handle,
-			  uintptr_t *image_spec)
-{
-	/* TODO */
-	return 0;
-}
+REGISTER_BL_IMAGE_DESCS(s32g_bl2_mem_params_descs)
diff --git a/plat/s32g/s32g274a_storage.c b/plat/s32g/s32g274a_storage.c
new file mode 100644
index 000000000..a94623605
--- /dev/null
+++ b/plat/s32g/s32g274a_storage.c
@@ -0,0 +1,101 @@
+/*
+ * Copyright 2019 NXP
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ */
+#include <common/bl_common.h>
+#include <drivers/io/io_driver.h>
+#include <drivers/io/io_memmap.h>
+#include <assert.h>
+#include <tools_share/firmware_image_package.h>
+#include "s32g_storage.h"
+
+
+static const io_dev_connector_t *s32g_sram_io_dev;
+static uintptr_t s32g_sram_boot_dev_handle;
+
+static int s32g_check_sram_dev(const uintptr_t spec);
+
+static const io_block_spec_t bl31_sram_spec = {
+	.offset = TEMP_S32G_BL31_READ_ADDR_IN_SRAM,
+	.length = BL31_LIMIT - BL31_BASE
+};
+
+static const struct plat_io_policy s32g_policies[] = {
+	[BL31_IMAGE_ID] = {
+		&s32g_sram_boot_dev_handle,
+		(uintptr_t)&bl31_sram_spec,
+		s32g_check_sram_dev
+	},
+};
+
+static int s32g_check_sram_dev(const uintptr_t spec)
+{
+	uintptr_t local_handle;
+	int ret;
+
+	ret = io_open(s32g_sram_boot_dev_handle, spec, &local_handle);
+	if (ret)
+		return ret;
+	/* must be closed, as load_image() will do another io_open() */
+	io_close(local_handle);
+
+	return 0;
+}
+
+int plat_get_image_source(unsigned int image_id, uintptr_t *dev_handle,
+			  uintptr_t *image_spec)
+{
+	const struct plat_io_policy *policy;
+	int ret;
+
+	assert(image_id < ARRAY_SIZE(s32g_policies));
+
+	policy = &s32g_policies[image_id];
+	assert(policy && policy->check);
+	ret = policy->check(policy->image_spec);
+	if (ret) {
+		*dev_handle = (uintptr_t)NULL;
+		*image_spec = (uintptr_t)NULL;
+		return ret;
+	}
+
+	*dev_handle = *(policy->dev_handle);
+	*image_spec = policy->image_spec;
+
+	return 0;
+}
+
+static void plat_s32g_io_setup(enum s32g_boot_source boot_source)
+{
+	int ret;
+
+	ret = register_io_dev_memmap(&s32g_sram_io_dev);
+	assert(ret == 0);
+
+	switch (boot_source) {
+	case S32G_SRAM_BOOT:
+		ret = io_dev_open(s32g_sram_io_dev,
+				  (uintptr_t)&bl31_sram_spec,
+				  &s32g_sram_boot_dev_handle);
+		assert(ret == 0);
+
+		ret = io_dev_init(s32g_sram_boot_dev_handle,
+				  (uintptr_t)BL31_IMAGE_ID);
+		assert(ret == 0);
+		break;
+	default:
+		ERROR("Unknown boot source: %d", boot_source);
+		panic();
+	}
+}
+
+void s32g_io_setup(void)
+{
+	/* Assume next image is in SRAM at a known offset; while impractical in
+	 * real-life deployment - mostly due to performance issues related to
+	 * boot timing - this is convenient during development, when all images
+	 * can be loaded by the BootROM.
+	 */
+	plat_s32g_io_setup(S32G_SRAM_BOOT);
+}
-- 
2.17.1

