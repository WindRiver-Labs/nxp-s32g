From 72f02763c20f219d39c55a59fbf4ab079a1e624f Mon Sep 17 00:00:00 2001
From: Bogdan-Gabriel Roman <bogdan-gabriel.roman@nxp.com>
Date: Fri, 14 Aug 2020 15:53:49 +0300
Subject: [PATCH 189/269] Boot OP-TEE during BL32 stage

If ATF is built with compile-time argument "SPD=opteed", BL32 binaries
(OP-TEE binaries) will be requested and ATF will include the BL32 boot
stage into its boot flow.

Issue: ALB-5525
Upstream-Status: Pending 

Signed-off-by: Bogdan-Gabriel Roman <bogdan-gabriel.roman@nxp.com>
Signed-off-by: Zhantao Tang <zhantao.tang@windriver.com>
---
 plat/nxp/s32g/bl31_lowlevel.S        |  10 ++
 plat/nxp/s32g/include/platform_def.h |  11 ++
 plat/nxp/s32g/platform.mk            |   7 ++
 plat/nxp/s32g/s32g_bl2_el3.c         | 153 ++++++++++++++++++++++++---
 plat/nxp/s32g/s32g_bl31.c            |  15 ++-
 plat/nxp/s32g/s32g_storage.c         |  22 ++++
 6 files changed, 204 insertions(+), 14 deletions(-)

diff --git a/plat/nxp/s32g/bl31_lowlevel.S b/plat/nxp/s32g/bl31_lowlevel.S
index 99aa32a78..1b6863ce5 100644
--- a/plat/nxp/s32g/bl31_lowlevel.S
+++ b/plat/nxp/s32g/bl31_lowlevel.S
@@ -119,6 +119,11 @@ func s32g_gic_fixups_for_secondary
 	msr	SCR_EL3, x8
 	isb
 
+	/* Write the secure ICC_SRE_EL1 register */
+	movz	x8, #0x1
+	msr	ICC_SRE_EL1, x8
+	isb
+
 	/* Set interrupt priority filter */
 	movz	x8, #0xff
 	msr	ICC_PMR_EL1, x8
@@ -131,6 +136,11 @@ func s32g_gic_fixups_for_secondary
 	movz	x8, #0x1
 	msr	ICC_IGRPEN0_EL1, x8
 
+	/* Enable Group 1 Secure interrupts */
+	mrs x8, ICC_IGRPEN1_EL3
+	orr x8, x8, #0xf
+	msr ICC_IGRPEN1_EL3, x8
+
 	isb
 
 	mov	x30, x13
diff --git a/plat/nxp/s32g/include/platform_def.h b/plat/nxp/s32g/include/platform_def.h
index 641735915..b80b15f47 100644
--- a/plat/nxp/s32g/include/platform_def.h
+++ b/plat/nxp/s32g/include/platform_def.h
@@ -171,6 +171,17 @@
 #define BL31_BASE		(S32G_PMEM_START)
 #define BL31_LIMIT		(S32G_PMEM_END)
 
+/* BL32 location in DDR - 22MB
+ * 20 MB for optee_os (optee_os itself + TA mappings during their execution)
+ * 2 MB for shared memory between optee and linux kernel
+ *
+ * Depending on the intensity of usage of TAs and their sizes,
+ * these values can be further shrunk. The current values are preliminary.
+ */
+#define S32G_BL32_SIZE		0x01600000
+#define S32G_BL32_BASE		(BL31_BASE - S32G_BL32_SIZE)
+#define S32G_BL32_LIMIT		(BL31_BASE)
+
 #define FIP_BASE		(S32G_SRAM_END - FIP_MAXIMUM_SIZE)
 /* Must be placed by mkimage starting with AppBootCode:Code, but
  * aligned to the block size of 512 bytes
diff --git a/plat/nxp/s32g/platform.mk b/plat/nxp/s32g/platform.mk
index 8e846a110..1c20f29fe 100644
--- a/plat/nxp/s32g/platform.mk
+++ b/plat/nxp/s32g/platform.mk
@@ -70,6 +70,7 @@ BL2_SOURCES		+= plat/nxp/s32g/s32g_lowlevel_bl2.S \
 			   ${DDR_DRV}/ddrss_firmware.c \
 			   ${DDR_DRV}/ddrss_regconf.c \
 			   ${BL31SSRAM_SRC_DUMP} \
+			   lib/optee/optee_utils.c \
 
 BL31_SOURCES		+= plat/nxp/s32g/s32g_bl31.c \
 			   plat/nxp/s32g/s32g_psci.c \
@@ -185,3 +186,9 @@ CRASH_REPORTING		:= 1
 # As verbose as it can be
 LOG_LEVEL		?= 50
 
+# If BL32_EXTRA1 option is present, include the binary it is pointing to
+# in the FIP image
+ifneq ($(BL32_EXTRA1),)
+$(eval $(call TOOL_ADD_IMG,bl32_extra1,--tos-fw-extra1))
+endif
+
diff --git a/plat/nxp/s32g/s32g_bl2_el3.c b/plat/nxp/s32g/s32g_bl2_el3.c
index c42d975c7..f13b876ae 100644
--- a/plat/nxp/s32g/s32g_bl2_el3.c
+++ b/plat/nxp/s32g/s32g_bl2_el3.c
@@ -4,12 +4,15 @@
  * SPDX-License-Identifier: BSD-3-Clause
  */
 
+#include <assert.h>
+
 #include <platform.h>
 #include <common/bl_common.h>
 #include <common/desc_image_load.h>
 #include <common/debug.h>
 #include <drivers/console.h>
 #include <lib/mmio.h>
+#include <lib/optee_utils.h>
 #include "s32g_linflexuart.h"
 #include "s32g_storage.h"
 #include "s32g_mc_rgm.h"
@@ -29,8 +32,13 @@
 #define AARCH64_UNCOND_BRANCH_OP	(BIT(26) | BIT(28))
 #define BL33_DTB_MAGIC			(0xedfe0dd0)
 
-static bl_mem_params_node_t s32g_bl2_mem_params_descs[] = {
-	{
+static bl_mem_params_node_t s32g_bl2_mem_params_descs[6];
+REGISTER_BL_IMAGE_DESCS(s32g_bl2_mem_params_descs)
+
+static void add_fip_img_to_mem_params_descs(bl_mem_params_node_t *params,
+					    size_t *index)
+{
+	bl_mem_params_node_t node = {
 		.image_id = FIP_IMAGE_ID,
 
 		SET_STATIC_PARAM_HEAD(ep_info, PARAM_EP, VERSION_2,
@@ -42,8 +50,15 @@ static bl_mem_params_node_t s32g_bl2_mem_params_descs[] = {
 		.image_info.image_max_size = FIP_MAXIMUM_SIZE,
 		.image_info.image_base = FIP_BASE,
 		.next_handoff_image_id = BL31_IMAGE_ID,
-	},
-	{
+	};
+
+	params[(*index)++] = node;
+}
+
+static void add_bl31_img_to_mem_params_descs(bl_mem_params_node_t *params,
+					     size_t *index)
+{
+	bl_mem_params_node_t node = {
 		.image_id = BL31_IMAGE_ID,
 
 		SET_STATIC_PARAM_HEAD(ep_info, PARAM_EP, VERSION_2,
@@ -57,9 +72,80 @@ static bl_mem_params_node_t s32g_bl2_mem_params_descs[] = {
 				      image_info_t, 0),
 		.image_info.image_max_size = BL31_LIMIT - BL31_BASE,
 		.image_info.image_base = BL31_BASE,
+#ifdef SPD_opteed
+		.next_handoff_image_id = BL32_IMAGE_ID,
+#else
+		.next_handoff_image_id = BL33_IMAGE_ID,
+#endif
+	};
+
+	params[(*index)++] = node;
+}
+
+#ifdef SPD_opteed
+static void add_bl32_img_to_mem_params_descs(bl_mem_params_node_t *params,
+					     size_t *index)
+{
+	bl_mem_params_node_t node = {
+		.image_id = BL32_IMAGE_ID,
+
+		SET_STATIC_PARAM_HEAD(ep_info, PARAM_EP, VERSION_2,
+				      entry_point_info_t,
+				      SECURE | EXECUTABLE),
+		.ep_info.pc = S32G_BL32_BASE,
+
+		SET_STATIC_PARAM_HEAD(image_info, PARAM_EP, VERSION_2,
+				      image_info_t, 0),
+		.image_info.image_max_size = S32G_BL32_SIZE,
+		.image_info.image_base = S32G_BL32_BASE,
 		.next_handoff_image_id = BL33_IMAGE_ID,
-	},
-	{
+	};
+
+	params[(*index)++] = node;
+}
+
+static void add_bl32_extra1_img_to_mem_params_descs(
+	bl_mem_params_node_t *params,
+	size_t *index)
+{
+	bl_mem_params_node_t node = {
+
+		.image_id = BL32_EXTRA1_IMAGE_ID,
+
+		SET_STATIC_PARAM_HEAD(ep_info, PARAM_EP, VERSION_2,
+				      entry_point_info_t,
+				      SECURE | NON_EXECUTABLE),
+
+		SET_STATIC_PARAM_HEAD(image_info, PARAM_EP, VERSION_2,
+				      image_info_t, IMAGE_ATTRIB_SKIP_LOADING),
+		.image_info.image_base = S32G_BL32_BASE,
+		.image_info.image_max_size = S32G_BL32_SIZE,
+
+		.next_handoff_image_id = INVALID_IMAGE_ID,
+	};
+
+	params[(*index)++] = node;
+}
+
+#else
+static void add_bl32_img_to_mem_params_descs(bl_mem_params_node_t *params,
+					     size_t *index)
+{
+
+}
+
+static void add_bl32_extra1_img_to_mem_params_descs(
+	bl_mem_params_node_t *params,
+	size_t *index)
+{
+
+}
+#endif /* SPD_opteed */
+
+static void add_bl33_img_to_mem_params_descs(bl_mem_params_node_t *params,
+					     size_t *index)
+{
+	bl_mem_params_node_t node = {
 		.image_id = BL33_IMAGE_ID,
 
 		SET_STATIC_PARAM_HEAD(ep_info, PARAM_EP, VERSION_2,
@@ -71,13 +157,22 @@ static bl_mem_params_node_t s32g_bl2_mem_params_descs[] = {
 		.image_info.image_max_size = S32G_BL33_IMAGE_SIZE,
 		.image_info.image_base = S32G_BL33_IMAGE_BASE,
 		.next_handoff_image_id = INVALID_IMAGE_ID,
-	},
-	{
+	};
+
+	params[(*index)++] = node;
+}
+
+static void add_invalid_img_to_mem_params_descs(bl_mem_params_node_t *params,
+						size_t *index)
+{
+	bl_mem_params_node_t node = {
 		.image_id = INVALID_IMAGE_ID,
 		SET_STATIC_PARAM_HEAD(image_info, PARAM_EP, VERSION_2,
 				      image_info_t, IMAGE_ATTRIB_SKIP_LOADING),
-	}
-};
+	};
+
+	params[(*index)++] = node;
+}
 
 void bl2_platform_setup(void)
 {
@@ -102,8 +197,20 @@ struct bl_load_info *plat_get_bl_image_load_info(void)
 void bl2_el3_early_platform_setup(u_register_t arg0, u_register_t arg1,
 				  u_register_t arg2, u_register_t arg3)
 {
+	size_t index;
+	bl_mem_params_node_t *params = s32g_bl2_mem_params_descs;
+
 	s32g_early_plat_init(false);
 	s32g_io_setup();
+
+	add_fip_img_to_mem_params_descs(params, &index);
+	add_bl31_img_to_mem_params_descs(params, &index);
+	add_bl32_img_to_mem_params_descs(params, &index);
+	add_bl32_extra1_img_to_mem_params_descs(params, &index);
+	add_bl33_img_to_mem_params_descs(params, &index);
+	add_invalid_img_to_mem_params_descs(params, &index);
+
+	bl_mem_params_desc_num = index;
 }
 
 static int disable_clk_node(void *blob, uint32_t *phandle)
@@ -234,6 +341,14 @@ int bl2_plat_handle_post_image_load(unsigned int image_id)
 	uint32_t magic;
 	int ret;
 
+	bl_mem_params_node_t *bl_mem_params = NULL;
+	bl_mem_params_node_t *pager_mem_params = NULL;
+	bl_mem_params_node_t *paged_mem_params = NULL;
+
+#define AARCH64_UNCOND_BRANCH_MASK	(0x7c000000)
+#define AARCH64_UNCOND_BRANCH_OP	(BIT(26) | BIT(28))
+#define BL33_DTB_MAGIC			(0xedfe0dd0)
+
 	if (image_id == BL33_IMAGE_ID) {
 		magic = mmio_read_32(BL33_ENTRYPOINT);
 		if (!is_branch_op(magic))
@@ -254,6 +369,22 @@ int bl2_plat_handle_post_image_load(unsigned int image_id)
 			return ret;
 	}
 
+	if (image_id == BL32_IMAGE_ID) {
+		bl_mem_params = get_bl_mem_params_node(image_id);
+		assert(bl_mem_params && "bl_mem_params cannot be NULL");
+
+		pager_mem_params = get_bl_mem_params_node(BL32_EXTRA1_IMAGE_ID);
+		assert(pager_mem_params && "pager_mem_params cannot be NULL");
+
+		ret = parse_optee_header(&bl_mem_params->ep_info,
+					 &pager_mem_params->image_info,
+					 &paged_mem_params->image_info);
+		if (ret != 0) {
+			WARN("OPTEE header parse error.\n");
+			return ret;
+		}
+	}
+
 	return 0;
 }
 
@@ -306,5 +437,3 @@ void bl2_el3_plat_arch_setup(void)
 	/* This will also populate CSR section from bl31ssram */
 	ddrss_init(&ddrss_conf, &ddrss_firmware, BL31SSRAM_CSR_BASE);
 }
-
-REGISTER_BL_IMAGE_DESCS(s32g_bl2_mem_params_descs)
diff --git a/plat/nxp/s32g/s32g_bl31.c b/plat/nxp/s32g/s32g_bl31.c
index be4d3838f..7d2434782 100644
--- a/plat/nxp/s32g/s32g_bl31.c
+++ b/plat/nxp/s32g/s32g_bl31.c
@@ -80,6 +80,7 @@ static const mmap_region_t s32g_mmap[] = {
 };
 
 static entry_point_info_t bl33_image_ep_info;
+static entry_point_info_t bl32_image_ep_info;
 
 static uintptr_t rdistif_base_addrs[PLATFORM_CORE_COUNT];
 
@@ -159,8 +160,10 @@ static uint32_t s32g_get_spsr_for_bl33_entry(void)
 entry_point_info_t *bl31_plat_get_next_image_ep_info(uint32_t type)
 {
 	assert(sec_state_is_valid(type));
-
-	return &bl33_image_ep_info;
+	if (type == NON_SECURE)
+		return &bl33_image_ep_info;
+	else
+		return &bl32_image_ep_info;
 }
 
 void bl31_early_platform_setup2(u_register_t arg0, u_register_t arg1,
@@ -170,6 +173,14 @@ void bl31_early_platform_setup2(u_register_t arg0, u_register_t arg1,
 	bl33_image_ep_info.pc = BL33_ENTRYPOINT;
 	bl33_image_ep_info.spsr = s32g_get_spsr_for_bl33_entry();
 	SET_SECURITY_STATE(bl33_image_ep_info.h.attr, NON_SECURE);
+
+#ifdef SPD_opteed
+	SET_PARAM_HEAD(&bl32_image_ep_info, PARAM_EP, VERSION_2, 0);
+	SET_SECURITY_STATE(bl32_image_ep_info.h.attr, SECURE);
+	bl32_image_ep_info.pc = S32G_BL32_BASE;
+	bl32_image_ep_info.spsr = 0;
+	bl32_image_ep_info.args.arg0 = MODE_RW_64;
+#endif
 }
 
 static void s32g_el3_mmu_fixup(void)
diff --git a/plat/nxp/s32g/s32g_storage.c b/plat/nxp/s32g/s32g_storage.c
index 40e56bbd0..5c5d9e859 100644
--- a/plat/nxp/s32g/s32g_storage.c
+++ b/plat/nxp/s32g/s32g_storage.c
@@ -43,6 +43,16 @@ static const io_uuid_spec_t bl31_uuid_spec = {
 	.uuid = UUID_EL3_RUNTIME_FIRMWARE_BL31,
 };
 
+#ifdef SPD_opteed
+static const io_uuid_spec_t bl32_uuid_spec = {
+	.uuid = UUID_SECURE_PAYLOAD_BL32,
+};
+
+static const io_uuid_spec_t bl32_extra1_uuid_spec = {
+	.uuid = UUID_SECURE_PAYLOAD_BL32_EXTRA1,
+};
+#endif
+
 static const io_uuid_spec_t bl33_uuid_spec = {
 	.uuid = UUID_NON_TRUSTED_FIRMWARE_BL33,
 };
@@ -58,6 +68,18 @@ static const struct plat_io_policy s32g_policies[] = {
 		(uintptr_t)&bl31_uuid_spec,
 		s32g_check_fip_dev
 	},
+#ifdef SPD_opteed
+	[BL32_IMAGE_ID] = {
+		&s32g_fip_dev_handle,
+		(uintptr_t)&bl32_uuid_spec,
+		s32g_check_fip_dev
+	},
+	[BL32_EXTRA1_IMAGE_ID] = {
+		&s32g_fip_dev_handle,
+		(uintptr_t)&bl32_extra1_uuid_spec,
+		s32g_check_fip_dev
+	},
+#endif
 	[BL33_IMAGE_ID] = {
 		&s32g_fip_dev_handle,
 		(uintptr_t)&bl33_uuid_spec,
-- 
2.17.1

