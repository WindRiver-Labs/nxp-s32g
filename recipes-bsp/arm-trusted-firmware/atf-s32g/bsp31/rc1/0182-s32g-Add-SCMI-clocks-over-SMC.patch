From ca0ce06e75ccf8bb6009bd54cedadc1a8e27c034 Mon Sep 17 00:00:00 2001
From: Ghennadi Procopciuc <Ghennadi.Procopciuc@nxp.com>
Date: Tue, 29 Sep 2020 10:34:39 +0300
Subject: [PATCH 182/269] s32g: Add SCMI clocks over SMC

This commit adds an SCMI server based as a runtime service.
The support is based on ST's SCMI-CLK server implementation and implements
all clocks operation except:
   * get rate ranges
   * ungate

Issue: ALB-4294, ALB-5510, ALB-4293
Upstream-Status: Pending 

Signed-off-by: Ghennadi Procopciuc <Ghennadi.Procopciuc@nxp.com>
Signed-off-by: Zhantao Tang <zhantao.tang@windriver.com>
---
 drivers/nxp/s32g/clk/plat_clk.c               | 199 ++++++++
 drivers/nxp/s32g/clk/s32g274a_scmi_ids.c      | 444 ++++++++++++++++
 drivers/nxp/s32g/clk/s32gen1_scmi_clk.c       | 199 ++++++++
 drivers/nxp/s32g/clk/s32gen1_scmi_ids.c       | 481 ++++++++++++++++++
 .../drivers/nxp/s32g/clk/s32gen1_scmi_clk.h   |  61 +++
 plat/nxp/s32g/include/platform_def.h          |  10 +-
 plat/nxp/s32g/include/s32g_bl_common.h        |  13 +
 plat/nxp/s32g/include/s32g_clocks.h           |   9 +-
 plat/nxp/s32g/include/s32g_dt.h               |   1 +
 plat/nxp/s32g/platform.mk                     |  21 +-
 plat/nxp/s32g/s32g_bl31.c                     |  58 +++
 plat/nxp/s32g/s32g_clocks.c                   |  91 ----
 plat/nxp/s32g/s32g_dt.c                       |  59 ++-
 plat/nxp/s32g/s32g_scmi_clk.c                 | 104 ++++
 plat/nxp/s32g/s32g_svc.c                      | 122 +++++
 15 files changed, 1765 insertions(+), 107 deletions(-)
 create mode 100644 drivers/nxp/s32g/clk/plat_clk.c
 create mode 100644 drivers/nxp/s32g/clk/s32g274a_scmi_ids.c
 create mode 100644 drivers/nxp/s32g/clk/s32gen1_scmi_clk.c
 create mode 100644 drivers/nxp/s32g/clk/s32gen1_scmi_ids.c
 create mode 100644 include/drivers/nxp/s32g/clk/s32gen1_scmi_clk.h
 create mode 100644 plat/nxp/s32g/s32g_scmi_clk.c
 create mode 100644 plat/nxp/s32g/s32g_svc.c

diff --git a/drivers/nxp/s32g/clk/plat_clk.c b/drivers/nxp/s32g/clk/plat_clk.c
new file mode 100644
index 000000000..5710f04cc
--- /dev/null
+++ b/drivers/nxp/s32g/clk/plat_clk.c
@@ -0,0 +1,199 @@
+/*
+ * Copyright 2020 NXP
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ */
+#include <clk/clk.h>
+#include <clk/s32gen1_clk_funcs.h>
+#include <clk/s32gen1_clk_modules.h>
+#include <clk/s32gen1_scmi_clk.h>
+#include <libfdt.h>
+#include <libfdt_env.h>
+#include <s32g_dt.h>
+
+struct s32gen1_clk_driver {
+	struct s32gen1_clk_priv priv;
+	struct clk_driver *driver;
+};
+
+void *get_base_addr(enum s32gen1_clk_source id, struct s32gen1_clk_priv *priv)
+{
+	switch (id) {
+	case S32GEN1_ACCEL_PLL:
+		return priv->accelpll;
+	case S32GEN1_ARM_DFS:
+		return priv->armdfs;
+	case S32GEN1_ARM_PLL:
+		return priv->armpll;
+	case S32GEN1_CGM0:
+		return priv->cgm0;
+	case S32GEN1_CGM1:
+		return priv->cgm1;
+	case S32GEN1_CGM2:
+		return priv->cgm2;
+	case S32GEN1_CGM5:
+		return priv->cgm5;
+	case S32GEN1_DDR_PLL:
+		return priv->ddrpll;
+	case S32GEN1_FXOSC:
+		return priv->fxosc;
+	case S32GEN1_PERIPH_DFS:
+		return priv->periphdfs;
+	case S32GEN1_PERIPH_PLL:
+		return priv->periphpll;
+	default:
+		ERROR("Unknown clock source id: %u\n", id);
+	}
+
+	return NULL;
+}
+
+static int bind_clk_provider(struct s32gen1_clk_driver *drv, void *fdt,
+			     const char *compatible, void **base_addr,
+			     int *node)
+{
+	struct dt_node_info info;
+
+	*node = fdt_node_offset_by_compatible(fdt, -1, compatible);
+	if (*node == -1) {
+		ERROR("Failed to get '%s' node\n", compatible);
+		return -EIO;
+	}
+
+	dt_fill_device_info(&info, *node);
+	if (!info.base) {
+		ERROR("Invalid 'reg' property of %s node\n", compatible);
+		return -EIO;
+	}
+
+	*base_addr = (void *)(uintptr_t)info.base;
+
+	return dt_clk_apply_defaults(fdt, *node);
+}
+
+static int s32gen1_clk_probe(struct s32gen1_clk_driver *drv, void *fdt,
+			     int node)
+{
+	struct s32gen1_clk_priv *priv = &drv->priv;
+	int ret;
+	size_t i;
+
+	struct clk_dep {
+		void **base_addr;
+		const char *compat;
+		int node;
+	} deps[] = {
+		{
+			.base_addr = &priv->fxosc,
+			.compat = "fsl,s32gen1-fxosc",
+		},
+		{
+			.base_addr = &priv->cgm0,
+			.compat = "fsl,s32gen1-mc_cgm0",
+		},
+		{
+			.base_addr = &priv->mc_me,
+			.compat = "fsl,s32gen1-mc_me",
+		},
+		{
+			.base_addr = &priv->rdc,
+			.compat = "fsl,s32gen1-rdc",
+		},
+		{
+			.base_addr = &priv->rgm,
+			.compat = "fsl,s32gen1-rgm",
+		},
+		{
+			.base_addr = &priv->cgm1,
+			.compat = "fsl,s32gen1-mc_cgm1",
+		},
+		{
+			.base_addr = &priv->cgm2,
+			.compat = "fsl,s32gen1-mc_cgm2",
+		},
+		{
+			.base_addr = &priv->cgm5,
+			.compat = "fsl,s32gen1-mc_cgm5",
+		},
+		{
+			.base_addr = &priv->armpll,
+			.compat = "fsl,s32gen1-armpll",
+		},
+		{
+			.base_addr = &priv->periphpll,
+			.compat = "fsl,s32gen1-periphpll",
+		},
+		{
+			.base_addr = &priv->accelpll,
+			.compat = "fsl,s32gen1-accelpll",
+		},
+		{
+			.base_addr = &priv->ddrpll,
+			.compat = "fsl,s32gen1-ddrpll",
+		},
+		{
+			.base_addr = &priv->armdfs,
+			.compat = "fsl,s32gen1-armdfs",
+		},
+		{
+			.base_addr = &priv->periphdfs,
+			.compat = "fsl,s32gen1-periphdfs",
+		},
+	};
+
+	for (i = 0; i < ARRAY_SIZE(deps); i++) {
+		ret = bind_clk_provider(drv, fdt, deps[i].compat,
+				deps[i].base_addr, &deps[i].node);
+		if (ret)
+			return ret;
+	}
+
+	ret = dt_clk_apply_defaults(fdt, node);
+	if (ret) {
+		ERROR("Failed to apply default clocks for '%s'\n",
+		      fdt_get_name(fdt, node, NULL));
+		return ret;
+	}
+
+	for (i = 0; i < ARRAY_SIZE(deps); i++) {
+		ret = dt_enable_clocks(fdt, deps[i].node);
+		if (ret)
+			return ret;
+	}
+
+	return 0;
+}
+
+static const struct clk_ops s32gen1_clk_ops = {
+	.enable = s32gen1_scmi_enable,
+	.set_rate = s32gen1_scmi_set_rate,
+	.get_rate = s32gen1_scmi_get_rate,
+	.set_parent = s32gen1_scmi_set_parent,
+	.request = s32gen1_scmi_request,
+};
+
+int dt_init_plat_clk(void *fdt)
+{
+	static struct s32gen1_clk_driver clk_drv;
+	int node;
+
+	node = fdt_node_offset_by_compatible(fdt, -1, "fsl,s32-gen1-clocking");
+	if (node == -1) {
+		ERROR("Failed to detect S32-GEN1 clock compatible.\n");
+		return -EIO;
+	}
+
+	clk_drv.driver = allocate_clk_driver();
+	if (!clk_drv.driver) {
+		ERROR("Failed to allocate clock driver\n");
+		return -ENOMEM;
+	}
+
+	clk_drv.driver->ops = &s32gen1_clk_ops;
+	clk_drv.driver->phandle = fdt_get_phandle(fdt, node);
+	clk_drv.driver->data = &clk_drv;
+
+	set_clk_driver_name(clk_drv.driver, fdt_get_name(fdt, node, NULL));
+
+	return s32gen1_clk_probe(&clk_drv, fdt, node);
+}
diff --git a/drivers/nxp/s32g/clk/s32g274a_scmi_ids.c b/drivers/nxp/s32g/clk/s32g274a_scmi_ids.c
new file mode 100644
index 000000000..72fce9d58
--- /dev/null
+++ b/drivers/nxp/s32g/clk/s32g274a_scmi_ids.c
@@ -0,0 +1,444 @@
+// SPDX-License-Identifier: BSD-3-Clause
+/*
+ * Copyright 2020 NXP
+ */
+#include <clk/s32gen1_clk_funcs.h>
+#include <clk/s32gen1_scmi_clk.h>
+#include <common/debug.h>
+#include <dt-bindings/clock/s32g274a-clock.h>
+#include <dt-bindings/clock/s32g274a-scmi-clock.h>
+#include <errno.h>
+#include <stdint.h>
+
+#define INDEX(X)	((X) - S32GEN1_SCMI_PLAT_CLK_BASE_ID)
+
+struct s32gen1_scmi_clk s32g274a_scmi_clk[] = {
+	SCMI_ARRAY_ENTRY(S32G274A_SCMI_CLK_USB_MEM,
+			 S32GEN1_CLK_XBAR_DIV4, "usb_mem"),
+	SCMI_ARRAY_ENTRY(S32G274A_SCMI_CLK_USB_LOW,
+			 S32GEN1_CLK_SIRC, "usb_low"),
+	SCMI_ARRAY_ENTRY(S32G274A_SCMI_CLK_PFE_AXI,
+			 S32G274A_CLK_PFE_SYS, "pfe_axi"),
+	SCMI_ARRAY_ENTRY(S32G274A_SCMI_CLK_PFE_APB,
+			 S32G274A_CLK_PFE_SYS, "pfe_apb"),
+	SCMI_ARRAY_ENTRY(S32G274A_SCMI_CLK_PFE_TS,
+			 S32GEN1_CLK_GMAC0_TS, "pfe_ts"),
+	SCMI_ARRAY_ENTRY(S32G274A_SCMI_CLK_PFE_PE,
+			 S32G274A_CLK_PFE_PE, "pfe_pe"),
+	/* PFE0 */
+	SCMI_ARRAY_ENTRY(S32G274A_SCMI_CLK_PFE0_RX_SGMII,
+			 S32GEN1_SCMI_COMPLEX_CLK, "pfe0_rx_sgmii"),
+	SCMI_ARRAY_ENTRY(S32G274A_SCMI_CLK_PFE0_TX_SGMII,
+			 S32GEN1_SCMI_COMPLEX_CLK, "pfe0_tx_sgmii"),
+	SCMI_ARRAY_ENTRY(S32G274A_SCMI_CLK_PFE0_RX_RGMII,
+			 S32GEN1_SCMI_COMPLEX_CLK, "pfe0_rx_rgmii"),
+	SCMI_ARRAY_ENTRY(S32G274A_SCMI_CLK_PFE0_TX_RGMII,
+			 S32GEN1_SCMI_COMPLEX_CLK, "pfe0_tx_rgmii"),
+	SCMI_ARRAY_ENTRY(S32G274A_SCMI_CLK_PFE0_RX_RMII,
+			 S32GEN1_SCMI_COMPLEX_CLK, "pfe0_rx_rmii"),
+	SCMI_ARRAY_ENTRY(S32G274A_SCMI_CLK_PFE0_TX_RMII,
+			 S32GEN1_SCMI_COMPLEX_CLK, "pfe0_tx_rmii"),
+	SCMI_ARRAY_ENTRY(S32G274A_SCMI_CLK_PFE0_RX_MII,
+			 S32GEN1_SCMI_COMPLEX_CLK, "pfe0_rx_mii"),
+	SCMI_ARRAY_ENTRY(S32G274A_SCMI_CLK_PFE0_TX_MII,
+			 S32GEN1_SCMI_COMPLEX_CLK, "pfe0_tx_mii"),
+	/* PFE1 */
+	SCMI_ARRAY_ENTRY(S32G274A_SCMI_CLK_PFE1_RX_SGMII,
+			 S32GEN1_SCMI_COMPLEX_CLK, "pfe1_rx_sgmii"),
+	SCMI_ARRAY_ENTRY(S32G274A_SCMI_CLK_PFE1_TX_SGMII,
+			 S32GEN1_SCMI_COMPLEX_CLK, "pfe1_tx_sgmii"),
+	SCMI_ARRAY_ENTRY(S32G274A_SCMI_CLK_PFE1_RX_RGMII,
+			 S32GEN1_SCMI_COMPLEX_CLK, "pfe1_rx_rgmii"),
+	SCMI_ARRAY_ENTRY(S32G274A_SCMI_CLK_PFE1_TX_RGMII,
+			 S32GEN1_SCMI_COMPLEX_CLK, "pfe1_tx_rgmii"),
+	SCMI_ARRAY_ENTRY(S32G274A_SCMI_CLK_PFE1_RX_RMII,
+			 S32GEN1_SCMI_COMPLEX_CLK, "pfe0_rx_rmii"),
+	SCMI_ARRAY_ENTRY(S32G274A_SCMI_CLK_PFE1_TX_RMII,
+			 S32GEN1_SCMI_COMPLEX_CLK, "pfe0_tx_rmii"),
+	SCMI_ARRAY_ENTRY(S32G274A_SCMI_CLK_PFE1_RX_MII,
+			 S32GEN1_SCMI_COMPLEX_CLK, "pfe0_rx_mii"),
+	SCMI_ARRAY_ENTRY(S32G274A_SCMI_CLK_PFE1_TX_MII,
+			 S32GEN1_SCMI_COMPLEX_CLK, "pfe0_tx_mii"),
+	/* PFE2 */
+	SCMI_ARRAY_ENTRY(S32G274A_SCMI_CLK_PFE2_RX_SGMII,
+			 S32GEN1_SCMI_COMPLEX_CLK, "pfe2_rx_sgmii"),
+	SCMI_ARRAY_ENTRY(S32G274A_SCMI_CLK_PFE2_TX_SGMII,
+			 S32GEN1_SCMI_COMPLEX_CLK, "pfe2_tx_sgmii"),
+	SCMI_ARRAY_ENTRY(S32G274A_SCMI_CLK_PFE2_RX_RGMII,
+			 S32GEN1_SCMI_COMPLEX_CLK, "pfe2_rx_rgmii"),
+	SCMI_ARRAY_ENTRY(S32G274A_SCMI_CLK_PFE2_TX_RGMII,
+			 S32GEN1_SCMI_COMPLEX_CLK, "pfe2_tx_rgmii"),
+	SCMI_ARRAY_ENTRY(S32G274A_SCMI_CLK_PFE2_RX_RMII,
+			 S32GEN1_SCMI_COMPLEX_CLK, "pfe0_rx_rmii"),
+	SCMI_ARRAY_ENTRY(S32G274A_SCMI_CLK_PFE2_TX_RMII,
+			 S32GEN1_SCMI_COMPLEX_CLK, "pfe0_tx_rmii"),
+	SCMI_ARRAY_ENTRY(S32G274A_SCMI_CLK_PFE2_RX_MII,
+			 S32GEN1_SCMI_COMPLEX_CLK, "pfe0_rx_mii"),
+	SCMI_ARRAY_ENTRY(S32G274A_SCMI_CLK_PFE2_TX_MII,
+			 S32GEN1_SCMI_COMPLEX_CLK, "pfe0_tx_mii"),
+};
+
+static int s32g_compound2clkid(uint32_t scmi_clk_id, uint32_t *clk_id)
+{
+	switch (scmi_clk_id) {
+	case S32G274A_SCMI_CLK_PFE0_RX_SGMII:
+	case S32G274A_SCMI_CLK_PFE0_RX_RGMII:
+		if (clk_id)
+			*clk_id = S32G274A_CLK_PFE_MAC0_RX;
+		break;
+	case S32G274A_SCMI_CLK_PFE0_TX_SGMII:
+	case S32G274A_SCMI_CLK_PFE0_TX_RGMII:
+		if (clk_id)
+			*clk_id = S32G274A_CLK_PFE_MAC0_TX_DIV;
+		break;
+	case S32G274A_SCMI_CLK_PFE1_RX_SGMII:
+	case S32G274A_SCMI_CLK_PFE1_RX_RGMII:
+		if (clk_id)
+			*clk_id = S32G274A_CLK_PFE_MAC1_RX;
+		break;
+	case S32G274A_SCMI_CLK_PFE1_TX_SGMII:
+	case S32G274A_SCMI_CLK_PFE1_TX_RGMII:
+		if (clk_id)
+			*clk_id = S32G274A_CLK_PFE_MAC1_TX;
+		break;
+	case S32G274A_SCMI_CLK_PFE2_RX_SGMII:
+	case S32G274A_SCMI_CLK_PFE2_RX_RGMII:
+		if (clk_id)
+			*clk_id = S32G274A_CLK_PFE_MAC2_RX;
+		break;
+	case S32G274A_SCMI_CLK_PFE2_TX_SGMII:
+	case S32G274A_SCMI_CLK_PFE2_TX_RGMII:
+		if (clk_id)
+			*clk_id = S32G274A_CLK_PFE_MAC2_TX;
+		break;
+	case S32G274A_SCMI_CLK_PFE0_RX_RMII:
+	case S32G274A_SCMI_CLK_PFE0_TX_RMII:
+	case S32G274A_SCMI_CLK_PFE0_RX_MII:
+	case S32G274A_SCMI_CLK_PFE0_TX_MII:
+	case S32G274A_SCMI_CLK_PFE1_RX_RMII:
+	case S32G274A_SCMI_CLK_PFE1_TX_RMII:
+	case S32G274A_SCMI_CLK_PFE1_RX_MII:
+	case S32G274A_SCMI_CLK_PFE1_TX_MII:
+	case S32G274A_SCMI_CLK_PFE2_RX_RMII:
+	case S32G274A_SCMI_CLK_PFE2_TX_RMII:
+	case S32G274A_SCMI_CLK_PFE2_RX_MII:
+	case S32G274A_SCMI_CLK_PFE2_TX_MII:
+		if (clk_id)
+			*clk_id = S32GEN1_SCMI_NOT_IMPLEMENTED_CLK;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+int plat_scmi_id2clk(uint32_t scmi_clk_id, uint32_t *clk_id)
+{
+	if (!clk_id)
+		return -EINVAL;
+
+	if (INDEX(scmi_clk_id) >= ARRAY_SIZE(s32g274a_scmi_clk))
+		return -EINVAL;
+
+	*clk_id = s32g274a_scmi_clk[INDEX(scmi_clk_id)].plat_id;
+	if (!*clk_id) {
+		ERROR("Unhandled S32G274A clock: %u\n", scmi_clk_id);
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+int plat_compound_clk_get(struct clk *clk)
+{
+	uint32_t scmi_clk_id = clk->id;
+
+	if (INDEX(scmi_clk_id) >= ARRAY_SIZE(s32g274a_scmi_clk))
+		return -EINVAL;
+
+	if (s32g_compound2clkid(scmi_clk_id, NULL)) {
+		ERROR("Invalid S32G274A compound clock : %u\n", scmi_clk_id);
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static int set_mac0_rx_parent(struct clk *clk)
+{
+	uint32_t rx_id;
+	uint32_t clk_id = clk->id;
+
+	if (clk_id == S32G274A_SCMI_CLK_PFE0_RX_SGMII) {
+		rx_id = S32G274A_CLK_SERDES1_LANE0_CDR;
+	} else if (clk_id == S32G274A_SCMI_CLK_PFE0_RX_RGMII) {
+		rx_id = S32G274A_CLK_PFE_MAC0_EXT_RX;
+	} else {
+		ERROR("Invalid PFE0 RX mode\n");
+		return -EINVAL;
+	}
+
+	return cc_set_mux_parent(clk, S32G274A_CLK_MC_CGM2_MUX4, rx_id);
+}
+
+static int set_mac0_tx_parent(struct clk *clk)
+{
+	uint32_t tx_id;
+	uint32_t clk_id = clk->id;
+
+	if (clk_id == S32G274A_SCMI_CLK_PFE0_TX_SGMII) {
+		tx_id = S32G274A_CLK_SERDES1_LANE0_TX;
+	} else if (clk_id == S32G274A_SCMI_CLK_PFE0_TX_RGMII) {
+		tx_id = S32GEN1_CLK_PERIPH_PLL_PHI5;
+	} else {
+		ERROR("Invalid PFE0 TX mode\n");
+		return -EINVAL;
+	}
+
+	return cc_set_mux_parent(clk, S32G274A_CLK_MC_CGM2_MUX1, tx_id);
+}
+
+static int set_mac1_rx_parent(struct clk *clk)
+{
+	uint32_t rx_id;
+	uint32_t clk_id = clk->id;
+
+	if (clk_id == S32G274A_SCMI_CLK_PFE1_RX_SGMII) {
+		rx_id = S32G274A_CLK_SERDES1_LANE1_CDR;
+	} else if (clk_id == S32G274A_SCMI_CLK_PFE1_RX_RGMII) {
+		rx_id = S32G274A_CLK_PFE_MAC1_EXT_RX;
+	} else {
+		ERROR("Invalid PFE1 RX mode\n");
+		return -EINVAL;
+	}
+
+	return cc_set_mux_parent(clk, S32G274A_CLK_MC_CGM2_MUX5, rx_id);
+}
+
+static int set_mac1_tx_parent(struct clk *clk)
+{
+	uint32_t tx_id;
+	uint32_t clk_id = clk->id;
+
+	if (clk_id == S32G274A_SCMI_CLK_PFE1_TX_SGMII) {
+		tx_id = S32G274A_CLK_SERDES1_LANE1_TX;
+	} else if (clk_id == S32G274A_SCMI_CLK_PFE1_TX_RGMII) {
+		tx_id = S32GEN1_CLK_PERIPH_PLL_PHI5;
+	} else {
+		ERROR("Invalid PFE1 TX mode\n");
+		return -EINVAL;
+	}
+
+	return cc_set_mux_parent(clk, S32G274A_CLK_MC_CGM2_MUX2, tx_id);
+}
+
+static int set_mac2_rx_parent(struct clk *clk)
+{
+	uint32_t rx_id;
+	uint32_t clk_id = clk->id;
+
+	if (clk_id == S32G274A_SCMI_CLK_PFE2_RX_SGMII) {
+		rx_id = S32G274A_CLK_SERDES0_LANE1_CDR;
+	} else if (clk_id == S32G274A_SCMI_CLK_PFE2_RX_RGMII) {
+		rx_id = S32G274A_CLK_PFE_MAC2_EXT_RX;
+	} else {
+		ERROR("Invalid PFE2 RX mode\n");
+		return -EINVAL;
+	}
+
+	return cc_set_mux_parent(clk, S32G274A_CLK_MC_CGM2_MUX6, rx_id);
+}
+
+static int set_mac2_tx_parent(struct clk *clk)
+{
+	uint32_t tx_id;
+	uint32_t clk_id = clk->id;
+
+	if (clk_id == S32G274A_SCMI_CLK_PFE2_TX_SGMII) {
+		tx_id = S32G274A_CLK_SERDES0_LANE1_TX;
+	} else if (clk_id == S32G274A_SCMI_CLK_PFE2_TX_RGMII) {
+		tx_id = S32GEN1_CLK_PERIPH_PLL_PHI5;
+	} else {
+		ERROR("Invalid PFE2 TX mode\n");
+		return -EINVAL;
+	}
+
+	return cc_set_mux_parent(clk, S32G274A_CLK_MC_CGM2_MUX3, tx_id);
+}
+
+int plat_compound_clk_set_parents(struct clk *clk)
+{
+	uint32_t clk_id = clk->id;
+	uint32_t id;
+
+	if (s32g_compound2clkid(clk_id, &id)) {
+		ERROR("Invalid compound clock : %u\n", clk_id);
+		return -EINVAL;
+	}
+
+	switch (id) {
+	case S32G274A_CLK_PFE_MAC0_TX_DIV:
+		return set_mac0_tx_parent(clk);
+	case S32G274A_CLK_PFE_MAC0_RX:
+		return set_mac0_rx_parent(clk);
+	case S32G274A_CLK_PFE_MAC1_TX:
+		return set_mac1_tx_parent(clk);
+	case S32G274A_CLK_PFE_MAC1_RX:
+		return set_mac1_rx_parent(clk);
+	case S32G274A_CLK_PFE_MAC2_TX:
+		return set_mac2_tx_parent(clk);
+	case S32G274A_CLK_PFE_MAC2_RX:
+		return set_mac2_rx_parent(clk);
+	case S32GEN1_SCMI_NOT_IMPLEMENTED_CLK:
+		return 0;
+	default:
+		ERROR("%s: Invalid clock %d\n", __func__, id);
+		return -EINVAL;
+	}
+}
+
+int plat_compound_clk_enable(struct clk *clk)
+{
+	struct clk sclock = *clk;
+	uint32_t clk_id = clk->id;
+	uint32_t id;
+	int ret;
+
+	if (s32g_compound2clkid(clk_id, &id)) {
+		ERROR("Invalid s32g274a compound clock : %u\n", clk_id);
+		return -EINVAL;
+	}
+
+	if (id == S32GEN1_SCMI_NOT_IMPLEMENTED_CLK) {
+		ERROR("Clock %s is not handled yet\n",
+		      s32g274a_scmi_clk[INDEX(clk_id)].name);
+		return -EINVAL;
+	}
+
+	ret = plat_compound_clk_set_parents(clk);
+	if (ret) {
+		ERROR("Failed to set parents for %u\n", clk_id);
+		return -EINVAL;
+	}
+
+	sclock.id = id;
+	ret = s32gen1_enable(&sclock, 1);
+	if (ret) {
+		ERROR("Failed to enable %u clock\n", clk_id);
+		return ret;
+	}
+
+	s32g274a_scmi_clk[INDEX(clk_id)].enabled = true;
+	return 0;
+}
+
+unsigned long plat_compound_clk_set_rate(struct clk *clk, unsigned long rate)
+{
+	struct clk sclock = *clk;
+	uint32_t scmi_clk_id = clk->id;
+	uint32_t id;
+	int ret;
+
+	if (INDEX(scmi_clk_id) >= ARRAY_SIZE(s32g274a_scmi_clk))
+		return -EINVAL;
+
+	ret = plat_compound_clk_set_parents(clk);
+	if (ret) {
+		ERROR("Failed to set parents for %u\n", scmi_clk_id);
+		return -EINVAL;
+	}
+
+	if (s32g_compound2clkid(scmi_clk_id, &id)) {
+		ERROR("Invalid compound clock : %u\n", scmi_clk_id);
+		return -EINVAL;
+	}
+
+	if (id == S32GEN1_SCMI_NOT_IMPLEMENTED_CLK) {
+		ERROR("Clock %s is not handled yet\n",
+		      s32g274a_scmi_clk[INDEX(scmi_clk_id)].name);
+		return 0;
+	}
+
+	sclock.id = id;
+	return s32gen1_set_rate(&sclock, rate);
+}
+
+unsigned long plat_compound_clk_get_rate(struct clk *clk)
+{
+	struct clk sclock = *clk;
+	uint32_t scmi_clk_id = clk->id;
+	uint32_t id;
+
+	if (INDEX(scmi_clk_id) >= ARRAY_SIZE(s32g274a_scmi_clk))
+		return 0;
+
+	if (s32g_compound2clkid(scmi_clk_id, &id)) {
+		ERROR("Invalid compound clock : %u\n", scmi_clk_id);
+		return 0;
+	}
+
+	if (id == S32GEN1_SCMI_NOT_IMPLEMENTED_CLK) {
+		ERROR("Clock %s is not handled yet\n",
+		      s32g274a_scmi_clk[INDEX(scmi_clk_id)].name);
+		return 0;
+	}
+
+	sclock.id = id;
+	return s32gen1_get_rate(&sclock);
+}
+
+uint32_t plat_get_nclocks(void)
+{
+	return S32GEN1_PLAT_SCMI_CLK(ARRAY_SIZE(s32g274a_scmi_clk));
+}
+
+const char *plat_scmi_clk_get_name(uint32_t scmi_clk_id)
+{
+	if (INDEX(scmi_clk_id) >= ARRAY_SIZE(s32g274a_scmi_clk))
+		return NULL;
+
+	return s32g274a_scmi_clk[INDEX(scmi_clk_id)].name;
+}
+
+bool plat_scmi_clk_is_enabled(uint32_t scmi_clk_id)
+{
+	if (INDEX(scmi_clk_id) >= ARRAY_SIZE(s32g274a_scmi_clk))
+		return false;
+
+	return s32g274a_scmi_clk[INDEX(scmi_clk_id)].enabled;
+}
+
+int plat_scmi_clk_get_rates(struct clk *clk, unsigned long *rates,
+			    size_t *nrates)
+{
+	struct clk sclock = *clk;
+	uint32_t scmi_clk_id = clk->id;
+	uint32_t id;
+	int ret;
+
+	if (INDEX(scmi_clk_id) >= ARRAY_SIZE(s32g274a_scmi_clk))
+		return -EINVAL;
+
+	ret = plat_compound_clk_set_parents(clk);
+	if (ret) {
+		ERROR("Failed to set parents for %u\n", scmi_clk_id);
+		return -EINVAL;
+	}
+
+	if (s32g_compound2clkid(scmi_clk_id, &id)) {
+		ERROR("Invalid compound clock : %u\n", scmi_clk_id);
+		return -EINVAL;
+	}
+
+	if (id == S32GEN1_SCMI_NOT_IMPLEMENTED_CLK) {
+		ERROR("Clock %s is not handled yet\n",
+		      s32g274a_scmi_clk[INDEX(scmi_clk_id)].name);
+		return -EINVAL;
+	}
+
+	sclock.id = id;
+	rates[0] = s32gen1_get_rate(&sclock);
+
+	return 0;
+}
diff --git a/drivers/nxp/s32g/clk/s32gen1_scmi_clk.c b/drivers/nxp/s32g/clk/s32gen1_scmi_clk.c
new file mode 100644
index 000000000..8a132ccfb
--- /dev/null
+++ b/drivers/nxp/s32g/clk/s32gen1_scmi_clk.c
@@ -0,0 +1,199 @@
+// SPDX-License-Identifier: BSD-3-Clause
+/*
+ * Copyright 2020 NXP
+ */
+#include <clk/s32gen1_clk_funcs.h>
+#include <clk/s32gen1_scmi_clk.h>
+#include <common/debug.h>
+#include <dt-bindings/clock/s32gen1-clock.h>
+#include <dt-bindings/clock/s32gen1-scmi-clock.h>
+#include <errno.h>
+#include <stdint.h>
+
+static bool is_scmi_clk(uint32_t id)
+{
+	if (id >= S32GEN1_SCMI_CLK_BASE_ID && id < S32GEN1_CLK_ID_BASE)
+		return true;
+
+	return false;
+}
+
+static int translate_clk(struct clk *clk, bool *is_compound)
+{
+	uint32_t clk_id;
+	int ret;
+
+	if (!clk)
+		return -EINVAL;
+
+	*is_compound = false;
+
+	if (!is_scmi_clk(clk->id))
+		return 0;
+
+	ret = cc_scmi_id2clk(clk->id, &clk_id);
+	if (ret) {
+		ERROR("Clock with ID %u isn't covered by this driver\n",
+		       clk->id);
+		return -EINVAL;
+	}
+
+	if (clk_id == S32GEN1_SCMI_COMPLEX_CLK)
+		*is_compound = true;
+	else
+		clk->id = clk_id;
+
+	return 0;
+}
+
+int s32gen1_scmi_request(uint32_t id, struct clk *clk)
+{
+	int ret;
+	bool is_compound;
+
+	ret = translate_clk(clk, &is_compound);
+	if (ret)
+		return ret;
+
+	if (is_compound)
+		return cc_compound_clk_get(clk);
+
+	if (!get_clock(clk->id)) {
+		ERROR("Clock %u is not part of the clock tree\n", clk->id);
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+unsigned long s32gen1_scmi_get_rate(struct clk *clk)
+{
+	int ret;
+	bool is_compound;
+
+	ret = translate_clk(clk, &is_compound);
+	if (ret)
+		return 0;
+
+	if (is_compound)
+		return cc_compound_clk_get_rate(clk);
+
+	return s32gen1_get_rate(clk);
+}
+
+unsigned long s32gen1_scmi_set_rate(struct clk *clk, unsigned long rate)
+{
+	int ret;
+	bool is_compound;
+
+	ret = translate_clk(clk, &is_compound);
+	if (ret)
+		return 0;
+
+	if (is_compound)
+		return cc_compound_clk_set_rate(clk, rate);
+
+	return s32gen1_set_rate(clk, rate);
+}
+
+int s32gen1_scmi_set_parent(struct clk *clk, struct clk *parent)
+{
+	if (is_scmi_clk(clk->id)) {
+		ERROR("Is not allowed to set parents for SCMI clocks\n");
+		return -EINVAL;
+	}
+
+	return s32gen1_set_parent(clk, parent);
+}
+
+static int clock_disable(struct clk *clk)
+{
+	/* Not implemented yet */
+	return -EINVAL;
+}
+
+static int clock_enable(struct clk *clk)
+{
+	int ret;
+	bool is_compound;
+
+	ret = translate_clk(clk, &is_compound);
+	if (ret)
+		return ret;
+
+	if (is_compound)
+		return cc_compound_clk_enable(clk);
+
+	return s32gen1_enable(clk, 1);
+}
+
+int s32gen1_scmi_enable(struct clk *clk, int enable)
+{
+	if (enable)
+		return clock_enable(clk);
+
+	return clock_disable(clk);
+}
+
+uint32_t s32gen1_scmi_nclocks(void)
+{
+	return cc_get_nclocks();
+}
+
+const char *s32gen1_scmi_clk_get_name(uint32_t scmi_clk_id)
+{
+	return cc_scmi_clk_get_name(scmi_clk_id);
+}
+
+bool s32gen1_scmi_clk_is_enabled(uint32_t scmi_clk_id)
+{
+	return cc_scmi_clk_is_enabled(scmi_clk_id);
+}
+
+int s32gen1_scmi_clk_get_rates(struct clk *clk, unsigned long *rates,
+			       size_t *nrates)
+{
+	int ret;
+	bool is_compound;
+
+	ret = translate_clk(clk, &is_compound);
+	if (ret)
+		return ret;
+
+	if (is_compound)
+		return cc_scmi_clk_get_rates(clk, rates, nrates);
+
+	rates[0] = s32gen1_get_rate(clk);
+
+	return 0;
+}
+
+unsigned long s32gen1_scmi_clk_get_rate(struct clk *clk)
+{
+	int ret;
+	bool is_compound;
+
+	ret = translate_clk(clk, &is_compound);
+	if (ret)
+		return 0;
+
+	if (is_compound)
+		return cc_compound_clk_get_rate(clk);
+
+	return s32gen1_get_rate(clk);
+}
+
+unsigned long s32gen1_scmi_clk_set_rate(struct clk *clk, unsigned long rate)
+{
+	int ret;
+	bool is_compound;
+
+	ret = translate_clk(clk, &is_compound);
+	if (ret)
+		return 0;
+
+	if (is_compound)
+		return cc_compound_clk_set_rate(clk, rate);
+
+	return s32gen1_set_rate(clk, rate);
+}
diff --git a/drivers/nxp/s32g/clk/s32gen1_scmi_ids.c b/drivers/nxp/s32g/clk/s32gen1_scmi_ids.c
new file mode 100644
index 000000000..067b16c06
--- /dev/null
+++ b/drivers/nxp/s32g/clk/s32gen1_scmi_ids.c
@@ -0,0 +1,481 @@
+// SPDX-License-Identifier: BSD-3-Clause
+/*
+ * Copyright 2020 NXP
+ */
+#include <clk/s32gen1_clk_funcs.h>
+#include <clk/s32gen1_scmi_clk.h>
+#include <common/debug.h>
+#include <dt-bindings/clock/s32gen1-clock.h>
+#include <dt-bindings/clock/s32gen1-scmi-clock.h>
+#include <errno.h>
+#include <stdint.h>
+
+#define INDEX(X)	((X) - S32GEN1_SCMI_CLK_BASE_ID)
+
+struct s32gen1_scmi_clk cc_scmi_clk[] = {
+	SCMI_ARRAY_ENTRY(S32GEN1_SCMI_CLK_A53,
+			 S32GEN1_CLK_A53_CORE, "a53"),
+	SCMI_ARRAY_ENTRY(S32GEN1_SCMI_CLK_SERDES_AXI,
+			 S32GEN1_CLK_XBAR, "serdes_axi"),
+	SCMI_ARRAY_ENTRY(S32GEN1_SCMI_CLK_SERDES_AUX,
+			 S32GEN1_CLK_FIRC, "serdes_aux"),
+	SCMI_ARRAY_ENTRY(S32GEN1_SCMI_CLK_SERDES_APB,
+			 S32GEN1_CLK_XBAR_DIV3, "serdes_apb"),
+	SCMI_ARRAY_ENTRY(S32GEN1_SCMI_CLK_SERDES_REF,
+			 S32GEN1_CLK_SERDES_REF, "serdes_ref"),
+	SCMI_ARRAY_ENTRY(S32GEN1_SCMI_CLK_SERDES_PAD_REF,
+			 S32GEN1_SCMI_COMPLEX_CLK, "serdes_pad_ref"),
+	SCMI_ARRAY_ENTRY(S32GEN1_SCMI_CLK_FTM0_SYS,
+			 S32GEN1_CLK_PER, "ftm0_sys"),
+	SCMI_ARRAY_ENTRY(S32GEN1_SCMI_CLK_FTM0_EXT,
+			 S32GEN1_CLK_FTM0_REF, "ftm0_ext"),
+	SCMI_ARRAY_ENTRY(S32GEN1_SCMI_CLK_FTM1_SYS,
+			 S32GEN1_CLK_PER, "ftm1_sys"),
+	SCMI_ARRAY_ENTRY(S32GEN1_SCMI_CLK_FTM1_EXT,
+			 S32GEN1_CLK_FTM1_REF, "ftm1_ext"),
+	SCMI_ARRAY_ENTRY(S32GEN1_SCMI_CLK_FLEXCAN_REG,
+			 S32GEN1_CLK_XBAR_DIV3, "flexcan_reg"),
+	SCMI_ARRAY_ENTRY(S32GEN1_SCMI_CLK_FLEXCAN_SYS,
+			 S32GEN1_CLK_XBAR_DIV3, "flexcan_sys"),
+	SCMI_ARRAY_ENTRY(S32GEN1_SCMI_CLK_FLEXCAN_CAN,
+			 S32GEN1_CLK_CAN_PE, "flexcan_can"),
+	SCMI_ARRAY_ENTRY(S32GEN1_SCMI_CLK_FLEXCAN_TS,
+			 S32GEN1_CLK_XBAR_DIV2, "flexcan_ts"),
+	SCMI_ARRAY_ENTRY(S32GEN1_SCMI_CLK_LINFLEX_XBAR,
+			 S32GEN1_CLK_LINFLEXD, "linflex_xbar"),
+	SCMI_ARRAY_ENTRY(S32GEN1_SCMI_CLK_LINFLEX_LIN,
+			 S32GEN1_CLK_LIN_BAUD, "linflex_lin"),
+	SCMI_ARRAY_ENTRY(S32GEN1_SCMI_CLK_GMAC0_RX_SGMII,
+			 S32GEN1_SCMI_COMPLEX_CLK, "gmac0_rx_sgmii"),
+	SCMI_ARRAY_ENTRY(S32GEN1_SCMI_CLK_GMAC0_TX_SGMII,
+			 S32GEN1_SCMI_COMPLEX_CLK, "gmac0_tx_sgmii"),
+	SCMI_ARRAY_ENTRY(S32GEN1_SCMI_CLK_GMAC0_TS_SGMII,
+			 S32GEN1_SCMI_COMPLEX_CLK, "gmac0_ts_sgmii"),
+	SCMI_ARRAY_ENTRY(S32GEN1_SCMI_CLK_GMAC0_RX_RGMII,
+			 S32GEN1_SCMI_COMPLEX_CLK, "gmac0_rx_rgmii"),
+	SCMI_ARRAY_ENTRY(S32GEN1_SCMI_CLK_GMAC0_TX_RGMII,
+			 S32GEN1_SCMI_COMPLEX_CLK, "gmac0_tx_rgmii"),
+	SCMI_ARRAY_ENTRY(S32GEN1_SCMI_CLK_GMAC0_TS_RGMII,
+			 S32GEN1_SCMI_COMPLEX_CLK, "gmac0_ts_rgmii"),
+	SCMI_ARRAY_ENTRY(S32GEN1_SCMI_CLK_GMAC0_RX_RMII,
+			 S32GEN1_SCMI_COMPLEX_CLK, "gmac0_rx_rmii"),
+	SCMI_ARRAY_ENTRY(S32GEN1_SCMI_CLK_GMAC0_TX_RMII,
+			 S32GEN1_SCMI_COMPLEX_CLK, "gmac0_tx_rmii"),
+	SCMI_ARRAY_ENTRY(S32GEN1_SCMI_CLK_GMAC0_TS_RMII,
+			 S32GEN1_SCMI_COMPLEX_CLK, "gmac0_ts_rmii"),
+	SCMI_ARRAY_ENTRY(S32GEN1_SCMI_CLK_GMAC0_RX_MII,
+			 S32GEN1_SCMI_COMPLEX_CLK, "gmac0_rx_mii"),
+	SCMI_ARRAY_ENTRY(S32GEN1_SCMI_CLK_GMAC0_TX_MII,
+			 S32GEN1_SCMI_COMPLEX_CLK, "gmac0_tx_mii"),
+	SCMI_ARRAY_ENTRY(S32GEN1_SCMI_CLK_GMAC0_TS_MII,
+			 S32GEN1_SCMI_COMPLEX_CLK, "gmac0_ts_mii"),
+	SCMI_ARRAY_ENTRY(S32GEN1_SCMI_CLK_GMAC0_AXI,
+			 S32GEN1_CLK_XBAR, "gmac0_axi"),
+	SCMI_ARRAY_ENTRY(S32GEN1_SCMI_CLK_SPI_REG,
+			 S32GEN1_CLK_SPI, "spi_reg"),
+	SCMI_ARRAY_ENTRY(S32GEN1_SCMI_CLK_SPI_MODULE,
+			 S32GEN1_CLK_SPI, "spi_module"),
+	SCMI_ARRAY_ENTRY(S32GEN1_SCMI_CLK_QSPI_REG,
+			 S32GEN1_CLK_XBAR_DIV3, "qspi_reg"),
+	SCMI_ARRAY_ENTRY(S32GEN1_SCMI_CLK_QSPI_AHB,
+			 S32GEN1_CLK_XBAR_DIV3, "qspi_ahb"),
+	SCMI_ARRAY_ENTRY(S32GEN1_SCMI_CLK_QSPI_FLASH2X,
+			 S32GEN1_CLK_QSPI_2X, "qspi_flash2x"),
+	SCMI_ARRAY_ENTRY(S32GEN1_SCMI_CLK_QSPI_FLASH1X,
+			 S32GEN1_CLK_QSPI, "qspi_flash1x"),
+	SCMI_ARRAY_ENTRY(S32GEN1_SCMI_CLK_USDHC_AHB,
+			 S32GEN1_CLK_XBAR, "usdhc_ahb"),
+	SCMI_ARRAY_ENTRY(S32GEN1_SCMI_CLK_USDHC_MODULE,
+			 S32GEN1_CLK_XBAR_DIV3, "usdhc_module"),
+	SCMI_ARRAY_ENTRY(S32GEN1_SCMI_CLK_USDHC_CORE,
+			 S32GEN1_CLK_SDHC, "usdhc_core"),
+	SCMI_ARRAY_ENTRY(S32GEN1_SCMI_CLK_USDHC_MOD32K,
+			 S32GEN1_CLK_SIRC, "usdhc_mod32k"),
+	SCMI_ARRAY_ENTRY(S32GEN1_SCMI_CLK_DDR_REG,
+			 S32GEN1_CLK_XBAR_DIV3, "ddr_reg"),
+	SCMI_ARRAY_ENTRY(S32GEN1_SCMI_CLK_DDR_PLL_REF,
+			 S32GEN1_CLK_DDR, "ddr_pll_ref"),
+	SCMI_ARRAY_ENTRY(S32GEN1_SCMI_CLK_DDR_AXI,
+			 S32GEN1_CLK_DDR, "ddr_axi"),
+	SCMI_ARRAY_ENTRY(S32GEN1_SCMI_CLK_SRAM_AXI,
+			 S32GEN1_CLK_XBAR, "sram_axi"),
+	SCMI_ARRAY_ENTRY(S32GEN1_SCMI_CLK_SRAM_REG,
+			 S32GEN1_CLK_XBAR_DIV3, "sram_reg"),
+	SCMI_ARRAY_ENTRY(S32GEN1_SCMI_CLK_I2C_REG,
+			 S32GEN1_CLK_XBAR_DIV3, "i2c_reg"),
+	SCMI_ARRAY_ENTRY(S32GEN1_SCMI_CLK_I2C_MODULE,
+			 S32GEN1_CLK_XBAR_DIV3, "i2c_module"),
+	SCMI_ARRAY_ENTRY(S32GEN1_SCMI_CLK_RTC_REG,
+			 S32GEN1_CLK_XBAR_DIV6, "rtc_reg"),
+	SCMI_ARRAY_ENTRY(S32GEN1_SCMI_CLK_RTC_SIRC,
+			 S32GEN1_CLK_SIRC, "rtc_sirc"),
+	SCMI_ARRAY_ENTRY(S32GEN1_SCMI_CLK_RTC_FIRC,
+			 S32GEN1_CLK_FIRC, "rtc_firc"),
+	SCMI_ARRAY_ENTRY(S32GEN1_SCMI_CLK_SIUL2_REG,
+			 S32GEN1_CLK_XBAR_DIV6, "siul2_reg"),
+	SCMI_ARRAY_ENTRY(S32GEN1_SCMI_CLK_SIUL2_FILTER,
+			 S32GEN1_CLK_FIRC, "siul2_filter"),
+	SCMI_ARRAY_ENTRY(S32GEN1_SCMI_CLK_CRC_REG,
+			 S32GEN1_CLK_XBAR_DIV3, "crc_reg"),
+	SCMI_ARRAY_ENTRY(S32GEN1_SCMI_CLK_CRC_MODULE,
+			 S32GEN1_CLK_XBAR_DIV3, "crc_module"),
+	SCMI_ARRAY_ENTRY(S32GEN1_SCMI_CLK_EIM0_REG,
+			 S32GEN1_CLK_A53_CORE_DIV10, "eim0_reg"),
+	SCMI_ARRAY_ENTRY(S32GEN1_SCMI_CLK_EIM0_MODULE,
+			 S32GEN1_CLK_A53_CORE_DIV10, "eim0_module"),
+	SCMI_ARRAY_ENTRY(S32GEN1_SCMI_CLK_EIM123_REG,
+			 S32GEN1_CLK_XBAR_DIV6, "eim123_reg"),
+	SCMI_ARRAY_ENTRY(S32GEN1_SCMI_CLK_EIM123_MODULE,
+			 S32GEN1_CLK_XBAR_DIV6, "eim123_module"),
+	SCMI_ARRAY_ENTRY(S32GEN1_SCMI_CLK_EIM_REG,
+			 S32GEN1_CLK_XBAR_DIV6, "eim_reg"),
+	SCMI_ARRAY_ENTRY(S32GEN1_SCMI_CLK_EIM_MODULE,
+			 S32GEN1_CLK_XBAR_DIV6, "eim_module"),
+	SCMI_ARRAY_ENTRY(S32GEN1_SCMI_CLK_FCCU_MODULE,
+			 S32GEN1_CLK_XBAR_DIV6, "fccu_module"),
+	SCMI_ARRAY_ENTRY(S32GEN1_SCMI_CLK_FCCU_SAFE,
+			 S32GEN1_CLK_FIRC, "fccu_safe"),
+	SCMI_ARRAY_ENTRY(S32GEN1_SCMI_CLK_SWT_MODULE,
+			 S32GEN1_CLK_XBAR_DIV3, "swt_module"),
+	SCMI_ARRAY_ENTRY(S32GEN1_SCMI_CLK_SWT_COUNTER,
+			 S32GEN1_CLK_FIRC, "swt_counter"),
+	SCMI_ARRAY_ENTRY(S32GEN1_SCMI_CLK_STM_MODULE,
+			 S32GEN1_CLK_XBAR_DIV3, "stm_module"),
+	SCMI_ARRAY_ENTRY(S32GEN1_SCMI_CLK_STM_REG,
+			 S32GEN1_CLK_XBAR_DIV3, "stm_reg"),
+	SCMI_ARRAY_ENTRY(S32GEN1_SCMI_CLK_PIT_MODULE,
+			 S32GEN1_CLK_XBAR_DIV3, "pit_module"),
+	SCMI_ARRAY_ENTRY(S32GEN1_SCMI_CLK_PIT_REG,
+			 S32GEN1_CLK_XBAR_DIV3, "pit_reg"),
+	SCMI_ARRAY_ENTRY(S32GEN1_SCMI_CLK_EDMA_MODULE,
+			 S32GEN1_CLK_XBAR, "edma_module"),
+	SCMI_ARRAY_ENTRY(S32GEN1_SCMI_CLK_EDMA_AHB,
+			 S32GEN1_CLK_XBAR, "edma_ahb"),
+};
+
+static int compound2clkid(uint32_t scmi_clk_id, uint32_t *clk_id)
+{
+	switch (scmi_clk_id) {
+	case S32GEN1_SCMI_CLK_GMAC0_RX_SGMII:
+	case S32GEN1_SCMI_CLK_GMAC0_RX_RGMII:
+		if (clk_id)
+			*clk_id = S32GEN1_CLK_GMAC0_RX;
+		break;
+	case S32GEN1_SCMI_CLK_GMAC0_TX_SGMII:
+	case S32GEN1_SCMI_CLK_GMAC0_TX_RGMII:
+		if (clk_id)
+			*clk_id = S32GEN1_CLK_GMAC0_TX;
+		break;
+	case S32GEN1_SCMI_CLK_GMAC0_TS_SGMII:
+	case S32GEN1_SCMI_CLK_GMAC0_TS_RGMII:
+		if (clk_id)
+			*clk_id = S32GEN1_CLK_GMAC0_TS;
+		break;
+	case S32GEN1_SCMI_CLK_SERDES_PAD_REF:
+	case S32GEN1_SCMI_CLK_GMAC0_RX_RMII:
+	case S32GEN1_SCMI_CLK_GMAC0_TX_RMII:
+	case S32GEN1_SCMI_CLK_GMAC0_TS_RMII:
+	case S32GEN1_SCMI_CLK_GMAC0_RX_MII:
+	case S32GEN1_SCMI_CLK_GMAC0_TX_MII:
+	case S32GEN1_SCMI_CLK_GMAC0_TS_MII:
+		if (clk_id)
+			*clk_id = S32GEN1_SCMI_NOT_IMPLEMENTED_CLK;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+int cc_set_mux_parent(struct clk *clk, uint32_t mux_id, uint32_t mux_source)
+{
+	struct clk source = *clk;
+	struct clk mux = *clk;
+	int ret;
+
+	source.id = mux_source;
+	mux.id = mux_id;
+
+	ret = s32gen1_set_parent(&mux, &source);
+	if (ret) {
+		ERROR("Failed to set cgm0_mux11 source\n");
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static int set_gmac_rx_parent(struct clk *clk)
+{
+	uint32_t rx_id;
+	uint32_t clk_id = clk->id;
+
+	if (clk_id == S32GEN1_SCMI_CLK_GMAC0_RX_SGMII ||
+	    clk_id == S32GEN1_SCMI_CLK_GMAC0_RX_RGMII) {
+		rx_id = S32GEN1_CLK_GMAC0_EXT_RX;
+	} else {
+		ERROR("Invalid GMAC RX mode\n");
+		return -EINVAL;
+	}
+
+	return cc_set_mux_parent(clk, S32GEN1_CLK_MC_CGM0_MUX11, rx_id);
+}
+
+static int set_gmac_tx_parent(struct clk *clk)
+{
+	uint32_t tx_id;
+	uint32_t clk_id = clk->id;
+
+	if (clk_id == S32GEN1_SCMI_CLK_GMAC0_TX_RGMII) {
+		tx_id = S32GEN1_CLK_PERIPH_PLL_PHI5;
+	} else if (clk_id == S32GEN1_SCMI_CLK_GMAC0_TX_SGMII) {
+		tx_id = S32GEN1_CLK_SERDES0_LANE0_TX;
+	} else {
+		ERROR("Invalid GMAC TX mode\n");
+		return -EINVAL;
+	}
+
+	return cc_set_mux_parent(clk, S32GEN1_CLK_MC_CGM0_MUX10, tx_id);
+}
+
+static int set_gmac_ts_parent(struct clk *clk)
+{
+	uint32_t ts_id;
+	uint32_t clk_id = clk->id;
+
+	if (clk_id == S32GEN1_SCMI_CLK_GMAC0_TS_RGMII ||
+	    clk_id == S32GEN1_SCMI_CLK_GMAC0_TS_SGMII) {
+		ts_id = S32GEN1_CLK_PERIPH_PLL_PHI4;
+	} else {
+		ERROR("Invalid GMAC TS mode\n");
+		return -EINVAL;
+	}
+
+	return cc_set_mux_parent(clk, S32GEN1_CLK_MC_CGM0_MUX9, ts_id);
+}
+
+static int cc_compound_clk_set_parents(struct clk *clk)
+{
+	uint32_t clk_id = clk->id;
+	uint32_t id;
+
+	if (compound2clkid(clk_id, &id)) {
+		ERROR("Invalid compound clock : %u\n", clk_id);
+		return -EINVAL;
+	}
+
+	switch (id) {
+	case S32GEN1_CLK_GMAC0_RX:
+		return set_gmac_rx_parent(clk);
+	case S32GEN1_CLK_GMAC0_TX:
+		return set_gmac_tx_parent(clk);
+	case S32GEN1_CLK_GMAC0_TS:
+		return set_gmac_ts_parent(clk);
+	case S32GEN1_SCMI_NOT_IMPLEMENTED_CLK:
+		return 0;
+	default:
+		return plat_compound_clk_set_parents(clk);
+	}
+}
+
+int cc_scmi_id2clk(uint32_t scmi_clk_id, uint32_t *clk_id)
+{
+	if (!clk_id)
+		return -EINVAL;
+
+	if (scmi_clk_id >= S32GEN1_SCMI_PLAT_CLK_BASE_ID)
+		return plat_scmi_id2clk(scmi_clk_id, clk_id);
+
+	if (INDEX(scmi_clk_id) >= ARRAY_SIZE(cc_scmi_clk))
+		return -EINVAL;
+
+	*clk_id = cc_scmi_clk[INDEX(scmi_clk_id)].plat_id;
+	if (!*clk_id) {
+		ERROR("Unhandled S32GEN1 clock: %u\n", scmi_clk_id);
+		return -EINVAL;
+	}
+	return 0;
+}
+
+int cc_compound_clk_get(struct clk *clk)
+{
+	uint32_t scmi_clk_id = clk->id;
+
+	if (scmi_clk_id >= S32GEN1_SCMI_PLAT_CLK_BASE_ID)
+		return plat_compound_clk_get(clk);
+
+	if (INDEX(scmi_clk_id) >= ARRAY_SIZE(cc_scmi_clk))
+		return -EINVAL;
+
+	if (compound2clkid(scmi_clk_id, NULL)) {
+		ERROR("Invalid compound clock : %u\n", scmi_clk_id);
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+unsigned long cc_compound_clk_set_rate(struct clk *clk, unsigned long rate)
+{
+	struct clk sclock = *clk;
+	uint32_t scmi_clk_id = clk->id;
+	uint32_t id;
+	int ret;
+
+	if (scmi_clk_id >= S32GEN1_SCMI_PLAT_CLK_BASE_ID)
+		return plat_compound_clk_set_rate(clk, rate);
+
+	if (INDEX(scmi_clk_id) >= ARRAY_SIZE(cc_scmi_clk))
+		return -EINVAL;
+
+	ret = cc_compound_clk_set_parents(clk);
+	if (ret) {
+		ERROR("Failed to set parents for %u\n", scmi_clk_id);
+		return -EINVAL;
+	}
+
+	if (compound2clkid(scmi_clk_id, &id)) {
+		ERROR("Invalid compound clock : %u\n", scmi_clk_id);
+		return -EINVAL;
+	}
+
+	if (id == S32GEN1_SCMI_NOT_IMPLEMENTED_CLK) {
+		ERROR("Clock %s is not handled yet\n",
+		      cc_scmi_clk[INDEX(scmi_clk_id)].name);
+		return 0;
+	}
+
+	sclock.id = id;
+	return s32gen1_set_rate(&sclock, rate);
+}
+
+int cc_compound_clk_enable(struct clk *clk)
+{
+	struct clk sclock = *clk;
+	uint32_t clk_id = clk->id;
+	uint32_t id;
+	int ret;
+
+	if (clk_id >= S32GEN1_SCMI_PLAT_CLK_BASE_ID)
+		return plat_compound_clk_enable(clk);
+
+	if (compound2clkid(clk_id, &id)) {
+		ERROR("Invalid compound clock : %u\n", clk_id);
+		return -EINVAL;
+	}
+
+	if (id == S32GEN1_SCMI_NOT_IMPLEMENTED_CLK) {
+		ERROR("Clock %s is not handled yet\n",
+		      cc_scmi_clk[INDEX(clk_id)].name);
+		return -EINVAL;
+	}
+
+	ret = cc_compound_clk_set_parents(clk);
+	if (ret) {
+		ERROR("Failed to set parents for %u\n", clk_id);
+		return -EINVAL;
+	}
+
+	sclock.id = id;
+	ret = s32gen1_enable(&sclock, 1);
+	if (ret) {
+		ERROR("Failed to enable %u clock\n", clk_id);
+		return ret;
+	}
+
+	cc_scmi_clk[INDEX(clk_id)].enabled = true;
+	return 0;
+}
+
+unsigned long cc_compound_clk_get_rate(struct clk *clk)
+{
+	struct clk sclock = *clk;
+	uint32_t scmi_clk_id = clk->id;
+	uint32_t id;
+
+	if (scmi_clk_id >= S32GEN1_SCMI_PLAT_CLK_BASE_ID)
+		return plat_compound_clk_get_rate(clk);
+
+	if (INDEX(scmi_clk_id) >= ARRAY_SIZE(cc_scmi_clk))
+		return 0;
+
+	if (compound2clkid(scmi_clk_id, &id)) {
+		ERROR("Invalid compound clock : %u\n", scmi_clk_id);
+		return 0;
+	}
+
+	if (id == S32GEN1_SCMI_NOT_IMPLEMENTED_CLK) {
+		ERROR("Clock %s is not handled yet\n",
+		      cc_scmi_clk[INDEX(scmi_clk_id)].name);
+		return 0;
+	}
+
+	sclock.id = id;
+	return s32gen1_get_rate(&sclock);
+}
+
+uint32_t cc_get_nclocks(void)
+{
+	return plat_get_nclocks();
+}
+
+const char *cc_scmi_clk_get_name(uint32_t scmi_clk_id)
+{
+	if (scmi_clk_id < S32GEN1_SCMI_CLK_BASE_ID)
+		return NULL;
+
+	if (scmi_clk_id >= S32GEN1_SCMI_PLAT_CLK_BASE_ID)
+		return plat_scmi_clk_get_name(scmi_clk_id);
+
+	return cc_scmi_clk[INDEX(scmi_clk_id)].name;
+}
+
+bool cc_scmi_clk_is_enabled(uint32_t scmi_clk_id)
+{
+	if (scmi_clk_id < S32GEN1_SCMI_CLK_BASE_ID)
+		return false;
+
+	if (scmi_clk_id >= S32GEN1_SCMI_PLAT_CLK_BASE_ID)
+		return plat_scmi_clk_is_enabled(scmi_clk_id);
+
+	return cc_scmi_clk[INDEX(scmi_clk_id)].enabled;
+}
+
+int cc_scmi_clk_get_rates(struct clk *clk, unsigned long *rates,
+			  size_t *nrates)
+{
+	struct clk sclock = *clk;
+	uint32_t scmi_clk_id = clk->id;
+	uint32_t id;
+	int ret;
+
+	if (scmi_clk_id >= S32GEN1_SCMI_PLAT_CLK_BASE_ID)
+		return plat_scmi_clk_get_rates(clk, rates, nrates);
+
+	if (INDEX(scmi_clk_id) >= ARRAY_SIZE(cc_scmi_clk))
+		return -EINVAL;
+
+	ret = cc_compound_clk_set_parents(clk);
+	if (ret) {
+		ERROR("Failed to set parents for %u\n", scmi_clk_id);
+		return -EINVAL;
+	}
+
+	if (compound2clkid(scmi_clk_id, &id)) {
+		ERROR("Invalid compound clock : %u\n", scmi_clk_id);
+		return -EINVAL;
+	}
+
+	if (id == S32GEN1_SCMI_NOT_IMPLEMENTED_CLK) {
+		ERROR("Clock %s is not handled yet\n",
+		      cc_scmi_clk[INDEX(scmi_clk_id)].name);
+		return -EINVAL;
+	}
+
+	sclock.id = id;
+	rates[0] = s32gen1_get_rate(&sclock);
+
+	return 0;
+}
+
diff --git a/include/drivers/nxp/s32g/clk/s32gen1_scmi_clk.h b/include/drivers/nxp/s32g/clk/s32gen1_scmi_clk.h
new file mode 100644
index 000000000..44b7b357f
--- /dev/null
+++ b/include/drivers/nxp/s32g/clk/s32gen1_scmi_clk.h
@@ -0,0 +1,61 @@
+/* SPDX-License-Identifier: BSD-3-Clause */
+/*
+ * Copyright 2020 NXP
+ */
+#ifndef S32GEN1_SCMI_CLK_H
+#define S32GEN1_SCMI_CLK_H
+
+#include <clk/clk.h>
+#include <stdint.h>
+#include <stdbool.h>
+
+#define SCMI_ARRAY_ENTRY(ID, PLAT_ID, NAME) \
+	[INDEX(ID)] = { .plat_id = (PLAT_ID), .name = (NAME), }
+
+struct s32gen1_scmi_clk {
+	uint32_t plat_id;
+	const char *name;
+	bool enabled;
+};
+
+int cc_scmi_id2clk(uint32_t scmi_clk_id, uint32_t *clk_id);
+int cc_compound_clk_get(struct clk *clk);
+unsigned long cc_compound_clk_get_rate(struct clk *clk);
+unsigned long cc_compound_clk_set_rate(struct clk *clk, unsigned long rate);
+int cc_compound_clk_enable(struct clk *clk);
+int cc_set_mux_parent(struct clk *clk, uint32_t mux_id, uint32_t mux_source);
+uint32_t cc_get_nclocks(void);
+const char *cc_scmi_clk_get_name(uint32_t scmi_clk_id);
+bool cc_scmi_clk_is_enabled(uint32_t scmi_clk_id);
+int cc_scmi_clk_get_rates(struct clk *clk, unsigned long *rates,
+			  size_t *nrates);
+unsigned long cc_scmi_clk_set_rate(struct clk *clk, unsigned long rate);
+
+int plat_scmi_id2clk(uint32_t scmi_clk_id, uint32_t *clk_id);
+int plat_compound_clk_get(struct clk *clk);
+unsigned long plat_compound_clk_get_rate(struct clk *clk);
+unsigned long plat_compound_clk_set_rate(struct clk *clk, unsigned long rate);
+int plat_compound_clk_enable(struct clk *clk);
+int plat_compound_clk_set_parents(struct clk *clk);
+uint32_t plat_get_nclocks(void);
+const char *plat_scmi_clk_get_name(uint32_t scmi_clk_id);
+bool plat_scmi_clk_is_enabled(uint32_t scmi_clk_id);
+int plat_scmi_clk_get_rates(struct clk *clk, unsigned long *rates,
+			    size_t *nrates);
+unsigned long plat_scmi_clk_set_rate(struct clk *clk, unsigned long rate);
+
+int s32gen1_scmi_request(uint32_t id, struct clk *clk);
+unsigned long s32gen1_scmi_get_rate(struct clk *clk);
+unsigned long s32gen1_scmi_set_rate(struct clk *clk, unsigned long rate);
+int s32gen1_scmi_set_parent(struct clk *clk, struct clk *parent);
+int s32gen1_scmi_enable(struct clk *clk, int enable);
+uint32_t s32gen1_scmi_nclocks(void);
+const char *s32gen1_scmi_clk_get_name(uint32_t scmi_clk_id);
+bool s32gen1_scmi_clk_is_enabled(uint32_t scmi_clk_id);
+int s32gen1_scmi_clk_get_rates(struct clk *clk, unsigned long *rates,
+			       size_t *nrates);
+unsigned long s32gen1_scmi_clk_get_rate(struct clk *clk);
+unsigned long s32gen1_scmi_clk_set_rate(struct clk *clk, unsigned long rate);
+
+#endif
+
diff --git a/plat/nxp/s32g/include/platform_def.h b/plat/nxp/s32g/include/platform_def.h
index ed3587996..641735915 100644
--- a/plat/nxp/s32g/include/platform_def.h
+++ b/plat/nxp/s32g/include/platform_def.h
@@ -193,11 +193,19 @@
 #if defined IMAGE_BL31
 #define FIRMWARE_WELCOME_STR_S32G_BL31	"This is S32G BL31\n"
 /* To limit usage, keep these in sync with sizeof(s32g_mmap) */
-#define MAX_MMAP_REGIONS		14
+#define MAX_MMAP_REGIONS		15
 #define MAX_XLAT_TABLES			(MAX_MMAP_REGIONS + BL31SRAM_MAX_PAGES)
 #endif
 #if defined IMAGE_BL33
 #pragma warning "BL33 image is being built; you should configure it out."
 #endif
 
+#define S32G_LINFLEX0_BASE	(0x401C8000ul)
+#define S32G_LINFLEX0_SIZE	(0x4000)
+#define S32G_UART_BASE		S32G_LINFLEX0_BASE
+#define S32G_UART_SIZE		S32G_LINFLEX0_SIZE
+
+#define S32G_SCMI_SHARED_MEM		0xd0000000U
+#define S32G_SCMI_SHARED_MEM_SIZE	0x400000U
+
 #endif /* PLATFORM_DEF_H */
diff --git a/plat/nxp/s32g/include/s32g_bl_common.h b/plat/nxp/s32g/include/s32g_bl_common.h
index f5b247dce..4ddff8c3e 100644
--- a/plat/nxp/s32g/include/s32g_bl_common.h
+++ b/plat/nxp/s32g/include/s32g_bl_common.h
@@ -10,6 +10,19 @@
 #include <stdint.h>
 #include "i2c/s32g_i2c.h"
 
+/**
+ * container_of - cast a member of a structure out to the containing structure
+ * @ptr:	the pointer to the member.
+ * @type:	the type of the container struct this is embedded in.
+ * @member:	the name of the member within the struct.
+ *
+ */
+#define container_of(ptr, type, member) ({			\
+	const typeof(((type *)0)->member ) *__mptr = (ptr);	\
+	(type *)((char *)__mptr - offsetof(type, member)); })
+
+#define UPTR(PTR)			((uintptr_t)(PTR))
+
 struct s32g_i2c_driver {
 	struct s32g_i2c_bus bus;
 	int fdt_node;
diff --git a/plat/nxp/s32g/include/s32g_clocks.h b/plat/nxp/s32g/include/s32g_clocks.h
index a039047a6..df4ff2067 100644
--- a/plat/nxp/s32g/include/s32g_clocks.h
+++ b/plat/nxp/s32g/include/s32g_clocks.h
@@ -131,7 +131,7 @@ enum s32g_dfs_type {
 
 #define S32G_DFS_BASE_ADDR	0x40054000ul
 /* @dfs - One of the enum s32g_dfs_type values */
-#define S32G_DFS_ADDR(dfs) (S32G_DFS_BASE_ADDR + (dfs) * 0x4000)
+#define S32G_DFS_ADDR(dfs)	(S32G_DFS_BASE_ADDR + (dfs) * 0x4000)
 /* DFS register offsets */
 #define DFS_PORTRESET_OFF	0X14ul
 #define DFS_PORTRESET(dfs)	((S32G_DFS_ADDR(dfs)) + DFS_PORTRESET_OFF)
@@ -240,6 +240,11 @@ enum s32g_refclk {
 	S32G_REFCLK_FXOSC,
 };
 
+
+#define MC_RGM_BASE_ADDR	0x40078000
+#define MC_ME_BASE_ADDR		0x40088000
+#define RDC_BASE_ADDR		0x40080000
+
 #define S32G_FXOSC_BASE_ADDR	0x40050000ul
 /* FXOSC registers */
 #define FXOSC_CTRL		(S32G_FXOSC_BASE_ADDR)
@@ -324,7 +329,7 @@ enum s32g_mc_cgm {
 #define MC_CGM_MUXn_CSC_SEL_PERIPH_PLL_PHI7	25
 #define MC_CGM_MUXn_CSC_SEL_PERIPH_DFS_DFS3	28
 
-void s32g_plat_clock_init(bool skip_ddr_clk);
+int s32g_plat_clock_init(bool skip_ddr_clk);
 void s32g_plat_ddr_clock_init(void);
 
 #define S32G274A_A53_CORE_CLK_MIN		(48000000ul)
diff --git a/plat/nxp/s32g/include/s32g_dt.h b/plat/nxp/s32g/include/s32g_dt.h
index 1de93b458..a4e953493 100644
--- a/plat/nxp/s32g/include/s32g_dt.h
+++ b/plat/nxp/s32g/include/s32g_dt.h
@@ -23,5 +23,6 @@ int dt_open_and_check(void);
 int fdt_get_address(void **fdt_addr);
 uint8_t fdt_get_status(int node);
 void dt_fill_device_info(struct dt_node_info *info, int node);
+int dt_enable_clocks(void *fdt, int node);
 
 #endif
diff --git a/plat/nxp/s32g/platform.mk b/plat/nxp/s32g/platform.mk
index ff0b08d55..8e846a110 100644
--- a/plat/nxp/s32g/platform.mk
+++ b/plat/nxp/s32g/platform.mk
@@ -23,7 +23,8 @@ PLAT_INCLUDES		+= -Iplat/nxp/s32g/include \
 			   -Iinclude/lib/libc \
 			   -Iinclude/drivers \
 			   -Iinclude/lib/psci \
-			   -Iinclude/drivers/nxp/s32g
+			   -Iinclude/drivers/nxp/s32g \
+			   -Idrivers/st \
 
 BL2_AT_EL3		:= 1
 
@@ -41,6 +42,13 @@ PLAT_BL_COMMON_SOURCES	+= plat/nxp/s32g/s32g_lowlevel_common.S \
 			   drivers/delay_timer/delay_timer.c \
 			   drivers/delay_timer/generic_delay_timer.c \
 			   drivers/nxp/s32g/memory_pool.c \
+			   drivers/nxp/s32g/clk/early_clocks.c \
+			   drivers/nxp/s32g/clk/enable_clk.c \
+			   drivers/nxp/s32g/clk/get_rate.c \
+			   drivers/nxp/s32g/clk/plat_clk.c \
+			   drivers/nxp/s32g/clk/s32g274a_clk.c \
+			   drivers/nxp/s32g/clk/s32gen1_clk.c \
+			   drivers/nxp/s32g/clk/set_par_rate.c \
 			   lib/cpus/aarch64/cortex_a53.S\
 			   common/fdt_wrappers.c \
 			   ${GICV3_SOURCES} \
@@ -68,11 +76,22 @@ BL31_SOURCES		+= plat/nxp/s32g/s32g_bl31.c \
 			   plat/nxp/s32g/s32g_resume.c \
 			   plat/nxp/s32g/s32g_pm.c \
 			   plat/nxp/s32g/s32g_vr5510.c \
+			   plat/nxp/s32g/s32g_svc.c \
+			   plat/nxp/s32g/s32g_scmi_clk.c \
 			   plat/common/plat_psci_common.c \
 			   plat/common/plat_gicv3.c \
 			   lib/utils/crc8.c \
 			   drivers/nxp/s32g/pmic/vr5510.c \
 			   drivers/nxp/s32g/s32g_wkpu.c \
+			   drivers/nxp/s32g/clk/clk.c \
+			   drivers/nxp/s32g/clk/fixed_clk.c \
+			   drivers/nxp/s32g/clk/s32g274a_scmi_ids.c \
+			   drivers/nxp/s32g/clk/s32gen1_scmi_clk.c \
+			   drivers/nxp/s32g/clk/s32gen1_scmi_ids.c \
+			   drivers/st/scmi-msg/base.c \
+			   drivers/st/scmi-msg/clock.c \
+			   drivers/st/scmi-msg/entry.c \
+			   drivers/st/scmi-msg/reset_domain.c \
 
 BL31_SOURCES		+= plat/nxp/s32g/bl31_lowlevel.S \
 			   plat/nxp/s32g/include/plat_macros.S
diff --git a/plat/nxp/s32g/s32g_bl31.c b/plat/nxp/s32g/s32g_bl31.c
index 9883b1016..be4d3838f 100644
--- a/plat/nxp/s32g/s32g_bl31.c
+++ b/plat/nxp/s32g/s32g_bl31.c
@@ -30,6 +30,7 @@
 #include "s32gen1-wkpu.h"
 #include "s32g_bl_common.h"
 #include "s32g_sramc.h"
+#include "clk/clk.h"
 
 #define MMU_ROUND_UP_TO_4K(x)	\
 			(((x) & ~0xfff) == (x) ? (x) : ((x) & ~0xfff) + 0x1000)
@@ -73,6 +74,8 @@ static const mmap_region_t s32g_mmap[] = {
 			MT_MEMORY | MT_RW, PAGE_SIZE),
 	MAP_REGION_FLAT(S32G_PMEM_START, S32G_PMEM_LEN,
 			MT_MEMORY | MT_RW | MT_SECURE),
+	MAP_REGION_FLAT(S32G_SCMI_SHARED_MEM, S32G_SCMI_SHARED_MEM_SIZE,
+			MT_NON_CACHEABLE | MT_RW | MT_SECURE),
 	{0},
 };
 
@@ -330,6 +333,59 @@ static unsigned int plat_s32g274a_mpidr_to_core_pos(unsigned long mpidr)
 	return (unsigned int)plat_core_pos_by_mpidr(mpidr);
 }
 
+static int check_clock_node(const void *fdt, int nodeoffset)
+{
+	const void *prop;
+	int len;
+
+	prop = fdt_getprop(fdt, nodeoffset, "assigned-clocks", &len);
+	if (!prop)
+		return len;
+
+	return 0;
+
+}
+
+static int next_node_with_clocks(const void *fdt, int startoffset)
+{
+	int offset, err;
+
+	for (offset = fdt_next_node(fdt, startoffset, NULL);
+	     offset >= 0;
+	     offset = fdt_next_node(fdt, offset, NULL)) {
+		err = check_clock_node(fdt, offset);
+		if ((err < 0) && (err != -FDT_ERR_NOTFOUND))
+			return err;
+		else if (err == 0)
+			return offset;
+	}
+
+	return offset; /* error from fdt_next_node() */
+}
+
+void clk_tree_init(void)
+{
+	void *fdt;
+	int clk_node;
+
+	if (dt_open_and_check() < 0) {
+		INFO("ERROR fdt check\n");
+		return;
+	}
+
+	if (fdt_get_address(&fdt) == 0) {
+		INFO("ERROR fdt\n");
+		return;
+	}
+
+	clk_node = -1;
+	while (true) {
+		clk_node = next_node_with_clocks(fdt, clk_node);
+		if (clk_node == -1)
+			break;
+	}
+}
+
 void bl31_platform_setup(void)
 {
 	int ret;
@@ -337,6 +393,8 @@ void bl31_platform_setup(void)
 	update_core_state(plat_my_core_pos(), 1);
 	s32g_gic_setup();
 
+	dt_clk_init();
+
 	generic_delay_timer_init();
 
 	dt_init_pmic();
diff --git a/plat/nxp/s32g/s32g_clocks.c b/plat/nxp/s32g/s32g_clocks.c
index 1dc8f552e..ecb2dd719 100644
--- a/plat/nxp/s32g/s32g_clocks.c
+++ b/plat/nxp/s32g/s32g_clocks.c
@@ -369,32 +369,6 @@ void s32g_ddr2firc(void)
 			     ARRAY_SIZE(cgm5_muxes));
 }
 
-/* Program a software-controlled clock divider as per chapter
- * "Clock Generation Module (MC_CGM)::
- *    Functional description::
- *      Clock dividers"
- */
-static int sw_mux_div_clk_config(uint8_t cgm, uint8_t mux,
-				 uint8_t dc, uint8_t divider)
-{
-	uintptr_t cgm_addr;
-
-	cgm_addr = mc_cgm_addr(cgm);
-	if (cgm_addr == S32G_ERR_PTR)
-		return -EINVAL;
-
-	/* set the divider */
-	mmio_write_32(CGM_MUXn_DCn(cgm_addr, mux, dc),
-			MUXn_DCn_DE | MC_CGM_MUXn_DCn_DIV(divider));
-
-	/* Wait for divider gets updated */
-	while (MC_CGM_MUXn_DIV_UPD_STAT_DIVSTAT
-			(mmio_read_32(CGM_MUXn_DIV_UPD_STAT(cgm_addr, mux))))
-		;
-
-	return 0;
-}
-
 static bool is_a53_core_clk_supported(uint64_t clk)
 {
 	int i;
@@ -445,70 +419,6 @@ int s32g_set_a53_core_clk(uint64_t clk)
 	return 0;
 }
 
-void s32g_plat_clock_init(bool skip_ddr_clk)
-{
-	assert(ARRAY_SIZE(s32g_core_pll_phi_freq) ==
-	       s32g_pll_phi_nr[S32G_CORE_PLL]);
-	assert(ARRAY_SIZE(s32g_periph_pll_phi_freq) ==
-	       s32g_pll_phi_nr[S32G_PERIPH_PLL]);
-	assert(ARRAY_SIZE(s32g_accel_pll_phi_freq) ==
-	       s32g_pll_phi_nr[S32G_ACCEL_PLL]);
-	assert(ARRAY_SIZE(s32g_ddr_pll_phi_freq) ==
-	       s32g_pll_phi_nr[S32G_DDR_PLL]);
-
-	/* Prepare FXOSC to run on */
-	start_fxosc();
-	/* Enable various partitions */
-	mc_me_enable_partition(S32G_MC_ME_PRTN0);
-	mc_me_enable_partition(S32G_MC_ME_PRTN1);
-	mc_me_enable_partition(S32G_MC_ME_PRTN2);
-	/* Enable partition clock for SDHC */
-	mc_me_enable_partition_block(S32G_MC_ME_USDHC_PART,
-				     S32G_MC_ME_USDHC_REQ);
-	/* Enable partition clock for DDR */
-	if (!skip_ddr_clk)
-		mc_me_enable_partition_block(S32G_MC_ME_DDR_0_PART,
-					     S32G_MC_ME_DDR_0_REQ);
-
-	/* Configure the CORE_PLL */
-	program_pll(S32G_CORE_PLL, S32G_REFCLK_FXOSC, s32g_core_pll_phi_freq,
-		    s32g_pll_rdiv[S32G_CORE_PLL], s32g_pll_mfi[S32G_CORE_PLL],
-		    s32g_pll_mfn[S32G_CORE_PLL]);
-	/* Configure the CORE_DFS) */
-	program_dfs(S32G_CORE_DFS, s32g_core_dfs_params);
-	/* Configure the core CGM mux */
-	sw_mux_clk_config(MC_CGM1, 0, MC_CGM_MUXn_CSC_SEL_CORE_PLL_PHI0);
-	/* Configure the XBAR CGM mux and div */
-	sw_mux_clk_config(MC_CGM0, 0, MC_CGM_MUXn_CSC_SEL_CORE_PLL_DFS1);
-	sw_mux_div_clk_config(MC_CGM0, 0, 0, 1);
-
-	/* Configure the PERIPH_PLL */
-	program_pll(S32G_PERIPH_PLL, S32G_REFCLK_FXOSC,
-		    s32g_periph_pll_phi_freq, s32g_pll_rdiv[S32G_PERIPH_PLL],
-		    s32g_pll_mfi[S32G_PERIPH_PLL],
-		    s32g_pll_mfn[S32G_PERIPH_PLL]);
-	/* Configure the PERIPH_DFS */
-	program_dfs(S32G_PERIPH_DFS, s32g_periph_dfs_params);
-	/* Configure the LinFlexD CGM mux */
-	sw_mux_clk_config(MC_CGM0, 8, MC_CGM_MUXn_CSC_SEL_PERIPH_PLL_PHI3);
-	/* Configure the SDHC CGM mux */
-	sw_mux_clk_config(MC_CGM0, 14, MC_CGM_MUXn_CSC_SEL_PERIPH_DFS_DFS3);
-
-	/* Configure the ACCEL_PLL */
-	program_pll(S32G_ACCEL_PLL, S32G_REFCLK_FXOSC, s32g_accel_pll_phi_freq,
-		    s32g_pll_rdiv[S32G_ACCEL_PLL], s32g_pll_mfi[S32G_ACCEL_PLL],
-		    s32g_pll_mfn[S32G_ACCEL_PLL]);
-
-	/* Configure the DDR_PLL */
-	if (!skip_ddr_clk) {
-		program_pll(S32G_DDR_PLL, S32G_REFCLK_FXOSC,
-			    s32g_ddr_pll_phi_freq, s32g_pll_rdiv[S32G_DDR_PLL],
-			    s32g_pll_mfi[S32G_DDR_PLL],
-			    s32g_pll_mfn[S32G_DDR_PLL]);
-		sw_mux_clk_config(MC_CGM5, 0, MC_CGM_MUXn_CSC_SEL_DDR_PLL_PHI0);
-	}
-}
-
 void s32g_plat_ddr_clock_init(void)
 {
 	assert(ARRAY_SIZE(s32g_ddr_pll_phi_freq) ==
@@ -523,4 +433,3 @@ void s32g_plat_ddr_clock_init(void)
 		    s32g_pll_mfn[S32G_DDR_PLL]);
 	sw_mux_clk_config(MC_CGM5, 0, MC_CGM_MUXn_CSC_SEL_DDR_PLL_PHI0);
 }
-
diff --git a/plat/nxp/s32g/s32g_dt.c b/plat/nxp/s32g/s32g_dt.c
index b4c4ab2cb..524af1b23 100644
--- a/plat/nxp/s32g/s32g_dt.c
+++ b/plat/nxp/s32g/s32g_dt.c
@@ -5,6 +5,10 @@
  * SPDX-License-Identifier: BSD-3-Clause
  */
 
+#include <clk/clk.h>
+#include <common/debug.h>
+#include <common/fdt_wrappers.h>
+#include <errno.h>
 #include <libfdt.h>
 #include <platform_def.h>
 #include <s32g_dt.h>
@@ -46,22 +50,53 @@ uint8_t fdt_get_status(int node)
 	return status;
 }
 
-void dt_fill_device_info(struct dt_node_info *info, int node)
+int dt_enable_clocks(void *fdt_addr, int node)
 {
 	const fdt32_t *cuint;
+	int len, i, index, ret;
+	uint32_t clk_id, clk_drv_id;
+	struct clk clk;
+
+	cuint = fdt_getprop(fdt_addr, node, "clocks", &len);
+	if (!cuint)
+		return 0;
+
+	if (len % FDT_CLOCK_CELL_SIZE) {
+		ERROR("Invalid clock definition for node: '%s'\n",
+		      fdt_get_name(fdt_addr, node, NULL));
+		return -EIO;
+	}
 
-	cuint = fdt_getprop(fdt, node, "reg", NULL);
-	if (cuint != NULL)
-		info->base = fdt32_to_cpu(*cuint);
-	else
-		info->base = 0;
+	for (i = 0; i < len / FDT_CLOCK_CELL_SIZE; i++) {
+		index = i * 2;
+		clk_drv_id = fdt32_to_cpu(cuint[index]);
+		clk_id = fdt32_to_cpu(cuint[index + 1]);
+
+		ret = get_clk(clk_drv_id, clk_id, &clk);
+		if (ret) {
+			ERROR("Failed to get the clock (drv:%d clk%d) of the node '%s'\n",
+			      clk_drv_id, clk_id,
+			      fdt_get_name(fdt_addr, node, NULL));
+			return ret;
+		}
+
+		ret = clk_enable(&clk);
+		if (ret) {
+			ERROR("Failed to enable the clock (drv:%d clk:%d) of the node '%s'\n",
+			      clk_drv_id, clk_id,
+			      fdt_get_name(fdt_addr, node, NULL));
+			return ret;
+		}
+	}
 
-	cuint = fdt_getprop(fdt, node, "clocks", NULL);
-	if (cuint != NULL) {
-		cuint++;
-		info->clock = (int)fdt32_to_cpu(*cuint);
-	} else
-		info->clock = -1;
+	return 0;
+}
+
+void dt_fill_device_info(struct dt_node_info *info, int node)
+{
+	const fdt32_t *cuint;
+
+	(void) fdt_get_reg_props_by_index(fdt, node, 0, &info->base, NULL);
 
 	cuint = fdt_getprop(fdt, node, "resets", NULL);
 	if (cuint != NULL) {
diff --git a/plat/nxp/s32g/s32g_scmi_clk.c b/plat/nxp/s32g/s32g_scmi_clk.c
new file mode 100644
index 000000000..b83e5beb0
--- /dev/null
+++ b/plat/nxp/s32g/s32g_scmi_clk.c
@@ -0,0 +1,104 @@
+/*
+ * Copyright 2020 NXP
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ */
+#include <cdefs.h>
+#include <clk/s32gen1_scmi_clk.h>
+#include <drivers/st/scmi-msg.h>
+#include <drivers/st/scmi.h>
+#include <errno.h>
+
+#define S32GEN1_CLK_DRV_NAME	"clks"
+
+size_t plat_scmi_clock_count(unsigned int agent_id __unused)
+{
+	return s32gen1_scmi_nclocks();
+}
+
+const char *plat_scmi_clock_get_name(unsigned int agent_id,
+				     unsigned int scmi_id)
+{
+	return s32gen1_scmi_clk_get_name(scmi_id);
+}
+
+int32_t plat_scmi_clock_rates_array(unsigned int agent_id, unsigned int scmi_id,
+				    unsigned long *rates, size_t *nb_elts)
+{
+	struct clk_driver *drv;
+	struct clk clk;
+	int ret;
+
+	*nb_elts = 1;
+
+	/* One single rate. Frequency scaling to be added */
+	if (rates == NULL)
+		return SCMI_SUCCESS;
+
+	drv = get_clk_driver_by_name(S32GEN1_CLK_DRV_NAME);
+	clk.drv = drv;
+	clk.id = scmi_id;
+
+	ret = s32gen1_scmi_clk_get_rates(&clk, rates, nb_elts);
+	if (ret == -EINVAL)
+		return SCMI_INVALID_PARAMETERS;
+
+	return 0;
+}
+
+int32_t plat_scmi_clock_rates_by_step(unsigned int agent_id,
+				      unsigned int scmi_id,
+				      unsigned long *min_max_step)
+{
+	return -EINVAL;
+}
+
+unsigned long plat_scmi_clock_get_rate(unsigned int agent_id,
+				       unsigned int scmi_id)
+{
+	struct clk_driver *drv;
+	struct clk clk;
+
+	drv = get_clk_driver_by_name(S32GEN1_CLK_DRV_NAME);
+	clk.drv = drv;
+	clk.id = scmi_id;
+
+	return s32gen1_scmi_clk_get_rate(&clk);
+}
+
+int32_t plat_scmi_clock_set_rate(unsigned int agent_id, unsigned int scmi_id,
+				 unsigned long rate)
+{
+	struct clk_driver *drv;
+	struct clk clk;
+
+	drv = get_clk_driver_by_name(S32GEN1_CLK_DRV_NAME);
+	clk.drv = drv;
+	clk.id = scmi_id;
+
+	if (s32gen1_scmi_clk_set_rate(&clk, rate) != rate)
+		return -EINVAL;
+
+	return s32gen1_scmi_enable(&clk, true);
+}
+
+int32_t plat_scmi_clock_get_state(unsigned int agent_id, unsigned int scmi_id)
+{
+	if (s32gen1_scmi_clk_is_enabled(scmi_id))
+		return 1;
+
+	return 0;
+}
+
+int32_t plat_scmi_clock_set_state(unsigned int agent_id, unsigned int scmi_id,
+				  bool enable_not_disable)
+{
+	struct clk_driver *drv;
+	struct clk clk;
+
+	drv = get_clk_driver_by_name(S32GEN1_CLK_DRV_NAME);
+	clk.drv = drv;
+	clk.id = scmi_id;
+
+	return s32gen1_scmi_enable(&clk, enable_not_disable);
+}
diff --git a/plat/nxp/s32g/s32g_svc.c b/plat/nxp/s32g/s32g_svc.c
new file mode 100644
index 000000000..fcaa2bdd7
--- /dev/null
+++ b/plat/nxp/s32g/s32g_svc.c
@@ -0,0 +1,122 @@
+/*
+ * Copyright 2020 NXP
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ */
+#include <common/debug.h>
+#include <common/runtime_svc.h>
+#include <drivers/st/scmi.h>
+#include <scmi-msg/common.h>
+
+#define S32G_SCMI_ID			0xc20000feU
+
+#define MSG_ID(m)			((m) & 0xffU)
+#define MSG_TYPE(m)			(((m) >> 8) & 0x3U)
+#define MSG_PRO_ID(m)			(((m) >> 10) & 0xffU)
+#define MSG_TOKEN(m)			(((m) >> 18) & 0x3ffU)
+
+struct scmi_shared_mem {
+	uint32_t reserved;
+	uint32_t channel_status;
+#define SCMI_SHMEM_CHAN_STAT_CHANNEL_ERROR      BIT(1)
+#define SCMI_SHMEM_CHAN_STAT_CHANNEL_FREE       BIT(0)
+	uint32_t reserved1[2];
+	uint32_t flags;
+#define SCMI_SHMEM_FLAG_INTR_ENABLED    BIT(0)
+	uint32_t length;
+	uint32_t msg_header;
+	uint8_t msg_payload[0];
+};
+
+/* Corresponding to msg_payload */
+struct response {
+	uint32_t status;
+	uint32_t data[0];
+};
+
+static const uint8_t s32g_protocols[] = {
+	SCMI_PROTOCOL_ID_BASE,
+	SCMI_PROTOCOL_ID_CLOCK,
+};
+
+const char *plat_scmi_vendor_name(void)
+{
+	return "NXP";
+}
+
+const char *plat_scmi_sub_vendor_name(void)
+{
+	return "S32G274A";
+}
+
+const uint8_t *plat_scmi_protocol_list(unsigned int agent_id)
+{
+	return s32g_protocols;
+}
+
+size_t plat_scmi_protocol_count(void)
+{
+	return sizeof(s32g_protocols);
+}
+
+static int32_t s32g_svc_smc_setup(void)
+{
+	struct scmi_shared_mem *mem = (void *)S32G_SCMI_SHARED_MEM;
+
+	mem->channel_status = SCMI_SHMEM_CHAN_STAT_CHANNEL_FREE;
+	return 0;
+}
+
+static int scmi_handler(uint32_t smc_fid, u_register_t x1,
+			u_register_t x2, u_register_t x3)
+{
+	struct scmi_shared_mem *mem = (void *)S32G_SCMI_SHARED_MEM;
+	struct response *response = (struct response *)&mem->msg_payload[0];
+	uint32_t msg_header = mem->msg_header;
+	struct scmi_msg msg = {
+		.in = (char *)&mem->msg_payload[0],
+		.in_size = mem->length - 4,
+		.agent_id = 0,
+		.protocol_id = MSG_PRO_ID(msg_header),
+		.message_id = MSG_ID(msg_header),
+		.out = (char *)response,
+		.out_size = S32G_SCMI_SHARED_MEM_SIZE - sizeof(*mem),
+	};
+
+	scmi_process_message(&msg);
+
+	mem->length = msg.out_size_out + 4;
+	mem->channel_status = 1;
+
+	return 0;
+}
+
+uintptr_t s32g_svc_smc_handler(uint32_t smc_fid,
+			       u_register_t x1,
+			       u_register_t x2,
+			       u_register_t x3,
+			       u_register_t x4,
+			       void *cookie,
+			       void *handle,
+			       u_register_t flags)
+{
+	switch (smc_fid) {
+	case S32G_SCMI_ID:
+		SMC_RET1(handle, scmi_handler(smc_fid, x1, x2, x3));
+		break;
+	default:
+		WARN("Unimplemented SIP Service Call: 0x%x\n", smc_fid);
+		SMC_RET1(handle, SMC_UNK);
+		break;
+	}
+}
+
+DECLARE_RT_SVC(s32g_svc,
+	       OEN_SIP_START,
+	       OEN_SIP_END,
+	       SMC_TYPE_FAST,
+	       s32g_svc_smc_setup,
+	       s32g_svc_smc_handler
+);
+
+
-- 
2.17.1

