From 4d2002afbd4fb6fb32edd3fae99bba42f167f89c Mon Sep 17 00:00:00 2001
From: Ghennadi Procopciuc <Ghennadi.Procopciuc@nxp.com>
Date: Tue, 29 Sep 2020 10:36:21 +0300
Subject: [PATCH 184/269] s32g: Isolate DDR clock settings

BL31SSRAM stage cannot use clock driver to set DDR clock due to SSRAM size,
consequently it will have a raw management over DDR clock.

Issue: ALB-4294, ALB-5510
Upstream-Status: Pending 

Signed-off-by: Ghennadi Procopciuc <Ghennadi.Procopciuc@nxp.com>
Signed-off-by: Zhantao Tang <zhantao.tang@windriver.com>
---
 plat/nxp/s32g/bl31_ssram/bl31_ssram.mk |   1 +
 plat/nxp/s32g/bl31_ssram/ddr_clk.c     | 175 +++++++++++++++++
 plat/nxp/s32g/include/s32g_clocks.h    |  10 +-
 plat/nxp/s32g/s32g_clocks.c            | 262 +------------------------
 4 files changed, 183 insertions(+), 265 deletions(-)
 create mode 100644 plat/nxp/s32g/bl31_ssram/ddr_clk.c

diff --git a/plat/nxp/s32g/bl31_ssram/bl31_ssram.mk b/plat/nxp/s32g/bl31_ssram/bl31_ssram.mk
index a5dde47da..5c314c510 100644
--- a/plat/nxp/s32g/bl31_ssram/bl31_ssram.mk
+++ b/plat/nxp/s32g/bl31_ssram/bl31_ssram.mk
@@ -8,6 +8,7 @@ BL31SSRAM_SOURCES =  plat/nxp/s32g/bl31_ssram/bl31ssram_stacks.S \
 		     plat/nxp/s32g/bl31_ssram/bl31ssram_entrypoint.S \
 		     plat/nxp/s32g/bl31_ssram/bl31ssram_main.c \
 		     plat/nxp/s32g/s32g_linflexuart.S \
+		     plat/nxp/s32g/bl31_ssram/ddr_clk.c \
 		     plat/nxp/s32g/s32g_clocks.c \
 		     plat/nxp/s32g/s32g_mc_me.c \
 		     ${DDR_DRV}/ddrss.c \
diff --git a/plat/nxp/s32g/bl31_ssram/ddr_clk.c b/plat/nxp/s32g/bl31_ssram/ddr_clk.c
new file mode 100644
index 000000000..7f69fd5df
--- /dev/null
+++ b/plat/nxp/s32g/bl31_ssram/ddr_clk.c
@@ -0,0 +1,175 @@
+/*
+ * Copyright 2020 NXP
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ */
+#include <lib/mmio.h>
+#include <libc/assert.h>
+#include <s32g_clocks.h>
+#include <s32g_mc_me.h>
+
+static void start_fxosc(void)
+{
+	uint32_t ctrl;
+
+	/* If FXOSC is already running, do nothing */
+	if (mmio_read_32(FXOSC_CTRL) & FXOSC_CTRL_OSCON)
+		return;
+
+	ctrl = FXOSC_CTRL_COMP_EN;
+	ctrl &= ~FXOSC_CTRL_OSC_BYP;
+	ctrl |= FXOSC_CTRL_EOCV(0x1);
+	ctrl |= FXOSC_CTRL_GM_SEL(0x7);
+	mmio_write_32(FXOSC_CTRL, ctrl);
+
+	/* Switch on the crystal oscillator */
+	mmio_write_32(FXOSC_CTRL, FXOSC_CTRL_OSCON | mmio_read_32(FXOSC_CTRL));
+
+	/* Wait until the clock is stable */
+	while (!(mmio_read_32(FXOSC_STAT) & FXOSC_STAT_OSC_STAT))
+		;
+}
+
+static uint64_t plldig_set_refclk(enum s32g_pll_type pll,
+				  enum s32g_refclk refclk)
+{
+	uint64_t refclk_freq = S32G_ERR_CLK_FREQ;
+	uint32_t pllclkmux;
+
+	switch (refclk) {
+	case S32G_REFCLK_FIRC:
+		pllclkmux = PLLDIG_PLLCLKMUX_REFCLK_FIRC;
+		refclk_freq = S32G_FIRC_FREQ;
+		break;
+	case S32G_REFCLK_FXOSC:
+		pllclkmux = PLLDIG_PLLCLKMUX_REFCLK_FXOSC;
+		refclk_freq = S32G_FXOSC_FREQ;
+		break;
+	default:
+		assert(0);
+		break;
+	}
+	mmio_write_32(PLLDIG_PLLCLKMUX(pll), pllclkmux);
+
+	return refclk_freq;
+}
+
+
+/*
+ * Program the pll for various blocks
+ *
+ * @pll: Type of PLL to program
+ * @refclk: Input reference clock to the PLL block
+ * @freq: Array of PHI frequencies for each type of PLL
+ * @plldv_rdiv: Divider of clkfreq_ref
+ * @plldv_mfi: Loop multiplication factor divider
+ * @pllfd_mfn: Numerator loop multiplication factor divider
+ *
+ * For details, please consult the "PLL Digital Interface (PLLDIG)" chapter
+ * of the S32G Reference Manual.
+ */
+static int program_pll(enum s32g_pll_type pll, enum s32g_refclk refclk,
+		const uint64_t freq[], uint32_t plldv_rdiv, uint32_t plldv_mfi,
+		uint32_t pllfd_mfn)
+{
+	uint32_t i, phi_nr;
+	uint64_t refclk_freq;
+
+	phi_nr = s32g_pll_phi_nr[pll];
+
+	/* Disable dividers */
+	for (i = 0; i < phi_nr; i++)
+		mmio_write_32(PLLDIG_PLLODIV(pll, i), 0x0);
+
+	/* Disable PLL */
+	mmio_write_32(PLLDIG_PLLCR(pll), PLLDIG_PLLCR_PLLPD);
+
+	refclk_freq = plldig_set_refclk(pll, refclk);
+	if (refclk_freq == S32G_ERR_CLK_FREQ)
+		return -1;
+
+	/* See chapter:
+	 *   PLL Digital Interface (PLLDIG)::Modes of operation
+	 * from the S32G Reference Manual.
+	 *
+	 * If we were allowed to build with floating-point support, we
+	 * should have:
+	 * fvco = refclk_freq * (plldv_mfi + (pllfd_mfn/(float)18432)) /
+	 *                       (float)plldv_rdiv
+	 * i.e.:
+	 * fvco * rdiv * 18432 = refclk * (mfi * 18432 + mfn)
+	 * odiv = (refclk * (mfi * 18432 + mfn)) / (freq[i] * rdiv * 18432) - 1
+	 */
+
+	/*
+	 * VCO should have value in [PLL_MIN_FREQ, PLL_MAX_FREQ].
+	 * Please consult the platform DataSheet in order to determine
+	 * the allowed values.
+	 */
+	assert(refclk_freq * (plldv_mfi * 18432 + pllfd_mfn) >=
+	       PLL_MIN_FREQ * plldv_rdiv * 18432);
+	assert(refclk_freq * (plldv_mfi * 18432 + pllfd_mfn) <=
+	       PLL_MAX_FREQ * plldv_rdiv * 18432);
+
+	mmio_write_32(PLLDIG_PLLDV(pll), PLLDIG_PLLDV_RDIV_SET(plldv_rdiv) |
+					 PLLDIG_PLLDV_MFI(plldv_mfi));
+	mmio_write_32(PLLDIG_PLLFD(pll), PLLDIG_PLLFD_MFN_SET(pllfd_mfn) |
+					 PLLDIG_PLLFD_SMDEN);
+
+	/* Calculate divider output frequency for required PHIn outputs */
+	for (i = 0; i < phi_nr; i++) {
+		uint32_t tmp;
+		uint32_t odiv;
+
+		assert(freq[i]);
+		/* Also, because MFN must be less than 18432 according to the
+		 * refman, the following inequality must hold:
+		 *    (refclk_freq * (MFI + 1) / (freq[i] * RDIV)) > 1
+		 */
+		assert(refclk_freq * (plldv_mfi + 1) > freq[i] * plldv_rdiv);
+
+		odiv = (uint32_t)((refclk_freq *
+				  (plldv_mfi * 18432 + pllfd_mfn)) /
+				  (freq[i] * plldv_rdiv * 18432) - 1);
+
+		tmp = mmio_read_32(PLLDIG_PLLODIV(pll, i));
+		mmio_write_32(PLLDIG_PLLODIV(pll, i),
+			      tmp | PLLDIG_PLLODIV_DIV_SET(odiv));
+	}
+
+	/* Enable the PLL */
+	mmio_write_32(PLLDIG_PLLCR(pll), 0x0);
+
+	/* Poll until PLL acquires lock */
+	while (!(mmio_read_32(PLLDIG_PLLSR(pll)) & PLLDIG_PLLSR_LOCK))
+		;
+
+	/* Enable dividers */
+	for (i = 0; i < phi_nr; i++) {
+		uint32_t tmp;
+
+		tmp = mmio_read_32(PLLDIG_PLLODIV(pll, i));
+		mmio_write_32(PLLDIG_PLLODIV(pll, i), PLLDIG_PLLODIV_DE | tmp);
+	}
+
+	return 0;
+}
+
+/**
+ * BL31SSRAM stage cannot use clock driver to set DDR clock due to SSRAM size,
+ * consequently it will have a raw management over DDR clock.
+ */
+void s32g_plat_ddr_clock_init(void)
+{
+	assert(ARRAY_SIZE(s32g_ddr_pll_phi_freq) ==
+	       s32g_pll_phi_nr[S32G_DDR_PLL]);
+
+	start_fxosc();
+	mc_me_enable_partition(S32G_MC_ME_PRTN0);
+	mc_me_enable_partition_block(S32G_MC_ME_DDR_0_PART,
+				     S32G_MC_ME_DDR_0_REQ);
+	program_pll(S32G_DDR_PLL, S32G_REFCLK_FXOSC, s32g_ddr_pll_phi_freq,
+		    s32g_pll_rdiv[S32G_DDR_PLL], s32g_pll_mfi[S32G_DDR_PLL],
+		    s32g_pll_mfn[S32G_DDR_PLL]);
+	sw_mux_clk_config(MC_CGM5, 0, MC_CGM_MUXn_CSC_SEL_DDR_PLL_PHI0);
+}
diff --git a/plat/nxp/s32g/include/s32g_clocks.h b/plat/nxp/s32g/include/s32g_clocks.h
index df4ff2067..b1d7cc8cb 100644
--- a/plat/nxp/s32g/include/s32g_clocks.h
+++ b/plat/nxp/s32g/include/s32g_clocks.h
@@ -6,6 +6,7 @@
 #ifndef _S32G_CLOCKS_H_
 #define _S32G_CLOCKS_H_
 
+#include <dt-bindings/clock/s32gen1-clock-freq.h>
 #include <stdint.h>
 #include <stdbool.h>
 
@@ -75,7 +76,8 @@ static const uint32_t s32g_pll_phi_nr[S32G_PLL_NR] = {2, 8, 2, 1};
 
 /* Array of parameters for each PLL */
 static const uint32_t s32g_pll_rdiv[S32G_PLL_NR] = {1, 1, 1, 1};
-static const uint32_t s32g_pll_mfi[S32G_PLL_NR] = {50, 50, 60, 40};
+static const uint32_t s32g_pll_mfi[S32G_PLL_NR] = {50, 50, 60,
+	S32GEN1_DDR_PLL_VCO_FREQ / S32GEN1_FXOSC_FREQ};
 static const uint32_t s32g_pll_mfn[S32G_PLL_NR] = {0, 0, 1, 0};
 
 /*
@@ -111,9 +113,8 @@ static const uint64_t s32g_accel_pll_phi_freq[] = {
 	ACCEL_PLL_PHI0_FREQ,
 	ACCEL_PLL_PHI1_FREQ,
 };
-#define DDR_PLL_PHI0_FREQ	(400000000ull)
 static const uint64_t s32g_ddr_pll_phi_freq[] = {
-	DDR_PLL_PHI0_FREQ,
+	S32GEN1_DDR_FREQ,
 };
 
 /*
@@ -339,11 +340,12 @@ void s32g_plat_ddr_clock_init(void);
 
 static const uint32_t core_pll_odiv_supported[] = { 1, 2, 4, 10, 20, 40 };
 
-int s32g_set_a53_core_clk(uint64_t freq);
 void s32g_ddr2firc(void);
 void s32g_sw_clks2firc(void);
 void s32g_disable_dfs(enum s32g_dfs_type dfs);
 void s32g_disable_pll(enum s32g_pll_type pll, uint32_t ndivs);
 void s32g_disable_fxosc(void);
 
+int sw_mux_clk_config(enum s32g_mc_cgm cgm, uint8_t mux, uint8_t source);
+
 #endif /* _S32G_CLOCKS_H_ */
diff --git a/plat/nxp/s32g/s32g_clocks.c b/plat/nxp/s32g/s32g_clocks.c
index ecb2dd719..23c76ed90 100644
--- a/plat/nxp/s32g/s32g_clocks.c
+++ b/plat/nxp/s32g/s32g_clocks.c
@@ -11,30 +11,6 @@
 #include <lib/mmio.h>
 #include <stdbool.h>
 
-static uint64_t plldig_set_refclk(enum s32g_pll_type pll,
-				  enum s32g_refclk refclk)
-{
-	uint64_t refclk_freq = S32G_ERR_CLK_FREQ;
-	uint32_t pllclkmux;
-
-	switch (refclk) {
-	case S32G_REFCLK_FIRC:
-		pllclkmux = PLLDIG_PLLCLKMUX_REFCLK_FIRC;
-		refclk_freq = S32G_FIRC_FREQ;
-		break;
-	case S32G_REFCLK_FXOSC:
-		pllclkmux = PLLDIG_PLLCLKMUX_REFCLK_FXOSC;
-		refclk_freq = S32G_FXOSC_FREQ;
-		break;
-	default:
-		assert(0);
-		break;
-	}
-	mmio_write_32(PLLDIG_PLLCLKMUX(pll), pllclkmux);
-
-	return refclk_freq;
-}
-
 void s32g_disable_pll(enum s32g_pll_type pll, uint32_t ndivs)
 {
 	uint32_t div;
@@ -47,128 +23,6 @@ void s32g_disable_pll(enum s32g_pll_type pll, uint32_t ndivs)
 	mmio_write_32(PLLDIG_PLLCR(pll), PLLDIG_PLLCR_PLLPD);
 }
 
-/*
- * Program the pll for various blocks
- *
- * @pll: Type of PLL to program
- * @refclk: Input reference clock to the PLL block
- * @freq: Array of PHI frequencies for each type of PLL
- * @plldv_rdiv: Divider of clkfreq_ref
- * @plldv_mfi: Loop multiplication factor divider
- * @pllfd_mfn: Numerator loop multiplication factor divider
- *
- * For details, please consult the "PLL Digital Interface (PLLDIG)" chapter
- * of the S32G Reference Manual.
- */
-static int program_pll(enum s32g_pll_type pll, enum s32g_refclk refclk,
-		       const uint64_t freq[], uint32_t plldv_rdiv,
-		       uint32_t plldv_mfi, uint32_t pllfd_mfn)
-{
-	uint32_t i, phi_nr;
-	uint64_t refclk_freq;
-
-	phi_nr = s32g_pll_phi_nr[pll];
-
-	/* Disable dividers */
-	for (i = 0; i < phi_nr; i++)
-		mmio_write_32(PLLDIG_PLLODIV(pll, i), 0x0);
-
-	/* Disable PLL */
-	mmio_write_32(PLLDIG_PLLCR(pll), PLLDIG_PLLCR_PLLPD);
-
-	refclk_freq = plldig_set_refclk(pll, refclk);
-	if (refclk_freq == S32G_ERR_CLK_FREQ)
-		return -1;
-
-	/* See chapter:
-	 *   PLL Digital Interface (PLLDIG)::Modes of operation
-	 * from the S32G Reference Manual.
-	 *
-	 * If we were allowed to build with floating-point support, we
-	 * should have:
-	 * fvco = refclk_freq * (plldv_mfi + (pllfd_mfn/(float)18432)) /
-	 *                       (float)plldv_rdiv
-	 * i.e.:
-	 * fvco * rdiv * 18432 = refclk * (mfi * 18432 + mfn)
-	 * odiv = (refclk * (mfi * 18432 + mfn)) / (freq[i] * rdiv * 18432) - 1
-	 */
-
-	/*
-	 * VCO should have value in [PLL_MIN_FREQ, PLL_MAX_FREQ].
-	 * Please consult the platform DataSheet in order to determine
-	 * the allowed values.
-	 */
-	assert(refclk_freq * (plldv_mfi * 18432 + pllfd_mfn) >=
-	       PLL_MIN_FREQ * plldv_rdiv * 18432);
-	assert(refclk_freq * (plldv_mfi * 18432 + pllfd_mfn) <=
-	       PLL_MAX_FREQ * plldv_rdiv * 18432);
-
-	mmio_write_32(PLLDIG_PLLDV(pll), PLLDIG_PLLDV_RDIV_SET(plldv_rdiv) |
-					 PLLDIG_PLLDV_MFI(plldv_mfi));
-	mmio_write_32(PLLDIG_PLLFD(pll), PLLDIG_PLLFD_MFN_SET(pllfd_mfn) |
-					 PLLDIG_PLLFD_SMDEN);
-
-	/* Calculate divider output frequency for required PHIn outputs */
-	for (i = 0; i < phi_nr; i++) {
-		uint32_t tmp;
-		uint32_t odiv;
-
-		assert(freq[i]);
-		/* Also, because MFN must be less than 18432 according to the
-		 * refman, the following inequality must hold:
-		 *    (refclk_freq * (MFI + 1) / (freq[i] * RDIV)) > 1
-		 */
-		assert(refclk_freq * (plldv_mfi + 1) > freq[i] * plldv_rdiv);
-
-		odiv = (uint32_t)((refclk_freq *
-				  (plldv_mfi * 18432 + pllfd_mfn)) /
-				  (freq[i] * plldv_rdiv * 18432) - 1);
-
-		tmp = mmio_read_32(PLLDIG_PLLODIV(pll, i));
-		mmio_write_32(PLLDIG_PLLODIV(pll, i),
-			      tmp | PLLDIG_PLLODIV_DIV_SET(odiv));
-	}
-
-	/* Enable the PLL */
-	mmio_write_32(PLLDIG_PLLCR(pll), 0x0);
-
-	/* Poll until PLL acquires lock */
-	while (!(mmio_read_32(PLLDIG_PLLSR(pll)) & PLLDIG_PLLSR_LOCK))
-		;
-
-	/* Enable dividers */
-	for (i = 0; i < phi_nr; i++) {
-		uint32_t tmp;
-
-		tmp = mmio_read_32(PLLDIG_PLLODIV(pll, i));
-		mmio_write_32(PLLDIG_PLLODIV(pll, i), PLLDIG_PLLODIV_DE | tmp);
-	}
-
-	return 0;
-}
-
-static void start_fxosc(void)
-{
-	uint32_t ctrl;
-
-	/* If FXOSC is already running, do nothing */
-	if (mmio_read_32(FXOSC_CTRL) & FXOSC_CTRL_OSCON)
-		return;
-
-	ctrl = FXOSC_CTRL_COMP_EN;
-	ctrl &= ~FXOSC_CTRL_OSC_BYP;
-	ctrl |= FXOSC_CTRL_EOCV(0x1);
-	ctrl |= FXOSC_CTRL_GM_SEL(0x7);
-	mmio_write_32(FXOSC_CTRL, ctrl);
-
-	/* Switch on the crystal oscillator */
-	mmio_write_32(FXOSC_CTRL, FXOSC_CTRL_OSCON | mmio_read_32(FXOSC_CTRL));
-
-	/* Wait until the clock is stable */
-	while (!(mmio_read_32(FXOSC_STAT) & FXOSC_STAT_OSC_STAT))
-		;
-}
-
 void s32g_disable_fxosc(void)
 {
 	uint32_t ctrl = mmio_read_32(FXOSC_CTRL);
@@ -190,55 +44,6 @@ void s32g_disable_dfs(enum s32g_dfs_type dfs)
 	mmio_write_32(DFS_CTL(dfs), DFS_CTL_RESET);
 }
 
-/* DFS enablement, according to chapter
- *    "Digital Frequency Synthesizer (DFS)::Initialization information"
- * from the S32G Reference Manual.
- *
- * Any port settings (MFI, MFN) must be applied _before_ calling this function.
- */
-static void enable_dfs(enum s32g_dfs_type dfs,
-		       const uint32_t params[][DFS_PARAMS_NR])
-{
-	uint32_t port, reset = 0;
-
-	/* deassert the master reset */
-	mmio_write_32(DFS_CTL(dfs), ~DFS_CTL_RESET);
-	/* deassert individual ports */
-	for (port = 0; port < S32G_DFS_PORTS_NR; port++)
-		reset |= (params[port][DFS_PORT_EN] << port);
-	mmio_write_32(DFS_PORTRESET(dfs), ~reset);
-
-	/* wait until all configured ports are locked */
-	while ((mmio_read_32(DFS_PORTSR(dfs)) & reset) != reset)
-		;
-}
-
-/* DFS init & config, according to chapter
- *    "Digital Frequency Synthesizer (DFS)::Initialization information"
- * from the S32G Reference Manual.
- *
- * DFS must be disabled before calling this function.
- */
-static int program_dfs(enum s32g_dfs_type dfs,
-		       const uint32_t params[][DFS_PARAMS_NR])
-{
-	uint32_t port = 0;
-
-	s32g_disable_dfs(dfs);
-
-	for (port = 0; port < S32G_DFS_PORTS_NR; port++) {
-		if (!(params[port][DFS_PORT_EN]))
-			continue;
-		mmio_write_32(DFS_DVPORTn(dfs, port),
-			      DFS_DVPORTn_MFI(params[port][DFS_DVPORT_MFI]) |
-			      DFS_DVPORTn_MFN(params[port][DFS_DVPORT_MFN]));
-	}
-
-	enable_dfs(dfs, params);
-
-	return 0;
-}
-
 static uintptr_t mc_cgm_addr(enum s32g_mc_cgm mc_cgm)
 {
 	switch (mc_cgm)	{
@@ -262,7 +67,7 @@ static uintptr_t mc_cgm_addr(enum s32g_mc_cgm mc_cgm)
  *      Clock selection multiplexer::
  *        Software-controlled clock multiplexer"
  */
-static int sw_mux_clk_config(enum s32g_mc_cgm cgm, uint8_t mux, uint8_t source)
+int sw_mux_clk_config(enum s32g_mc_cgm cgm, uint8_t mux, uint8_t source)
 {
 	uint32_t css, csc;
 	uintptr_t cgm_addr;
@@ -368,68 +173,3 @@ void s32g_ddr2firc(void)
 	switch_muxes_to_firc(MC_CGM5, &cgm5_muxes[0],
 			     ARRAY_SIZE(cgm5_muxes));
 }
-
-static bool is_a53_core_clk_supported(uint64_t clk)
-{
-	int i;
-
-	if (!IS_A53_CORE_CLK_VALID(clk))
-		return false;
-
-	for (i = 0; i < ARRAY_SIZE(core_pll_odiv_supported); i++) {
-		if ((CORE_PLL_FVCO / clk == core_pll_odiv_supported[i]) &&
-		    (!(CORE_PLL_FVCO % clk)))
-			return true;
-	}
-	return false;
-}
-
-int s32g_set_a53_core_clk(uint64_t clk)
-{
-	uint64_t core_pll_phi_freq[2] = {clk, CORE_PLL_PHI1_FREQ};
-	uint32_t odiv;
-	int i;
-
-	if (!is_a53_core_clk_supported(clk)) {
-		printf("Requested frequency is not supported. Use one of:\n");
-		for (i = 0; i < ARRAY_SIZE(core_pll_odiv_supported); i++) {
-			odiv = core_pll_odiv_supported[i];
-			if (CORE_PLL_FVCO % odiv)
-				continue;
-			if (!IS_A53_CORE_CLK_VALID(CORE_PLL_FVCO / odiv))
-				continue;
-			printf("\t%lu\n", CORE_PLL_FVCO / odiv);
-		}
-		return -EINVAL;
-	}
-
-	sw_mux_clk_config(MC_CGM1, 0,
-			  MC_CGM_MUXn_CSC_SEL_CORE_PLL_FIRC);
-	s32g_disable_dfs(S32G_CORE_DFS);
-
-	/* Configure the CORE_PLL */
-	program_pll(S32G_CORE_PLL, S32G_REFCLK_FXOSC, core_pll_phi_freq,
-		    s32g_pll_rdiv[S32G_CORE_PLL], s32g_pll_mfi[S32G_CORE_PLL],
-		    s32g_pll_mfn[S32G_CORE_PLL]);
-	/* Configure the CORE_DFS*/
-	program_dfs(S32G_CORE_DFS, s32g_core_dfs_params);
-	/* Configure the core CGM mux */
-	sw_mux_clk_config(MC_CGM1, 0, MC_CGM_MUXn_CSC_SEL_CORE_PLL_PHI0);
-
-	return 0;
-}
-
-void s32g_plat_ddr_clock_init(void)
-{
-	assert(ARRAY_SIZE(s32g_ddr_pll_phi_freq) ==
-	       s32g_pll_phi_nr[S32G_DDR_PLL]);
-
-	start_fxosc();
-	mc_me_enable_partition(S32G_MC_ME_PRTN0);
-	mc_me_enable_partition_block(S32G_MC_ME_DDR_0_PART,
-				     S32G_MC_ME_DDR_0_REQ);
-	program_pll(S32G_DDR_PLL, S32G_REFCLK_FXOSC, s32g_ddr_pll_phi_freq,
-		    s32g_pll_rdiv[S32G_DDR_PLL], s32g_pll_mfi[S32G_DDR_PLL],
-		    s32g_pll_mfn[S32G_DDR_PLL]);
-	sw_mux_clk_config(MC_CGM5, 0, MC_CGM_MUXn_CSC_SEL_DDR_PLL_PHI0);
-}
-- 
2.17.1

