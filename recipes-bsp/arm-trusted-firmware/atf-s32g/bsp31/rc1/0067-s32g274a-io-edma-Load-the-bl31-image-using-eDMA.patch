From 833d5b9c6e0102fca7cb6e2506bc62e5ea4442bc Mon Sep 17 00:00:00 2001
From: Dan Nica <dan.nica@nxp.com>
Date: Wed, 5 Feb 2020 14:18:11 +0200
Subject: [PATCH 067/269] s32g274a: io: edma: Load the bl31 image using eDMA

Issue: ALB-4576
Upstream-Status: Pending 

Signed-off-by: Dan Nica <dan.nica@nxp.com>
Signed-off-by: Zhantao Tang <zhantao.tang@windriver.com>
---
 drivers/nxp/s32g/io/io_memmap.c   | 11 ++++-
 plat/s32g/include/s32g274a_edma.h | 17 ++++++++
 plat/s32g/platform.mk             |  1 +
 plat/s32g/s32g274a_edma.c         | 68 +++++++++++++++++++++++++++++++
 4 files changed, 96 insertions(+), 1 deletion(-)
 create mode 100644 plat/s32g/s32g274a_edma.c

diff --git a/drivers/nxp/s32g/io/io_memmap.c b/drivers/nxp/s32g/io/io_memmap.c
index aca5e4256..c1d01ea29 100644
--- a/drivers/nxp/s32g/io/io_memmap.c
+++ b/drivers/nxp/s32g/io/io_memmap.c
@@ -12,6 +12,7 @@
 #include <drivers/io/io_memmap.h>
 #include <drivers/io/io_storage.h>
 #include <lib/utils.h>
+#include <s32g274a_edma.h>
 
 /* As we need to be able to keep state for seek, only one file can be open
  * at a time. Make this a structure and point to the entity->info. When we
@@ -121,7 +122,15 @@ static int memmap_block_read(io_entity_t *entity, uintptr_t buffer,
 	pos_after = fp->file_pos + length;
 	assert((pos_after >= fp->file_pos) && (pos_after <= fp->size));
 
-	memcpy((void *)buffer, (void *)(fp->base + fp->file_pos), length);
+	if (IS_ON_32BITS(buffer) &&
+	    IS_ON_32BITS((uint64_t)buffer + length) &&
+	    IS_ON_32BITS((uint64_t)fp->base + fp->file_pos) &&
+	    IS_ON_32BITS((uint64_t)fp->base + fp->file_pos + length))
+		edma_xfer_sync(buffer, (uintptr_t)(fp->base + fp->file_pos),
+			       length, DMA_CHANNEL_1);
+	else
+		memcpy((void *)buffer, (void *)(fp->base + fp->file_pos),
+		       length);
 
 	*length_read = length;
 	fp->file_pos = pos_after;
diff --git a/plat/s32g/include/s32g274a_edma.h b/plat/s32g/include/s32g274a_edma.h
index b0e877c39..9684877ed 100644
--- a/plat/s32g/include/s32g274a_edma.h
+++ b/plat/s32g/include/s32g274a_edma.h
@@ -13,15 +13,32 @@
 
 #define EDMA0_MP_ES			(EDMA0_MP + 0x4)
 #define EDMA0_CHn_CSR(ch)		(EDMA0_TCD + 0x1000 * (ch))
+#define CH_CSR_DONE			BIT(30)
 #define EDMA0_CHn_ES(ch)		(EDMA0_TCD + 0x1000 * (ch) + 0x04)
+#define CH_ES_ERR			BIT(31)
 #define EDMA0_TCDn_SADDR(ch)		(EDMA0_TCD + 0x1000 * (ch) + 0x20)
 #define EDMA0_TCDn_SOFF(ch)		(EDMA0_TCD + 0x1000 * (ch) + 0x24)
 #define EDMA0_TCDn_ATTR(ch)		(EDMA0_TCD + 0x1000 * (ch) + 0x26)
+#define ATTR_SSIZE_SHIFT		(8)
+#define ATTR_SSIZE(x)			((x) << ATTR_SSIZE_SHIFT)
+#define ATTR_DSIZE(x)			(x)
+#define ATTR_SSIZE_MAX_OPTION		(6)
 #define EDMA0_TCDn_NBYTES_MLOFFNO(ch)	(EDMA0_TCD + 0x1000 * (ch) + 0x28)
+#define NBYTES_MLOFFNO_NBYTES(x)	((x) & 0x3fffffff)
 #define EDMA0_TCDn_DADDR(ch)		(EDMA0_TCD + 0x1000 * (ch) + 0x30)
 #define EDMA0_TCDn_DOFF(ch)		(EDMA0_TCD + 0x1000 * (ch) + 0x34)
 #define EDMA0_TCDn_CITER_ELINKNO(ch)	(EDMA0_TCD + 0x1000 * (ch) + 0x36)
+#define CITER_ELINKNO_CITER(x)		((x) & 0x7fff)
 #define EDMA0_TCDn_CSR(ch)		(EDMA0_TCD + 0x1000 * (ch) + 0x3c)
+#define TCD_CSR_START			BIT(0)
 #define EDMA0_TCDn_BITER_ELINKNO(ch)	(EDMA0_TCD + 0x1000 * (ch) + 0x3e)
+#define BITER_ELINKNO_BITER(x)		((x) & 0x7fff)
+
+#ifndef __ASSEMBLY__
+size_t edma_xfer_sync(uintptr_t to, uintptr_t from, size_t length,
+		      uint32_t channel);
+#endif
+
+#define IS_ON_32BITS(x)			(!((uint64_t)(x) >> 32))
 
 #endif /* S32G274A_EDMA_H */
diff --git a/plat/s32g/platform.mk b/plat/s32g/platform.mk
index eb0496423..e28def764 100644
--- a/plat/s32g/platform.mk
+++ b/plat/s32g/platform.mk
@@ -32,6 +32,7 @@ BL2_SOURCES		+= plat/s32g/s32g_lowlevel_bl2.S \
 			   plat/s32g/s32g_clocks.c \
 			   plat/s32g/s32g_pinctrl.c \
 			   plat/s32g/s32g274a_storage.c \
+			   plat/s32g/s32g274a_edma.c \
 			   drivers/io/io_storage.c \
 			   common/desc_image_load.c \
 			   drivers/nxp/s32g/io/io_memmap.c \
diff --git a/plat/s32g/s32g274a_edma.c b/plat/s32g/s32g274a_edma.c
new file mode 100644
index 000000000..b93bbfca3
--- /dev/null
+++ b/plat/s32g/s32g274a_edma.c
@@ -0,0 +1,68 @@
+/*
+ * Copyright 2020 NXP
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ */
+
+#include <lib/mmio.h>
+#include <assert.h>
+#include "s32g274a_edma.h"
+
+/* Determine the optimum data transfer size based on
+ * the highest common alignment between 'to', 'from' and 'length'.
+ * For more information see the S32G Reference Manual, the
+ * 'TCD Transfer Attributes Register' section.
+ */
+static int16_t max_xfer_size(uintptr_t to, uintptr_t from, size_t length,
+			     uint16_t *tcd_attr)
+{
+	int i;
+	uint64_t orr_args = (uint64_t)to | (uint64_t)from | (uint64_t)length;
+
+	for (i = ATTR_SSIZE_MAX_OPTION; i >= 0; i--) {
+		if (!(orr_args % BIT(i))) {
+			*tcd_attr = ATTR_SSIZE(i) | ATTR_DSIZE(i);
+			return BIT(i);
+		}
+	}
+
+	return 0;
+}
+
+size_t edma_xfer_sync(uintptr_t to, uintptr_t from, size_t length,
+		      uint32_t channel)
+{
+	uint16_t tcd_attr;
+	int16_t xfer_size = max_xfer_size(to, from, length, &tcd_attr);
+
+	assert(IS_ON_32BITS(to));
+	assert(IS_ON_32BITS((uint64_t)to + length));
+	assert(IS_ON_32BITS(from));
+	assert(IS_ON_32BITS((uint64_t)from + length));
+
+	mmio_write_32(EDMA0_TCDn_DADDR(channel), (uint32_t)to);
+	mmio_write_32(EDMA0_TCDn_SADDR(channel), (uint32_t)from);
+	mmio_write_32(EDMA0_TCDn_NBYTES_MLOFFNO(channel),
+					NBYTES_MLOFFNO_NBYTES(length));
+
+	mmio_write_16(EDMA0_TCDn_DOFF(channel), xfer_size);
+	mmio_write_16(EDMA0_TCDn_SOFF(channel), xfer_size);
+	mmio_write_16(EDMA0_TCDn_ATTR(channel), tcd_attr);
+	mmio_write_16(EDMA0_TCDn_CITER_ELINKNO(channel),
+						CITER_ELINKNO_CITER(1));
+	mmio_write_16(EDMA0_TCDn_BITER_ELINKNO(channel),
+						BITER_ELINKNO_BITER(1));
+
+	mmio_write_32(EDMA0_TCDn_CSR(channel), TCD_CSR_START);
+
+	while (true) {
+		if (mmio_read_32(EDMA0_CHn_ES(channel)) & CH_ES_ERR) {
+			mmio_write_32(EDMA0_CHn_ES(channel), CH_ES_ERR);
+			return 0;
+		}
+		if (mmio_read_32(EDMA0_CHn_CSR(channel)) & CH_CSR_DONE) {
+			mmio_write_32(EDMA0_CHn_CSR(channel), CH_CSR_DONE);
+			return length;
+		}
+	}
+}
-- 
2.17.1

