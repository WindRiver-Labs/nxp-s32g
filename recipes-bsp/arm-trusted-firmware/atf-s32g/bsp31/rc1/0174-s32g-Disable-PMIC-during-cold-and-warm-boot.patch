From e3f4f2d8434162ca61328d1a1cb8e9213cbef6a2 Mon Sep 17 00:00:00 2001
From: Ghennadi Procopciuc <Ghennadi.Procopciuc@nxp.com>
Date: Mon, 2 Nov 2020 15:40:01 +0200
Subject: [PATCH 174/269] s32g: Disable PMIC during cold and warm boot

Issue: ALB-5836
Upstream-Status: Pending 

Signed-off-by: Ghennadi Procopciuc <Ghennadi.Procopciuc@nxp.com>
Signed-off-by: Zhantao Tang <zhantao.tang@windriver.com>
---
 include/drivers/nxp/s32g/pmic/vr5510.h |  25 +++++
 plat/nxp/s32g/include/s32g_bl_common.h |   1 +
 plat/nxp/s32g/s32g_bl31.c              |   6 ++
 plat/nxp/s32g/s32g_resume.c            |   5 +
 plat/nxp/s32g/s32g_vr5510.c            | 136 +++++++++++++++++++++++++
 5 files changed, 173 insertions(+)

diff --git a/include/drivers/nxp/s32g/pmic/vr5510.h b/include/drivers/nxp/s32g/pmic/vr5510.h
index c1f61f88d..69432d632 100644
--- a/include/drivers/nxp/s32g/pmic/vr5510.h
+++ b/include/drivers/nxp/s32g/pmic/vr5510.h
@@ -84,9 +84,15 @@
 #define VR5510_FS_I_ABIST2_CTRL			5
 #define VR5510_FS_I_NOT_ABIST2_CTRL		6
 #define VR5510_FS_I_WD_CFG			7
+#define VR5510_ERR_CNT_MASK			0xF
+#define VR5510_ERR_CNT(V)			((V) & VR5510_ERR_CNT_MASK)
 #define VR5510_FS_I_NOT_WD_CFG			8
 
 #define VR5510_FS_I_SAFE_INPUTS			9
+#define VR5510_FCCU_CFG_OFFSET			14
+#define VR5510_FCCU_CFG_MASK			(3 << VR5510_FCCU_CFG_OFFSET)
+#define VR5510_FCCU_CFG(V)			((V) & VR5510_FCCU_CFG_MASK >>\
+						 VR5510_FCCU_CFG_OFFSET)
 #define VR5510_SAFE_INPUTS_TW_STBY_60US		0x4
 #define VR5510_SAFE_INPUTS_TW_STBY_80US		0x5
 #define VR5510_SAFE_INPUTS_TW_STBY_100US	0x6
@@ -106,6 +112,8 @@
 #define VR5510_FS_I_SVS				13
 #define VR5510_FS_I_NOT_SVS			14
 #define VR5510_FS_WD_WINDOW			15
+#define VR5510_WD_WINDOW_OFFSET			12
+#define VR5510_WD_WINDOW_MASK			0xF000
 #define VR5510_FS_NOT_WD_WINDOW			16
 #define VR5510_FS_WD_SEED			17
 #define VR5510_FS_WD_ANSWER			18
@@ -114,10 +122,27 @@
 
 #define VR5510_FS_SAFE_IOS			21
 #define VR5510_SAFE_IOS_STBY_REQ		BIT(1)
+#define VR5510_SAFE_IOS_GOTO_INITFS		BIT(2)
 
 #define VR5510_FS_DIAG_SAFETY			22
+#define VR5510_ABIST1_OK_OFFSET			10
+#define VR5510_ABIST1_OK_MASK			BIT(VR5510_ABIST1_OK_OFFSET)
+#define VR5510_ABIST1_OK(V)			((V) & VR5510_ABIST1_OK_MASK >>\
+						 VR5510_ABIST1_OK_OFFSET)
 #define VR5510_FS_INTB_MASK			23
 #define VR5510_FS_STATES			24
+#define VR5510_STATE_MASK			0x1FU
+#define VR5510_STATE_OFFSET			0
+#define VR5510_STATE(V)				(((V) & VR5510_STATE_MASK) >>\
+						 VR5510_STATE_OFFSET)
+
+enum fs_states {
+	INIT_FS = 6,
+	WAIT_ABIST2,
+	ABIST2,
+	ASSERT_FS0B,
+	NORMAL_FS,
+};
 
 struct vr5510_inst;
 typedef struct vr5510_inst *vr5510_t;
diff --git a/plat/nxp/s32g/include/s32g_bl_common.h b/plat/nxp/s32g/include/s32g_bl_common.h
index fa7bc0c9e..f5b247dce 100644
--- a/plat/nxp/s32g/include/s32g_bl_common.h
+++ b/plat/nxp/s32g/include/s32g_bl_common.h
@@ -21,6 +21,7 @@ void plat_gic_restore(void);
 void s32g_early_plat_init(bool skip_ddr_clk);
 int pmic_prepare_for_suspend(void);
 void pmic_system_off(void);
+int pmic_disable_wdg(void);
 
 void update_core_state(uint32_t core, uint32_t state);
 bool is_last_core(void);
diff --git a/plat/nxp/s32g/s32g_bl31.c b/plat/nxp/s32g/s32g_bl31.c
index 1b5fb94c6..9883b1016 100644
--- a/plat/nxp/s32g/s32g_bl31.c
+++ b/plat/nxp/s32g/s32g_bl31.c
@@ -332,6 +332,8 @@ static unsigned int plat_s32g274a_mpidr_to_core_pos(unsigned long mpidr)
 
 void bl31_platform_setup(void)
 {
+	int ret;
+
 	update_core_state(plat_my_core_pos(), 1);
 	s32g_gic_setup();
 
@@ -339,6 +341,10 @@ void bl31_platform_setup(void)
 
 	dt_init_pmic();
 	dt_init_wkpu();
+
+	ret = pmic_disable_wdg();
+	if (ret)
+		ERROR("Failed to disable VR5510 watchdog\n");
 }
 
 /* TODO: Last-minute modifications before exiting BL31:
diff --git a/plat/nxp/s32g/s32g_resume.c b/plat/nxp/s32g/s32g_resume.c
index d9417842d..49c1ebaeb 100644
--- a/plat/nxp/s32g/s32g_resume.c
+++ b/plat/nxp/s32g/s32g_resume.c
@@ -31,6 +31,11 @@ static void reset_rtc(void)
 void s32g_resume_entrypoint(void)
 {
 	static struct console_s32g console;
+	int ret;
+
+	ret = pmic_disable_wdg();
+	if (ret)
+		ERROR("Failed to disable VR5510 watchdog\n");
 
 	/* Prepare resume operation */
 	s32g_ncore_isol_cluster0();
diff --git a/plat/nxp/s32g/s32g_vr5510.c b/plat/nxp/s32g/s32g_vr5510.c
index e40b589c0..c169f86da 100644
--- a/plat/nxp/s32g/s32g_vr5510.c
+++ b/plat/nxp/s32g/s32g_vr5510.c
@@ -6,6 +6,65 @@
 #include "pmic/vr5510.h"
 #include "s32g_bl_common.h"
 
+static int watchdog_refresh(vr5510_t fsu)
+{
+	uint16_t reg;
+	uint8_t *regp = (uint8_t *)&reg;
+	int ret;
+
+	ret = vr5510_read(fsu, VR5510_FS_WD_SEED, regp, sizeof(reg));
+	if (ret)
+		return ret;
+
+	/* Challenger watchdog refresh */
+	reg = ((~(reg * 4 + 2) & 0xFFFFFFFFU) / 4) & 0xFFFFU;
+
+	ret = vr5510_write(fsu, VR5510_FS_WD_ANSWER, regp, sizeof(reg));
+	if (ret) {
+		ERROR("Failed to write VR5510 WD answer\n");
+		return ret;
+	}
+
+	ret = vr5510_read(fsu, VR5510_FS_I_WD_CFG, regp, sizeof(reg));
+	if (ret)
+		return ret;
+
+	if (VR5510_ERR_CNT(reg)) {
+		ERROR("Failed to refresh watchdog\n");
+		return -EIO;
+	}
+
+	return 0;
+}
+
+static int vr5510_goto_initfs(vr5510_t fsu)
+{
+	int ret;
+	uint16_t reg;
+	uint8_t *regp = (uint8_t *)&reg;
+
+	ret = watchdog_refresh(fsu);
+	if (ret) {
+		ERROR("Failed to refresh VR5510 WDG\n");
+		return ret;
+	}
+
+	ret = vr5510_read(fsu, VR5510_FS_SAFE_IOS, regp, sizeof(reg));
+	if (ret)
+		return ret;
+
+	reg |= VR5510_SAFE_IOS_GOTO_INITFS;
+	ret = vr5510_write(fsu, VR5510_FS_SAFE_IOS, regp, sizeof(reg));
+	if (ret)
+		return ret;
+
+	ret = vr5510_read(fsu, VR5510_FS_SAFE_IOS, regp, sizeof(reg));
+	if (ret)
+		return ret;
+
+	return 0;
+}
+
 int pmic_prepare_for_suspend(void)
 {
 	int ret;
@@ -24,6 +83,9 @@ int pmic_prepare_for_suspend(void)
 	if (ret)
 		return ret;
 
+	ret = vr5510_goto_initfs(fsu);
+	if (ret)
+		return ret;
 
 	/* Clear I2C errors if any */
 	reg = VR5510_FLAG3_I2C_M_REQ | VR5510_FLAG3_I2C_M_CRC;
@@ -128,3 +190,77 @@ void pmic_system_off(void)
 		ERROR("Failed to write VR5510_M_SM_CTRL1 register\n");
 }
 
+int pmic_disable_wdg(void)
+{
+	vr5510_t fsu;
+	uint16_t reg;
+	uint8_t *regp = (uint8_t *)&reg;
+	int ret;
+
+	s32g_reinit_i2c();
+
+	ret = vr5510_get_inst(VR5510_FSU_NAME, &fsu);
+	if (ret) {
+		ERROR("Failed to get VR5510 FSU\n");
+		return ret;
+	}
+
+	ret = vr5510_read(fsu, VR5510_FS_STATES, regp, sizeof(reg));
+	if (ret)
+		return ret;
+
+	if (VR5510_STATE(reg) != INIT_FS) {
+		WARN("VR5510 is not in INIT_FS state\n");
+		return 0;
+	}
+
+	/* Disable watchdog */
+	ret = vr5510_read(fsu, VR5510_FS_WD_WINDOW, regp, sizeof(reg));
+	if (ret)
+		return ret;
+
+	reg &= ~VR5510_WD_WINDOW_MASK;
+	ret = vr5510_write(fsu, VR5510_FS_WD_WINDOW, regp, sizeof(reg));
+	if (ret) {
+		ERROR("Failed write watchdog window\n");
+		return ret;
+	}
+
+	reg = ~reg & 0xFFFFU;
+	ret = vr5510_write(fsu, VR5510_FS_NOT_WD_WINDOW, regp, sizeof(reg));
+	if (ret) {
+		ERROR("Failed write watchdog window\n");
+		return ret;
+	}
+
+	ret = vr5510_read(fsu, VR5510_FS_DIAG_SAFETY, regp, sizeof(reg));
+	if (ret)
+		return ret;
+
+	if (!VR5510_ABIST1_OK(reg)) {
+		ERROR("VR5510 is not in ABIST1 state\n");
+		return -EIO;
+	}
+
+	/* Disable FCCU monitoring */
+	ret = vr5510_read(fsu, VR5510_FS_I_SAFE_INPUTS, regp, sizeof(reg));
+	if (ret)
+		return ret;
+
+	reg &= ~VR5510_FCCU_CFG_MASK;
+	ret = vr5510_write(fsu, VR5510_FS_I_SAFE_INPUTS, regp, sizeof(reg));
+	if (ret) {
+		ERROR("Failed to disable FCCU\n");
+		return ret;
+	}
+
+	reg &= ~reg & 0xFFFFU;
+	ret = vr5510_write(fsu, VR5510_FS_I_NOT_SAFE_INPUTS, regp, sizeof(reg));
+	if (ret) {
+		ERROR("Failed to disable FCCU\n");
+		return ret;
+	}
+
+	return watchdog_refresh(fsu);
+}
+
-- 
2.17.1

