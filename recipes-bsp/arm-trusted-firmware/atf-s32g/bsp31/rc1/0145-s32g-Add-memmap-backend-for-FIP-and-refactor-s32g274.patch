From 91134e61eb785a3ae97168f4e164397f660fda77 Mon Sep 17 00:00:00 2001
From: Dan Nica <dan.nica@nxp.com>
Date: Wed, 3 Jun 2020 11:47:10 +0300
Subject: [PATCH 145/269] s32g: Add memmap backend for FIP and refactor
 s32g274a_storage.c

Issue: ALB-4935
Upstream-Status: Pending 

Signed-off-by: Dan Nica <dan.nica@nxp.com>
Signed-off-by: Zhantao Tang <zhantao.tang@windriver.com>
---
 plat/s32g/include/s32g_storage.h |   6 --
 plat/s32g/s32g274a_storage.c     | 145 +++++++++++++++++--------------
 2 files changed, 78 insertions(+), 73 deletions(-)

diff --git a/plat/s32g/include/s32g_storage.h b/plat/s32g/include/s32g_storage.h
index 2ec9401d8..85c933e02 100644
--- a/plat/s32g/include/s32g_storage.h
+++ b/plat/s32g/include/s32g_storage.h
@@ -6,12 +6,6 @@
 #ifndef S32G_STORAGE_H
 #define S32G_STORAGE_H
 
-enum s32g_boot_source {
-	S32G_MMC_BOOT,
-	S32G_FIP_BOOT,
-	/* TODO add FIP, QSPI, SD/MMC */
-};
-
 struct plat_io_policy {
 	uintptr_t *dev_handle;
 	uintptr_t image_spec;
diff --git a/plat/s32g/s32g274a_storage.c b/plat/s32g/s32g274a_storage.c
index e89fd1c28..c39c8d37c 100644
--- a/plat/s32g/s32g274a_storage.c
+++ b/plat/s32g/s32g274a_storage.c
@@ -7,26 +7,38 @@
 #include <drivers/io/io_driver.h>
 #include <drivers/mmc.h>
 #include <drivers/nxp/s32g/io/io_mmc.h>
+#include <drivers/io/io_memmap.h>
 #include <drivers/io/io_fip.h>
 #include <drivers/nxp/s32g/mmc/s32g274a_mmc.h>
 #include <assert.h>
 #include <tools_share/firmware_image_package.h>
 #include "s32g_storage.h"
 
-static const io_dev_connector_t *s32g_fip_io_dev;
-static uintptr_t s32g_fip_dev_handle;
+#define FIP_BACKEND_MEMMAP_ID	(BL33_IMAGE_ID + 1)
 
-static const io_dev_connector_t *s32g_mmc_io_dev;
+static const io_dev_connector_t *s32g_mmc_io_conn;
 static uintptr_t s32g_mmc_dev_handle;
 
-static int s32g_check_fip_dev(const uintptr_t spec);
+static const io_dev_connector_t *s32g_fip_io_conn;
+static uintptr_t s32g_fip_dev_handle;
+
+static const io_dev_connector_t *s32g_memmap_io_conn;
+static uintptr_t s32g_memmap_dev_handle;
+
 static int s32g_check_mmc_dev(const uintptr_t spec);
+static int s32g_check_fip_dev(const uintptr_t spec);
+static int s32g_check_memmap_dev(const uintptr_t spec);
 
 static const io_block_spec_t fip_mmc_spec = {
 	.offset = FIP_MMC_OFFSET,
 	.length = ROUND_TO_MMC_BLOCK_SIZE(FIP_MAXIMUM_SIZE),
 };
 
+static const io_block_spec_t fip_memmap_spec = {
+	.offset = FIP_BASE,
+	.length = ROUND_TO_MMC_BLOCK_SIZE(FIP_MAXIMUM_SIZE),
+};
+
 static const io_uuid_spec_t bl31_uuid_spec = {
 	.uuid = UUID_EL3_RUNTIME_FIRMWARE_BL31,
 };
@@ -51,20 +63,29 @@ static const struct plat_io_policy s32g_policies[] = {
 		(uintptr_t)&bl33_uuid_spec,
 		s32g_check_fip_dev
 	},
+	[FIP_BACKEND_MEMMAP_ID] = {
+		&s32g_memmap_dev_handle,
+		(uintptr_t)&fip_memmap_spec,
+		s32g_check_memmap_dev
+	},
 };
 
 static int s32g_check_fip_dev(const uintptr_t spec)
 {
-	int result;
+	int ret;
 	uintptr_t local_image_handle;
 
-	result = io_dev_init(s32g_fip_dev_handle, (uintptr_t)FIP_IMAGE_ID);
-	if (!result) {
-		result = io_open(s32g_fip_dev_handle, spec, &local_image_handle);
-		if (!result)
-			io_close(local_image_handle);
-	}
-	return result;
+	ret = io_dev_init(s32g_fip_dev_handle,
+			  (uintptr_t)FIP_BACKEND_MEMMAP_ID);
+	if (ret)
+		return ret;
+	ret = io_open(s32g_fip_dev_handle, spec, &local_image_handle);
+	if (ret)
+		return ret;
+	/* must be closed, as load_image() will do another io_open() */
+	io_close(local_image_handle);
+
+	return 0;
 }
 
 static int s32g_check_mmc_dev(const uintptr_t spec)
@@ -81,6 +102,22 @@ static int s32g_check_mmc_dev(const uintptr_t spec)
 	return 0;
 }
 
+static int s32g_check_memmap_dev(const uintptr_t spec)
+{
+	uintptr_t local_handle;
+	int ret;
+
+	return 0;
+
+	ret = io_open(s32g_memmap_dev_handle, spec, &local_handle);
+	if (ret)
+		return ret;
+	/* must be closed, as load_image() will do another io_open() */
+	io_close(local_handle);
+
+	return 0;
+}
+
 int plat_get_image_source(unsigned int image_id, uintptr_t *dev_handle,
 			  uintptr_t *image_spec)
 {
@@ -104,63 +141,37 @@ int plat_get_image_source(unsigned int image_id, uintptr_t *dev_handle,
 	return 0;
 }
 
-static void plat_s32g_io_setup(enum s32g_boot_source boot_source)
+void s32g_io_setup(void)
 {
-	uintptr_t handle;
-
-	switch (boot_source) {
-	case S32G_MMC_BOOT:
-		handle = s32g_mmc_dev_handle;
-
-		if (s32g274a_mmc_register())
-			goto err_register;
-
-		if (register_io_dev_mmc(&s32g_mmc_io_dev))
-			goto err_register;
-
-		if (io_dev_open(s32g_mmc_io_dev,
-				(uintptr_t)&fip_mmc_spec,
-				&s32g_mmc_dev_handle))
-			goto err_io_dev_open;
-
-		if (io_dev_init(s32g_mmc_dev_handle, 0))
-			goto err_io_dev_init;
-
-		break;
-
-	case S32G_FIP_BOOT:
-		handle = s32g_fip_dev_handle;
-
-		if (register_io_dev_fip(&s32g_fip_io_dev))
-			goto err_register;
-
-		if (io_dev_open(s32g_fip_io_dev,
-				(uintptr_t)&bl31_uuid_spec,
-				&s32g_fip_dev_handle))
-			goto err_io_dev_open;
-
-		if (io_dev_init(s32g_fip_dev_handle, 0))
-			goto err_io_dev_init;
-
-		break;
-
-	default:
-		ERROR("Unknown boot source: %d", boot_source);
-		goto err_boot_source;
-	}
+	if (s32g274a_mmc_register())
+		goto err;
+	if (register_io_dev_mmc(&s32g_mmc_io_conn))
+		goto err;
+	if (io_dev_open(s32g_mmc_io_conn, (uintptr_t)&fip_mmc_spec,
+			&s32g_mmc_dev_handle))
+		goto err;
+	if (io_dev_init(s32g_mmc_dev_handle, 0))
+		goto err;
+
+	if (register_io_dev_fip(&s32g_fip_io_conn))
+		goto err;
+	if (io_dev_open(s32g_fip_io_conn, (uintptr_t)&bl31_uuid_spec,
+			&s32g_fip_dev_handle))
+		goto err;
+	if (io_dev_init(s32g_fip_dev_handle, 0))
+		goto err;
+
+	if (register_io_dev_memmap(&s32g_memmap_io_conn))
+		goto err;
+	if (io_dev_open(s32g_memmap_io_conn, (uintptr_t)&fip_memmap_spec,
+			&s32g_memmap_dev_handle))
+		goto err;
+	if (io_dev_init(s32g_memmap_dev_handle,
+			(uintptr_t)FIP_BACKEND_MEMMAP_ID))
+		goto err;
 
 	return;
-
-err_io_dev_init:
-	io_dev_close(handle);
-err_io_dev_open:
-err_boot_source:
-err_register:
+err:
+	ERROR("Error: %s failed\n", __func__);
 	panic();
 }
-
-void s32g_io_setup(void)
-{
-	plat_s32g_io_setup(S32G_MMC_BOOT);
-	plat_s32g_io_setup(S32G_FIP_BOOT);
-}
-- 
2.17.1

