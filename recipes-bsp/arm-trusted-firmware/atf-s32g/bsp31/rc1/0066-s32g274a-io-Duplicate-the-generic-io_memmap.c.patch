From 1b0badf84a3326d137cf97daf9a85f43387095b2 Mon Sep 17 00:00:00 2001
From: Dan Nica <dan.nica@nxp.com>
Date: Wed, 5 Feb 2020 14:14:52 +0200
Subject: [PATCH 066/269] s32g274a: io: Duplicate the generic 'io_memmap.c'

Duplicate the 'io_memmap.c' from 'drivers/io' and place it
in 'drivers/nxp/s32g'. This will allow us to modify some
callbacks and implement platform specific improvements.

Issue: ALB-4576
Upstream-Status: Pending 

Signed-off-by: Dan Nica <dan.nica@nxp.com>
Signed-off-by: Zhantao Tang <zhantao.tang@windriver.com>
---
 drivers/nxp/s32g/io/io_memmap.c | 193 ++++++++++++++++++++++++++++++++
 plat/s32g/platform.mk           |   2 +-
 2 files changed, 194 insertions(+), 1 deletion(-)
 create mode 100644 drivers/nxp/s32g/io/io_memmap.c

diff --git a/drivers/nxp/s32g/io/io_memmap.c b/drivers/nxp/s32g/io/io_memmap.c
new file mode 100644
index 000000000..aca5e4256
--- /dev/null
+++ b/drivers/nxp/s32g/io/io_memmap.c
@@ -0,0 +1,193 @@
+/*
+ * Copyright (c) 2014-2018, ARM Limited and Contributors. All rights reserved.
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ */
+
+#include <assert.h>
+#include <string.h>
+#include <platform_def.h>
+#include <common/debug.h>
+#include <drivers/io/io_driver.h>
+#include <drivers/io/io_memmap.h>
+#include <drivers/io/io_storage.h>
+#include <lib/utils.h>
+
+/* As we need to be able to keep state for seek, only one file can be open
+ * at a time. Make this a structure and point to the entity->info. When we
+ * can malloc memory we can change this to support more open files.
+ */
+struct file_state {
+	/* Use the 'in_use' flag as any value for base and file_pos could be
+	 * valid.
+	 */
+	int		in_use;
+	uintptr_t	base;
+	size_t		file_pos;
+	size_t		size;
+};
+
+static struct file_state current_file = {0};
+
+static io_type_t device_type_memmap(void)
+{
+	return IO_TYPE_MEMMAP;
+}
+
+static const io_dev_info_t memmap_dev_info;
+
+static int memmap_dev_open(const uintptr_t dev_spec __unused,
+			   io_dev_info_t **dev_info)
+{
+	assert(dev_info);
+	*dev_info = (io_dev_info_t *)&memmap_dev_info;
+
+	return 0;
+}
+
+static const io_dev_connector_t memmap_dev_connector = {
+	.dev_open = memmap_dev_open
+};
+
+static int memmap_dev_close(io_dev_info_t *dev_info)
+{
+	return 0;
+}
+
+static int memmap_block_open(io_dev_info_t *dev_info, const uintptr_t spec,
+			     io_entity_t *entity)
+{
+	int result = -ENOMEM;
+	const io_block_spec_t *block_spec = (io_block_spec_t *)spec;
+
+	/* Since we need to track open state for seek() we only allow one open
+	 * spec at a time. When we have dynamic memory we can malloc and set
+	 * entity->info.
+	 */
+	if (current_file.in_use == 0) {
+		assert(block_spec);
+		assert(entity);
+
+		current_file.in_use = 1;
+		current_file.base = block_spec->offset;
+		current_file.file_pos = 0;
+		current_file.size = block_spec->length;
+		entity->info = (uintptr_t)&current_file;
+		result = 0;
+	} else {
+		WARN("A Memmap device is already active. Close first.\n");
+	}
+
+	return result;
+}
+
+static int memmap_block_seek(io_entity_t *entity, int mode, ssize_t offset)
+{
+	int result = -ENOENT;
+	struct file_state *fp;
+
+	/* We only support IO_SEEK_SET for the moment. */
+	if (mode == IO_SEEK_SET) {
+		assert(entity);
+		fp = (struct file_state *)entity->info;
+		assert((offset >= 0) && (offset < fp->size));
+		fp->file_pos = offset;
+		result = 0;
+	}
+
+	return result;
+}
+
+static int memmap_block_len(io_entity_t *entity, size_t *length)
+{
+	assert(entity);
+	assert(length);
+
+	*length = ((struct file_state *)entity->info)->size;
+
+	return 0;
+}
+
+static int memmap_block_read(io_entity_t *entity, uintptr_t buffer,
+			     size_t length, size_t *length_read)
+{
+	struct file_state *fp;
+	size_t pos_after;
+
+	assert(entity);
+	assert(length_read);
+
+	fp = (struct file_state *)entity->info;
+	pos_after = fp->file_pos + length;
+	assert((pos_after >= fp->file_pos) && (pos_after <= fp->size));
+
+	memcpy((void *)buffer, (void *)(fp->base + fp->file_pos), length);
+
+	*length_read = length;
+	fp->file_pos = pos_after;
+
+	return 0;
+}
+
+static int memmap_block_write(io_entity_t *entity, const uintptr_t buffer,
+			      size_t length, size_t *length_written)
+{
+	struct file_state *fp;
+	size_t pos_after;
+
+	assert(entity);
+	assert(length_written);
+
+	fp = (struct file_state *)entity->info;
+	pos_after = fp->file_pos + length;
+	assert((pos_after >= fp->file_pos) && (pos_after <= fp->size));
+
+	memcpy((void *)(fp->base + fp->file_pos), (void *)buffer, length);
+
+	*length_written = length;
+	fp->file_pos = pos_after;
+
+	return 0;
+}
+
+static int memmap_block_close(io_entity_t *entity)
+{
+	assert(entity);
+
+	entity->info = 0;
+
+	/* This would be a mem free() if we had malloc.*/
+	zeromem((void *)&current_file, sizeof(current_file));
+
+	return 0;
+}
+
+int register_io_dev_memmap(const io_dev_connector_t **dev_con)
+{
+	int result;
+
+	assert(dev_con);
+
+	result = io_register_device(&memmap_dev_info);
+	if (result == 0)
+		*dev_con = &memmap_dev_connector;
+
+	return result;
+}
+
+static const io_dev_funcs_t memmap_dev_funcs = {
+	.type = device_type_memmap,
+	.open = memmap_block_open,
+	.seek = memmap_block_seek,
+	.size = memmap_block_len,
+	.read = memmap_block_read,
+	.write = memmap_block_write,
+	.close = memmap_block_close,
+	.dev_init = NULL,
+	.dev_close = memmap_dev_close,
+};
+
+static const io_dev_info_t memmap_dev_info = {
+	.funcs = &memmap_dev_funcs,
+	.info = (uintptr_t)NULL
+};
diff --git a/plat/s32g/platform.mk b/plat/s32g/platform.mk
index eec4fa734..eb0496423 100644
--- a/plat/s32g/platform.mk
+++ b/plat/s32g/platform.mk
@@ -33,8 +33,8 @@ BL2_SOURCES		+= plat/s32g/s32g_lowlevel_bl2.S \
 			   plat/s32g/s32g_pinctrl.c \
 			   plat/s32g/s32g274a_storage.c \
 			   drivers/io/io_storage.c \
-			   drivers/io/io_memmap.c \
 			   common/desc_image_load.c \
+			   drivers/nxp/s32g/io/io_memmap.c \
 			   ${DDR_DRV}/ddrss.c \
 			   ${DDR_DRV}/ddrss_firmware.c \
 			   ${DDR_DRV}/ddrss_regconf.c
-- 
2.17.1

