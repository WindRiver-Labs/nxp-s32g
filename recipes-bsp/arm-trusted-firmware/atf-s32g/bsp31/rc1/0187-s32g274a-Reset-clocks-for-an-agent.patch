From 8b6ccf17f94b37f3a9d9261f6f3345d4d20ea6ae Mon Sep 17 00:00:00 2001
From: Ghennadi Procopciuc <Ghennadi.Procopciuc@nxp.com>
Date: Tue, 3 Nov 2020 10:46:39 +0200
Subject: [PATCH 187/269] s32g274a: Reset clocks for an agent

Issue: ALB-5510
Upstream-Status: Pending 

Signed-off-by: Ghennadi Procopciuc <Ghennadi.Procopciuc@nxp.com>
Signed-off-by: Zhantao Tang <zhantao.tang@windriver.com>
---
 .../drivers/nxp/s32g/clk/s32gen1_scmi_clk.h   |  1 +
 plat/nxp/s32g/s32g_scmi_clk.c                 | 99 ++++++++++++++++++-
 plat/nxp/s32g/s32g_svc.c                      |  6 ++
 3 files changed, 102 insertions(+), 4 deletions(-)

diff --git a/include/drivers/nxp/s32g/clk/s32gen1_scmi_clk.h b/include/drivers/nxp/s32g/clk/s32gen1_scmi_clk.h
index cbe368bcb..1c222acb9 100644
--- a/include/drivers/nxp/s32g/clk/s32gen1_scmi_clk.h
+++ b/include/drivers/nxp/s32g/clk/s32gen1_scmi_clk.h
@@ -56,6 +56,7 @@ int s32gen1_scmi_clk_get_rates(struct clk *clk, unsigned long *rates,
 			       size_t *nrates);
 unsigned long s32gen1_scmi_clk_get_rate(struct clk *clk);
 unsigned long s32gen1_scmi_clk_set_rate(struct clk *clk, unsigned long rate);
+int32_t plat_scmi_clock_agent_reset(unsigned int agent_id);
 
 #endif
 
diff --git a/plat/nxp/s32g/s32g_scmi_clk.c b/plat/nxp/s32g/s32g_scmi_clk.c
index b83e5beb0..cf0029273 100644
--- a/plat/nxp/s32g/s32g_scmi_clk.c
+++ b/plat/nxp/s32g/s32g_scmi_clk.c
@@ -5,12 +5,87 @@
  */
 #include <cdefs.h>
 #include <clk/s32gen1_scmi_clk.h>
+#include <common/debug.h>
 #include <drivers/st/scmi-msg.h>
 #include <drivers/st/scmi.h>
+#include <dt-bindings/clock/s32gen1-scmi-clock.h>
 #include <errno.h>
+#include <lib/utils_def.h>
 
 #define S32GEN1_CLK_DRV_NAME	"clks"
 
+#ifndef S32GEN1_CLK_MAX_AGENTS
+#define S32GEN1_CLK_MAX_AGENTS	2
+#endif
+
+/* Clocks state for each agent */
+static uint8_t clk_states[S32GEN1_CLK_MAX_AGENTS][S32GEN1_SCMI_CLK_MAX_ID];
+
+static bool is_agent_valid(unsigned int agent_id)
+{
+	if (agent_id >= ARRAY_SIZE(clk_states)) {
+		ERROR("Unable to register agent %d due to %s size\n",
+		      agent_id, __STRING(S32GEN1_CLK_MAX_AGENTS));
+		return false;
+	}
+
+	return true;
+}
+
+static bool valid_agent_clk(unsigned int agent_id, unsigned int clk_id,
+			    bool enable)
+{
+	if (!is_agent_valid(agent_id))
+		return false;
+
+	if (clk_id >= ARRAY_SIZE(clk_states[0])) {
+		ERROR("Unable to register clock %d due to %s size\n",
+		      clk_id, __STRING(S32GEN1_SCMI_CLK_MAX_ID));
+		return false;
+	}
+
+	if (!enable && !clk_states[agent_id][clk_id]) {
+		ERROR("Trying to disable a disabled clock %s\n",
+		      s32gen1_scmi_clk_get_name(clk_id));
+		return false;
+	}
+
+	if (enable && (clk_states[agent_id][clk_id] == UINT8_MAX)) {
+		ERROR("Too many clock enable operations for clock %s\n",
+		      s32gen1_scmi_clk_get_name(clk_id));
+		return false;
+	}
+
+	return true;
+}
+
+int32_t plat_scmi_clock_agent_reset(unsigned int agent_id)
+{
+	size_t i, j;
+
+	if (!is_agent_valid(agent_id))
+		return SCMI_INVALID_PARAMETERS;
+
+	for (i = 0; i < ARRAY_SIZE(clk_states[agent_id]); i++) {
+		if (!clk_states[agent_id][i])
+			continue;
+
+		for (j = 0; j < clk_states[agent_id][i]; j++)
+			plat_scmi_clock_set_state(agent_id, i, false);
+	}
+
+	return 0;
+}
+
+static void update_clk_refcnt(unsigned int agent_id, unsigned int clk_id,
+			      bool enable)
+{
+	if (!enable)
+		clk_states[agent_id][clk_id]--;
+	else
+		clk_states[agent_id][clk_id]++;
+}
+
 size_t plat_scmi_clock_count(unsigned int agent_id __unused)
 {
 	return s32gen1_scmi_nclocks();
@@ -43,14 +118,14 @@ int32_t plat_scmi_clock_rates_array(unsigned int agent_id, unsigned int scmi_id,
 	if (ret == -EINVAL)
 		return SCMI_INVALID_PARAMETERS;
 
-	return 0;
+	return SCMI_SUCCESS;
 }
 
 int32_t plat_scmi_clock_rates_by_step(unsigned int agent_id,
 				      unsigned int scmi_id,
 				      unsigned long *min_max_step)
 {
-	return -EINVAL;
+	return SCMI_NOT_SUPPORTED;
 }
 
 unsigned long plat_scmi_clock_get_rate(unsigned int agent_id,
@@ -72,12 +147,19 @@ int32_t plat_scmi_clock_set_rate(unsigned int agent_id, unsigned int scmi_id,
 	struct clk_driver *drv;
 	struct clk clk;
 
+	/**
+	 * Limitation: The rate of a clock cannot be
+	 * changed once it's enabled
+	 */
+	if (s32gen1_scmi_clk_is_enabled(scmi_id))
+		return SCMI_DENIED;
+
 	drv = get_clk_driver_by_name(S32GEN1_CLK_DRV_NAME);
 	clk.drv = drv;
 	clk.id = scmi_id;
 
 	if (s32gen1_scmi_clk_set_rate(&clk, rate) != rate)
-		return -EINVAL;
+		return SCMI_INVALID_PARAMETERS;
 
 	return s32gen1_scmi_enable(&clk, true);
 }
@@ -95,10 +177,19 @@ int32_t plat_scmi_clock_set_state(unsigned int agent_id, unsigned int scmi_id,
 {
 	struct clk_driver *drv;
 	struct clk clk;
+	int ret;
 
 	drv = get_clk_driver_by_name(S32GEN1_CLK_DRV_NAME);
 	clk.drv = drv;
 	clk.id = scmi_id;
 
-	return s32gen1_scmi_enable(&clk, enable_not_disable);
+	if (!valid_agent_clk(agent_id, scmi_id, enable_not_disable))
+		return SCMI_INVALID_PARAMETERS;
+
+	ret = s32gen1_scmi_enable(&clk, enable_not_disable);
+	if (!ret)
+		update_clk_refcnt(agent_id, scmi_id, enable_not_disable);
+
+	return ret;
 }
+
diff --git a/plat/nxp/s32g/s32g_svc.c b/plat/nxp/s32g/s32g_svc.c
index fcaa2bdd7..759dbd1cd 100644
--- a/plat/nxp/s32g/s32g_svc.c
+++ b/plat/nxp/s32g/s32g_svc.c
@@ -3,6 +3,7 @@
  *
  * SPDX-License-Identifier: BSD-3-Clause
  */
+#include <clk/s32gen1_scmi_clk.h>
 #include <common/debug.h>
 #include <common/runtime_svc.h>
 #include <drivers/st/scmi.h>
@@ -54,6 +55,11 @@ const uint8_t *plat_scmi_protocol_list(unsigned int agent_id)
 	return s32g_protocols;
 }
 
+int32_t plat_scmi_reset_agent(unsigned int agent_id)
+{
+	return plat_scmi_clock_agent_reset(agent_id);
+}
+
 size_t plat_scmi_protocol_count(void)
 {
 	return sizeof(s32g_protocols);
-- 
2.17.1

