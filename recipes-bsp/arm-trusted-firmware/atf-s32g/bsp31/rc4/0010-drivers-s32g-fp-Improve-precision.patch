From 56ea778da1292f191ea41117e5a2c11d62601362 Mon Sep 17 00:00:00 2001
From: Ghennadi Procopciuc <ghennadi.procopciuc@nxp.com>
Date: Fri, 22 Oct 2021 08:22:47 +0300
Subject: [PATCH 10/16] drivers: s32g: fp: Improve precision

Two improvements added here:
- allow 1 percent error when converting FP to uint64_t
- reduce precision during fp_div in case of overflows

Issue: ALB-7712
Upstream-Status: Pending 

Signed-off-by: Ghennadi Procopciuc <ghennadi.procopciuc@nxp.com>
Signed-off-by: Zhantao Tang <zhantao.tang@windriver.com>
---
 include/drivers/nxp/s32g/s32g_fp.h | 51 ++++++++++++++++++++++++++----
 1 file changed, 45 insertions(+), 6 deletions(-)

diff --git a/include/drivers/nxp/s32g/s32g_fp.h b/include/drivers/nxp/s32g/s32g_fp.h
index a4316cd80..24b821adf 100644
--- a/include/drivers/nxp/s32g/s32g_fp.h
+++ b/include/drivers/nxp/s32g/s32g_fp.h
@@ -1,11 +1,13 @@
 // SPDX-License-Identifier: BSD-3-Clause
 /*
- * Copyright 2020 NXP
+ * Copyright 2020-2021 NXP
  */
 #ifndef S32G_FP_H
 #define S32G_FP_H
 
-#define FP_PRECISION 100000000U
+#define FP_PRECISION		100000000U
+/* 1 percent error */
+#define FP_PRECISION_ERROR	(FP_PRECISION / 100U)
 
 struct fp_data {
 	uint64_t val;
@@ -22,28 +24,65 @@ static inline struct fp_data u2fp(uint64_t val)
 
 static inline uint64_t fp2u(struct fp_data val)
 {
-	return val.val / FP_PRECISION;
+	return (val.val + FP_PRECISION_ERROR) / FP_PRECISION;
 }
 
 static inline void __reduce_factors(uint64_t *a, uint64_t *b)
 {
-	while (*a % 10 == 0 && *b % 10 == 0) {
-		*a /= 10;
-		*b /= 10;
+	uint64_t factor;
+
+	for (factor = 2; factor <= 5; factor++) {
+		while (*a % factor == 0 && *b % factor == 0) {
+			*a /= factor;
+			*b /= factor;
+		}
 	}
 }
 
+static inline void __reduce_precision(uint64_t a, uint64_t b,
+				      uint64_t *precision_lost)
+{
+	uint64_t result;
+	bool overflow;
+
+	*precision_lost = 1;
+
+	if (!a || !b)
+		return;
+
+	do {
+		overflow = false;
+		result = a * b;
+
+		if (result / a != b) {
+			*precision_lost <<= 1;
+			a >>= 1;
+			b >>= 1;
+			overflow = true;
+		}
+	} while (overflow);
+}
+
 static inline struct fp_data fp_div(struct fp_data a, struct fp_data b)
 {
 	struct fp_data res;
 	uint64_t div_factor = FP_PRECISION;
+	uint64_t prec_factor;
 
 	/* Avoid overflow if possible */
 	__reduce_factors(&a.val, &b.val);
 	__reduce_factors(&div_factor, &b.val);
 
+	__reduce_precision(a.val, div_factor, &prec_factor);
+
+	/* Equivalent of a.val * div_factor / b.val */
+	a.val /= prec_factor;
+	b.val /= prec_factor;
+	div_factor /= prec_factor;
+
 	res.val = a.val * div_factor / b.val;
 
+	res.val *= prec_factor;
 	return res;
 }
 
-- 
2.17.1

