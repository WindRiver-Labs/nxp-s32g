From 9f7afa62cc9712fbc3f5a4e20be6fe7c7de97146 Mon Sep 17 00:00:00 2001
From: Ghennadi Procopciuc <ghennadi.procopciuc@nxp.com>
Date: Fri, 22 Oct 2021 07:57:32 +0300
Subject: [PATCH 06/16] s32g3: emu: Adapt LinFlex

Issue: ALB-7712
Upstream-Status: Pending 

Signed-off-by: Ghennadi Procopciuc <ghennadi.procopciuc@nxp.com>
Signed-off-by: Zhantao Tang <zhantao.tang@windriver.com>
---
 drivers/nxp/s32g/clk/early_clocks.c           | 10 ++++-
 drivers/nxp/uart/linflexuart.c                | 20 +++++++++-
 plat/nxp/s32/s32g/include/s32g_pinctrl.h      | 26 +++++++++++++
 plat/nxp/s32/s32g/include/s32g_platform_def.h |  8 ++++
 plat/nxp/s32/s32g/s32g_common.mk              |  4 ++
 plat/nxp/s32/s32g/s32g_pinctrl.c              | 39 +++++++++++++------
 6 files changed, 92 insertions(+), 15 deletions(-)

diff --git a/drivers/nxp/s32g/clk/early_clocks.c b/drivers/nxp/s32g/clk/early_clocks.c
index 1bfcb6ae9..326ddcac4 100644
--- a/drivers/nxp/s32g/clk/early_clocks.c
+++ b/drivers/nxp/s32g/clk/early_clocks.c
@@ -60,11 +60,13 @@ static struct clk xbar_2x = CLK_INIT(S32GEN1_CLK_XBAR_2X);
 /* LINFLEX clock */
 static struct clk periph_pll_mux = CLK_INIT(S32GEN1_CLK_PERIPH_PLL_MUX);
 static struct clk periph_pll_vco = CLK_INIT(S32GEN1_CLK_PERIPH_PLL_VCO);
+#if S32G_EMU == 0
 static struct clk periph_pll_phi3 = CLK_INIT(S32GEN1_CLK_PERIPH_PLL_PHI3);
-static struct clk periph_dfs3 = CLK_INIT(S32GEN1_CLK_PERIPH_PLL_DFS3);
 static struct clk mc_cgm0_mux8 = CLK_INIT(S32GEN1_CLK_MC_CGM0_MUX8);
-static struct clk mc_cgm0_mux14 = CLK_INIT(S32GEN1_CLK_MC_CGM0_MUX14);
 static struct clk lin_baud = CLK_INIT(S32GEN1_CLK_LIN_BAUD);
+#endif
+static struct clk periph_dfs3 = CLK_INIT(S32GEN1_CLK_PERIPH_PLL_DFS3);
+static struct clk mc_cgm0_mux14 = CLK_INIT(S32GEN1_CLK_MC_CGM0_MUX14);
 static struct clk sdhc = CLK_INIT(S32GEN1_CLK_SDHC);
 
 /* DDR clock */
@@ -118,6 +120,7 @@ static int enable_xbar_clock(void)
 	return s32gen1_enable(&xbar_2x, 1);
 }
 
+#if S32G_EMU == 0
 static int enable_lin_clock(void)
 {
 	int ret;
@@ -142,6 +145,7 @@ static int enable_lin_clock(void)
 
 	return s32gen1_enable(&lin_baud, 1);
 }
+#endif
 
 static int enable_sdhc_clock(void)
 {
@@ -208,9 +212,11 @@ int s32g_plat_clock_init(bool skip_ddr_clk)
 	if (ret)
 		return ret;
 
+#if S32G_EMU == 0
 	ret = enable_lin_clock();
 	if (ret)
 		return ret;
+#endif
 
 	ret = enable_sdhc_clock();
 	if (ret)
diff --git a/drivers/nxp/uart/linflexuart.c b/drivers/nxp/uart/linflexuart.c
index 7f00885ca..b3777a125 100644
--- a/drivers/nxp/uart/linflexuart.c
+++ b/drivers/nxp/uart/linflexuart.c
@@ -50,6 +50,18 @@ static uint32_t linflex_read(uintptr_t base, uintptr_t reg)
 	return mmio_read_32(base + reg);
 }
 
+#if S32G_EMU == 1
+static uint32_t get_ldiv_mult(struct console_linflex *cons)
+{
+	return 1;
+}
+
+static uint32_t get_lin_rate(struct console_linflex *cons)
+{
+	// Rate in Hz
+	return 133000;
+}
+#else
 static uint32_t get_ldiv_mult(struct console_linflex *cons)
 {
 	uint32_t mult, cr;
@@ -64,11 +76,17 @@ static uint32_t get_ldiv_mult(struct console_linflex *cons)
 	return mult;
 }
 
+static uint32_t get_lin_rate(struct console_linflex *cons)
+{
+	return cons->clock;
+}
+#endif
+
 static void linflex_set_brg(struct console_linflex *cons)
 {
 	uint32_t ibr, fbr;
 	uintptr_t base = cons->base;
-	uint32_t divisr = cons->clock;
+	uint32_t divisr = get_lin_rate(cons);
 	uint32_t dividr = (uint32_t)(cons->baud * get_ldiv_mult(cons));
 
 	ibr = (uint32_t)(divisr / dividr);
diff --git a/plat/nxp/s32/s32g/include/s32g_pinctrl.h b/plat/nxp/s32/s32g/include/s32g_pinctrl.h
index 86a3baff9..d8753ef2e 100644
--- a/plat/nxp/s32/s32g/include/s32g_pinctrl.h
+++ b/plat/nxp/s32/s32g/include/s32g_pinctrl.h
@@ -54,10 +54,36 @@
 #define SIUL2_IMCR_S32G_G1_UART0_RXD_to_pad	\
 	(SIUL2_MSCR_MUX_MODE_ALT2)
 
+#if S32G_EMU == 1
+#define SIUL2_MSCR_S32G_G1_PORT_CTRL_UART1_TXD	 \
+	(SIUL2_MSCR_S32_G1_SRC_100MHz |		 \
+	 SIUL2_MSCR_S32_G1_OBE_EN |		 \
+	 SIUL2_MSCR_MUX_MODE_ALT1)
+#else
+#define SIUL2_MSCR_S32G_G1_PORT_CTRL_UART1_TXD	 \
+	(SIUL2_MSCR_S32_G1_SRC_100MHz |		 \
+	 SIUL2_MSCR_S32_G1_OBE_EN |		 \
+	 SIUL2_MSCR_MUX_MODE_ALT2)
+#endif
+
+#if S32G_EMU == 1
+#define SIUL2_IMCR_S32G_G1_UART1_RXD_to_pad	(SIUL2_MSCR_MUX_MODE_ALT3)
+#else
+#define SIUL2_IMCR_S32G_G1_UART1_RXD_to_pad	(SIUL2_MSCR_MUX_MODE_ALT4)
+#endif
+
+
+
+/* LinFLEX 0 */
 #define SIUL2_PC09_MSCR_S32_G1_UART0		41
 #define SIUL2_PC10_MSCR_S32_G1_UART0		42
 #define SIUL2_PC10_IMCR_S32_G1_UART0		(512 - 512)
 
+/* LinFLEX 1 */
+#define SIUL2_PB09_MSCR_S32_G1_UART1		25
+#define SIUL2_PB10_MSCR_S32_G1_UART1		26
+#define SIUL2_PB10_IMCR_S32_G1_UART1		(736 - 512)
+
 /*
  * Pinctrl for SDHC
  */
diff --git a/plat/nxp/s32/s32g/include/s32g_platform_def.h b/plat/nxp/s32/s32g/include/s32g_platform_def.h
index 7b8350bc8..bd40a8d86 100644
--- a/plat/nxp/s32/s32g/include/s32g_platform_def.h
+++ b/plat/nxp/s32/s32g/include/s32g_platform_def.h
@@ -221,8 +221,16 @@
 
 #define S32G_LINFLEX0_BASE	(0x401C8000ul)
 #define S32G_LINFLEX0_SIZE	(0x4000)
+#define S32G_LINFLEX1_BASE	(0x401CC000ul)
+#define S32G_LINFLEX1_SIZE	(0x4000)
+
+#if S32G_EMU == 1
+#define S32G_UART_BASE		S32G_LINFLEX1_BASE
+#define S32G_UART_SIZE		S32G_LINFLEX1_SIZE
+#else
 #define S32G_UART_BASE		S32G_LINFLEX0_BASE
 #define S32G_UART_SIZE		S32G_LINFLEX0_SIZE
+#endif
 
 #define S32G_SCMI_SHARED_MEM		0xd0000000U
 #define S32G_SCMI_SHARED_MEM_SIZE	0x400000U
diff --git a/plat/nxp/s32/s32g/s32g_common.mk b/plat/nxp/s32/s32g/s32g_common.mk
index ba03b4a05..df4499cf4 100644
--- a/plat/nxp/s32/s32g/s32g_common.mk
+++ b/plat/nxp/s32/s32g/s32g_common.mk
@@ -227,7 +227,11 @@ ERRATA_SPECULATIVE_AT	:= 1
 
 ### Platform-specific defines ###
 # Which LinFlexD to use as a UART device
+ifeq ($(S32G_EMU),0)
 S32G_LINFLEX_MODULE	:= 0
+else
+S32G_LINFLEX_MODULE	:= 1
+endif
 $(eval $(call add_define_val,S32G_LINFLEX_MODULE,$(S32G_LINFLEX_MODULE)))
 # Sharing the LinFlexD UART is not always a safe option. Different drivers
 # (e.g. Linux and TF-A) can configure the UART controller differently; even so,
diff --git a/plat/nxp/s32/s32g/s32g_pinctrl.c b/plat/nxp/s32/s32g/s32g_pinctrl.c
index 932ea5f55..b26d41ee4 100644
--- a/plat/nxp/s32/s32g/s32g_pinctrl.c
+++ b/plat/nxp/s32/s32g/s32g_pinctrl.c
@@ -1,5 +1,5 @@
 /*
- * Copyright 2019-2020 NXP
+ * Copyright 2019-2021 NXP
  *
  * SPDX-License-Identifier: BSD-3-Clause
  */
@@ -10,17 +10,32 @@
 
 static void linflex_config_pinctrl(int lf)
 {
-	assert(lf == 0);
-
-	/* set PC09 - MSCR[41] - for UART0 TXD */
-	mmio_write_32(SIUL2_0_MSCRn(SIUL2_PC09_MSCR_S32_G1_UART0),
-		      SIUL2_MSCR_S32G_G1_PORT_CTRL_UART0_TXD);
-	/* set PC10 - MSCR[42] - for UART0 RXD */
-	mmio_write_32(SIUL2_0_MSCRn(SIUL2_PC10_MSCR_S32_G1_UART0),
-		      SIUL2_MSCR_S32G_G1_PORT_CTRL_UART_RXD);
-	/* set PC10 - MSCR[512]/IMCR[0] - for UART0 RXD */
-	mmio_write_32(SIUL2_0_IMCRn(SIUL2_PC10_IMCR_S32_G1_UART0),
-		      SIUL2_IMCR_S32G_G1_UART0_RXD_to_pad);
+	if (!lf) {
+		/* set PC09 - MSCR[41] - for UART0 TXD */
+		mmio_write_32(SIUL2_0_MSCRn(SIUL2_PC09_MSCR_S32_G1_UART0),
+			      SIUL2_MSCR_S32G_G1_PORT_CTRL_UART0_TXD);
+		/* set PC10 - MSCR[42] - for UART0 RXD */
+		mmio_write_32(SIUL2_0_MSCRn(SIUL2_PC10_MSCR_S32_G1_UART0),
+			      SIUL2_MSCR_S32G_G1_PORT_CTRL_UART_RXD);
+		/* set PC10 - MSCR[512]/IMCR[0] - for UART0 RXD */
+		mmio_write_32(SIUL2_0_IMCRn(SIUL2_PC10_IMCR_S32_G1_UART0),
+			      SIUL2_IMCR_S32G_G1_UART0_RXD_to_pad);
+		return;
+	}
+
+	if (lf == 1) {
+		/* set PB09 - MSCR[25] - for UART1 TXD */
+		mmio_write_32(SIUL2_0_MSCRn(SIUL2_PB09_MSCR_S32_G1_UART1),
+			      SIUL2_MSCR_S32G_G1_PORT_CTRL_UART1_TXD);
+
+		/* set PB10 - MSCR[26] - for UART1 RXD */
+		mmio_write_32(SIUL2_0_MSCRn(SIUL2_PB10_MSCR_S32_G1_UART1),
+			      SIUL2_MSCR_S32G_G1_PORT_CTRL_UART_RXD);
+
+		/* set PB10 - MSCR[736]/IMCR[224] - for UART1 RXD */
+		mmio_write_32(SIUL2_1_IMCRn(SIUL2_PB10_IMCR_S32_G1_UART1),
+			      SIUL2_IMCR_S32G_G1_UART1_RXD_to_pad);
+	}
 }
 
 static void sdhc_config_pinctrl(void)
-- 
2.17.1

