From ba2f65a6f91d25db4624bb67139f4bc610b640c7 Mon Sep 17 00:00:00 2001
From: Andrei Cherechesu <andrei.cherechesu@nxp.com>
Date: Thu, 14 Oct 2021 04:06:54 +0300
Subject: [PATCH 19/24] s32g2: Update DDR firmware to 2020_06_SP2 Update 1

This commit updates the DDR driver for S32G274A Rev2 to
firmware 2020_06_SP2 generated with S32CT v1.4 Update 1.

Issue: ALB-7757
Upstream-Status: Pending 

Signed-off-by: Andrei Cherechesu <andrei.cherechesu@nxp.com>
Signed-off-by: Zhantao Tang <zhantao.tang@windriver.com>
---
 drivers/nxp/s32g/ddr/ddr_init.c          |  56 +--
 drivers/nxp/s32g/ddr/ddr_lp_mmio.c       |  49 ++-
 drivers/nxp/s32g/ddr/ddr_utils_mmio.c    | 531 ++++++++++++-----------
 drivers/nxp/s32g/ddr/ddrss_cfg.c         |  44 +-
 drivers/nxp/s32g/ddr/dmem_cfg.c          |   8 +-
 drivers/nxp/s32g/ddr/imem_cfg.c          |   8 +-
 include/drivers/nxp/s32g/ddr/ddr_init.h  |  49 ++-
 include/drivers/nxp/s32g/ddr/ddr_lp.h    |  15 +-
 include/drivers/nxp/s32g/ddr/ddr_utils.h | 249 +++++++----
 9 files changed, 574 insertions(+), 435 deletions(-)

diff --git a/drivers/nxp/s32g/ddr/ddr_init.c b/drivers/nxp/s32g/ddr/ddr_init.c
index a511a75f3..f5cc84bb4 100644
--- a/drivers/nxp/s32g/ddr/ddr_init.c
+++ b/drivers/nxp/s32g/ddr/ddr_init.c
@@ -31,10 +31,10 @@
 #include <ddr/ddr_init.h>
 #include <lib/mmio.h>
 
-static uint32_t ddrc_init_cfg(struct ddrss_config *config);
-static uint32_t execute_training(struct ddrss_config *config);
+static uint32_t ddrc_init_cfg(const struct ddrss_config *config);
+static uint32_t execute_training(const struct ddrss_config *config);
 static uint32_t load_phy_image(uint32_t start_addr, size_t size,
-			       uint16_t image[]);
+			       const uint16_t image[]);
 
 /* Main method needed to initialize ddr subsystem. */
 uint32_t ddr_init(void)
@@ -61,7 +61,8 @@ uint32_t ddr_init(void)
 			return ret;
 
 		/* Execute post training setup */
-		ret = post_train_setup(STORE_CSR_MASK | INIT_MEM_MASK);
+		ret = post_train_setup((uint8_t)(STORE_CSR_MASK |
+						 INIT_MEM_MASK));
 		if (ret != NO_ERR)
 			return ret;
 	}
@@ -69,25 +70,25 @@ uint32_t ddr_init(void)
 }
 
 /* Initialize ddr controller with given settings. */
-static uint32_t ddrc_init_cfg(struct ddrss_config *config)
+static uint32_t ddrc_init_cfg(const struct ddrss_config *config)
 {
 	uint32_t ret = NO_ERR;
 
-	ret = load_register_cfg(config->ddrc_cfg_size, config->ddrc_cfg);
+	ret = load_register_cfg(config->ddrc_size, config->ddrc);
 	return ret;
 }
 
 /* Execute phy training with given settings. 2D training stage is optional. */
-static uint32_t execute_training(struct ddrss_config *config)
+static uint32_t execute_training(const struct ddrss_config *config)
 {
 	uint32_t ret = NO_ERR;
 	/* Apply DQ swapping settings */
-	ret = load_dq_cfg(config->dq_swap_cfg_size, config->dq_swap_cfg);
+	ret = load_dq_cfg(config->dq_swap_size, config->dq_swap);
 	if (ret != NO_ERR)
 		return ret;
 
 	/* Initialize phy module */
-	ret = load_register_cfg_16(config->phy_cfg_size, config->phy_cfg);
+	ret = load_register_cfg_16(config->phy_size, config->phy);
 	if (ret != NO_ERR)
 		return ret;
 
@@ -111,9 +112,9 @@ static uint32_t execute_training(struct ddrss_config *config)
 	set_optimal_pll();
 
 	mmio_write_32(MICROCONT_MUX_SEL, LOCK_CSR_ACCESS);
-	mmio_write_32(APBONLY_MICRORESET, 0x00000009);
-	mmio_write_32(APBONLY_MICRORESET, 0x00000001);
-	mmio_write_32(APBONLY_MICRORESET, 0x00000000);
+	mmio_write_32(APBONLY_MICRORESET, APBONLY_RESET_STALL_MASK);
+	mmio_write_32(APBONLY_MICRORESET, APBONLY_STALL_TO_MICRO_MASK);
+	mmio_write_32(APBONLY_MICRORESET, APBONLY_MICRORESET_CLR_MASK);
 
 	ret = wait_firmware_execution();
 	mmio_write_32(MICROCONT_MUX_SEL, UNLOCK_CSR_ACCESS);
@@ -124,7 +125,7 @@ static uint32_t execute_training(struct ddrss_config *config)
 	 * Check if 2d training images have been initialized before executing
 	 * the second training stage.
 	 */
-	if (config->imem_2d_size > 0 && config->dmem_2d_size > 0) {
+	if (config->imem_2d_size > 0U && config->dmem_2d_size > 0U) {
 		/* Load 2d imem image */
 		mmio_write_32(MICROCONT_MUX_SEL, UNLOCK_CSR_ACCESS);
 		ret = load_phy_image(IMEM_START_ADDR, config->imem_2d_size,
@@ -145,9 +146,9 @@ static uint32_t execute_training(struct ddrss_config *config)
 		set_optimal_pll();
 
 		mmio_write_32(MICROCONT_MUX_SEL, LOCK_CSR_ACCESS);
-		mmio_write_32(APBONLY_MICRORESET, 0x00000009);
-		mmio_write_32(APBONLY_MICRORESET, 0x00000001);
-		mmio_write_32(APBONLY_MICRORESET, 0x00000000);
+		mmio_write_32(APBONLY_MICRORESET, APBONLY_RESET_STALL_MASK);
+		mmio_write_32(APBONLY_MICRORESET, APBONLY_STALL_TO_MICRO_MASK);
+		mmio_write_32(APBONLY_MICRORESET, APBONLY_MICRORESET_CLR_MASK);
 
 		ret = wait_firmware_execution();
 		if (ret != NO_ERR)
@@ -156,13 +157,13 @@ static uint32_t execute_training(struct ddrss_config *config)
 
 	mmio_write_32(MICROCONT_MUX_SEL, UNLOCK_CSR_ACCESS);
 	/*  Load pie image after training has executed */
-	ret = load_register_cfg_16(config->pie_cfg_size, config->pie_cfg);
+	ret = load_register_cfg_16(config->pie_size, config->pie);
 	mmio_write_32(MICROCONT_MUX_SEL, LOCK_CSR_ACCESS);
 	return ret;
 }
 
 /* Load register array into memory. */
-uint32_t load_register_cfg_16(size_t size, struct regconf_16 cfg[])
+uint32_t load_register_cfg_16(size_t size, const struct regconf_16 cfg[])
 {
 	size_t i;
 
@@ -173,7 +174,7 @@ uint32_t load_register_cfg_16(size_t size, struct regconf_16 cfg[])
 }
 
 /* Load register array into memory. */
-uint32_t load_register_cfg(size_t size, struct regconf cfg[])
+uint32_t load_register_cfg(size_t size, const struct regconf cfg[])
 {
 	size_t i;
 
@@ -184,7 +185,7 @@ uint32_t load_register_cfg(size_t size, struct regconf cfg[])
 }
 
 /* Load dq config array into memory. */
-uint32_t load_dq_cfg(size_t size, struct dqconf cfg[])
+uint32_t load_dq_cfg(size_t size, const struct dqconf cfg[])
 {
 	size_t i;
 
@@ -196,13 +197,14 @@ uint32_t load_dq_cfg(size_t size, struct dqconf cfg[])
 
 /* Load image into memory at consecutive addresses */
 static uint32_t load_phy_image(uint32_t start_addr, size_t size,
-			       uint16_t image[])
+			       const uint16_t image[])
 {
 	size_t i;
+	uint32_t current_addr = start_addr;
 
 	for (i = 0; i < size; i++) {
-		mmio_write_32((uintptr_t)start_addr, image[i]);
-		start_addr += sizeof(uint32_t);
+		mmio_write_32((uintptr_t)current_addr, image[i]);
+		current_addr += sizeof(uint32_t);
 	}
 	return NO_ERR;
 }
@@ -211,8 +213,8 @@ static uint32_t load_phy_image(uint32_t start_addr, size_t size,
 void set_optimal_pll(void)
 {
 	/* Configure phy pll for 3200MTS data rate */
-	mmio_write_32(MASTER_PLLCTRL1, 0x00000021);
-	mmio_write_32(MASTER_PLLTESTMODE, 0x00000024);
-	mmio_write_32(MASTER_PLLCTRL4, 0x0000017f);
-	mmio_write_32(MASTER_PLLCTRL2, 0x00000019);
+	mmio_write_32(MASTER_PLLCTRL1, PLLCTRL1_VALUE);
+	mmio_write_32(MASTER_PLLTESTMODE, PLLTESTMODE_VALUE);
+	mmio_write_32(MASTER_PLLCTRL4, PLLCTRL4_VALUE);
+	mmio_write_32(MASTER_PLLCTRL2, PLLCTRL2_VALUE);
 }
diff --git a/drivers/nxp/s32g/ddr/ddr_lp_mmio.c b/drivers/nxp/s32g/ddr/ddr_lp_mmio.c
index f06f9d629..8e1a2f81d 100644
--- a/drivers/nxp/s32g/ddr/ddr_lp_mmio.c
+++ b/drivers/nxp/s32g/ddr/ddr_lp_mmio.c
@@ -37,14 +37,15 @@ void store_csr(uintptr_t store_at)
 {
 	size_t i;
 	uint16_t csr;
+	uintptr_t current_addr = store_at;
 
 	mmio_write_32(MICROCONT_MUX_SEL, UNLOCK_CSR_ACCESS);
 	mmio_write_32(DDR_PHYA_UCCLKHCLKENABLES, HCLKEN_MASK | UCCLKEN_MASK);
 
 	for (i = 0; i < csr_to_store_size; i++) {
 		csr = mmio_read_16(DDRSS_BASE_ADDR + csr_to_store[i]);
-		mmio_write_16(store_at, csr);
-		store_at += sizeof(uint16_t);
+		mmio_write_16(current_addr, csr);
+		current_addr += sizeof(uint16_t);
 	}
 
 	mmio_write_32(DDR_PHYA_UCCLKHCLKENABLES, HCLKEN_MASK);
@@ -56,10 +57,11 @@ void load_csr(uintptr_t load_from)
 {
 	size_t i;
 	uint16_t csr;
+	uintptr_t current_addr = load_from;
 
 	for (i = 0; i < csr_to_store_size; i++) {
-		csr = mmio_read_16(load_from);
-		load_from += sizeof(uint16_t);
+		csr = mmio_read_16(current_addr);
+		current_addr += sizeof(uint16_t);
 		mmio_write_16(DDRSS_BASE_ADDR + csr_to_store[i], csr);
 	}
 }
@@ -70,14 +72,17 @@ void ddrss_to_io_retention_mode(void)
 	uint32_t sbrctl, pwrctl, swctl, dfimisc, tmp32;
 
 	/* Disable AXI Ports */
-	mmio_write_32(DDRC_UMCTL2_MP_BASE_ADDR + OFFSET_DDRC_PCTRL_0, 0);
-	mmio_write_32(DDRC_UMCTL2_MP_BASE_ADDR + OFFSET_DDRC_PCTRL_1, 0);
-	mmio_write_32(DDRC_UMCTL2_MP_BASE_ADDR + OFFSET_DDRC_PCTRL_2, 0);
+	mmio_write_32(DDRC_UMCTL2_MP_BASE_ADDR + OFFSET_DDRC_PCTRL_0,
+		      DISABLE_AXI_PORT);
+	mmio_write_32(DDRC_UMCTL2_MP_BASE_ADDR + OFFSET_DDRC_PCTRL_1,
+		      DISABLE_AXI_PORT);
+	mmio_write_32(DDRC_UMCTL2_MP_BASE_ADDR + OFFSET_DDRC_PCTRL_2,
+		      DISABLE_AXI_PORT);
 
 	do {
 		tmp32 = mmio_read_32(DDRC_UMCTL2_MP_BASE_ADDR +
 				     OFFSET_DDRC_STAT);
-	} while (tmp32 != 0);
+	} while (tmp32 != STAT_RESET_VALUE);
 
 	/* Disable Scrubber */
 	sbrctl = mmio_read_32(DDRC_BASE_ADDR + OFFSET_DDRC_SBRCTL);
@@ -85,7 +90,7 @@ void ddrss_to_io_retention_mode(void)
 		      (~SCRUB_EN_MASK));
 	do {
 		tmp32 = mmio_read_32(DDRC_BASE_ADDR + OFFSET_DDRC_SBRSTAT);
-	} while ((tmp32 & SCRUB_BUSY_MASK) != 0);
+	} while ((tmp32 & SCRUB_BUSY_MASK) != SBRSTAT_SCRUBBER_NOT_BUSY);
 
 	/* Move to Self Refresh */
 	pwrctl = mmio_read_32(DDRC_BASE_ADDR + OFFSET_DDRC_PWRCTL);
@@ -105,43 +110,45 @@ void ddrss_to_io_retention_mode(void)
 	} while ((tmp32 & SELFREF_STATE_MASK) != SELFREF_STATE_SRPD);
 
 	/* Transition Phy to LP3 */
-	mmio_write_32(DDRC_BASE_ADDR + OFFSET_DDRC_DFIMISC, 0);
+	mmio_write_32(DDRC_BASE_ADDR + OFFSET_DDRC_DFIMISC,
+		      DFIMISC_TRANSITION_PHY_TO_LP3);
 	swctl = mmio_read_32(DDRC_BASE_ADDR + OFFSET_DDRC_SWCTL);
 	mmio_write_32(DDRC_BASE_ADDR + OFFSET_DDRC_SWCTL, swctl &
 		      (~SW_DONE_MASK));
 
 	dfimisc = mmio_read_32(DDRC_BASE_ADDR + OFFSET_DDRC_DFIMISC);
 	mmio_write_32(DDRC_BASE_ADDR + OFFSET_DDRC_DFIMISC, dfimisc |
-		      DFI_FREQUENCY(0x1f));
+		      DFI_FREQUENCY(DFIMISC_LP3_PHY_STATE));
 
 	dfimisc = mmio_read_32(DDRC_BASE_ADDR + OFFSET_DDRC_DFIMISC);
 	mmio_write_32(DDRC_BASE_ADDR + OFFSET_DDRC_DFIMISC, dfimisc |
 		      DFI_INIT_START_MASK);
 	do {
 		tmp32 = mmio_read_32(DDRC_BASE_ADDR + OFFSET_DDRC_DFISTAT);
-	} while ((tmp32 & DFI_INIT_COMPLETE_MASK) != 0);
+	} while ((tmp32 & DFI_INIT_COMPLETE_MASK) !=
+		 DFISTAT_DFI_INIT_INCOMPLETE);
 
 	dfimisc = mmio_read_32(DDRC_BASE_ADDR + OFFSET_DDRC_DFIMISC);
 	mmio_write_32(DDRC_BASE_ADDR + OFFSET_DDRC_DFIMISC, dfimisc |
-		      DFI_FREQUENCY(0x1f));
+		      DFI_FREQUENCY(DFIMISC_LP3_PHY_STATE));
 	dfimisc = mmio_read_32(DDRC_BASE_ADDR + OFFSET_DDRC_DFIMISC);
 	mmio_write_32(DDRC_BASE_ADDR + OFFSET_DDRC_DFIMISC, dfimisc &
 		      (~DFI_INIT_START_MASK));
 	do {
 		tmp32 = mmio_read_32(DDRC_BASE_ADDR + OFFSET_DDRC_DFISTAT);
-	} while ((tmp32 & DFI_INIT_COMPLETE_MASK) == 0);
+	} while ((tmp32 & DFI_INIT_COMPLETE_MASK) ==
+		 DFISTAT_DFI_INIT_INCOMPLETE);
 
 	swctl = mmio_read_32(DDRC_BASE_ADDR + OFFSET_DDRC_SWCTL);
 	mmio_write_32(DDRC_BASE_ADDR + OFFSET_DDRC_SWCTL, swctl |
 		      SW_DONE_MASK);
 	do {
 		tmp32 = mmio_read_32(DDRC_BASE_ADDR + OFFSET_DDRC_SWSTAT);
-	} while ((tmp32 & SW_DONE_ACK_MASK) == 0);
+	} while ((tmp32 & SW_DONE_ACK_MASK) == SWSTAT_SW_NOT_DONE);
 
 	/* Set PwrOkIn to 0 */
 	tmp32 = mmio_read_32(DDR_RET_CONTROL_REG);
 	mmio_write_32(DDR_RET_CONTROL_REG, tmp32 & (~DDR_RET_CONTROL_MASK));
-
 	tmp32 = mmio_read_32(DDR_CONFIG_0_REG);
 	mmio_write_32(DDR_CONFIG_0_REG, tmp32 | DDR_CONFIG_0_MEM_RET);
 }
@@ -152,12 +159,12 @@ uint32_t ddrss_to_normal_mode(uintptr_t csr_array)
 	uint32_t pwrctl, init0, ret;
 
 	ret = load_register_cfg(ddrc_cfg_size, ddrc_cfg);
-	if (ret != 0)
+	if (ret != NO_ERR)
 		return ret;
 
 	mmio_write_32(MICROCONT_MUX_SEL, UNLOCK_CSR_ACCESS);
 	ret = load_dq_cfg(dq_swap_cfg_size, dq_swap_cfg);
-	if (ret != 0)
+	if (ret != NO_ERR)
 		return ret;
 
 	mmio_write_32(MICROCONT_MUX_SEL, LOCK_CSR_ACCESS);
@@ -177,7 +184,7 @@ uint32_t ddrss_to_normal_mode(uintptr_t csr_array)
 
 	mmio_write_32(MICROCONT_MUX_SEL, UNLOCK_CSR_ACCESS);
 	ret = load_register_cfg_16(phy_cfg_size, phy_cfg);
-	if (ret != 0)
+	if (ret != NO_ERR)
 		return ret;
 
 	mmio_write_32(MICROCONT_MUX_SEL, LOCK_CSR_ACCESS);
@@ -189,10 +196,10 @@ uint32_t ddrss_to_normal_mode(uintptr_t csr_array)
 	mmio_write_32(MICROCONT_MUX_SEL, UNLOCK_CSR_ACCESS);
 	load_csr(csr_array);
 	ret = load_register_cfg_16(pie_cfg_size, pie_cfg);
-	if (ret != 0)
+	if (ret != NO_ERR)
 		return ret;
 
 	mmio_write_32(MICROCONT_MUX_SEL, LOCK_CSR_ACCESS);
 
-	return post_train_setup(0);
+	return post_train_setup(STORE_CSR_DISABLED | INIT_MEM_DISABLED);
 }
diff --git a/drivers/nxp/s32g/ddr/ddr_utils_mmio.c b/drivers/nxp/s32g/ddr/ddr_utils_mmio.c
index 5a4b04079..6f67cd949 100644
--- a/drivers/nxp/s32g/ddr/ddr_utils_mmio.c
+++ b/drivers/nxp/s32g/ddr/ddr_utils_mmio.c
@@ -39,19 +39,24 @@ void store_csr(uintptr_t store_at);
 static uint32_t enable_axi_ports(void);
 static uint32_t get_mail(uint32_t *mail);
 static uint32_t ack_mail(void);
+static uint32_t init_memory_ecc_scrubber(void);
+static bool sel_clk_src(uint32_t clk_src);
 
 uint8_t polling_needed = 2;
 
 /* Modify bitfield value with delta, given bitfield position and mask */
 bool update_bf(uint32_t *v, uint8_t pos, uint32_t mask, int32_t delta)
 {
-	if (mask >= (((*v >> pos) & mask) + delta)) {
-		*v = (*v & ~(mask << pos)) | ((((*v >> pos) 
-			& mask) + delta) << pos);
-		return true;
-	} else {
-		return false;
+	bool ret = false;
+	uint32_t bf_val = (*v >> pos) & mask;
+	int64_t new_val = (int64_t)(bf_val) + delta;
+
+	if (mask >= (uint32_t)(new_val)) {
+		*v = (*v & ~(mask << pos)) | ((uint32_t)(new_val) << pos);
+		ret = true;
 	}
+
+	return ret;
 }
 
 /*
@@ -59,46 +64,53 @@ bool update_bf(uint32_t *v, uint8_t pos, uint32_t mask, int32_t delta)
  * @param clk_src - requested clock source
  * @return - true whether clock source has been changed, false otherwise
  */
-bool sel_clk_src(uint32_t clk_src)
+static bool sel_clk_src(uint32_t clk_src)
 {
 	uint32_t tmp32;
+	bool ret = true;
 
 	/* Check if the clock source is already set to clk_src*/
 	tmp32 = mmio_read_32(MC_CGM5_BASE_ADDR + OFFSET_MUX_0_CSS);
-	if (((tmp32 & 0x3fffffffU) >> 24) == clk_src)
-		return false;
-
-	/* To wait till clock switching is completed */
-	do {
-		tmp32 = mmio_read_32(MC_CGM5_BASE_ADDR + OFFSET_MUX_0_CSS);
-	} while (((tmp32 >> 16) & 0x1U) != 0x0);
-
-	/* Set DDR_CLK source on src_clk */
-	tmp32 = mmio_read_32(MC_CGM5_BASE_ADDR + OFFSET_MUX_0_CSC);
-	mmio_write_32(MC_CGM5_BASE_ADDR + OFFSET_MUX_0_CSC,
-		      (0xc0ffffffU & tmp32) | (clk_src << 24));
-
-	 /* Request clock switch */
-	tmp32 = mmio_read_32(MC_CGM5_BASE_ADDR + OFFSET_MUX_0_CSC);
-	mmio_write_32(MC_CGM5_BASE_ADDR + OFFSET_MUX_0_CSC,
-		      (0x1U << 2) | tmp32);
-
-	/* To wait till clock switching is completed */
-	do {
-		tmp32 = mmio_read_32(MC_CGM5_BASE_ADDR + OFFSET_MUX_0_CSS);
-	} while (((tmp32 >> 16) & 0x1U) != 0x0);
-
-	/* To wait till Switch after request is succeeded */
-	do {
-		tmp32 = mmio_read_32(MC_CGM5_BASE_ADDR + OFFSET_MUX_0_CSS);
-	} while (((tmp32 >> 17) & 0x1U) != 0x1);
+	if (((tmp32 & CSS_SELSTAT_MASK) >> CSS_SELSTAT_POS) == clk_src) {
+		ret = false;
+	} else {
+		/* To wait till clock switching is completed */
+		do {
+			tmp32 = mmio_read_32(MC_CGM5_BASE_ADDR +
+					     OFFSET_MUX_0_CSS);
+		} while (((tmp32 >> CSS_SWIP_POS) &
+			  CSS_SW_IN_PROGRESS) != CSS_SW_COMPLETED);
+
+		/* Set DDR_CLK source on src_clk */
+		tmp32 = mmio_read_32(MC_CGM5_BASE_ADDR + OFFSET_MUX_0_CSC);
+		mmio_write_32(MC_CGM5_BASE_ADDR + OFFSET_MUX_0_CSC,
+		      (CSC_SELCTL_MASK & tmp32) | (clk_src << CSC_SELCTL_POS));
+
+		/* Request clock switch */
+		tmp32 = mmio_read_32(MC_CGM5_BASE_ADDR + OFFSET_MUX_0_CSC);
+		mmio_write_32(MC_CGM5_BASE_ADDR + OFFSET_MUX_0_CSC,
+		      (CSC_CLK_SWITCH_REQUEST << CSC_CLK_SWITCH_POS) | tmp32);
+
+		/* To wait till clock switching is completed */
+		do {
+			tmp32 = mmio_read_32(MC_CGM5_BASE_ADDR + OFFSET_MUX_0_CSS);
+		} while (((tmp32 >> CSS_SWIP_POS) & CSS_SW_IN_PROGRESS) !=
+			 CSS_SW_COMPLETED);
 
-	/* Make sure correct clock source is selected */
-	do {
-		tmp32 = mmio_read_32(MC_CGM5_BASE_ADDR + OFFSET_MUX_0_CSS);
-	} while (((tmp32 & 0x3fffffffU) >> 24) != clk_src);
+		/* To wait till Switch after request is succeeded */
+		do {
+			tmp32 = mmio_read_32(MC_CGM5_BASE_ADDR + OFFSET_MUX_0_CSS);
+		} while (((tmp32 >> CSS_SW_TRIGGER_CAUSE_POS) &
+			  CSS_SW_AFTER_REQUEST_SUCCEDED) !=
+			 CSS_SW_AFTER_REQUEST_SUCCEDED);
 
-	return true;
+		/* Make sure correct clock source is selected */
+		do {
+			tmp32 = mmio_read_32(MC_CGM5_BASE_ADDR + OFFSET_MUX_0_CSS);
+		} while (((tmp32 & CSS_SELSTAT_MASK) >> CSS_SELSTAT_POS)
+			 != clk_src);
+	}
+	return ret;
 }
 
 /* Sets default AXI parity. */
@@ -109,17 +121,17 @@ uint32_t set_axi_parity(void)
 
 	/* Enable Parity For All AXI Interfaces */
 	tmp32 = mmio_read_32(DDR_SS_REG);
-	mmio_write_32(DDR_SS_REG, tmp32 | 0x1ff0U);
+	mmio_write_32(DDR_SS_REG, tmp32 | DDR_SS_AXI_PARITY_ENABLE_MASK);
 
 	/* Set AXI_PARITY_TYPE to 0x1ff;   0-even, 1-odd */
 	tmp32 = mmio_read_32(DDR_SS_REG);
-	mmio_write_32(DDR_SS_REG, tmp32 | 0x1ff0000U);
+	mmio_write_32(DDR_SS_REG, tmp32 | DDR_SS_AXI_PARITY_TYPE_MASK);
 
 	/* For LPDDR4 Set DFI1_ENABLED to 0x1 */
 	tmp32 = mmio_read_32(DDRC_BASE_ADDR);
 	if ((tmp32 & MSTR_LPDDR4_MASK) == MSTR_LPDDR4_VAL) {
 		tmp32 = mmio_read_32(DDR_SS_REG);
-		mmio_write_32(DDR_SS_REG, tmp32 | 0x1U);
+		mmio_write_32(DDR_SS_REG, tmp32 | DDR_SS_DFI_1_ENABLED);
 	}
 
 	/*
@@ -130,29 +142,32 @@ uint32_t set_axi_parity(void)
 
 	/* De-assert Reset To Controller and AXI Ports */
 	tmp32 = mmio_read_32(MC_RGM_PRST_0);
-	mmio_write_32(MC_RGM_PRST_0, ~(0x1U << 3) & tmp32);
+	mmio_write_32(MC_RGM_PRST_0,
+		~(FORCED_RESET_ON_PERIPH << PRST_0_PERIPH_3_RST_POS) &
+		 tmp32);
 
 	/* Check if the initial clock source was not on FIRC */
 	if (switched_to_firc)
 		switched_to_firc = sel_clk_src(DDR_PHI0_PLL);
 
 	/* Enable HIF, CAM Queueing */
-	mmio_write_32(DDRC_BASE_ADDR + OFFSET_DDRC_DBG1, 0x0);
+	mmio_write_32(DDRC_BASE_ADDR + OFFSET_DDRC_DBG1,
+		      DBG1_DISABLE_DE_QUEUEING);
 
 	/* Disable auto-refresh: RFSHCTL3.dis_auto_refresh = 1 */
 	tmp32 = mmio_read_32(DDRC_BASE_ADDR + OFFSET_DDRC_RFSHCTL3);
 	mmio_write_32(DDRC_BASE_ADDR + OFFSET_DDRC_RFSHCTL3,
-		      (0x1U | tmp32));
+		      (RFSHCTL3_DISABLE_AUTO_REFRESH | tmp32));
 
 	/* Disable power down: PWRCTL.powerdown_en = 0 */
 	tmp32 = mmio_read_32(DDRC_BASE_ADDR + OFFSET_DDRC_PWRCTL);
 	mmio_write_32(DDRC_BASE_ADDR + OFFSET_DDRC_PWRCTL,
-		      ((~0x00000002U) & tmp32));
+		      ((~PWRCTL_POWER_DOWN_ENABLE_MASK) & tmp32));
 
 	/* Disable self-refresh: PWRCTL.selfref_en = 0 */
 	tmp32 = mmio_read_32(DDRC_BASE_ADDR + OFFSET_DDRC_PWRCTL);
 	mmio_write_32(DDRC_BASE_ADDR + OFFSET_DDRC_PWRCTL,
-		      ((~0x00000001U) & tmp32));
+		      ((~PWRCTL_SELF_REFRESH_ENABLE_MASK) & tmp32));
 
 	/*
 	 * Disable assertion of dfi_dram_clk_disable:
@@ -160,28 +175,29 @@ uint32_t set_axi_parity(void)
 	 */
 	tmp32 = mmio_read_32(DDRC_BASE_ADDR + OFFSET_DDRC_PWRCTL);
 	mmio_write_32(DDRC_BASE_ADDR + OFFSET_DDRC_PWRCTL,
-		      ((~0x00000008U) & tmp32));
+		      ((~PWRCTL_EN_DFI_DRAM_CLOCK_DIS_MASK) & tmp32));
 
 	/* Enable Quasi-Dynamic Programming */
 	mmio_write_32(DDRC_BASE_ADDR + OFFSET_DDRC_SWCTL,
-		      DDRC_SWCTL_SWDONE_ENABLE);
+		      SWCTL_SWDONE_ENABLE);
 
 	/* Confirm Register Programming Done Ack is Cleared */
 	do {
 		tmp32 = mmio_read_32(DDRC_BASE_ADDR + OFFSET_DDRC_SWSTAT);
-	} while ((tmp32 & DDRC_SWSTAT_SWDONE_ACK_MASK) == 1);
+	} while ((tmp32 & SWSTAT_SWDONE_ACK_MASK) == SWSTAT_SW_DONE);
 
 	/* DFI_INIT_COMPLETE_EN set to 0 */
 	tmp32 = mmio_read_32(DDRC_BASE_ADDR + OFFSET_DDRC_DFIMISC);
-	mmio_write_32(DDRC_BASE_ADDR + OFFSET_DDRC_DFIMISC, (~0x1U) & tmp32);
+	mmio_write_32(DDRC_BASE_ADDR + OFFSET_DDRC_DFIMISC,
+		      (~DFIMISC_DFI_INIT_COMPLETE_EN_MASK) & tmp32);
 
 	/* Set SWCTL.sw_done to 1 */
 	mmio_write_32(DDRC_BASE_ADDR + OFFSET_DDRC_SWCTL,
-		      DDRC_SWCTL_SWDONE_DONE);
+		      SWCTL_SWDONE_DONE);
 
 	do {
 		tmp32 = mmio_read_32(DDRC_BASE_ADDR + OFFSET_DDRC_SWSTAT);
-	} while ((tmp32 & DDRC_SWSTAT_SWDONE_ACK_MASK) == 0);
+	} while ((tmp32 & SWSTAT_SWDONE_ACK_MASK) == SWSTAT_SW_NOT_DONE);
 
 	return NO_ERR;
 }
@@ -191,13 +207,13 @@ static uint32_t enable_axi_ports(void)
 {
 	/* Port 0 Control Register*/
 	mmio_write_32(DDRC_UMCTL2_MP_BASE_ADDR + OFFSET_DDRC_PCTRL_0,
-		      0x00000001);
+		      ENABLE_AXI_PORT);
 	/* Port 1 Control Register*/
 	mmio_write_32(DDRC_UMCTL2_MP_BASE_ADDR + OFFSET_DDRC_PCTRL_1,
-		      0x00000001);
+		      ENABLE_AXI_PORT);
 	/* Port 2 Control Register*/
 	mmio_write_32(DDRC_UMCTL2_MP_BASE_ADDR + OFFSET_DDRC_PCTRL_2,
-		      0x00000001);
+		      ENABLE_AXI_PORT);
 
 	return NO_ERR;
 }
@@ -205,7 +221,7 @@ static uint32_t enable_axi_ports(void)
 /*
  * Post PHY training setup - complementary settings that need to be
  * performed after running the firmware.
- *  @param options - various flags controlling post training actions
+ * @param options - various flags controlling post training actions
  * (whether to init memory with ECC scrubber / whether to store CSR)
  */
 uint32_t post_train_setup(uint8_t options)
@@ -219,113 +235,116 @@ uint32_t post_train_setup(uint8_t options)
 	 */
 	do {
 		tmp32 = mmio_read_32(DDR_PHYA_MASTER0_CALBUSY);
-	} while ((tmp32 & 0x1u) != 0);
+	} while ((tmp32 & MASTER0_CAL_ACTIVE) != MASTER0_CAL_DONE);
 
 #ifdef STORE_CSR_ENABLE
-	if ((options & STORE_CSR_MASK) != 0)
+	if ((options & STORE_CSR_MASK) != STORE_CSR_DISABLED)
 		store_csr(RETENTION_ADDR);
 #endif
 
 	/* Set SWCTL.sw_done to 0 */
 	mmio_write_32(DDRC_BASE_ADDR + OFFSET_DDRC_SWCTL,
-		      DDRC_SWCTL_SWDONE_ENABLE);
+		      SWCTL_SWDONE_ENABLE);
 	do {
 		tmp32 = mmio_read_32(DDRC_BASE_ADDR + OFFSET_DDRC_SWSTAT);
-	} while ((tmp32 & DDRC_SWSTAT_SWDONE_ACK_MASK) != 0);
+	} while ((tmp32 & SWSTAT_SWDONE_ACK_MASK) != SWSTAT_SW_NOT_DONE);
 
 	/* Set DFIMISC.dfi_init_start to 1*/
 	tmp32 = mmio_read_32(DDRC_BASE_ADDR + OFFSET_DDRC_DFIMISC);
 	mmio_write_32(DDRC_BASE_ADDR + OFFSET_DDRC_DFIMISC,
-		      (0x00000020U | tmp32));
+		      (DFIMISC_DFI_INIT_START_MASK | tmp32));
 
 	/* Set SWCTL.sw_done to 1 */
 	mmio_write_32(DDRC_BASE_ADDR + OFFSET_DDRC_SWCTL,
-		      DDRC_SWCTL_SWDONE_DONE);
+		      SWCTL_SWDONE_DONE);
 	/* Wait SWSTAT.sw_done_ack to 1*/
 	do {
 		tmp32 = mmio_read_32(DDRC_BASE_ADDR + OFFSET_DDRC_SWSTAT);
-	} while ((tmp32 & DDRC_SWSTAT_SWDONE_ACK_MASK) == 0);
+	} while ((tmp32 & SWSTAT_SWDONE_ACK_MASK) == SWSTAT_SW_NOT_DONE);
 
 	/* Wait DFISTAT.dfi_init_complete to 1 */
 	do {
 		tmp32 = mmio_read_32(DDRC_BASE_ADDR + OFFSET_DDRC_DFISTAT);
-	} while ((tmp32 & 0x1U) == 0);
+	} while ((tmp32 & DFISTAT_DFI_INIT_DONE) ==
+		 DFISTAT_DFI_INIT_INCOMPLETE);
 
 	/* Set SWCTL.sw_done to 0 */
 	mmio_write_32(DDRC_BASE_ADDR + OFFSET_DDRC_SWCTL,
-		      DDRC_SWCTL_SWDONE_ENABLE);
+		      SWCTL_SWDONE_ENABLE);
 	do {
 		tmp32 = mmio_read_32(DDRC_BASE_ADDR + OFFSET_DDRC_SWSTAT);
-	} while ((tmp32 & DDRC_SWSTAT_SWDONE_ACK_MASK) != 0);
+	} while ((tmp32 & SWSTAT_SWDONE_ACK_MASK) != SWSTAT_SW_NOT_DONE);
 
 	/* Set dfi_init_start to 0 */
 	tmp32 = mmio_read_32(DDRC_BASE_ADDR + OFFSET_DDRC_DFIMISC);
 	mmio_write_32(DDRC_BASE_ADDR + OFFSET_DDRC_DFIMISC,
-		      (~0x00000020U) & tmp32);
+		      (~DFIMISC_DFI_INIT_START_MASK) & tmp32);
 
 	/* Set dfi_complete_en to 1 */
 	tmp32 = mmio_read_32(DDRC_BASE_ADDR + OFFSET_DDRC_DFIMISC);
 	mmio_write_32(DDRC_BASE_ADDR + OFFSET_DDRC_DFIMISC,
-		      0x00000001U | tmp32);
+		      DFIMISC_DFI_INIT_COMPLETE_EN_MASK | tmp32);
 
 	/* Set PWRCTL.selfref_sw to 0 */
 	tmp32 = mmio_read_32(DDRC_BASE_ADDR + OFFSET_DDRC_PWRCTL);
 	mmio_write_32(DDRC_BASE_ADDR + OFFSET_DDRC_PWRCTL,
-		      ((~0x00000020U) & tmp32));
+		      ((~PWRCTL_SELFREF_SW_MASK) & tmp32));
 
 	/* Set SWCTL.sw_done to 1 */
 	mmio_write_32(DDRC_BASE_ADDR + OFFSET_DDRC_SWCTL,
-		      DDRC_SWCTL_SWDONE_DONE);
+		      SWCTL_SWDONE_DONE);
 	do {
 		tmp32 = mmio_read_32(DDRC_BASE_ADDR + OFFSET_DDRC_SWSTAT);
-	} while ((tmp32 & DDRC_SWSTAT_SWDONE_ACK_MASK) == 0);
+	} while ((tmp32 & SWSTAT_SWDONE_ACK_MASK) == SWSTAT_SW_NOT_DONE);
 
 	/* Wait for DWC_ddr_umctl2 to move to normal operating mode */
 	do {
 		tmp32 = mmio_read_32(DDRC_BASE_ADDR + OFFSET_DDRC_STAT);
-	} while ((tmp32 & 0x7U) == 0);
+	} while ((tmp32 & STAT_OPERATING_MODE_MASK) ==
+		 STAT_OPERATING_MODE_INIT);
 
 	/* Enable auto-refresh: RFSHCTL3.dis_auto_refresh = 0 */
 	tmp32 = mmio_read_32(DDRC_BASE_ADDR + OFFSET_DDRC_RFSHCTL3);
 	mmio_write_32(DDRC_BASE_ADDR + OFFSET_DDRC_RFSHCTL3,
-		      (~0x00000001U) & tmp32);
+		      (~RFSHCTL3_DIS_AUTO_REFRESH_MASK) & tmp32);
 
 	/*
 	 * If ECC feature is enabled (ECCCFG0[ecc_mode] > 0)
 	 * initialize memory with the ecc scrubber
 	 */
 	tmp32 = mmio_read_32(DDRC_BASE_ADDR + OFFSET_DDRC_ECCCFG0);
-	if (((tmp32 & 0x7U) > 0) && ((options & INIT_MEM_MASK) != 0)) {
+	if (((tmp32 & ECCCFG0_ECC_MODE_MASK) > ECCCFG0_ECC_DISABLED) &&
+	    ((options & INIT_MEM_MASK) != INIT_MEM_DISABLED)) {
 		ret = init_memory_ecc_scrubber();
-		if (ret != NO_ERR)
-			return ret;
 	}
 
-	/* Enable power down: PWRCTL.powerdown_en = 1 */
-	tmp32 = mmio_read_32(DDRC_BASE_ADDR + OFFSET_DDRC_PWRCTL);
-	mmio_write_32(DDRC_BASE_ADDR + OFFSET_DDRC_PWRCTL,
-		      0x00000002U | tmp32);
+	if (ret == NO_ERR) {
+		/* Enable power down: PWRCTL.powerdown_en = 1 */
+		tmp32 = mmio_read_32(DDRC_BASE_ADDR + OFFSET_DDRC_PWRCTL);
+		mmio_write_32(DDRC_BASE_ADDR + OFFSET_DDRC_PWRCTL,
+		      PWRCTL_POWER_DOWN_ENABLE_MASK | tmp32);
 
-	/* Enable self-refresh: PWRCTL.selfref_en = 1*/
-	tmp32 = mmio_read_32(DDRC_BASE_ADDR + OFFSET_DDRC_PWRCTL);
-	mmio_write_32(DDRC_BASE_ADDR + OFFSET_DDRC_PWRCTL,
-		      0x00000001U | tmp32);
+		/* Enable self-refresh: PWRCTL.selfref_en = 1*/
+		tmp32 = mmio_read_32(DDRC_BASE_ADDR + OFFSET_DDRC_PWRCTL);
+		mmio_write_32(DDRC_BASE_ADDR + OFFSET_DDRC_PWRCTL,
+		      PWRCTL_SELF_REFRESH_ENABLE_MASK | tmp32);
 
-	/*
-	 * Enable assertion of dfi_dram_clk_disable:
-	 * PWRTL.en_dfi_dram_clk_disable = 1
-	 */
-	tmp32 = mmio_read_32(DDRC_BASE_ADDR + OFFSET_DDRC_PWRCTL);
-	mmio_write_32(DDRC_BASE_ADDR + OFFSET_DDRC_PWRCTL,
-		      0x00000008U | tmp32);
+		/*
+		 * Enable assertion of dfi_dram_clk_disable:
+		 * PWRTL.en_dfi_dram_clk_disable = 1
+		 */
+		tmp32 = mmio_read_32(DDRC_BASE_ADDR + OFFSET_DDRC_PWRCTL);
+		mmio_write_32(DDRC_BASE_ADDR + OFFSET_DDRC_PWRCTL,
+		      PWRCTL_EN_DFI_DRAM_CLOCK_DIS_MASK | tmp32);
 
-	ret |= enable_derating_temp_errata();
+		ret |= enable_derating_temp_errata();
 
-	/*
-	 * Each platform has a different number of AXI ports so this
-	 * method should be implemented in hardware specific source
-	 */
-	ret |= enable_axi_ports();
+		/*
+		 * Each platform has a different number of AXI ports so this
+		 * method should be implemented in hardware specific source
+		 */
+		ret |= enable_axi_ports();
+	}
 	return ret;
 }
 
@@ -334,22 +353,23 @@ uint32_t wait_firmware_execution(void)
 {
 	uint32_t mail = 0;
 	uint32_t ret;
+	bool exit_loop = false;
 
-	while (true) {
+	while (!exit_loop) {
 		/* Obtain message from PHY (major message) */
 		ret = get_mail(&mail);
 
-		if (ret != NO_ERR)
-			break;
-
-		/* 0x07 means OK, 0xFF means failure */
-		if (mail == 0x07)
-			break;
-
-		if (mail == 0xff) {
-			/* Training stage failed */
-			ret = TRAINING_FAILED;
-			break;
+		if (ret == NO_ERR) {
+			if (mail == TRAINING_OK_MSG) {
+				/* 0x07 means OK, 0xFF means failure */
+				exit_loop = true;
+			} else if (mail == TRAINING_FAILED_MSG) {
+				/* Training stage failed */
+				ret = TRAINING_FAILED;
+				exit_loop = true;
+			}
+		} else {
+			exit_loop = true;
 		}
 	}
 
@@ -361,18 +381,18 @@ static uint32_t ack_mail(void)
 {
 	uint32_t timeout = DEFAULT_TIMEOUT;
 	/* ACK message */
-	mmio_write_32(DDR_PHYA_APBONLY_DCTWRITEPROT, 0);
-	uint32_t tmp32 = mmio_read_32(DDR_PHYA_APBONLY_UCTSHSADOWREGS);
+	mmio_write_32(DDR_PHYA_DCTWRITEPROT, APBONLY_DCTWRITEPROT_ACK_EN);
+	uint32_t tmp32 = mmio_read_32(DDR_PHYA_APBONLY_UCTSHADOWREGS);
 
 	/* Wait firmware to respond to ACK (UctWriteProtShadow to be set) */
-	while ((--timeout != 0) &&
-	       ((tmp32 & UCT_WRITE_PROT_SHADOW_MASK) == 0))
-		tmp32 = mmio_read_32(DDR_PHYA_APBONLY_UCTSHSADOWREGS);
+	while ((--timeout != 0u) && ((tmp32 & UCT_WRITE_PROT_SHADOW_MASK) ==
+				     UCT_WRITE_PROT_SHADOW_ACK))
+		tmp32 = mmio_read_32(DDR_PHYA_APBONLY_UCTSHADOWREGS);
 
-	if (timeout == 0)
+	if (timeout == 0u)
 		return TIMEOUT_ERR;
 
-	mmio_write_32(DDR_PHYA_APBONLY_DCTWRITEPROT, 1);
+	mmio_write_32(DDR_PHYA_DCTWRITEPROT, APBONLY_DCTWRITEPROT_ACK_DIS);
 
 	return NO_ERR;
 }
@@ -381,13 +401,13 @@ static uint32_t ack_mail(void)
 static uint32_t get_mail(uint32_t *mail)
 {
 	uint32_t timeout = DEFAULT_TIMEOUT;
-	uint32_t tmp32 = mmio_read_32(DDR_PHYA_APBONLY_UCTSHSADOWREGS);
+	uint32_t tmp32 = mmio_read_32(DDR_PHYA_APBONLY_UCTSHADOWREGS);
 
-	while ((--timeout != 0) &&
-	       ((tmp32 & UCT_WRITE_PROT_SHADOW_MASK) != 0))
-		tmp32 = mmio_read_32(DDR_PHYA_APBONLY_UCTSHSADOWREGS);
+	while ((--timeout != 0u) && ((tmp32 & UCT_WRITE_PROT_SHADOW_MASK) !=
+				     UCT_WRITE_PROT_SHADOW_ACK))
+		tmp32 = mmio_read_32(DDR_PHYA_APBONLY_UCTSHADOWREGS);
 
-	if (timeout == 0)
+	if (timeout == 0u)
 		return TIMEOUT_ERR;
 
 	*mail = mmio_read_32(DDR_PHYA_APBONLY_UCTWRITEONLYSHADOW);
@@ -397,41 +417,47 @@ static uint32_t get_mail(uint32_t *mail)
 }
 
 /* Initialize memory with the ecc scrubber */
-uint32_t init_memory_ecc_scrubber(void)
+static uint32_t init_memory_ecc_scrubber(void)
 {
 	uint8_t region_lock;
 	uint32_t tmp32, pattern = 0x00000000U;
 
 	/* Save previous ecc region parity locked state. */
-	region_lock = mmio_read_32(DDRC_BASE_ADDR + OFFSET_DDRC_ECCCFG1)
-				   & (0x1UL << 4);
+	region_lock = (uint8_t)(mmio_read_32(DDRC_BASE_ADDR + OFFSET_DDRC_ECCCFG1) &
+				(ECCCFG1_REGION_PARITY_LOCKED <<
+				 ECCCFG1_REGION_PARITY_LOCK_POS));
 
 	/* Enable ecc region lock. */
 	tmp32 = mmio_read_32(DDRC_BASE_ADDR + OFFSET_DDRC_ECCCFG1);
 	mmio_write_32(DDRC_BASE_ADDR + OFFSET_DDRC_ECCCFG1,
-		      (0x1UL << 4) | tmp32);
+		      (ECCCFG1_REGION_PARITY_LOCKED <<
+		       ECCCFG1_REGION_PARITY_LOCK_POS) | tmp32);
 
 	/* Set SBRCTL.scrub_mode = 1. */
 	tmp32 = mmio_read_32(DDRC_BASE_ADDR + OFFSET_DDRC_SBRCTL);
 	mmio_write_32(DDRC_BASE_ADDR + OFFSET_DDRC_SBRCTL,
-		      (0x1U << 2) | tmp32);
+		      (SBRCTL_SCRUB_MODE_WRITE << SBRCTL_SCRUB_MODE_POS) |
+		       tmp32);
 
 	/* Set SBRCTL.scrub_during_lowpower = 1. */
 	tmp32 = mmio_read_32(DDRC_BASE_ADDR + OFFSET_DDRC_SBRCTL);
 	mmio_write_32(DDRC_BASE_ADDR + OFFSET_DDRC_SBRCTL,
-		      (0x1U << 1) | tmp32);
+		      (SBRCTL_SCRUB_DURING_LOWPOWER_CONTINUED <<
+		       SBRCTL_SCRUB_DURING_LOWPOWER_POS) | tmp32);
 
 	/* Set SBRCTL.scrub_interval = 0. */
 	tmp32 = mmio_read_32(DDRC_BASE_ADDR + OFFSET_DDRC_SBRCTL);
 	mmio_write_32(DDRC_BASE_ADDR + OFFSET_DDRC_SBRCTL,
-		      ~(0x1fffU << 8) & tmp32);
+		      ~(SBRCTL_SCRUB_INTERVAL_FIELD <<
+			SBRCTL_SCRUB_INTERVAL_POS) & tmp32);
 
 	/* Set the desired pattern through SBRWDATA0 register. */
 	mmio_write_32(DDRC_BASE_ADDR + OFFSET_DDRC_SBRWDATA0, pattern);
 
 	/* Enable the SBR by programming SBRCTL.scrub_en = 1. */
 	tmp32 = mmio_read_32(DDRC_BASE_ADDR + OFFSET_DDRC_SBRCTL);
-	mmio_write_32(DDRC_BASE_ADDR + OFFSET_DDRC_SBRCTL, 0x1U | tmp32);
+	mmio_write_32(DDRC_BASE_ADDR + OFFSET_DDRC_SBRCTL,
+		      SBRCTL_SCRUB_EN | tmp32);
 
 	/*
 	 * Poll until SBRSTAT.scrub_done = 1
@@ -439,7 +465,8 @@ uint32_t init_memory_ecc_scrubber(void)
 	 */
 	do {
 		tmp32 = mmio_read_32(DDRC_BASE_ADDR + OFFSET_DDRC_SBRSTAT);
-	} while ((tmp32 & 0x2U) == 0);
+	} while ((tmp32 & SBRSTAT_SCRUB_DONE_MASK) ==
+		 SBRSTAT_SCRUBBER_NOT_DONE);
 
 	/*
 	 * Poll until SBRSTAT.scrub_busy = 0
@@ -447,30 +474,38 @@ uint32_t init_memory_ecc_scrubber(void)
 	 */
 	do {
 		tmp32 = mmio_read_32(DDRC_BASE_ADDR + OFFSET_DDRC_SBRSTAT);
-	} while ((tmp32 & 0x1U) != 0);
+	} while ((tmp32 & SBRSTAT_SCRUBBER_BUSY_MASK) !=
+		 SBRSTAT_SCRUBBER_NOT_BUSY);
 
 	/* Disable SBR by programming SBRCTL.scrub_en = 0. */
 	tmp32 = mmio_read_32(DDRC_BASE_ADDR + OFFSET_DDRC_SBRCTL);
-	mmio_write_32(DDRC_BASE_ADDR + OFFSET_DDRC_SBRCTL, ~(0x1U) & tmp32);
+	mmio_write_32(DDRC_BASE_ADDR + OFFSET_DDRC_SBRCTL,
+		      ~SBRCTL_SCRUB_EN & tmp32);
 
 	/* Enter normal scrub operation (Reads): SBRCTL.scrub_mode = 0. */
 	tmp32 = mmio_read_32(DDRC_BASE_ADDR + OFFSET_DDRC_SBRCTL);
 	mmio_write_32(DDRC_BASE_ADDR + OFFSET_DDRC_SBRCTL,
-		      ~(0x1U << 2) & tmp32);
+		      ~(SBRCTL_SCRUB_MODE_WRITE << SBRCTL_SCRUB_MODE_POS) &
+			tmp32);
 
 	/* Set SBRCTL.scrub_interval = 1. */
 	tmp32 = mmio_read_32(DDRC_BASE_ADDR + OFFSET_DDRC_SBRCTL);
-	tmp32 = ~(0x1fffU << 8) & tmp32;
+	tmp32 = ~(SBRCTL_SCRUB_INTERVAL_FIELD <<
+		  SBRCTL_SCRUB_INTERVAL_POS) & tmp32;
 	mmio_write_32(DDRC_BASE_ADDR + OFFSET_DDRC_SBRCTL,
-		      (0x1UL << 8) | tmp32);
+		      (SBRCTL_SCRUB_INTERVAL_VALUE_1 <<
+		       SBRCTL_SCRUB_INTERVAL_POS) | tmp32);
 
 	/* Enable the SBR by programming SBRCTL.scrub_en = 1. */
 	tmp32 = mmio_read_32(DDRC_BASE_ADDR + OFFSET_DDRC_SBRCTL);
-	mmio_write_32(DDRC_BASE_ADDR + OFFSET_DDRC_SBRCTL, 0x1U | tmp32);
+	mmio_write_32(DDRC_BASE_ADDR + OFFSET_DDRC_SBRCTL,
+		      SBRCTL_SCRUB_EN | tmp32);
 
 	/* Restore locked state of ecc region. */
 	tmp32 = mmio_read_32(DDRC_BASE_ADDR + OFFSET_DDRC_ECCCFG1);
-	tmp32 = (tmp32 & ~(0x1UL << 4)) | (region_lock << 4);
+	tmp32 = (tmp32 & ~(ECCCFG1_REGION_PARITY_LOCKED <<
+			   ECCCFG1_REGION_PARITY_LOCK_POS)) |
+		(region_lock << ECCCFG1_REGION_PARITY_LOCK_POS);
 	mmio_write_32(DDRC_BASE_ADDR + OFFSET_DDRC_ECCCFG1, tmp32);
 
 	return NO_ERR;
@@ -485,7 +520,7 @@ uint32_t read_lpddr4_mr(uint8_t mr_index)
 	/* Set MRR_DDR_SEL_REG to 0x1 to enable LPDDR4 mode */
 	tmp32 = mmio_read_32(PERF_BASE_ADDR + OFFSET_MRR_0_DATA_REG_ADDR);
 	mmio_write_32(PERF_BASE_ADDR + OFFSET_MRR_0_DATA_REG_ADDR,
-		      (tmp32 | 0x1U));
+		      (tmp32 | MRR_0_DDR_SEL_REG_MASK));
 
 	/*
 	 * Ensure no MR transaction is in progress:
@@ -493,7 +528,7 @@ uint32_t read_lpddr4_mr(uint8_t mr_index)
 	 */
 	do {
 		tmp32 = mmio_read_32(DDRC_BASE_ADDR + OFFSET_DDRC_MRSTAT);
-		if ((tmp32 & 0x1U) == 0)
+		if ((tmp32 & MRSTAT_MR_BUSY) == MRSTAT_MR_NOT_BUSY)
 			succesive_reads++;
 		else
 			succesive_reads = 0;
@@ -501,28 +536,31 @@ uint32_t read_lpddr4_mr(uint8_t mr_index)
 
 	/* Set MR_TYPE = 0x1 (Read) and MR_RANK = 0x1 (Rank 0) */
 	tmp32 = mmio_read_32(DDRC_BASE_ADDR + OFFSET_DDRC_MRCTRL0);
-	tmp32 |= 0x1U;
-	tmp32 = (tmp32 & ~(0xfUL << 4)) | (0x1UL << 4);
+	tmp32 |= MRCTRL0_MR_TYPE_READ;
+	tmp32 = (tmp32 & ~(MRCTRL0_RANK_ACCESS_FIELD <<
+			   MRCTRL0_RANK_ACCESS_POS)) |
+		(MRCTRL0_RANK_0 << MRCTRL0_RANK_ACCESS_POS);
 	mmio_write_32(DDRC_BASE_ADDR + OFFSET_DDRC_MRCTRL0, tmp32);
 
 	/* Configure MR address: MRCTRL1[8:15] */
 	tmp32 = mmio_read_32(DDRC_BASE_ADDR + OFFSET_DDRC_MRCTRL1);
-	tmp32 = (tmp32 & ~(0xffUL << 8)) | ((uint16_t)mr_index << 8);
-	mmio_write_32(DDRC_BASE_ADDR + OFFSET_DDRC_MRCTRL1,
-		      tmp32);
+	tmp32 = (tmp32 & ~(MRCTRL1_MR_ADDRESS_FIELD <<
+			   MRCTRL1_MR_ADDRESS_POS)) |
+		((uint16_t)mr_index << MRCTRL1_MR_ADDRESS_POS);
+	mmio_write_32(DDRC_BASE_ADDR + OFFSET_DDRC_MRCTRL1, tmp32);
 
 	dsb();
 
 	/* Initiate MR transaction: MR_WR = 0x1 */
 	tmp32 = mmio_read_32(DDRC_BASE_ADDR + OFFSET_DDRC_MRCTRL0);
 	mmio_write_32(DDRC_BASE_ADDR + OFFSET_DDRC_MRCTRL0,
-		      tmp32 | (0x1UL << 31));
+		      tmp32 | (MRCTRL0_WR_ENGAGE << MRCTRL0_WR_ENGAGE_POS));
 
 	/* Wait until MR transaction completed */
 	succesive_reads = 0;
 	do {
 		tmp32 = mmio_read_32(DDRC_BASE_ADDR + OFFSET_DDRC_MRSTAT);
-		if ((tmp32 & 0x1U) == 0)
+		if ((tmp32 & MRSTAT_MR_BUSY) == MRSTAT_MR_NOT_BUSY)
 			succesive_reads++;
 		else
 			succesive_reads = 0;
@@ -540,7 +578,7 @@ uint32_t write_lpddr4_mr(uint8_t mr_index, uint8_t mr_data)
 	/* Set MRR_DDR_SEL_REG to 0x1 to enable LPDDR4 mode */
 	tmp32 = mmio_read_32(PERF_BASE_ADDR + OFFSET_MRR_0_DATA_REG_ADDR);
 	mmio_write_32(PERF_BASE_ADDR + OFFSET_MRR_0_DATA_REG_ADDR,
-		      tmp32 | 0x1U);
+		      tmp32 | MRCTRL0_MR_TYPE_READ);
 
 	/*
 	 * Ensure no MR transaction is in progress:
@@ -548,7 +586,7 @@ uint32_t write_lpddr4_mr(uint8_t mr_index, uint8_t mr_data)
 	 */
 	do {
 		tmp32 = mmio_read_32(DDRC_BASE_ADDR + OFFSET_DDRC_MRSTAT);
-		if ((tmp32 & 0x1U) == 0)
+		if ((tmp32 & MRSTAT_MR_BUSY) == MRSTAT_MR_NOT_BUSY)
 			succesive_reads++;
 		else
 			succesive_reads = 0;
@@ -556,14 +594,17 @@ uint32_t write_lpddr4_mr(uint8_t mr_index, uint8_t mr_data)
 
 	/* Set MR_TYPE = 0x0 (Write) and MR_RANK = 0x1 (Rank 0) */
 	tmp32 = mmio_read_32(DDRC_BASE_ADDR + OFFSET_DDRC_MRCTRL0);
-	tmp32 &= ~(0x1U);
-	tmp32 = (tmp32 & ~(0xfUL << 4)) | (0x1UL << 4);
+	tmp32 &= ~(MRCTRL0_MR_TYPE_READ);
+	tmp32 = (tmp32 & ~(MRCTRL0_RANK_ACCESS_FIELD <<
+			   MRCTRL0_RANK_ACCESS_POS)) |
+		(MRCTRL0_RANK_0 << MRCTRL0_RANK_ACCESS_POS);
 	mmio_write_32(DDRC_BASE_ADDR + OFFSET_DDRC_MRCTRL0, tmp32);
 
 	/* Configure MR address: MRCTRL1[8:15] and MR data: MRCTRL1[0:7]*/
 	tmp32 = mmio_read_32(DDRC_BASE_ADDR + OFFSET_DDRC_MRCTRL1);
-	tmp32 = (tmp32 & (0xffffUL << 16)) | ((uint16_t)mr_index << 8) |
-		mr_data;
+	tmp32 = (tmp32 & (MRCTRL1_MR_DATA_ADDRESS_FIELD <<
+			  MRCTRL1_MR_DATA_ADDRESS_POS)) |
+		((uint16_t)mr_index << MRCTRL1_MR_ADDRESS_POS) | mr_data;
 	mmio_write_32(DDRC_BASE_ADDR + OFFSET_DDRC_MRCTRL1, tmp32);
 
 	dsb();
@@ -571,13 +612,13 @@ uint32_t write_lpddr4_mr(uint8_t mr_index, uint8_t mr_data)
 	/* Initiate MR transaction: MR_WR = 0x1 */
 	tmp32 = mmio_read_32(DDRC_BASE_ADDR + OFFSET_DDRC_MRCTRL0);
 	mmio_write_32(DDRC_BASE_ADDR + OFFSET_DDRC_MRCTRL0,
-		      tmp32 | (0x1UL << 31));
+		      tmp32 | (MRCTRL0_WR_ENGAGE << MRCTRL0_WR_ENGAGE_POS));
 
 	/* Wait until MR transaction completed */
 	succesive_reads = 0;
 	do {
 		tmp32 = mmio_read_32(DDRC_BASE_ADDR + OFFSET_DDRC_MRSTAT);
-		if ((tmp32 & 0x1U) == 0)
+		if ((tmp32 & MRSTAT_MR_BUSY) == MRSTAT_MR_NOT_BUSY)
 			succesive_reads++;
 		else
 			succesive_reads = 0;
@@ -593,8 +634,8 @@ uint8_t read_tuf(void)
 	uint8_t mr4_die_1, mr4_die_2;
 
 	mr4_val = read_lpddr4_mr(MR4_IDX);
-	mr4_die_1 = mr4_val & 0x7U;
-	mr4_die_2 = (mr4_val >> 16) & 0x7U;
+	mr4_die_1 = (uint8_t)(mr4_val & MR4_MASK);
+	mr4_die_2 = (uint8_t)((mr4_val >> MR4_SHIFT) & MR4_MASK);
 
 	return (mr4_die_1 > mr4_die_2) ? mr4_die_1 : mr4_die_2;
 }
@@ -611,114 +652,108 @@ uint32_t enable_derating_temp_errata(void)
 {
 	uint32_t tmp32, bf_val;
 
-	if (read_tuf() > TUF_THRESHOLD) {
-		/* Disable timing parameter derating: DERATEEN.DERATE_EN = 0 */
+	if (read_tuf() < TUF_THRESHOLD) {
+		/* Enable timing parameter derating: DERATEEN.DERATE_EN = 1 */
 		tmp32 = mmio_read_32(DDRC_BASE_ADDR + OFFSET_DDRC_DERATEEN);
 		mmio_write_32(DDRC_BASE_ADDR + OFFSET_DDRC_DERATEEN,
-			      tmp32 & ~DDRC_DERATEEN_MASK_DISABLE);
+			      tmp32 | DERATEEN_ENABLE);
 
-		/*
-		 * Update average time interval between refreshes per rank:
-		 * RFSHTMG.T_RFC_NOM_X1_X32 = RFSHTMG.T_RFC_NOM_X1_X32 / 4
-		 */
-		tmp32 = mmio_read_32(DDRC_BASE_ADDR + OFFSET_DDRC_RFSHTMG);
-		bf_val = (tmp32 >> DDRC_RFSHTMG_VAL_SHIFT) & DDRC_RFSHTMG_VAL;
-		bf_val = bf_val >> 2;
-		tmp32 = (tmp32 & ~DDRC_RFSHTMG_MASK) |
-			(bf_val << DDRC_RFSHTMG_VAL_SHIFT);
-		mmio_write_32(DDRC_BASE_ADDR + OFFSET_DDRC_RFSHTMG, tmp32);
+		polling_needed = 0;
+		return NO_ERR;
+	}
 
-		/*
-		 * Toggle RFSHCTL3.REFRESH_UPDATE_LEVEL to indicate that
-		 * refresh registers have been updated
-		 */
-		tmp32 = mmio_read_32(DDRC_BASE_ADDR + OFFSET_DDRC_RFSHCTL3);
-		bf_val = (tmp32 >> DDRC_RFSHCTL3_UPDATE_SHIFT) &
-			 DDRC_RFSHCTL3_AUTO_REFRESH_VAL;
-		bf_val = bf_val ^ 0x1U;
-		tmp32 = (tmp32 & ~DDRC_RFSHCTL3_MASK) |
-			(bf_val << DDRC_RFSHCTL3_UPDATE_SHIFT);
-		mmio_write_32(DDRC_BASE_ADDR + OFFSET_DDRC_RFSHCTL3,
-			      tmp32);
-
-		/* Set SWCTL.sw_done to 0 */
-		mmio_write_32(DDRC_BASE_ADDR + OFFSET_DDRC_SWCTL,
-			      DDRC_SWCTL_SWDONE_ENABLE);
-		do {
-			tmp32 = mmio_read_32(DDRC_BASE_ADDR + 
-					     OFFSET_DDRC_SWSTAT);
-		} while ((tmp32 & DDRC_SWSTAT_SWDONE_ACK_MASK) != 0);
+	/* Disable timing parameter derating: DERATEEN.DERATE_EN = 0 */
+	tmp32 = mmio_read_32(DDRC_BASE_ADDR + OFFSET_DDRC_DERATEEN);
+	mmio_write_32(DDRC_BASE_ADDR + OFFSET_DDRC_DERATEEN,
+		      tmp32 & ~DERATEEN_MASK_DIS);
 
-		tmp32 = mmio_read_32(DDRC_BASE_ADDR + OFFSET_DDRC_DRAMTMG4);
+	/*
+	 * Update average time interval between refreshes per rank:
+	 * RFSHTMG.T_RFC_NOM_X1_X32 = RFSHTMG.T_RFC_NOM_X1_X32 / 4
+	 */
+	tmp32 = mmio_read_32(DDRC_BASE_ADDR + OFFSET_DDRC_RFSHTMG);
+	bf_val = (tmp32 >> RFSHTMG_VAL_SHIFT) & RFSHTMG_VAL;
+	bf_val = bf_val >> RFSHTMG_UPDATE_SHIFT;
+	tmp32 = (tmp32 & ~RFSHTMG_MASK) |
+		(uint32_t)(bf_val << RFSHTMG_VAL_SHIFT);
+	mmio_write_32(DDRC_BASE_ADDR + OFFSET_DDRC_RFSHTMG, tmp32);
 
-		/*
-		 * Set minimum time from activate to read/write command to same
-		 * bank: DRAMTMG4.T_RCD += 2
-		 */
-		if (!update_bf(&tmp32, DDRC_DRAMTMG4_TRCD_POS,
-			       DDRC_DRAMTMG5_TRCD_MASK, 2))
-			return BITFIELD_EXCEEDED;
+	/*
+	 * Toggle RFSHCTL3.REFRESH_UPDATE_LEVEL to indicate that
+	 * refresh registers have been updated
+	 */
+	tmp32 = mmio_read_32(DDRC_BASE_ADDR + OFFSET_DDRC_RFSHCTL3);
+	bf_val = (tmp32 >> RFSHCTL3_UPDATE_SHIFT) & RFSHCTL3_AUTO_REFRESH_VAL;
+	bf_val = bf_val ^ RFSHCTL3_UPDATE_LEVEL_TOGGLE;
+	tmp32 = (tmp32 & ~RFSHCTL3_MASK) | (bf_val << RFSHCTL3_UPDATE_SHIFT);
+	mmio_write_32(DDRC_BASE_ADDR + OFFSET_DDRC_RFSHCTL3, tmp32);
 
-		/*
-		 * Set minimum time between activates from bank "a" to bank "b"
-		 * DRAMTMG4.T_RRD += 2
-		 */
-		if (!update_bf(&tmp32, DDRC_DRAMTMG4_TRRD_POS,
-			       DDRC_DRAMTMG5_TRRD_MASK, 2))
-			return BITFIELD_EXCEEDED;
+	/* Set SWCTL.sw_done to 0 */
+	mmio_write_32(DDRC_BASE_ADDR + OFFSET_DDRC_SWCTL,
+		      SWCTL_SWDONE_ENABLE);
+	do {
+		tmp32 = mmio_read_32(DDRC_BASE_ADDR + OFFSET_DDRC_SWSTAT);
+	} while ((tmp32 & SWSTAT_SWDONE_ACK_MASK) != SWSTAT_SW_NOT_DONE);
 
-		mmio_write_32(DDRC_BASE_ADDR + OFFSET_DDRC_DRAMTMG4, tmp32);
+	tmp32 = mmio_read_32(DDRC_BASE_ADDR + OFFSET_DDRC_DRAMTMG4);
+	/*
+	 * Set minimum time from activate to read/write command to same
+	 * bank: DRAMTMG4.T_RCD += 2
+	 */
+	if (!update_bf(&tmp32, DRAMTMG4_TRCD_POS, DRAMTMG4_TRCD_MASK,
+		       DRAMTMG4_TRCD_DELTA_TIME))
+		return BITFIELD_EXCEEDED;
 
-		/*
-		 * Set minimum time between activate and precharge to same bank
-		 * DRAMTMG0.T_RAS_MIN += 2
-		 */
-		tmp32 = mmio_read_32(DDRC_BASE_ADDR + OFFSET_DDRC_DRAMTMG0);
-		if (!update_bf(&tmp32, DDRC_DRAMTMG0_TRAS_POS,
-			       DDRC_DRAMTMG0_TRAS_MASK, 2))
-			return BITFIELD_EXCEEDED;
+	/*
+	 * Set minimum time between activates from bank "a" to bank "b"
+	 * DRAMTMG4.T_RRD += 2
+	 */
+	if (!update_bf(&tmp32, DRAMTMG4_TRRD_POS, DRAMTMG4_TRRD_MASK,
+		       DRAMTMG4_TRRD_DELTA_TIME))
+		return BITFIELD_EXCEEDED;
 
-		mmio_write_32(DDRC_BASE_ADDR + OFFSET_DDRC_DRAMTMG0, tmp32);
+	mmio_write_32(DDRC_BASE_ADDR + OFFSET_DDRC_DRAMTMG4, tmp32);
 
-		/*
-		 * Set minimum time from single-bank precharge to activate of
-		 * same bank: DRAMTMG4.T_RP += 2
-		 */
-		tmp32 = mmio_read_32(DDRC_BASE_ADDR + OFFSET_DDRC_DRAMTMG4);
-		if (!update_bf(&tmp32, DDRC_DRAMTMG4_TRP_POS,
-			       DDRC_DRAMTMG4_TRP_MASK, 2))
-			return BITFIELD_EXCEEDED;
+	/*
+	 * Set minimum time between activate and precharge to same bank
+	 * DRAMTMG0.T_RAS_MIN += 2
+	 */
+	tmp32 = mmio_read_32(DDRC_BASE_ADDR + OFFSET_DDRC_DRAMTMG0);
+	if (!update_bf(&tmp32, DRAMTMG0_TRAS_POS,
+		       DRAMTMG0_TRAS_MASK, DRAMTMG0_TRAS_DELTA_TIME))
+		return BITFIELD_EXCEEDED;
 
-		mmio_write_32(DDRC_BASE_ADDR + OFFSET_DDRC_DRAMTMG4, tmp32);
+	mmio_write_32(DDRC_BASE_ADDR + OFFSET_DDRC_DRAMTMG0, tmp32);
 
-		/*
-		 * Set minimum time between activates to same bank:
-		 * DRAMTMG1.T_RC += 3
-		 */
-		tmp32 = mmio_read_32(DDRC_BASE_ADDR + OFFSET_DDRC_DRAMTMG1);
-		if (!update_bf(&tmp32, DDRC_DRAMTMG1_TRC_POS,
-			       DDRC_DRAMTMG1_TRC_MASK, 3))
-			return BITFIELD_EXCEEDED;
+	/*
+	 * Set minimum time from single-bank precharge to activate of
+	 * same bank: DRAMTMG4.T_RP += 2
+	 */
+	tmp32 = mmio_read_32(DDRC_BASE_ADDR + OFFSET_DDRC_DRAMTMG4);
+	if (!update_bf(&tmp32, DRAMTMG4_TRP_POS,
+		       DRAMTMG4_TRP_MASK, DRAMTMG4_TRP_DELTA_TIME))
+		return BITFIELD_EXCEEDED;
 
-		mmio_write_32(DDRC_BASE_ADDR + OFFSET_DDRC_DRAMTMG1, tmp32);
+	mmio_write_32(DDRC_BASE_ADDR + OFFSET_DDRC_DRAMTMG4, tmp32);
 
-		/* Set SWCTL.sw_done to 1 */
-		mmio_write_32(DDRC_BASE_ADDR + OFFSET_DDRC_SWCTL,
-			      DDRC_SWCTL_SWDONE_DONE);
-		do {
-			tmp32 = mmio_read_32(DDRC_BASE_ADDR + 
-					     OFFSET_DDRC_SWSTAT);
-		} while ((tmp32 & DDRC_SWSTAT_SWDONE_ACK_MASK) == 0);
+	/*
+	 * Set minimum time between activates to same bank:
+	 * DRAMTMG1.T_RC += 3
+	 */
+	tmp32 = mmio_read_32(DDRC_BASE_ADDR + OFFSET_DDRC_DRAMTMG1);
+	if (!update_bf(&tmp32, DRAMTMG1_TRC_POS,
+		       DRAMTMG1_TRC_MASK, DRAMTMG1_TRC_DELTA_TIME))
+		return BITFIELD_EXCEEDED;
 
-		polling_needed = 1;
+	mmio_write_32(DDRC_BASE_ADDR + OFFSET_DDRC_DRAMTMG1, tmp32);
 
-	} else {
-		/* Enable timing parameter derating: DERATEEN.DERATE_EN = 1 */
-		tmp32 = mmio_read_32(DDRC_BASE_ADDR + OFFSET_DDRC_DERATEEN);
-		mmio_write_32(DDRC_BASE_ADDR + OFFSET_DDRC_DERATEEN,
-			      tmp32 | DDRC_DERATEEN_ENABLE);
+	/* Set SWCTL.sw_done to 1 */
+	mmio_write_32(DDRC_BASE_ADDR + OFFSET_DDRC_SWCTL, SWCTL_SWDONE_DONE);
+	do {
+		tmp32 = mmio_read_32(DDRC_BASE_ADDR + OFFSET_DDRC_SWSTAT);
+	} while ((tmp32 & SWSTAT_SWDONE_ACK_MASK) == SWSTAT_SW_NOT_DONE);
+
+	polling_needed = 1;
 
-		polling_needed = 0;
-	}
 	return NO_ERR;
 }
diff --git a/drivers/nxp/s32g/ddr/ddrss_cfg.c b/drivers/nxp/s32g/ddr/ddrss_cfg.c
index f8a7d17f6..f5e3ffad1 100644
--- a/drivers/nxp/s32g/ddr/ddrss_cfg.c
+++ b/drivers/nxp/s32g/ddr/ddrss_cfg.c
@@ -1,5 +1,5 @@
 /*
- * Copyright 2020-2021 NXP
+ * Copyright 2021 NXP
  *
  * Redistribution and use in source and binary forms, with or without
  * modification, are permitted provided that the following conditions are met:
@@ -34,23 +34,23 @@
 
 struct ddrss_config configs[] = {
 	{
-		.memory_type = LPDDR4,
-		.ddrc_cfg = &ddrc_cfg[0],
-		.ddrc_cfg_size = 0,
-		.dq_swap_cfg = &dq_swap_cfg[0],
-		.dq_swap_cfg_size = 0,
-		.phy_cfg = &phy_cfg[0],
-		.phy_cfg_size = 0,
-		.imem_1d = &imem_1d[0],
+		.memory_type = (uint8_t)LPDDR4,
+		.ddrc = &ddrc_cfg[0],
+		.ddrc_size = 0,
+		.dq_swap = &dq_swap_cfg[0],
+		.dq_swap_size = 0,
+		.phy = &phy_cfg[0],
+		.phy_size = 0,
+		.imem_1d = &imem_1d_cfg[0],
 		.imem_1d_size = 0,
-		.dmem_1d = &dmem_1d[0],
+		.dmem_1d = &dmem_1d_cfg[0],
 		.dmem_1d_size = 0,
-		.imem_2d = &imem_2d[0],
+		.imem_2d = &imem_2d_cfg[0],
 		.imem_2d_size = 0,
-		.dmem_2d = &dmem_2d[0],
+		.dmem_2d = &dmem_2d_cfg[0],
 		.dmem_2d_size = 0,
-		.pie_cfg = &pie_cfg[0],
-		.pie_cfg_size = 0,
+		.pie = &pie_cfg[0],
+		.pie_size = 0,
 	}
 };
 
@@ -59,14 +59,14 @@ void init_image_sizes(void)
 	size_t i;
 
 	for (i = 0; i < ddrss_config_size; i++) {
-		configs[i].ddrc_cfg_size = ddrc_cfg_size;
-		configs[i].dq_swap_cfg_size = dq_swap_cfg_size;
-		configs[i].phy_cfg_size = phy_cfg_size;
-		configs[i].imem_1d_size = imem_1d_size;
-		configs[i].dmem_1d_size = dmem_1d_size;
-		configs[i].imem_2d_size = imem_2d_size;
-		configs[i].dmem_2d_size = dmem_2d_size;
-		configs[i].pie_cfg_size = pie_cfg_size;
+		configs[i].ddrc_size = ddrc_cfg_size;
+		configs[i].dq_swap_size = dq_swap_cfg_size;
+		configs[i].phy_size = phy_cfg_size;
+		configs[i].imem_1d_size = imem_1d_cfg_size;
+		configs[i].dmem_1d_size = dmem_1d_cfg_size;
+		configs[i].imem_2d_size = imem_2d_cfg_size;
+		configs[i].dmem_2d_size = dmem_2d_cfg_size;
+		configs[i].pie_size = pie_cfg_size;
 	}
 }
 
diff --git a/drivers/nxp/s32g/ddr/dmem_cfg.c b/drivers/nxp/s32g/ddr/dmem_cfg.c
index 9486b3045..0cabdb11d 100644
--- a/drivers/nxp/s32g/ddr/dmem_cfg.c
+++ b/drivers/nxp/s32g/ddr/dmem_cfg.c
@@ -30,7 +30,7 @@
 
 #include <ddr/ddr_init.h>
 
-uint16_t dmem_1d[] = {
+uint16_t dmem_1d_cfg[] = {
 	0x0000,
 	0x0000,
 	0x0000,
@@ -863,9 +863,9 @@ uint16_t dmem_1d[] = {
 	0x0000,
 };
 
-size_t dmem_1d_size = ARRAY_SIZE(dmem_1d);
+size_t dmem_1d_cfg_size = ARRAY_SIZE(dmem_1d_cfg);
 
-uint16_t dmem_2d[] = {
+uint16_t dmem_2d_cfg[] = {
 	0x0000,
 	0x0000,
 	0x0000,
@@ -1570,4 +1570,4 @@ uint16_t dmem_2d[] = {
 	0x0000,
 };
 
-size_t dmem_2d_size = ARRAY_SIZE(dmem_2d);
+size_t dmem_2d_cfg_size = ARRAY_SIZE(dmem_2d_cfg);
diff --git a/drivers/nxp/s32g/ddr/imem_cfg.c b/drivers/nxp/s32g/ddr/imem_cfg.c
index c083ad9ec..2984ea3b3 100644
--- a/drivers/nxp/s32g/ddr/imem_cfg.c
+++ b/drivers/nxp/s32g/ddr/imem_cfg.c
@@ -30,7 +30,7 @@
 
 #include <ddr/ddr_init.h>
 
-uint16_t imem_1d[] = {
+uint16_t imem_1d_cfg[] = {
 	0x0114,
 	0x0000,
 	0x0050,
@@ -16417,9 +16417,9 @@ uint16_t imem_1d[] = {
 	0x0000,
 };
 
-size_t imem_1d_size = ARRAY_SIZE(imem_1d);
+size_t imem_1d_cfg_size = ARRAY_SIZE(imem_1d_cfg);
 
-uint16_t imem_2d[] = {
+uint16_t imem_2d_cfg[] = {
 	0x0204,
 	0x0000,
 	0x0050,
@@ -32806,4 +32806,4 @@ uint16_t imem_2d[] = {
 	0x0000,
 };
 
-size_t imem_2d_size = ARRAY_SIZE(imem_2d);
+size_t imem_2d_cfg_size = ARRAY_SIZE(imem_2d_cfg);
diff --git a/include/drivers/nxp/s32g/ddr/ddr_init.h b/include/drivers/nxp/s32g/ddr/ddr_init.h
index 002d925e8..fe3712ae2 100644
--- a/include/drivers/nxp/s32g/ddr/ddr_init.h
+++ b/include/drivers/nxp/s32g/ddr/ddr_init.h
@@ -44,6 +44,17 @@
 #define LOCK_CSR_ACCESS   0x00000001
 #define UNLOCK_CSR_ACCESS 0x00000000
 
+#define APBONLY_RESET_TO_MICRO_MASK		0x00000008U
+#define APBONLY_STALL_TO_MICRO_MASK		0x00000001U
+#define APBONLY_RESET_STALL_MASK	APBONLY_RESET_TO_MICRO_MASK | \
+	APBONLY_STALL_TO_MICRO_MASK
+#define APBONLY_MICRORESET_CLR_MASK	0x00000000
+
+#define PLLCTRL1_VALUE		0x00000021
+#define PLLTESTMODE_VALUE	0x00000024
+#define PLLCTRL4_VALUE		0x0000017F
+#define PLLCTRL2_VALUE		0x00000019
+
 #define FIRMWARE_VERSION "2020_06_SP2"
 
 /* Enum for DRAM Type */
@@ -69,12 +80,12 @@ struct dqconf {
 
 struct ddrss_config {
 	uint8_t memory_type;
-	struct regconf *ddrc_cfg;
-	size_t ddrc_cfg_size;
-	struct dqconf *dq_swap_cfg;
-	size_t dq_swap_cfg_size;
-	struct regconf_16 *phy_cfg;
-	size_t phy_cfg_size;
+	struct regconf *ddrc;
+	size_t ddrc_size;
+	struct dqconf *dq_swap;
+	size_t dq_swap_size;
+	struct regconf_16 *phy;
+	size_t phy_size;
 	uint16_t *imem_1d;
 	size_t imem_1d_size;
 	uint16_t *dmem_1d;
@@ -83,8 +94,8 @@ struct ddrss_config {
 	size_t imem_2d_size;
 	uint16_t *dmem_2d;
 	size_t dmem_2d_size;
-	struct regconf_16 *pie_cfg;
-	size_t pie_cfg_size;
+	struct regconf_16 *pie;
+	size_t pie_size;
 };
 
 extern struct regconf ddrc_cfg[];
@@ -93,14 +104,14 @@ extern struct dqconf dq_swap_cfg[];
 extern size_t dq_swap_cfg_size;
 extern struct regconf_16 phy_cfg[];
 extern size_t phy_cfg_size;
-extern uint16_t imem_1d[];
-extern size_t imem_1d_size;
-extern uint16_t dmem_1d[];
-extern size_t dmem_1d_size;
-extern uint16_t imem_2d[];
-extern size_t imem_2d_size;
-extern uint16_t dmem_2d[];
-extern size_t dmem_2d_size;
+extern uint16_t imem_1d_cfg[];
+extern size_t imem_1d_cfg_size;
+extern uint16_t dmem_1d_cfg[];
+extern size_t dmem_1d_cfg_size;
+extern uint16_t imem_2d_cfg[];
+extern size_t imem_2d_cfg_size;
+extern uint16_t dmem_2d_cfg[];
+extern size_t dmem_2d_cfg_size;
 extern struct regconf_16 pie_cfg[];
 extern size_t pie_cfg_size;
 extern struct ddrss_config configs[];
@@ -122,7 +133,7 @@ void init_image_sizes(void);
  * @param cfg - array of configuration elements
  * @return - error code, 0 if init succeeds, non-zero on error.
  */
-uint32_t load_register_cfg(size_t size, struct regconf cfg[]);
+uint32_t load_register_cfg(size_t size, const struct regconf cfg[]);
 
 /*
  * Writes the data associated for each address. Similar to
@@ -133,7 +144,7 @@ uint32_t load_register_cfg(size_t size, struct regconf cfg[]);
  * @param cfg - array of configuration elements
  * @return - error code, 0 if init succeeds, non-zero on error.
  */
-uint32_t load_register_cfg_16(size_t size, struct regconf_16 cfg[]);
+uint32_t load_register_cfg_16(size_t size, const struct regconf_16 cfg[]);
 
 /*
  * Writes the data associated for each address. Similar to
@@ -144,7 +155,7 @@ uint32_t load_register_cfg_16(size_t size, struct regconf_16 cfg[]);
  * @param cfg - array of configuration elements
  * @return - error code, 0 if init succeeds, non-zero on error.
  */
-uint32_t load_dq_cfg(size_t size, struct dqconf cfg[]);
+uint32_t load_dq_cfg(size_t size, const struct dqconf cfg[]);
 
 /* Updates PHY internal PLL settings. */
 void set_optimal_pll(void);
diff --git a/include/drivers/nxp/s32g/ddr/ddr_lp.h b/include/drivers/nxp/s32g/ddr/ddr_lp.h
index d7ad40f6a..6afdebc6a 100644
--- a/include/drivers/nxp/s32g/ddr/ddr_lp.h
+++ b/include/drivers/nxp/s32g/ddr/ddr_lp.h
@@ -33,11 +33,11 @@
 
 #include "ddr_init.h"
 
-#define DDRSS_BASE_ADDR                 0x40380000
+#define DDRSS_BASE_ADDR                 0x40380000U
 
-#define DDR_GPR_OFFSET                  (0x4007c600UL)
-#define DDR_CONFIG_0_REG                (DDR_GPR_OFFSET + 0x00)
-#define DDR_RET_CONTROL_REG             (DDR_GPR_OFFSET + 0x1c)
+#define DDR_GPR_OFFSET                  (0x4007c600U)
+#define DDR_CONFIG_0_REG                (DDR_GPR_OFFSET + 0x00U)
+#define DDR_RET_CONTROL_REG             (DDR_GPR_OFFSET + 0x1cU)
 #define DDR_RET_CONTROL_MASK            SHIFT_BIT(0)
 #define DDR_CONFIG_0_MEM_RET            SHIFT_BIT(14)
 
@@ -45,7 +45,12 @@
 #define SELFREF_STATE_SRPD              (0x2UL << 8)
 #define SELFREF_STATE_MASK              (SHIFT_BIT(8) | SHIFT_BIT(9))
 #define SELFREF_TYPE_NOT_AUTO_SR_CTRL   (0x2UL << 4)
-#define OPERATING_MODE_SELF_REFRESH     (0x3)
+#define OPERATING_MODE_SELF_REFRESH     0x3U
+
+#define DISABLE_AXI_PORT                0x0
+#define DFIMISC_TRANSITION_PHY_TO_LP3   0x0
+#define DFIMISC_LP3_PHY_STATE           0x1fUL
+#define	STAT_RESET_VALUE                0x0U
 
 extern const uint32_t csr_to_store[];
 extern size_t csr_to_store_size;
diff --git a/include/drivers/nxp/s32g/ddr/ddr_utils.h b/include/drivers/nxp/s32g/ddr/ddr_utils.h
index 09e11a2ac..abb9a36f5 100644
--- a/include/drivers/nxp/s32g/ddr/ddr_utils.h
+++ b/include/drivers/nxp/s32g/ddr/ddr_utils.h
@@ -38,86 +38,173 @@
 #define STORE_CSR_ENABLE
 
 /* Possible errors */
-#define NO_ERR              0x00000000
-#define TIMEOUT_ERR         0x00000002
-#define TRAINING_FAILED     0x00000003
-#define BITFIELD_EXCEEDED   0x00000004
+#define NO_ERR              0x00000000U
+#define TIMEOUT_ERR         0x00000002U
+#define TRAINING_FAILED     0x00000003U
+#define BITFIELD_EXCEEDED   0x00000004U
 
 /* DDRC related */
-#define DDRC_BASE_ADDR                   0x403C0000
-#define OFFSET_DDRC_SWCTL                0x320
-#define OFFSET_DDRC_DFIMISC              0x1b0
-#define OFFSET_DDRC_DFISTAT              0x1bc
-#define OFFSET_DDRC_PWRCTL               0x30
-#define OFFSET_DDRC_SWSTAT               0x324
-#define OFFSET_DDRC_STAT                 0x04
-#define OFFSET_DDRC_DBG1                 0x304
-#define OFFSET_DDRC_ECCCFG0              0x70
-#define OFFSET_DDRC_ECCCFG1              0x74
-#define OFFSET_DDRC_SBRCTL               0xf24
-#define OFFSET_DDRC_SBRSTAT              0xf28
-#define OFFSET_DDRC_SBRWDATA0            0xf2c
-#define OFFSET_DDRC_MRSTAT               0x18
-#define OFFSET_DDRC_MRCTRL0              0x10
-#define OFFSET_DDRC_MRCTRL1              0x14
-#define OFFSET_DDRC_DERATEEN             0x20
-#define OFFSET_DDRC_RFSHTMG              0x64
-#define OFFSET_DDRC_DRAMTMG0             0x100
-#define OFFSET_DDRC_DRAMTMG1             0x104
-#define OFFSET_DDRC_DRAMTMG4             0x110
+#define DDRC_BASE_ADDR                   0x403C0000U
+#define OFFSET_DDRC_SWCTL                0x320U
+#define OFFSET_DDRC_DFIMISC              0x1b0U
+#define OFFSET_DDRC_DFISTAT              0x1bcU
+#define OFFSET_DDRC_PWRCTL               0x30U
+#define OFFSET_DDRC_SWSTAT               0x324U
+#define OFFSET_DDRC_STAT                 0x04U
+#define OFFSET_DDRC_DBG1                 0x304U
+#define OFFSET_DDRC_ECCCFG0              0x70U
+#define OFFSET_DDRC_ECCCFG1              0x74U
+#define OFFSET_DDRC_SBRCTL               0xf24U
+#define OFFSET_DDRC_SBRSTAT              0xf28U
+#define OFFSET_DDRC_SBRWDATA0            0xf2cU
+#define OFFSET_DDRC_MRSTAT               0x18U
+#define OFFSET_DDRC_MRCTRL0              0x10U
+#define OFFSET_DDRC_MRCTRL1              0x14U
+#define OFFSET_DDRC_DERATEEN             0x20U
+#define OFFSET_DDRC_RFSHTMG              0x64U
+#define OFFSET_DDRC_DRAMTMG0             0x100U
+#define OFFSET_DDRC_DRAMTMG1             0x104U
+#define OFFSET_DDRC_DRAMTMG4             0x110U
 
 /* DDRC masks and values */
-#define DDRC_RFSHTMG_VAL_SHIFT           16
-#define DDRC_RFSHTMG_VAL                 0xfffU
-#define DDRC_RFSHTMG_MASK                (DDRC_RFSHTMG_VAL << \
-	DDRC_RFSHTMG_VAL_SHIFT)
-#define DDRC_RFSHCTL3_UPDATE_SHIFT       1
-#define DDRC_RFSHCTL3_AUTO_REFRESH_VAL   0x1U
-#define DDRC_RFSHCTL3_MASK               (DDRC_RFSHCTL3_AUTO_REFRESH_VAL \
-	<< DDRC_RFSHCTL3_UPDATE_SHIFT)
-#define DDRC_DERATEEN_ENABLE             0x1U
-#define DDRC_SWCTL_SWDONE_ENABLE         0x0
-#define DDRC_SWSTAT_SWDONE_ACK_MASK      0x1U
-#define DDRC_DRAMTMG4_TRCD_POS           24
-#define DDRC_DRAMTMG5_TRCD_MASK          0x1f
-#define DDRC_DRAMTMG4_TRRD_POS           8
-#define DDRC_DRAMTMG5_TRRD_MASK          0xf
-#define DDRC_DRAMTMG0_TRAS_POS           0
-#define DDRC_DRAMTMG0_TRAS_MASK          0x3f
-#define DDRC_DRAMTMG4_TRP_POS            0
-#define DDRC_DRAMTMG4_TRP_MASK           0x1f
-#define DDRC_DRAMTMG1_TRC_POS            0
-#define DDRC_DRAMTMG1_TRC_MASK           0x7f
-#define DDRC_SWCTL_SWDONE_DONE           0x1
-#define SUCCESSIVE_READ                  2
-#define DDRC_DERATEEN_MASK_DISABLE       0x1U
-#define MSTR_LPDDR4_MASK                 0x20U
-#define MSTR_LPDDR4_VAL                  0x20U
+#define MSTR_LPDDR4_MASK	0x20U
+#define MSTR_LPDDR4_VAL		0x20U
+#define SWSTAT_SW_DONE		1U
+#define SWSTAT_SW_NOT_DONE	0U
+#define SWCTL_SWDONE_DONE	0x1
+#define SWCTL_SWDONE_ENABLE	0x0
+#define SWSTAT_SWDONE_ACK_MASK	0x1U
+#define RFSHTMG_VAL_SHIFT           16
+#define RFSHTMG_VAL                 0xfffUL
+#define RFSHTMG_MASK                (RFSHTMG_VAL << \
+	RFSHTMG_VAL_SHIFT)
+#define RFSHCTL3_UPDATE_SHIFT       1
+#define RFSHCTL3_AUTO_REFRESH_VAL   0x1U
+#define RFSHCTL3_MASK               (RFSHCTL3_AUTO_REFRESH_VAL \
+	<< RFSHCTL3_UPDATE_SHIFT)
+#define DERATEEN_ENABLE		0x1U
+#define DRAMTMG4_TRCD_POS	24
+#define DRAMTMG4_TRCD_MASK	0x1f
+#define DRAMTMG4_TRRD_POS	8
+#define DRAMTMG4_TRRD_MASK	0xf
+#define DRAMTMG0_TRAS_POS	0
+#define DRAMTMG0_TRAS_MASK	0x3f
+#define DRAMTMG4_TRP_POS	0
+#define DRAMTMG4_TRP_MASK	0x1f
+#define DRAMTMG1_TRC_POS	0
+#define DRAMTMG1_TRC_MASK	0x7f
+#define SUCCESSIVE_READ		0x2U
+#define	DERATEEN_MASK_DIS	0x1U
+
+#define RFSHTMG_UPDATE_SHIFT		2
+#define RFSHCTL3_UPDATE_LEVEL_TOGGLE	0x1U
+#define DRAMTMG4_TRCD_DELTA_TIME	2
+#define DRAMTMG4_TRRD_DELTA_TIME	2
+#define DRAMTMG0_TRAS_DELTA_TIME	2
+#define DRAMTMG4_TRP_DELTA_TIME		2
+#define DRAMTMG1_TRC_DELTA_TIME		3
+#define ERRATA_CHANGES_REVERTED		1
+#define ERRATA_CHANGES_UNMODIFIED	0
+
+#define CSS_SELSTAT_MASK		0x3f000000U
+#define	CSS_SELSTAT_POS			24
+#define	CSS_SWIP_POS			16
+#define	CSS_SW_IN_PROGRESS		0x1U
+#define	CSS_SW_COMPLETED		0x0U
+#define	CSC_SELCTL_MASK			0xC0FFFFFFU
+#define CSC_SELCTL_POS			24
+#define	CSC_CLK_SWITCH_REQUEST		0x1U
+#define	CSC_CLK_SWITCH_POS		2
+#define	CSS_SW_AFTER_REQUEST_SUCCEDED	0x1U
+#define	CSS_SW_TRIGGER_CAUSE_POS	17
+
+#define DDR_SS_AXI_PARITY_ENABLE_MASK	0x00001FF0U
+#define DDR_SS_AXI_PARITY_TYPE_MASK	0x01FF0000U
+#define DDR_SS_DFI_1_ENABLED		0x1U
+#define FORCED_RESET_ON_PERIPH		0x1U
+#define PRST_0_PERIPH_3_RST_POS		3
+#define DBG1_DISABLE_DE_QUEUEING	0x0U
+#define RFSHCTL3_DISABLE_AUTO_REFRESH	0x1U
+#define ENABLE_AXI_PORT			0x000000001
+
+#define PWRCTL_POWER_DOWN_ENABLE_MASK		0x00000002U
+#define PWRCTL_SELF_REFRESH_ENABLE_MASK		0x00000001U
+#define PWRCTL_EN_DFI_DRAM_CLOCK_DIS_MASK	0x00000008U
+#define DFIMISC_DFI_INIT_COMPLETE_EN_MASK	0x000000001U
+
+#define MASTER0_CAL_ACTIVE		0x1U
+#define MASTER0_CAL_DONE		0x0U
+#define	DFIMISC_DFI_INIT_START_MASK	0x00000020U
+#define	DFISTAT_DFI_INIT_DONE		0x1U
+#define	DFISTAT_DFI_INIT_INCOMPLETE	0x0U
+#define	PWRCTL_SELFREF_SW_MASK		0x00000020U
+#define	STAT_OPERATING_MODE_MASK		0x7U
+#define	STAT_OPERATING_MODE_INIT		0x0U
+#define	RFSHCTL3_DIS_AUTO_REFRESH_MASK	0x00000001U
+#define	ECCCFG0_ECC_MODE_MASK		0x7U
+#define	ECCCFG0_ECC_DISABLED		0x0U
+#define	TRAINING_OK_MSG			0x07U
+#define	TRAINING_FAILED_MSG		0xFFU
+#define	ECCCFG1_REGION_PARITY_LOCKED	0x1UL
+#define	ECCCFG1_REGION_PARITY_LOCK_POS	4
+#define	SBRCTL_SCRUB_MODE_WRITE		0x1UL
+#define	SBRCTL_SCRUB_MODE_POS		2
+
+#define	APBONLY_DCTWRITEPROT_ACK_EN	0
+#define	APBONLY_DCTWRITEPROT_ACK_DIS	1
+#define	SBRCTL_SCRUB_DURING_LOWPOWER_CONTINUED	0x1UL
+#define	SBRCTL_SCRUB_DURING_LOWPOWER_POS		1
+
+#define	SBRCTL_SCRUB_INTERVAL_FIELD	0x1FFFU
+#define	SBRCTL_SCRUB_INTERVAL_POS		8
+#define	SBRCTL_SCRUB_EN		0x1U
+#define	SBRSTAT_SCRUB_DONE_MASK		0x2U
+#define	SBRSTAT_SCRUBBER_NOT_DONE		0x0U
+#define	SBRSTAT_SCRUBBER_BUSY_MASK		0x1U
+#define	SBRSTAT_SCRUBBER_NOT_BUSY		0x0U
+#define	SBRCTL_SCRUB_INTERVAL_VALUE_1	0x1UL
+#define	MRR_0_DDR_SEL_REG_MASK	0x1U
+
+#define	MRSTAT_MR_BUSY			0x1U
+#define	MRSTAT_MR_NOT_BUSY			0x0U
+#define	MRCTRL0_MR_TYPE_READ		0x1U
+#define	MRCTRL0_RANK_ACCESS_POS		4
+#define	MRCTRL0_RANK_ACCESS_FIELD		0xfUL
+#define	MRCTRL0_RANK_0			0x1UL
+#define	MRCTRL1_MR_ADDRESS_FIELD		0xffUL
+#define	MRCTRL1_MR_ADDRESS_POS		8
+#define	MRCTRL0_WR_ENGAGE			0x1UL
+#define	MRCTRL0_WR_ENGAGE_POS		31
+#define	MRCTRL1_MR_DATA_ADDRESS_FIELD	0xffffUL
+#define	MRCTRL1_MR_DATA_ADDRESS_POS	16
+#define STORE_CSR_DISABLED			0x0U
+#define INIT_MEM_DISABLED			0x0U
 
 /* Performance monitoring registers */
-#define PERF_BASE_ADDR                   0x403E0000
-#define OFFSET_MRR_0_DATA_REG_ADDR       0x40
-#define OFFSET_MRR_1_DATA_REG_ADDR       0x44
+#define PERF_BASE_ADDR                   0x403E0000U
+#define OFFSET_MRR_0_DATA_REG_ADDR       0x40U
+#define OFFSET_MRR_1_DATA_REG_ADDR       0x44U
 
 /* uMCTL2 Multi-Port Registers */
-#define DDRC_UMCTL2_MP_BASE_ADDR         0x403C03F8
-#define OFFSET_DDRC_PCTRL_0              0x98
-#define OFFSET_DDRC_PCTRL_1              0x148
-#define OFFSET_DDRC_PCTRL_2              0x1f8
+#define DDRC_UMCTL2_MP_BASE_ADDR         0x403C03F8U
+#define OFFSET_DDRC_PCTRL_0              0x98U
+#define OFFSET_DDRC_PCTRL_1              0x148U
+#define OFFSET_DDRC_PCTRL_2              0x1f8U
 
 /* PHY related */
-#define DDR_PHYA_MASTER0_CALBUSY                 0x4038165C
-#define DDR_PHYA_APBONLY_UCTSHSADOWREGS          0x40380404U
-#define UCT_WRITE_PROT_SHADOW_MASK               0x1U
-#define DDR_PHYA_APBONLY_DCTWRITEPROT            0x4038040C
-#define DDR_PHYA_APBONLY_UCTWRITEONLYSHADOW      0x40380410
-#define OFFSET_DDRC_RFSHCTL3                     0x60
-#define DDR_PHYA_UCCLKHCLKENABLES                0x40380BEC
+#define DDR_PHYA_MASTER0_CALBUSY		0x4038165C
+#define DDR_PHYA_APBONLY_UCTSHADOWREGS		0x40380404U
+#define UCT_WRITE_PROT_SHADOW_MASK              0x1U
+#define DDR_PHYA_DCTWRITEPROT			0x4038040C
+#define DDR_PHYA_APBONLY_UCTWRITEONLYSHADOW	0x40380410
+#define OFFSET_DDRC_RFSHCTL3			0x60U
+#define DDR_PHYA_UCCLKHCLKENABLES		0x40380BEC
+#define UCT_WRITE_PROT_SHADOW_ACK		0x0U
 
 #define SHIFT_BIT(nr)             ((1UL) << (nr))
 #define UCCLKEN_MASK              SHIFT_BIT(0)
 #define HCLKEN_MASK               SHIFT_BIT(1)
-#define OFFSET_DDRC_INIT0         0xd0
+#define OFFSET_DDRC_INIT0         0xd0U
 
 #define STORE_CSR_MASK            SHIFT_BIT(0)
 #define INIT_MEM_MASK             SHIFT_BIT(1)
@@ -134,7 +221,7 @@
 
 /* Standby SRAM */
 #define STNDBY_RAM_BASE           0x24000000
-#define RETENTION_ADDR            BL31SSRAM_CSR_BASE
+#define RETENTION_ADDR            STNDBY_RAM_BASE
 
 /* DDR Subsystem */
 #define DDR_SS_REG                0x403D0000
@@ -142,12 +229,12 @@
 /* Reset Generation Module */
 #define MC_RGM_PRST_0             0x40078040
 #ifndef MC_CGM5_BASE_ADDR
-#define MC_CGM5_BASE_ADDR         0x40068000
+#define MC_CGM5_BASE_ADDR         0x40068000U
 #endif
-#define OFFSET_MUX_0_CSS          0x304
-#define OFFSET_MUX_0_CSC          0x300
-#define FIRC_CLK_SRC              0x0
-#define DDR_PHI0_PLL              0x24
+#define OFFSET_MUX_0_CSS          0x304U
+#define OFFSET_MUX_0_CSC          0x300U
+#define FIRC_CLK_SRC              0x0U
+#define DDR_PHI0_PLL              0x24U
 
 /* Default timeout for DDR PHY operations */
 #define DEFAULT_TIMEOUT 1000000
@@ -158,11 +245,13 @@
 
 /* ERR050543 related defines */
 #define MR4_IDX 4
-#define TUF_THRESHOLD 3
-#define REQUIRED_OK_CHECKS 3
+#define MR4_MASK	0x7U
+#define MR4_SHIFT	16
+#define TUF_THRESHOLD 0x3U
+#define REQUIRED_OK_CHECKS 0x3U
 
 /* ERR050760 related defines */
-#define REQUIRED_MRSTAT_READS 2
+#define REQUIRED_MRSTAT_READS 0x2U
 
 extern uint8_t polling_needed;
 
@@ -180,16 +269,6 @@ uint32_t post_train_setup(uint8_t options);
 /* Wait until firmware finishes execution and return training result */
 uint32_t wait_firmware_execution(void);
 
-/* Initialize memory with the ecc scrubber */
-uint32_t init_memory_ecc_scrubber(void);
-
-/*
- * Set the ddr clock source, FIRC or DDR_PLL_PHI0.
- * @param clk_src - requested clock source
- * @return - true whether clock source has been changed, false otherwise
- */
-bool sel_clk_src(uint32_t clk_src);
-
 /* Read lpddr4 mode register.
  * @param mr_index - index of mode register to be read
  */
-- 
2.17.1

