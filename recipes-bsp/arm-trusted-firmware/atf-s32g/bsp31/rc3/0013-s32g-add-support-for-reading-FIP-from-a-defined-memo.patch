From 67617008ab73cd3b6da66a633078da00c6003af0 Mon Sep 17 00:00:00 2001
From: Catalin Udma <catalin-dan.udma@nxp.com>
Date: Mon, 11 Oct 2021 13:42:24 +0300
Subject: [PATCH 13/24] s32g: add support for reading FIP from a defined memory
 offset

A new parameter is added in Makefile: FIP_MEM_OFFSET

When it is not defined, the existing procedure for loading FIP is used:
it is read from the QSPI/MMC offsets depending on boot source

When FIP_MEM_OFFSET is defined as a memory address, FIP is loaded from
the defined memory address independent of the boot source. It is the M7
bootloader responsibility to load the fip at the specified address
before starting BL2.
FIP_MEM_OFFSET should be chosen such that it does not overlap with the
existing memory mapping and SRAM usage.

How to build example:
make DEBUG=1 PLAT=s32g2 BL33=<path to u-boot.bin> FIP_MEM_OFFSET=0x34520000

Issue: ALB-7495

Upstream-Status: Pending 

Signed-off-by: Catalin Udma <catalin-dan.udma@nxp.com>
Signed-off-by: Zhantao Tang <zhantao.tang@windriver.com>
---
 plat/nxp/s32g/s32g_common.mk |  8 ++++++++
 plat/nxp/s32g/s32g_storage.c | 25 +++++++++++++++++++++----
 2 files changed, 29 insertions(+), 4 deletions(-)

diff --git a/plat/nxp/s32g/s32g_common.mk b/plat/nxp/s32g/s32g_common.mk
index da490acf4..ee35d743a 100644
--- a/plat/nxp/s32g/s32g_common.mk
+++ b/plat/nxp/s32g/s32g_common.mk
@@ -155,6 +155,14 @@ $(eval $(call add_define,FIP_MMC_OFFSET))
 FIP_QSPI_OFFSET		?= 0x3400
 $(eval $(call add_define,FIP_QSPI_OFFSET))
 
+# If FIP_MEM_OFFSET is defined, the FIP is not read from boot source (QSPI/MMC)
+# but from this defined memory address.
+# The use case is that M7 bootloader loads the FIP from storage at this SRAM
+# location and BL2 will read from it without accessing the storage.
+ifdef FIP_MEM_OFFSET
+$(eval $(call add_define,FIP_MEM_OFFSET))
+endif
+
 FIP_MAXIMUM_SIZE	:= 0x400000
 $(eval $(call add_define,FIP_MAXIMUM_SIZE))
 
diff --git a/plat/nxp/s32g/s32g_storage.c b/plat/nxp/s32g/s32g_storage.c
index 161effab5..67921b64f 100644
--- a/plat/nxp/s32g/s32g_storage.c
+++ b/plat/nxp/s32g/s32g_storage.c
@@ -72,6 +72,13 @@ static io_block_spec_t qspi_fip_memmap_spec = {
 	.length = FIP_MAXIMUM_SIZE,
 };
 
+#ifdef FIP_MEM_OFFSET
+static io_block_spec_t mem_fip_memmap_spec = {
+	.offset = FIP_MEM_OFFSET,
+	.length = FIP_MAXIMUM_SIZE,
+};
+#endif
+
 static struct plat_io_policy s32g_policies[] = {
 	[BL31_IMAGE_ID] = {
 		&s32g_fip_dev_handle,
@@ -226,6 +233,8 @@ static void set_fip_img_source(struct plat_io_policy *policy)
 	bl_mem_params_node_t *fip_params =
 			get_bl_mem_params_node(FIP_IMAGE_ID);
 	image_info_t *image_info = &fip_params->image_info;
+	io_block_spec_t *io_mem_spec = &qspi_fip_memmap_spec;
+	bool use_mem_offset = false;
 
 	/* No need to check boot_source value integrity here.
 	 * If the previous check had failed, the boot flow would
@@ -240,15 +249,23 @@ static void set_fip_img_source(struct plat_io_policy *policy)
 	 * and second time when the entire FIP is read and image_size
 	 * will be the one obtained in bl2_plat_handle_post_image_load.
 	 */
-	if (boot_source == BOOT_SOURCE_QSPI) {
+
+#ifdef FIP_MEM_OFFSET
+	/* Independent of the boot source, read FIP from Memory */
+	io_mem_spec = &mem_fip_memmap_spec;
+	use_mem_offset = true;
+#endif
+
+	if ((use_mem_offset == true) ||
+		(boot_source == BOOT_SOURCE_QSPI)) {
 		/* io_dev_init will check the header before image_info->image_size
 		 * is computed.
 		 */
-		qspi_fip_memmap_spec.length = image_info->image_size ?
-			image_info->image_size : qspi_fip_memmap_spec.length;
+		io_mem_spec->length = image_info->image_size ?
+			image_info->image_size : io_mem_spec->length;
 		*policy = (struct plat_io_policy) {
 			.dev_handle = &s32g_memmap_dev_handle,
-			.image_spec = (uintptr_t)&qspi_fip_memmap_spec,
+			.image_spec = (uintptr_t)io_mem_spec,
 			.check = s32g_check_memmap_dev,
 		};
 	} else {
-- 
2.17.1

