From 1d97640a7381e784919bb56c5850cdf111578d2b Mon Sep 17 00:00:00 2001
From: Ghennadi Procopciuc <ghennadi.procopciuc@nxp.com>
Date: Tue, 5 Oct 2021 14:45:47 +0300
Subject: [PATCH 11/24] s32g: Correct A53 kick-off

This corrects A53 enablement in MC_ME IP.

Issue: ALB-7714
Upstream-Status: Pending 

Signed-off-by: Ghennadi Procopciuc <ghennadi.procopciuc@nxp.com>
Signed-off-by: Zhantao Tang <zhantao.tang@windriver.com>
---
 plat/nxp/s32g/include/s32g_mc_me.h | 24 +++++++++++-------
 plat/nxp/s32g/s32g2/s32g2_mc_rgm.c |  2 +-
 plat/nxp/s32g/s32g3/s32g3_mc_rgm.c |  2 +-
 plat/nxp/s32g/s32g_mc_me.c         | 39 ++++++++++++++++++++----------
 4 files changed, 43 insertions(+), 24 deletions(-)

diff --git a/plat/nxp/s32g/include/s32g_mc_me.h b/plat/nxp/s32g/include/s32g_mc_me.h
index 551729d64..c692020f4 100644
--- a/plat/nxp/s32g/include/s32g_mc_me.h
+++ b/plat/nxp/s32g/include/s32g_mc_me.h
@@ -1,7 +1,7 @@
 /*
  * MC Mode Entry definitions for S32G274A and compatible SoCs
  *
- * Copyright 2019-2020 NXP
+ * Copyright 2019-2021 NXP
  *
  * SPDX-License-Identifier: BSD-3-Clause
  */
@@ -38,14 +38,18 @@
 #define S32G_MC_ME_CTL_KEY_INVERTEDKEY	0x0000A50F
 
 /* PRTNn registers */
+#define S32G_MC_ME_PRTN_N_PCONF_OFF	0x0
+#define S32G_MC_ME_PRTN_N_PUPD_OFF	0x4
+#define S32G_MC_ME_PRTN_N_STAT_OFF	0x8
+
 #define S32G_MC_ME_PRTN_N_BASE(n) \
 	(S32G_MC_ME_BASE_ADDR + 0x100 + (n) * 0x200)
 #define S32G_MC_ME_PRTN_N_PCONF(n) \
-	(S32G_MC_ME_PRTN_N_BASE(n) + 0x0)
+	(S32G_MC_ME_PRTN_N_BASE(n) + S32G_MC_ME_PRTN_N_PCONF_OFF)
 #define S32G_MC_ME_PRTN_N_PUPD(n) \
-	(S32G_MC_ME_PRTN_N_BASE(n) + 0x4)
+	(S32G_MC_ME_PRTN_N_BASE(n) + S32G_MC_ME_PRTN_N_PUPD_OFF)
 #define S32G_MC_ME_PRTN_N_STAT(n) \
-	(S32G_MC_ME_PRTN_N_BASE(n) + 0x8)
+	(S32G_MC_ME_PRTN_N_BASE(n) + S32G_MC_ME_PRTN_N_STAT_OFF)
 
 /* COFB0 */
 #define S32G_MC_ME_PRTN_N_COFB0_STAT(n) \
@@ -60,17 +64,19 @@
 #define S32G_MC_ME_PRTN_N_REQ(n)		BIT(n)
 
 /* PRTNn_COREm registers */
-#define S32G_MC_ME_PRTN_N_CORE_M_BASE(n, m) \
+#define MC_ME_PRTN_PART(n, m) \
 	(S32G_MC_ME_BASE_ADDR + 0x140 + (n) * 0x200 + \
-	 mc_me_core2prtn_core_id(n, m) * 0x20)
+	 (m) * 0x20)
+#define S32G_MC_ME_PRTN_N_CORE_M_BASE(n, m) \
+	MC_ME_PRTN_PART(n, mc_me_core2prtn_core_id((n), (m)))
 #define S32G_MC_ME_PRTN_N_CORE_M_ADDR(n, m) \
 	(S32G_MC_ME_PRTN_N_CORE_M_BASE(n, m) + 0xc)
 #define S32G_MC_ME_PRTN_N_CORE_M_PCONF(n, m) \
-	S32G_MC_ME_PRTN_N_CORE_M_BASE(n, m)
+	(S32G_MC_ME_PRTN_N_CORE_M_BASE(n, m) + S32G_MC_ME_PRTN_N_PCONF_OFF)
 #define S32G_MC_ME_PRTN_N_CORE_M_PUPD(n, m) \
-	(S32G_MC_ME_PRTN_N_CORE_M_BASE(n, m) + 0x4)
+	(S32G_MC_ME_PRTN_N_CORE_M_BASE(n, m) + S32G_MC_ME_PRTN_N_PUPD_OFF)
 #define S32G_MC_ME_PRTN_N_CORE_M_STAT(n, m) \
-	(S32G_MC_ME_PRTN_N_CORE_M_BASE(n, m) + 0x8)
+	(S32G_MC_ME_PRTN_N_CORE_M_BASE(n, m) + S32G_MC_ME_PRTN_N_STAT_OFF)
 #define S32G_MC_ME_PRTN_N_CORE_M_PCONF_CCE_MASK		0x1ul
 #define S32G_MC_ME_PRTN_N_CORE_M_PUPD_CCUPD_MASK	0x1ul
 #define S32G_MC_ME_PRTN_N_CORE_M_STAT_CCS_MASK		BIT(0)
diff --git a/plat/nxp/s32g/s32g2/s32g2_mc_rgm.c b/plat/nxp/s32g/s32g2/s32g2_mc_rgm.c
index 87b326375..daa5a8bc4 100644
--- a/plat/nxp/s32g/s32g2/s32g2_mc_rgm.c
+++ b/plat/nxp/s32g/s32g2/s32g2_mc_rgm.c
@@ -11,5 +11,5 @@ uint8_t get_rgm_a53_bit(uint8_t core)
 	 * Bit corresponding to CA53_n in the cores'
 	 * RGM reset partition (n=0..3)
 	 */
-	return BIT(core + 1);
+	return core + 1;
 }
diff --git a/plat/nxp/s32g/s32g3/s32g3_mc_rgm.c b/plat/nxp/s32g/s32g3/s32g3_mc_rgm.c
index 1f2c69778..f66837216 100644
--- a/plat/nxp/s32g/s32g3/s32g3_mc_rgm.c
+++ b/plat/nxp/s32g/s32g3/s32g3_mc_rgm.c
@@ -20,5 +20,5 @@ uint8_t get_rgm_a53_bit(uint8_t core)
 		[7] = 72,
 	};
 
-	return BIT(periph_rgm_coresp[core] % 64);
+	return periph_rgm_coresp[core] % 64;
 }
diff --git a/plat/nxp/s32g/s32g_mc_me.c b/plat/nxp/s32g/s32g_mc_me.c
index b518c913e..75c99b84f 100644
--- a/plat/nxp/s32g/s32g_mc_me.c
+++ b/plat/nxp/s32g/s32g_mc_me.c
@@ -177,7 +177,7 @@ bool s32g_core_in_reset(uint32_t core)
 {
 	uint32_t stat, rst;
 
-	rst = get_rgm_a53_bit(core);
+	rst = BIT(get_rgm_a53_bit(core));
 	stat = mmio_read_32(S32G_MC_RGM_PSTAT(S32G_MC_RGM_RST_DOMAIN_CA53));
 	return ((stat & rst) != 0);
 }
@@ -207,10 +207,10 @@ static void enable_a53_partition(void)
 	mc_me_apply_hw_changes();
 }
 
-static void enable_a53_core_clock(uint32_t core)
+static void enable_a53_core_cluster(uint32_t core)
 {
-	uint32_t pconf;
-	uint32_t part = S32G_MC_ME_CA53_PART;
+	uint32_t stat, part = S32G_MC_ME_CA53_PART;
+	uint64_t addr;
 
 	/* For S32G2 we have the following mapping:
 	 * MC_ME_PRTN1_CORE0_* -> CA53 cluster0 core0/1
@@ -219,11 +219,13 @@ static void enable_a53_core_clock(uint32_t core)
 	 * MC_ME_PRTN1_CORE0_* -> CA53 cluster0 core0/1/2/3
 	 * MC_ME_PRTN1_CORE2_* -> CA53 cluster1 core0/1/2/3
 	 */
-	uint32_t pconf_index = (core % 4) & ~1;
+	uint32_t pconf_cluster = (core % 4) & ~1;
 
-	pconf = mmio_read_32(S32G_MC_ME_PRTN_N_CORE_M_PCONF(part, pconf_index));
+	addr = MC_ME_PRTN_PART(part, pconf_cluster) +
+	    S32G_MC_ME_PRTN_N_STAT_OFF;
+	stat = mmio_read_32(addr);
 
-	if (pconf & S32G_MC_ME_PRTN_N_CORE_M_PCONF_CCE_MASK)
+	if (stat & S32G_MC_ME_PRTN_N_CORE_M_STAT_CCS_MASK)
 		return;
 
 	/* When in performance (i.e., not in lockstep) mode, the following
@@ -232,12 +234,23 @@ static void enable_a53_core_clock(uint32_t core)
 	 * on even-numbered cores.
 	 */
 	/* Enable clock and make changes effective */
-	mc_me_part_core_pconf_write_cce(1, part, pconf_index);
-	mc_me_part_core_pupd_write_ccupd(1, part, pconf_index);
+	addr = MC_ME_PRTN_PART(part, pconf_cluster) +
+	    S32G_MC_ME_PRTN_N_PCONF_OFF;
+	mmio_write_32(addr, S32G_MC_ME_PRTN_N_CORE_M_PCONF_CCE_MASK);
+
+	addr = MC_ME_PRTN_PART(part, pconf_cluster) +
+	    S32G_MC_ME_PRTN_N_PUPD_OFF;
+	mmio_write_32(addr, S32G_MC_ME_PRTN_N_CORE_M_PUPD_CCUPD_MASK);
+
 	mc_me_apply_hw_changes();
+
 	/* Wait for the core clock to become active */
-	while (!s32g_core_clock_running(part, pconf_index))
-		;
+	addr = MC_ME_PRTN_PART(part, pconf_cluster) +
+	    S32G_MC_ME_PRTN_N_STAT_OFF;
+	do {
+		stat = mmio_read_32(addr);
+		stat &= S32G_MC_ME_PRTN_N_CORE_M_STAT_CCS_MASK;
+	} while (stat != S32G_MC_ME_PRTN_N_CORE_M_STAT_CCS_MASK);
 }
 
 static void set_core_high_addr(uintptr_t addr, uint32_t core)
@@ -267,7 +280,7 @@ static void set_core_high_addr(uintptr_t addr, uint32_t core)
 void s32g_kick_secondary_ca53_core(uint32_t core, uintptr_t entrypoint)
 {
 	uint32_t rst;
-	uint32_t rst_mask = get_rgm_a53_bit(core);
+	uint32_t rst_mask = BIT(get_rgm_a53_bit(core));
 	const uint32_t part = S32G_MC_ME_CA53_PART;
 
 	enable_a53_partition();
@@ -278,7 +291,7 @@ void s32g_kick_secondary_ca53_core(uint32_t core, uintptr_t entrypoint)
 	 */
 	mc_me_part_core_addr_write(entrypoint, part, core);
 
-	enable_a53_core_clock(core);
+	enable_a53_core_cluster(core);
 
 	/* Release the core reset */
 	rst = mmio_read_32(S32G_MC_RGM_PRST(S32G_MC_RGM_RST_DOMAIN_CA53));
-- 
2.17.1

