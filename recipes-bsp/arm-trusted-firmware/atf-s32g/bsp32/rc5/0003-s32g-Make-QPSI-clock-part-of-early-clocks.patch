From 4db542c38ea37ea00e2c884186e496b434451ff9 Mon Sep 17 00:00:00 2001
From: Ghennadi Procopciuc <ghennadi.procopciuc@nxp.com>
Date: Mon, 31 Jan 2022 15:00:25 +0200
Subject: [PATCH 03/11] s32g: Make QPSI clock part of early clocks

This is needed to allow boot from QSPI, otherwise the ATF
might read from an underclocked or ungated QSPI.

Issue: ALB-8441
Upstream-Status: Pending 

Signed-off-by: Ghennadi Procopciuc <ghennadi.procopciuc@nxp.com>
Signed-off-by: Zhantao Tang <zhantao.tang@windriver.com>
---
 drivers/nxp/s32/clk/early_clocks.c | 51 +++++++++++++++++++++++++++---
 fdts/fsl-s32-gen1.dtsi             |  4 +--
 2 files changed, 48 insertions(+), 7 deletions(-)

diff --git a/drivers/nxp/s32/clk/early_clocks.c b/drivers/nxp/s32/clk/early_clocks.c
index e5e7fdd6c..5090f1acd 100644
--- a/drivers/nxp/s32/clk/early_clocks.c
+++ b/drivers/nxp/s32/clk/early_clocks.c
@@ -65,10 +65,16 @@ static struct clk periph_pll_phi3 = CLK_INIT(S32GEN1_CLK_PERIPH_PLL_PHI3);
 static struct clk mc_cgm0_mux8 = CLK_INIT(S32GEN1_CLK_MC_CGM0_MUX8);
 static struct clk lin_baud = CLK_INIT(S32GEN1_CLK_LIN_BAUD);
 #endif
+/* SDHC */
 static struct clk periph_dfs3 = CLK_INIT(S32GEN1_CLK_PERIPH_PLL_DFS3);
 static struct clk mc_cgm0_mux14 = CLK_INIT(S32GEN1_CLK_MC_CGM0_MUX14);
 static struct clk sdhc = CLK_INIT(S32GEN1_CLK_SDHC);
 
+/* QSPI */
+static struct clk periph_dfs1 = CLK_INIT(S32GEN1_CLK_PERIPH_PLL_DFS1);
+static struct clk mc_cgm0_mux12 = CLK_INIT(S32GEN1_CLK_MC_CGM0_MUX12);
+static struct clk qspi = CLK_INIT(S32GEN1_CLK_QSPI);
+
 /* DDR clock */
 static struct clk ddr_pll_mux = CLK_INIT(S32GEN1_CLK_DDR_PLL_MUX);
 static struct clk ddr_pll_vco = CLK_INIT(S32GEN1_CLK_DDR_PLL_VCO);
@@ -165,7 +171,7 @@ static int enable_lin_clock(void)
 }
 #endif
 
-static int enable_sdhc_clock(void)
+static int setup_periph_pll(void)
 {
 	int ret;
 	unsigned long rate;
@@ -174,19 +180,27 @@ static int enable_sdhc_clock(void)
 	if (ret)
 		return ret;
 
-	ret = s32gen1_set_parent(&mc_cgm0_mux14, &periph_dfs3);
-	if (ret)
-		return ret;
-
 	rate = s32gen1_set_rate(&periph_pll_vco,
 				S32GEN1_PERIPH_PLL_VCO_FREQ);
 	if (rate != S32GEN1_PERIPH_PLL_VCO_FREQ)
 		return -EINVAL;
 
+	return 0;
+}
+
+static int enable_sdhc_clock(void)
+{
+	int ret;
+	unsigned long rate;
+
 	rate = s32gen1_set_rate(&periph_dfs3, S32GEN1_PERIPH_DFS3_FREQ);
 	if (rate != S32GEN1_PERIPH_DFS3_FREQ)
 		return -EINVAL;
 
+	ret = s32gen1_set_parent(&mc_cgm0_mux14, &periph_dfs3);
+	if (ret)
+		return ret;
+
 	rate = s32gen1_set_rate(&sdhc, S32GEN1_SDHC_CLK_FREQ);
 	if (rate != S32GEN1_SDHC_CLK_FREQ)
 		return -EINVAL;
@@ -194,6 +208,26 @@ static int enable_sdhc_clock(void)
 	return s32gen1_enable(&sdhc, 1);
 }
 
+static int enable_qspi_clock(void)
+{
+	int ret;
+	unsigned long rate;
+
+	rate = s32gen1_set_rate(&periph_dfs1, S32GEN1_PERIPH_DFS1_FREQ);
+	if (rate != S32GEN1_PERIPH_DFS1_FREQ)
+		return -EINVAL;
+
+	ret = s32gen1_set_parent(&mc_cgm0_mux12, &periph_dfs1);
+	if (ret)
+		return ret;
+
+	rate = s32gen1_set_rate(&qspi, S32GEN1_QSPI_CLK_FREQ);
+	if (rate != S32GEN1_QSPI_CLK_FREQ)
+		return -EINVAL;
+
+	return s32gen1_enable(&qspi, 1);
+}
+
 int s32_enable_ddr_clock(void)
 {
 	int ret;
@@ -231,11 +265,18 @@ int s32_plat_clock_init(bool skip_ddr_clk)
 	if (ret)
 		return ret;
 #endif
+	ret = setup_periph_pll();
+	if (ret)
+		return ret;
 
 	ret = enable_sdhc_clock();
 	if (ret)
 		return ret;
 
+	ret = enable_qspi_clock();
+	if (ret)
+		return ret;
+
 	if (!skip_ddr_clk)
 		return s32_enable_ddr_clock();
 
diff --git a/fdts/fsl-s32-gen1.dtsi b/fdts/fsl-s32-gen1.dtsi
index ca96f9a27..9d945b19f 100644
--- a/fdts/fsl-s32-gen1.dtsi
+++ b/fdts/fsl-s32-gen1.dtsi
@@ -230,8 +230,8 @@
 				<&clks S32GEN1_CLK_PERIPH_PLL_DFS1>,
 				<&clks S32GEN1_CLK_PERIPH_PLL_DFS3>;
 			assigned-clock-rates =
-				<800000000>,
-				<800000000>;
+				<S32GEN1_PERIPH_DFS1_FREQ>,
+				<S32GEN1_PERIPH_DFS3_FREQ>;
 		};
 
 		accelpll: accelpll@40040000 {
-- 
2.17.1

