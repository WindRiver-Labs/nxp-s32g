From 5bb7082a091d3e5c2c8d43bd8a969b4df9f3d086 Mon Sep 17 00:00:00 2001
From: Ciprian Costea <ciprianmarian.costea@nxp.com>
Date: Wed, 2 Mar 2022 13:00:57 +0200
Subject: [PATCH 4/5] s32r: psci: Implement 'pwr_domain_pwr_down_wfi' callback

Issue: ALB-8546
Upstream-Status: Pending 

Signed-off-by: Ciprian Costea <ciprianmarian.costea@nxp.com>
Signed-off-by: Zhantao Tang <zhantao.tang@windriver.com>
---
 plat/nxp/s32/include/s32_plat_funcs.h |  12 ++
 plat/nxp/s32/s32_psci.c               | 155 ++++----------------------
 plat/nxp/s32/s32g/s32g_common.mk      |   1 +
 plat/nxp/s32/s32g/s32g_plat_funcs.c   | 128 +++++++++++++++++++++
 plat/nxp/s32/s32r/s32r.mk             |   3 +-
 plat/nxp/s32/s32r/s32r_plat_funcs.c   |   9 ++
 6 files changed, 176 insertions(+), 132 deletions(-)
 create mode 100644 plat/nxp/s32/include/s32_plat_funcs.h
 create mode 100644 plat/nxp/s32/s32g/s32g_plat_funcs.c
 create mode 100644 plat/nxp/s32/s32r/s32r_plat_funcs.c

diff --git a/plat/nxp/s32/include/s32_plat_funcs.h b/plat/nxp/s32/include/s32_plat_funcs.h
new file mode 100644
index 000000000..5df136f9d
--- /dev/null
+++ b/plat/nxp/s32/include/s32_plat_funcs.h
@@ -0,0 +1,12 @@
+/*
+ * Copyright 2022 NXP
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ */
+
+#ifndef S32_PLAT_FUNCS_H
+#define S32_PLAT_FUNCS_H
+
+void s32_plat_suspend(unsigned int cpu);
+
+#endif
diff --git a/plat/nxp/s32/s32_psci.c b/plat/nxp/s32/s32_psci.c
index 24c2c44de..6c66f83f1 100644
--- a/plat/nxp/s32/s32_psci.c
+++ b/plat/nxp/s32/s32_psci.c
@@ -6,18 +6,12 @@
 #include "platform_def.h"
 #include "s32_lowlevel.h"
 #include "s32_ncore.h"
+#include "s32_plat_funcs.h"
 
 #if defined(PLAT_s32g2) || defined(PLAT_s32g3)
-#include "bl31_sram.h"
 #include <lib/mmio.h>
-#include <lib/xlat_tables/xlat_tables_v2.h>
-#include <plat/nxp/s32g/bl31_ssram/ssram_mailbox.h>
-#include "s32_sramc.h"
-#include "s32gen1-wkpu.h"
 #include "s32g_bl_common.h"
-#include "s32g_clocks.h"
 #include "s32g_mc_me.h"
-#include "s32g_resume.h"
 #include "s32g_vr5510.h"
 #else
 #include "s32_bl_common.h"
@@ -111,111 +105,43 @@ static void s32_pwr_domain_on_finish(const psci_power_state_t *target_state)
 	write_scr_el3(read_scr_el3() & ~SCR_IRQ_BIT);
 }
 #if defined(PLAT_s32g2) || defined(PLAT_s32g3)
-#if S32G_EMU == 0
-static void copy_bl31sram_image(void)
-{
-	uint32_t npages;
-	int ret;
-
-	/* Clear all BL31SRAM sections */
-	ret = s32_sram_clear(BL31SRAM_BASE, BL31SRAM_LIMIT);
-	if (ret)
-		ERROR("Failed to initialize SRAM from BL31SRAM stage\n");
-
-	npages = bl31sram_len / PAGE_SIZE;
-	if (bl31sram_len % PAGE_SIZE)
-		npages++;
-
-	ret = xlat_change_mem_attributes(BL31SRAM_BASE,
-					 npages * PAGE_SIZE,
-					 MT_MEMORY | MT_RW | MT_EXECUTE_NEVER);
-	if (ret)
-		ERROR("Failed to change the attributes of BL31 SRAM memory\n");
-
-	/* Copy bl31 sram stage */
-	memcpy((void *)BL31SRAM_BASE, bl31sram, bl31sram_len);
-	ret = xlat_change_mem_attributes(BL31SRAM_BASE,
-			npages * PAGE_SIZE,
-			MT_CODE | MT_SECURE);
-	if (ret)
-		ERROR("Failed to change the attributes of BL31 SRAM memory\n");
-}
-#endif
-
-static void bl31sram_entry(void)
+static void s32g_pwr_domain_suspend_finish(
+					const psci_power_state_t *target_state)
 {
-	bl31_sram_entry_t entry;
-
-	entry = (void *)BL31SRAM_BASE;
-	entry();
+	NOTICE("S32G TF-A: %s\n", __func__);
+	gicv3_cpuif_enable(plat_my_core_pos());
 }
 
-static void set_warm_entry(void)
+static void s32g_pwr_domain_suspend(const psci_power_state_t *target_state)
 {
-	uintptr_t warm_entry, short_boot;
-
-	warm_entry = BL31SSRAM_MAILBOX + offsetof(struct s32g_ssram_mailbox,
-						  bl31_warm_entrypoint);
-	short_boot = BL31SSRAM_MAILBOX + offsetof(struct s32g_ssram_mailbox,
-						  short_boot);
-	mmio_write_64(warm_entry, (uintptr_t)s32g_resume_entrypoint);
-	mmio_write_8(short_boot, (uint8_t)s32gen1_is_wkp_short_boot());
+	NOTICE("S32G TF-A: %s\n", __func__);
 }
 
-static void __dead2 platform_suspend(unsigned int current_cpu)
+static void s32g_get_sys_suspend_power_state(psci_power_state_t *req_state)
 {
-	size_t i;
-	size_t ncores = PLATFORM_CORE_COUNT;
-
-	for (i = 0; i < PLATFORM_CORE_COUNT; i++)
-		gicv3_cpuif_disable(i);
-
-	plat_gic_save();
-	set_warm_entry();
-	pmic_prepare_for_suspend();
-	s32gen1_wkpu_enable_irqs();
-
-	/* Shutting down cores */
-	/* M7 cores */
-	s32_turn_off_mcores();
-
-	if (is_lockstep_enabled())
-		ncores /= 2;
-
-	/* A53 cores */
-	for (i = 0; i < ncores; i++) {
-		if (i != current_cpu)
-			s32_turn_off_core(S32_MC_ME_CA53_PART, i);
-	}
-
-	/* PFE blocks */
-	s32_disable_cofb_clk(S32G_MC_ME_PFE_PART, 0);
-	/* Keep the DDR clock */
-	s32_disable_cofb_clk(S32_MC_ME_USDHC_PART,
-			      S32_MC_ME_PRTN_N_REQ(S32_MC_ME_DDR_0_REQ));
-
-	/* Switching all MC_CGM muxes to FIRC */
-	s32g_sw_clks2firc();
+	int i;
 
-	/* Turn off DFS */
-	s32g_disable_dfs(S32_PERIPH_DFS);
-	s32g_disable_dfs(S32_CORE_DFS);
+	NOTICE("S32G TF-A: %s\n", __func__);
 
-	/* Turn off PLL */
-	s32g_disable_pll(S32_ACCEL_PLL, 2);
-	s32g_disable_pll(S32_PERIPH_PLL, 8);
-	s32g_disable_pll(S32_CORE_PLL, 2);
+	/* FIXME revisit this, along with the power domain tree */
+	/* CPU, cluster & system: off */
+	for (i = MPIDR_AFFLVL0; i <= PLAT_MAX_PWR_LVL; i++)
+		req_state->pwr_domain_state[i] = PLAT_MAX_OFF_STATE;
+}
 
-	bl31sram_entry();
-	plat_panic_handler();
+static void s32g_pwr_domain_suspend_pwrdown_early(
+		const psci_power_state_t *target_state)
+{
+	NOTICE("S32G TF-A: %s\n", __func__);
 }
+#endif
 
-static void __dead2 s32g_pwr_domain_pwr_down_wfi(
+static void __dead2 s32_pwr_domain_pwr_down_wfi(
 					const psci_power_state_t *target_state)
 {
 	unsigned int pos = plat_my_core_pos();
 
-	NOTICE("S32G TF-A: %s: cpu = %u\n", __func__, pos);
+	NOTICE("S32 TF-A: %s: cpu = %u\n", __func__, pos);
 
 	if (!is_last_core()) {
 		update_core_state(pos, 0);
@@ -229,45 +155,12 @@ static void __dead2 s32g_pwr_domain_pwr_down_wfi(
 		plat_secondary_cold_boot_setup();
 	}
 
-#if S32G_EMU == 0
-	copy_bl31sram_image();
-#endif
-	platform_suspend(pos);
+	s32_plat_suspend(pos);
 
 	/* Unreachable code */
 	plat_panic_handler();
 }
 
-static void s32g_pwr_domain_suspend_finish(
-					const psci_power_state_t *target_state)
-{
-	NOTICE("S32G TF-A: %s\n", __func__);
-	gicv3_cpuif_enable(plat_my_core_pos());
-}
-
-static void s32g_pwr_domain_suspend(const psci_power_state_t *target_state)
-{
-	NOTICE("S32G TF-A: %s\n", __func__);
-}
-
-static void s32g_get_sys_suspend_power_state(psci_power_state_t *req_state)
-{
-	int i;
-
-	NOTICE("S32G TF-A: %s\n", __func__);
-
-	/* FIXME revisit this, along with the power domain tree */
-	/* CPU, cluster & system: off */
-	for (i = MPIDR_AFFLVL0; i <= PLAT_MAX_PWR_LVL; i++)
-		req_state->pwr_domain_state[i] = PLAT_MAX_OFF_STATE;
-}
-
-static void s32g_pwr_domain_suspend_pwrdown_early(
-		const psci_power_state_t *target_state)
-{
-	NOTICE("S32G TF-A: %s\n", __func__);
-}
-#endif
 static void s32_pwr_domain_off(const psci_power_state_t *target_state)
 {
 	NOTICE("S32 TF-A: %s\n", __func__);
@@ -304,6 +197,7 @@ const plat_psci_ops_t s32_psci_pm_ops = {
 	/* cap: PSCI_CPU_ON_AARCH64 */
 	.pwr_domain_on = s32_pwr_domain_on,
 	.pwr_domain_on_finish = s32_pwr_domain_on_finish,
+	.pwr_domain_pwr_down_wfi = s32_pwr_domain_pwr_down_wfi,
 #if defined(PLAT_s32g2) || defined(PLAT_s32g3)
 	/* cap: PSCI_CPU_SUSPEND_AARCH64 */
 	.pwr_domain_suspend = s32g_pwr_domain_suspend,
@@ -312,7 +206,6 @@ const plat_psci_ops_t s32_psci_pm_ops = {
 	.pwr_domain_suspend_pwrdown_early =
 					s32g_pwr_domain_suspend_pwrdown_early,
 	.pwr_domain_suspend_finish = s32g_pwr_domain_suspend_finish,
-	.pwr_domain_pwr_down_wfi = s32g_pwr_domain_pwr_down_wfi,
 #endif
 	.system_reset = s32_system_reset,
 	.system_off = s32_system_off,
diff --git a/plat/nxp/s32/s32g/s32g_common.mk b/plat/nxp/s32/s32g/s32g_common.mk
index 3732e452a..a2173e4e5 100644
--- a/plat/nxp/s32/s32g/s32g_common.mk
+++ b/plat/nxp/s32/s32g/s32g_common.mk
@@ -34,6 +34,7 @@ PLAT_BL_COMMON_SOURCES	+= \
 			   ${S32_DRIVERS}/ocotp.c \
 			   lib/utils/crc8.c \
 			   ${S32_SOC_FAMILY}/s32g_vr5510.c \
+			   ${S32_SOC_FAMILY}/s32g_plat_funcs.c \
 			   ${S32_DRIVERS}/pmic/vr5510.c \
 			   ${BL31SRAM_SRC_DUMP} \
 
diff --git a/plat/nxp/s32/s32g/s32g_plat_funcs.c b/plat/nxp/s32/s32g/s32g_plat_funcs.c
new file mode 100644
index 000000000..4df1fe092
--- /dev/null
+++ b/plat/nxp/s32/s32g/s32g_plat_funcs.c
@@ -0,0 +1,128 @@
+/*
+ * Copyright 2022 NXP
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ */
+
+#include "bl31_sram.h"
+#include "s32_plat_funcs.h"
+#include "s32_sramc.h"
+#include "s32g_bl_common.h"
+#include "s32g_clocks.h"
+#include "s32g_mc_me.h"
+#include "s32g_resume.h"
+#include "s32g_vr5510.h"
+#include "s32gen1-wkpu.h"
+
+#include <drivers/arm/gicv3.h>
+#include <lib/mmio.h>
+#include <lib/xlat_tables/xlat_tables_v2.h>
+#include <plat/nxp/s32g/bl31_ssram/ssram_mailbox.h>
+#include <plat/common/platform.h>
+
+static void bl31sram_entry(void)
+{
+	bl31_sram_entry_t entry;
+
+	entry = (void *)BL31SRAM_BASE;
+	entry();
+}
+
+static void set_warm_entry(void)
+{
+	uintptr_t warm_entry, short_boot;
+
+	warm_entry = BL31SSRAM_MAILBOX + offsetof(struct s32g_ssram_mailbox,
+						  bl31_warm_entrypoint);
+	short_boot = BL31SSRAM_MAILBOX + offsetof(struct s32g_ssram_mailbox,
+						  short_boot);
+	mmio_write_64(warm_entry, (uintptr_t)s32g_resume_entrypoint);
+	mmio_write_8(short_boot, (uint8_t)s32gen1_is_wkp_short_boot());
+}
+
+static void __dead2 platform_suspend(unsigned int current_cpu)
+{
+	size_t i;
+	size_t ncores = PLATFORM_CORE_COUNT;
+
+	for (i = 0; i < PLATFORM_CORE_COUNT; i++)
+		gicv3_cpuif_disable(i);
+
+	plat_gic_save();
+	set_warm_entry();
+	pmic_prepare_for_suspend();
+	s32gen1_wkpu_enable_irqs();
+
+	/* Shutting down cores */
+	/* M7 cores */
+	s32_turn_off_mcores();
+
+	if (is_lockstep_enabled())
+		ncores /= 2;
+
+	/* A53 cores */
+	for (i = 0; i < ncores; i++) {
+		if (i != current_cpu)
+			s32_turn_off_core(S32_MC_ME_CA53_PART, i);
+	}
+
+	/* PFE blocks */
+	s32_disable_cofb_clk(S32G_MC_ME_PFE_PART, 0);
+	/* Keep the DDR clock */
+	s32_disable_cofb_clk(S32_MC_ME_USDHC_PART,
+			      S32_MC_ME_PRTN_N_REQ(S32_MC_ME_DDR_0_REQ));
+
+	/* Switching all MC_CGM muxes to FIRC */
+	s32g_sw_clks2firc();
+
+	/* Turn off DFS */
+	s32g_disable_dfs(S32_PERIPH_DFS);
+	s32g_disable_dfs(S32_CORE_DFS);
+
+	/* Turn off PLL */
+	s32g_disable_pll(S32_ACCEL_PLL, 2);
+	s32g_disable_pll(S32_PERIPH_PLL, 8);
+	s32g_disable_pll(S32_CORE_PLL, 2);
+
+	bl31sram_entry();
+	plat_panic_handler();
+}
+
+#if S32G_EMU == 0
+static void copy_bl31sram_image(void)
+{
+	uint32_t npages;
+	int ret;
+
+	/* Clear all BL31SRAM sections */
+	ret = s32_sram_clear(BL31SRAM_BASE, BL31SRAM_LIMIT);
+	if (ret)
+		ERROR("Failed to initialize SRAM from BL31SRAM stage\n");
+
+	npages = bl31sram_len / PAGE_SIZE;
+	if (bl31sram_len % PAGE_SIZE)
+		npages++;
+
+	ret = xlat_change_mem_attributes(BL31SRAM_BASE,
+					 npages * PAGE_SIZE,
+					 MT_MEMORY | MT_RW | MT_EXECUTE_NEVER);
+	if (ret)
+		ERROR("Failed to change the attributes of BL31 SRAM memory\n");
+
+	/* Copy bl31 sram stage */
+	memcpy((void *)BL31SRAM_BASE, bl31sram, bl31sram_len);
+	ret = xlat_change_mem_attributes(BL31SRAM_BASE,
+			npages * PAGE_SIZE,
+			MT_CODE | MT_SECURE);
+	if (ret)
+		ERROR("Failed to change the attributes of BL31 SRAM memory\n");
+}
+#endif
+
+void s32_plat_suspend(unsigned int cpu)
+{
+#if S32G_EMU == 0
+	copy_bl31sram_image();
+#endif
+	platform_suspend(cpu);
+}
diff --git a/plat/nxp/s32/s32r/s32r.mk b/plat/nxp/s32/s32r/s32r.mk
index f5f332273..53fe4bfa6 100644
--- a/plat/nxp/s32/s32r/s32r.mk
+++ b/plat/nxp/s32/s32r/s32r.mk
@@ -25,6 +25,7 @@ PLAT_BL_COMMON_SOURCES += ${S32_DRIVERS}/clk/s32r45_clk.c \
 		${S32_PLAT}/s32gen1_sramc.c \
 		lib/cpus/aarch64/s32.S \
 		lib/cpus/aarch64/cortex_a53.S \
+		${PLAT_SOC_PATH}/s32r_plat_funcs.c \
 
 BL2_SOURCES 	+=  \
 	${PLAT_SOC_PATH}/s32r_bl2_el3.c \
@@ -40,4 +41,4 @@ ERRATA_S32_050543	:= 1
 S32_LINFLEX_MODULE := 0
 $(eval $(call add_define_val,S32_LINFLEX_MODULE,$(S32_LINFLEX_MODULE)))
 
-DTB_FILE_NAME		?= fsl-s32r45-evb.dtb
\ No newline at end of file
+DTB_FILE_NAME		?= fsl-s32r45-evb.dtb
diff --git a/plat/nxp/s32/s32r/s32r_plat_funcs.c b/plat/nxp/s32/s32r/s32r_plat_funcs.c
new file mode 100644
index 000000000..3f7011423
--- /dev/null
+++ b/plat/nxp/s32/s32r/s32r_plat_funcs.c
@@ -0,0 +1,9 @@
+/*
+ * Copyright 2022 NXP
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ */
+
+#include "s32_plat_funcs.h"
+
+void s32_plat_suspend(unsigned int cpu) {}
-- 
2.17.1

