From 19e477d52e84245867c78658123d73908efba91e Mon Sep 17 00:00:00 2001
From: Andra-Teodora Ilie <andra.ilie@nxp.com>
Date: Tue, 23 Nov 2021 16:10:34 +0200
Subject: [PATCH 22/50] s32: mc_rgm: Add common s32_mc_rgm header

Issue: ALB-7411
Upstream-Status: Pending 

Signed-off-by: Andra-Teodora Ilie <andra.ilie@nxp.com>
Signed-off-by: Zhantao Tang <zhantao.tang@windriver.com>
---
 include/drivers/nxp/s32/ddr/ddrss.h           |  6 +--
 plat/nxp/s32/include/s32_mc_rgm.h             | 52 +++++++++++++++++++
 plat/nxp/s32/s32g/include/s32g_mc_rgm.h       | 44 +---------------
 plat/nxp/s32/s32g/s32g2/platform.mk           |  2 +-
 plat/nxp/s32/s32g/s32g_bl2_el3.c              |  2 +-
 plat/nxp/s32/s32g/s32g_bl31.c                 |  2 +-
 plat/nxp/s32/s32g/s32g_mc_me.c                | 28 +++++-----
 .../s32g2/s32g2_mc_rgm.c => s32gen1_mc_rgm.c} |  2 +-
 8 files changed, 75 insertions(+), 63 deletions(-)
 create mode 100644 plat/nxp/s32/include/s32_mc_rgm.h
 rename plat/nxp/s32/{s32g/s32g2/s32g2_mc_rgm.c => s32gen1_mc_rgm.c} (89%)

diff --git a/include/drivers/nxp/s32/ddr/ddrss.h b/include/drivers/nxp/s32/ddr/ddrss.h
index 0bf400c41..f9ec25ba7 100644
--- a/include/drivers/nxp/s32/ddr/ddrss.h
+++ b/include/drivers/nxp/s32/ddr/ddrss.h
@@ -158,10 +158,10 @@ static inline void deassert_ddr_reset(void)
 {
 	uint32_t rgm_prst_0;
 
-	rgm_prst_0 = mmio_read_32(S32G_MC_RGM_PRST(0));
+	rgm_prst_0 = mmio_read_32(S32_MC_RGM_PRST(0));
 	rgm_prst_0 &= ~(BIT(3) | BIT(0));
-	mmio_write_32(S32G_MC_RGM_PRST(0), rgm_prst_0);
-	while (mmio_read_32(S32G_MC_RGM_PSTAT(0)) != rgm_prst_0)
+	mmio_write_32(S32_MC_RGM_PRST(0), rgm_prst_0);
+	while (mmio_read_32(S32_MC_RGM_PSTAT(0)) != rgm_prst_0)
 		;
 }
 
diff --git a/plat/nxp/s32/include/s32_mc_rgm.h b/plat/nxp/s32/include/s32_mc_rgm.h
new file mode 100644
index 000000000..85b8da503
--- /dev/null
+++ b/plat/nxp/s32/include/s32_mc_rgm.h
@@ -0,0 +1,52 @@
+/*
+ * Copyright 2021 NXP
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ */
+
+#ifndef __S32_MC_RGM_H__
+#define __S32_MC_RGM_H__
+
+#include <lib/utils_def.h>
+#include <lib/libc/stdint.h>
+
+#define S32_MC_RGM_BASE_ADDR		0x40078000ul
+#define S32_MC_RGM_SIZE				0x1000ul
+#define S32_MC_RGM_PRST_BASE_ADDR	(S32_MC_RGM_BASE_ADDR + 0x40)
+#define S32_MC_RGM_PSTAT_BASE_ADDR	(S32_MC_RGM_BASE_ADDR + 0x140)
+#define S32_MC_RGM_DRET_ADDR		(S32_MC_RGM_BASE_ADDR + 0x1C)
+/* Peripheral reset */
+#define S32_MC_RGM_PRST(p)			(S32_MC_RGM_PRST_BASE_ADDR + 0x8 * p)
+#define S32_MC_RGM_PSTAT(p)		    (S32_MC_RGM_PSTAT_BASE_ADDR + 0x8 * p)
+#define MC_RGM_PRST_PERIPH_N_RST(n)		BIT(n)
+#define MC_RGM_STAT_PERIPH_N_STAT(n)	BIT(n)
+
+#define PERIPH_3_RST				BIT(3)
+
+
+/* Software-resettable domain/partition 0: M7 cores */
+#define S32_MC_RGM_RST_DOMAIN_CM7	0
+/* Bit corresponding to CM7_n in the cores' RGM reset partition (n=0..2) */
+#define S32_MC_RGM_RST_CM7_BIT(n)	BIT(n)
+
+/* Software-resettable domain/partition 1: CA53 cores */
+#define S32_MC_RGM_RST_DOMAIN_CA53	1
+/* The entire domain defined by S32_MC_RGM_RST_DOMAIN_CA53 can be reset */
+#define S32_MC_RGM_RST_CA53_PART_BIT	BIT(0)
+
+#define MC_RGM_DES	(S32_MC_RGM_BASE_ADDR)
+#define DES_F_POR	BIT(0)
+#define DES_F_DR_ANY	0xc0073f5a
+
+#define MC_RGM_FES	(S32_MC_RGM_BASE_ADDR + 0x8)
+#define FES_F_FR_ANY	0xc0340058
+
+/* Reset Domain Controller definitions */
+#define S32_RDC_BASE_ADDR	0x40080000ull
+#define RDC_RD_CTRL(part)	(S32_RDC_BASE_ADDR + (part) * 4)
+#define RDC_CTRL_UNLOCK		BIT(31)
+#define RDC_CTRL_XBAR_DISABLE	BIT(3)
+
+uint8_t get_rgm_a53_bit(uint8_t core);
+
+#endif /* __S32_MC_RGM_H__ */
diff --git a/plat/nxp/s32/s32g/include/s32g_mc_rgm.h b/plat/nxp/s32/s32g/include/s32g_mc_rgm.h
index 5c011c5e3..c8223fcb6 100644
--- a/plat/nxp/s32/s32g/include/s32g_mc_rgm.h
+++ b/plat/nxp/s32/s32g/include/s32g_mc_rgm.h
@@ -7,41 +7,9 @@
 #ifndef __S32G_MC_RGM_H__
 #define __S32G_MC_RGM_H__
 
-#include <lib/utils_def.h>
-#include <lib/libc/stdint.h>
+#include "s32_mc_rgm.h"
 
-#define S32G_MC_RGM_BASE_ADDR	0x40078000ul
-#define S32G_MC_RGM_SIZE	0x1000ul
-#define S32G_MC_RGM_PRST_BASE_ADDR	(S32G_MC_RGM_BASE_ADDR + 0x40)
-#define S32G_MC_RGM_PSTAT_BASE_ADDR	(S32G_MC_RGM_BASE_ADDR + 0x140)
-#define S32G_MC_RGM_DRET_ADDR		(S32G_MC_RGM_BASE_ADDR + 0x1C)
-/* Peripheral reset */
-#define S32G_MC_RGM_PRST(p)	(S32G_MC_RGM_PRST_BASE_ADDR + 0x8 * p)
-#define S32G_MC_RGM_PSTAT(p)	(S32G_MC_RGM_PSTAT_BASE_ADDR + 0x8 * p)
-#define MC_RGM_PRST_PERIPH_N_RST(n)	BIT(n)
-#define MC_RGM_STAT_PERIPH_N_STAT(n)	BIT(n)
-
-#define PERIPH_3_RST		BIT(3)
-
-
-/* Software-resettable domain/partition 0: M7 cores */
-#define S32G_MC_RGM_RST_DOMAIN_CM7	0
-/* Bit corresponding to CM7_n in the cores' RGM reset partition (n=0..2) */
-#define S32G_MC_RGM_RST_CM7_BIT(n)	BIT(n)
-
-/* Software-resettable domain/partition 1: CA53 cores */
-#define S32G_MC_RGM_RST_DOMAIN_CA53	1
-/* The entire domain defined by S32G_MC_RGM_RST_DOMAIN_CA53 can be reset */
-#define S32G_MC_RGM_RST_CA53_PART_BIT	BIT(0)
-
-#define MC_RGM_DES	(S32G_MC_RGM_BASE_ADDR)
-#define DES_F_POR	BIT(0)
-#define DES_F_DR_ANY	0xc0073f5a
-
-#define MC_RGM_FES	(S32G_MC_RGM_BASE_ADDR + 0x8)
-#define FES_F_FR_ANY	0xc0340058
-
-#define MC_RGM_RDSS	(S32G_MC_RGM_BASE_ADDR + 0x24)
+#define MC_RGM_RDSS	(S32_MC_RGM_BASE_ADDR + 0x24)
 #define RDSS_FES_RES	BIT(1)
 #define RDSS_DES_RES	BIT(0)
 
@@ -55,12 +23,4 @@ enum reset_cause {
 	CAUSE_ERROR
 };
 
-/* Reset Domain Controller definitions */
-#define S32G_RDC_BASE_ADDR	0x40080000ull
-#define RDC_RD_CTRL(part)	(S32G_RDC_BASE_ADDR + (part) * 4)
-#define RDC_CTRL_UNLOCK		BIT(31)
-#define RDC_CTRL_XBAR_DISABLE	BIT(3)
-
-uint8_t get_rgm_a53_bit(uint8_t core);
-
 #endif /* __S32G_MC_RGM_H__ */
diff --git a/plat/nxp/s32/s32g/s32g2/platform.mk b/plat/nxp/s32/s32g/s32g2/platform.mk
index 579320b95..42952793a 100644
--- a/plat/nxp/s32/s32g/s32g2/platform.mk
+++ b/plat/nxp/s32/s32g/s32g2/platform.mk
@@ -16,7 +16,7 @@ PLAT_INCLUDES		+= -Iplat/nxp/s32/s32g/s32g2/include \
 
 PLAT_BL_COMMON_SOURCES	+= drivers/nxp/s32/clk/s32g274a_clk.c \
 			   plat/nxp/s32/s32gen1_mc_me.c \
-			   plat/nxp/s32/s32g/s32g2/s32g2_mc_rgm.c \
+			   plat/nxp/s32/s32gen1_mc_rgm.c \
 			   plat/nxp/s32/s32gen1_sramc.c \
 			   plat/nxp/s32/s32g/s32g2/s32g2_vr5510.c \
 			   lib/cpus/aarch64/s32g2.S \
diff --git a/plat/nxp/s32/s32g/s32g_bl2_el3.c b/plat/nxp/s32/s32g/s32g_bl2_el3.c
index f7e3c4518..eaf6870ef 100644
--- a/plat/nxp/s32/s32g/s32g_bl2_el3.c
+++ b/plat/nxp/s32/s32g/s32g_bl2_el3.c
@@ -542,7 +542,7 @@ static mmap_region_t s32g_mmap[] = {
 	/* This will cover both the MC_RGM and the GPR accesses, while reducing
 	 * the number of used up MMU regions.
 	 */
-	MAP_REGION_FLAT(S32G_MC_RGM_BASE_ADDR, S32G_MC_RGM_SIZE,
+	MAP_REGION_FLAT(S32_MC_RGM_BASE_ADDR, S32_MC_RGM_SIZE,
 			MT_DEVICE | MT_RW),
 	MAP_REGION_FLAT(SRAMC0_BASE_ADDR, SRAMC_SIZE,
 			MT_DEVICE | MT_RW),
diff --git a/plat/nxp/s32/s32g/s32g_bl31.c b/plat/nxp/s32/s32g/s32g_bl31.c
index 890f2b5a7..111f14993 100644
--- a/plat/nxp/s32/s32g/s32g_bl31.c
+++ b/plat/nxp/s32/s32g/s32g_bl31.c
@@ -54,7 +54,7 @@ static const mmap_region_t s32g_mmap[] = {
 	/* This will cover both the MC_RGM and the GPR accesses, while reducing
 	 * the number of used up MMU regions.
 	 */
-	MAP_REGION_FLAT(S32G_MC_RGM_BASE_ADDR, S32G_MC_RGM_SIZE,
+	MAP_REGION_FLAT(S32_MC_RGM_BASE_ADDR, S32_MC_RGM_SIZE,
 			MT_DEVICE | MT_RW),
 	/* When we execute at System Monitor on behalf of EL2/EL1, we might
 	 * have to reconfigure Ncore
diff --git a/plat/nxp/s32/s32g/s32g_mc_me.c b/plat/nxp/s32/s32g/s32g_mc_me.c
index 1546a9d9c..308ca6238 100644
--- a/plat/nxp/s32/s32g/s32g_mc_me.c
+++ b/plat/nxp/s32/s32g/s32g_mc_me.c
@@ -143,16 +143,16 @@ void mc_me_enable_partition(uint32_t part)
 	while (mmio_read_32(RDC_RD_CTRL(part)) & RDC_CTRL_XBAR_DISABLE)
 		;
 	/* Release partition reset */
-	reg = mmio_read_32(S32G_MC_RGM_PRST(part));
+	reg = mmio_read_32(S32_MC_RGM_PRST(part));
 	reg &= ~MC_RGM_PRST_PERIPH_N_RST(0);
-	mmio_write_32(S32G_MC_RGM_PRST(part), reg);
+	mmio_write_32(S32_MC_RGM_PRST(part), reg);
 
 	/* Clear OSSE bit */
 	mc_me_part_pconf_write_osse(0, part);
 
 	mc_me_part_pupd_update_and_wait(S32_MC_ME_PRTN_N_PUPD_OSSUD_MASK,
 					part);
-	while (mmio_read_32(S32G_MC_RGM_PSTAT(part)) &
+	while (mmio_read_32(S32_MC_RGM_PSTAT(part)) &
 			    MC_RGM_STAT_PERIPH_N_STAT(0))
 		;
 	/* Lock RDC register write */
@@ -178,7 +178,7 @@ bool s32g_core_in_reset(uint32_t core)
 	uint32_t stat, rst;
 
 	rst = BIT(get_rgm_a53_bit(core));
-	stat = mmio_read_32(S32G_MC_RGM_PSTAT(S32G_MC_RGM_RST_DOMAIN_CA53));
+	stat = mmio_read_32(S32_MC_RGM_PSTAT(S32_MC_RGM_RST_DOMAIN_CA53));
 	return ((stat & rst) != 0);
 }
 
@@ -286,20 +286,20 @@ void s32g_kick_secondary_ca53_core(uint32_t core, uintptr_t entrypoint)
 	enable_a53_core_cluster(core);
 
 	/* Release the core reset */
-	rst = mmio_read_32(S32G_MC_RGM_PRST(S32G_MC_RGM_RST_DOMAIN_CA53));
+	rst = mmio_read_32(S32_MC_RGM_PRST(S32_MC_RGM_RST_DOMAIN_CA53));
 
 	/* Forced reset */
 	if (!(rst & rst_mask)) {
 		rst |= rst_mask;
-		mmio_write_32(S32G_MC_RGM_PRST(S32G_MC_RGM_RST_DOMAIN_CA53),
+		mmio_write_32(S32_MC_RGM_PRST(S32_MC_RGM_RST_DOMAIN_CA53),
 			      rst);
 		while (!s32g_core_in_reset(core))
 			;
 	}
 
-	rst = mmio_read_32(S32G_MC_RGM_PRST(S32G_MC_RGM_RST_DOMAIN_CA53));
+	rst = mmio_read_32(S32_MC_RGM_PRST(S32_MC_RGM_RST_DOMAIN_CA53));
 	rst &= ~rst_mask;
-	mmio_write_32(S32G_MC_RGM_PRST(S32G_MC_RGM_RST_DOMAIN_CA53), rst);
+	mmio_write_32(S32_MC_RGM_PRST(S32_MC_RGM_RST_DOMAIN_CA53), rst);
 	/* Wait for reset bit to deassert */
 	while (s32g_core_in_reset(core))
 		;
@@ -314,13 +314,13 @@ void s32g_reset_core(uint8_t part, uint8_t core)
 
 	if (part == S32_MC_ME_CA53_PART) {
 		resetc = BIT(get_rgm_a53_bit(core));
-		prst = S32G_MC_RGM_PRST(S32G_MC_RGM_RST_DOMAIN_CA53);
-		pstat = S32G_MC_RGM_PSTAT(S32G_MC_RGM_RST_DOMAIN_CA53);
+		prst = S32_MC_RGM_PRST(S32_MC_RGM_RST_DOMAIN_CA53);
+		pstat = S32_MC_RGM_PSTAT(S32_MC_RGM_RST_DOMAIN_CA53);
 	} else {
 		/* M7 cores */
-		resetc = S32G_MC_RGM_RST_CM7_BIT(core);
-		prst = S32G_MC_RGM_PRST(S32G_MC_RGM_RST_DOMAIN_CM7);
-		pstat = S32G_MC_RGM_PSTAT(S32G_MC_RGM_RST_DOMAIN_CM7);
+		resetc = S32_MC_RGM_RST_CM7_BIT(core);
+		prst = S32_MC_RGM_PRST(S32_MC_RGM_RST_DOMAIN_CM7);
+		pstat = S32_MC_RGM_PSTAT(S32_MC_RGM_RST_DOMAIN_CM7);
 	}
 	statv = resetc;
 
@@ -411,7 +411,7 @@ void s32g_set_stby_master_core(uint8_t part, uint8_t core)
 void s32g_destructive_reset(void)
 {
 	/* Prevent reset escalation */
-	mmio_write_32(S32G_MC_RGM_DRET_ADDR, 0);
+	mmio_write_32(S32_MC_RGM_DRET_ADDR, 0);
 
 	mmio_write_32(MC_ME_MODE_CONF, MC_ME_MODE_CONF_DRST);
 	mmio_write_32(MC_ME_MODE_UPD, MC_ME_MODE_UPD_UPD);
diff --git a/plat/nxp/s32/s32g/s32g2/s32g2_mc_rgm.c b/plat/nxp/s32/s32gen1_mc_rgm.c
similarity index 89%
rename from plat/nxp/s32/s32g/s32g2/s32g2_mc_rgm.c
rename to plat/nxp/s32/s32gen1_mc_rgm.c
index daa5a8bc4..082bc3b82 100644
--- a/plat/nxp/s32/s32g/s32g2/s32g2_mc_rgm.c
+++ b/plat/nxp/s32/s32gen1_mc_rgm.c
@@ -3,7 +3,7 @@
  *
  * SPDX-License-Identifier: BSD-3-Clause
  */
-#include <s32g_mc_rgm.h>
+#include <s32_mc_rgm.h>
 
 uint8_t get_rgm_a53_bit(uint8_t core)
 {
-- 
2.17.1

