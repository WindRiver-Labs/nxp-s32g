From 82577dd6f3bd28b98c8aeba301b16caf889a2838 Mon Sep 17 00:00:00 2001
From: Andra-Teodora Ilie <andra.ilie@nxp.com>
Date: Thu, 9 Dec 2021 11:40:22 +0200
Subject: [PATCH 32/50] s32: bl31: Move common bl31 functions to generic layer

Issue: ALB-7411
Upstream-Status: Pending 

Signed-off-by: Andra-Teodora Ilie <andra.ilie@nxp.com>
Signed-off-by: Zhantao Tang <zhantao.tang@windriver.com>
---
 plat/nxp/s32/include/s32_bl_common.h          |   9 +
 plat/nxp/s32/include/s32_lowlevel.h           |  13 +
 plat/nxp/s32/include/s32_platform_def.h       |   2 +
 plat/nxp/s32/s32_bl31.c                       | 285 ++++++++++++++++++
 plat/nxp/s32/s32_common.mk                    |   7 +
 .../bl31_lowlevel.S => s32_lowlevel_bl31.S}   |  15 +-
 plat/nxp/s32/s32g/include/s32g_bl_common.h    |   9 -
 plat/nxp/s32/s32g/include/s32g_lowlevel.h     |   4 +-
 plat/nxp/s32/s32g/include/s32g_platform_def.h |   6 +-
 plat/nxp/s32/s32g/s32g_bl31.c                 | 262 +---------------
 plat/nxp/s32/s32g/s32g_common.mk              |   6 -
 11 files changed, 328 insertions(+), 290 deletions(-)
 create mode 100644 plat/nxp/s32/include/s32_lowlevel.h
 create mode 100644 plat/nxp/s32/s32_bl31.c
 rename plat/nxp/s32/{s32g/bl31_lowlevel.S => s32_lowlevel_bl31.S} (94%)

diff --git a/plat/nxp/s32/include/s32_bl_common.h b/plat/nxp/s32/include/s32_bl_common.h
index f6ce03c14..a2c9769b2 100644
--- a/plat/nxp/s32/include/s32_bl_common.h
+++ b/plat/nxp/s32/include/s32_bl_common.h
@@ -33,6 +33,15 @@ bool is_lockstep_enabled(void);
 
 void s32_early_plat_init(bool skip_ddr_clk);
 
+void s32_gic_setup(void);
+void plat_gic_save(void);
+void plat_gic_restore(void);
+
+void update_core_state(uint32_t core, uint32_t state);
+bool is_last_core(void);
+bool is_cluster0_off(void);
+bool is_cluster1_off(void);
+
 struct s32_i2c_driver *s32_add_i2c_module(void *fdt, int fdt_node);
 
 #endif /* S32_BL_COMMON_H */
diff --git a/plat/nxp/s32/include/s32_lowlevel.h b/plat/nxp/s32/include/s32_lowlevel.h
new file mode 100644
index 000000000..1cfb3a808
--- /dev/null
+++ b/plat/nxp/s32/include/s32_lowlevel.h
@@ -0,0 +1,13 @@
+/*
+ * Copyright 2021 NXP
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ */
+
+#ifndef S32_LOWLEVEL_H
+#define S32_LOWLEVEL_H
+
+void s32_smp_fixup(void);
+
+#endif /* S32_LOWLEVEL_H */
+
diff --git a/plat/nxp/s32/include/s32_platform_def.h b/plat/nxp/s32/include/s32_platform_def.h
index 90501fb1c..e634c66a3 100644
--- a/plat/nxp/s32/include/s32_platform_def.h
+++ b/plat/nxp/s32/include/s32_platform_def.h
@@ -99,6 +99,8 @@
 #define BOOTROM_ADMA_RSRVD_BASE		(0x343ff000)
 #define BL2_LIMIT					(BOOTROM_ADMA_RSRVD_BASE - 1)
 
+#define DTB_SIZE		(BL2_BASE - DTB_BASE)
+
 /* U-boot addresses in SRAM. BL33_DTB and BL33_ENTRYPOINT must be kept in
  * sync with u-boot's CONFIG_DTB_SRAM_ADDR and CONFIG_SYS_TEXT_BASE.
  */
diff --git a/plat/nxp/s32/s32_bl31.c b/plat/nxp/s32/s32_bl31.c
new file mode 100644
index 000000000..77b4708cf
--- /dev/null
+++ b/plat/nxp/s32/s32_bl31.c
@@ -0,0 +1,285 @@
+/*
+ * Copyright 2021 NXP
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ */
+#include <arch_helpers.h>
+#include <assert.h>
+#include <common/bl_common.h>
+#include <drivers/arm/gicv3.h>
+#include <lib/xlat_tables/xlat_tables_v2.h>
+#include <plat/common/platform.h>
+
+#include "platform_def.h"
+#include "s32_clocks.h"
+#include "s32_linflexuart.h"
+#include "s32_lowlevel.h"
+#include "s32_mc_me.h"
+#include "s32_mc_rgm.h"
+#include "s32_ncore.h"
+#include "s32_sramc.h"
+
+#define MMU_ROUND_UP_TO_4K(x)	\
+			(((x) & ~0xfff) == (x) ? (x) : ((x) & ~0xfff) + 0x1000)
+
+IMPORT_SYM(uintptr_t, __RW_START__, BL31_RW_START);
+
+static gicv3_redist_ctx_t rdisif_ctxs[PLATFORM_CORE_COUNT];
+static gicv3_dist_ctx_t dist_ctx;
+
+static const mmap_region_t s32_mmap[] = {
+#if !defined(PLAT_s32r)
+	MAP_REGION_FLAT(S32G_SSRAM_BASE, S32G_SSRAM_LIMIT - S32G_SSRAM_BASE,
+			 MT_MEMORY | MT_RW | MT_SECURE),
+#endif
+	MAP_REGION_FLAT(S32_UART_BASE, S32_UART_SIZE,
+			MT_DEVICE | MT_RW | MT_NS),
+	MAP_REGION_FLAT(S32GEN1_GIC_BASE, S32GEN1_GIC_SIZE,
+			MT_DEVICE | MT_RW),
+	MAP_REGION_FLAT(S32_MC_ME_BASE_ADDR, S32_MC_ME_SIZE,
+			MT_DEVICE | MT_RW),
+	MAP_REGION_FLAT(MC_CGM0_BASE_ADDR,
+			MMU_ROUND_UP_TO_4K(S32_DFS_ADDR(S32_DFS_NR)),
+			MT_DEVICE | MT_RW),
+	/* This will cover both the MC_RGM and the GPR accesses, while reducing
+	 * the number of used up MMU regions.
+	 */
+	MAP_REGION_FLAT(S32_MC_RGM_BASE_ADDR, S32_MC_RGM_SIZE,
+			MT_DEVICE | MT_RW),
+	/* When we execute at System Monitor on behalf of EL2/EL1, we might
+	 * have to reconfigure Ncore
+	 */
+	MAP_REGION_FLAT(NCORE_BASE_ADDR, S32_NCORE_SIZE,
+			MT_DEVICE | MT_RW),
+	MAP_REGION_FLAT(SRAMC0_BASE_ADDR, SRAMC_SIZE,
+			MT_DEVICE | MT_RW),
+#if !defined(PLAT_s32r)
+	MAP_REGION_FLAT(SSRAMC_BASE_ADDR, SRAMC_SIZE,
+			MT_DEVICE | MT_RW),
+	MAP_REGION2(BL31SRAM_BASE, BL31SRAM_BASE,
+		    MMU_ROUND_UP_TO_4K(BL31SRAM_SIZE),
+		    MT_MEMORY | MT_RW, PAGE_SIZE),
+#endif
+	MAP_REGION2(S32_BL33_IMAGE_BASE, S32_BL33_IMAGE_BASE,
+			MMU_ROUND_UP_TO_4K(S32_BL33_IMAGE_SIZE),
+			MT_MEMORY | MT_RW, PAGE_SIZE),
+	MAP_REGION2(DTB_BASE, DTB_BASE, MMU_ROUND_UP_TO_4K(DTB_SIZE),
+			MT_MEMORY | MT_RW, PAGE_SIZE),
+	MAP_REGION_FLAT(S32_PMEM_START, S32_PMEM_LEN,
+			MT_MEMORY | MT_RW | MT_SECURE),
+	MAP_REGION_FLAT(S32_SCMI_SHARED_MEM, S32_SCMI_SHARED_MEM_SIZE,
+			MT_NON_CACHEABLE | MT_RW | MT_SECURE),
+	{0},
+};
+
+static entry_point_info_t bl33_image_ep_info;
+static entry_point_info_t bl32_image_ep_info;
+
+static uintptr_t rdistif_base_addrs[PLATFORM_CORE_COUNT];
+
+static const interrupt_prop_t interrupt_props[] = {
+	INTR_PROP_DESC(S32_SECONDARY_WAKE_SGI, GIC_HIGHEST_SEC_PRIORITY,
+		       INTR_GROUP0, GIC_INTR_CFG_EDGE),
+};
+
+static unsigned int plat_s32_mpidr_to_core_pos(unsigned long mpidr);
+
+const gicv3_driver_data_t s32_gic_data = {
+	.gicd_base = PLAT_GICD_BASE,
+	.gicr_base = PLAT_GICR_BASE,
+	.rdistif_num = PLATFORM_CORE_COUNT,
+	.rdistif_base_addrs = rdistif_base_addrs,
+	.interrupt_props = interrupt_props,
+	.interrupt_props_num = ARRAY_SIZE(interrupt_props),
+	.mpidr_to_core_pos = plat_s32_mpidr_to_core_pos,
+};
+
+volatile uint32_t s32_core_release_var[PLATFORM_CORE_COUNT];
+
+void update_core_state(uint32_t core, uint32_t state)
+{
+	s32_core_release_var[core] = state;
+	flush_dcache_range((uintptr_t)&s32_core_release_var[core],
+			   sizeof(s32_core_release_var[core]));
+}
+
+bool is_last_core(void)
+{
+	size_t i, on = 0U;
+
+	inv_dcache_range((uintptr_t)s32_core_release_var,
+			 sizeof(s32_core_release_var));
+	for (i = 0U; i < ARRAY_SIZE(s32_core_release_var); i++)
+		if (s32_core_release_var[i])
+			on++;
+
+	return (on == 1);
+}
+
+bool is_cluster0_off(void)
+{
+	size_t i;
+
+	inv_dcache_range((uintptr_t)s32_core_release_var,
+			 sizeof(s32_core_release_var));
+	for (i = 0U; i < PLATFORM_CORE_COUNT / 2; i++)
+		if (s32_core_release_var[i])
+			return false;
+
+	return true;
+}
+
+bool is_cluster1_off(void)
+{
+	size_t i;
+
+	inv_dcache_range((uintptr_t)s32_core_release_var,
+			 sizeof(s32_core_release_var));
+	for (i = PLATFORM_CORE_COUNT / 2; i < PLATFORM_CORE_COUNT; i++)
+		if (s32_core_release_var[i])
+			return false;
+
+	return true;
+}
+
+static uint32_t s32_get_spsr_for_bl33_entry(void)
+{
+	uint32_t spsr;
+	unsigned long el_status, mode;
+
+	/* figure out what mode we enter the non-secure world */
+	el_status = read_id_aa64pfr0_el1() >> ID_AA64PFR0_EL2_SHIFT;
+	el_status &= ID_AA64PFR0_ELX_MASK;
+#if (S32_HAS_HV == 0)
+	mode = MODE_EL1;
+#else
+	mode = (el_status) ? MODE_EL2 : MODE_EL1;
+#endif
+	spsr = SPSR_64(mode, MODE_SP_ELX, DISABLE_ALL_EXCEPTIONS);
+
+	return spsr;
+}
+
+entry_point_info_t *bl31_plat_get_next_image_ep_info(uint32_t type)
+{
+	assert(sec_state_is_valid(type));
+	if (type == NON_SECURE)
+		return &bl33_image_ep_info;
+	else
+		return &bl32_image_ep_info;
+}
+
+void bl31_early_platform_setup2(u_register_t arg0, u_register_t arg1,
+		u_register_t arg2, u_register_t arg3)
+{
+	SET_PARAM_HEAD(&bl33_image_ep_info, PARAM_EP, VERSION_1, 0);
+	bl33_image_ep_info.pc = BL33_ENTRYPOINT;
+	bl33_image_ep_info.spsr = s32_get_spsr_for_bl33_entry();
+	SET_SECURITY_STATE(bl33_image_ep_info.h.attr, NON_SECURE);
+
+#ifdef SPD_opteed
+	SET_PARAM_HEAD(&bl32_image_ep_info, PARAM_EP, VERSION_2, 0);
+	SET_SECURITY_STATE(bl32_image_ep_info.h.attr, SECURE);
+	bl32_image_ep_info.pc = S32_BL32_BASE;
+	bl32_image_ep_info.spsr = 0;
+	bl32_image_ep_info.args.arg0 = MODE_RW_64;
+	bl32_image_ep_info.args.arg3 = BL33_DTB;
+#endif
+}
+
+static void s32_el3_mmu_fixup(void)
+{
+	const unsigned long code_start = BL_CODE_BASE;
+	const unsigned long code_size = BL_CODE_END - BL_CODE_BASE;
+	const unsigned long rw_start = BL31_RW_START;
+	const unsigned long rw_size = BL_END - BL31_RW_START;
+	mmap_region_t regions[] = {
+		{
+			.base_pa = code_start,
+			.base_va = code_start,
+			.size = code_size,
+			.attr = MT_CODE | MT_SECURE,
+		},
+		{
+			.base_pa = rw_start,
+			.base_va = rw_start,
+			.size = rw_size,
+			.attr = MT_RW | MT_MEMORY | MT_SECURE,
+		},
+	};
+	int i;
+
+	/* The calls to mmap_add_region() consume mmap regions,
+	 * so they must be counted in the static asserts
+	 */
+	_Static_assert(ARRAY_SIZE(s32_mmap) + ARRAY_SIZE(regions) - 1 <=
+		MAX_MMAP_REGIONS,
+		"Fewer MAX_MMAP_REGIONS than in s32_mmap will likely result in a MMU exception at runtime");
+	_Static_assert(ARRAY_SIZE(s32_mmap) + ARRAY_SIZE(regions) - 1
+#if !defined(PLAT_s32r)
+	    + BL31SRAM_MAX_PAGES
+#endif
+		<= MAX_XLAT_TABLES,
+		"Fewer MAX_XLAT_TABLES than in s32_mmap will likely result in a MMU exception at runtime");
+
+	/* MMU initialization; while technically not necessary on cold boot,
+	 * it is required for warm boot path processing
+	 */
+	for (i = 0; i < ARRAY_SIZE(regions); i++)
+		mmap_add_region(regions[i].base_pa, regions[i].base_va,
+				regions[i].size, regions[i].attr);
+
+	mmap_add(s32_mmap);
+
+	init_xlat_tables();
+	enable_mmu_el3(0);
+}
+
+void s32_gic_setup(void)
+{
+	gicv3_driver_init(&s32_gic_data);
+	gicv3_distif_init();
+	gicv3_rdistif_init(plat_my_core_pos());
+	gicv3_cpuif_enable(plat_my_core_pos());
+}
+
+void plat_gic_save(void)
+{
+	for (int i = 0; i < PLATFORM_CORE_COUNT; i++)
+		gicv3_rdistif_save(i, &rdisif_ctxs[i]);
+
+	gicv3_distif_save(&dist_ctx);
+}
+
+void plat_gic_restore(void)
+{
+	gicv3_distif_init_restore(&dist_ctx);
+
+	for (int i = 0; i < PLATFORM_CORE_COUNT; i++)
+		gicv3_rdistif_init_restore(i, &rdisif_ctxs[i]);
+}
+
+void bl31_plat_arch_setup(void)
+{
+	s32_smp_fixup();
+	s32_el3_mmu_fixup();
+
+#if (S32_USE_LINFLEX_IN_BL31 == 1)
+	console_s32_register();
+#endif
+}
+
+static unsigned int plat_s32_mpidr_to_core_pos(unsigned long mpidr)
+{
+	return (unsigned int)plat_core_pos_by_mpidr(mpidr);
+}
+
+/* TODO: Last-minute modifications before exiting BL31:
+ *  - restrict the S32_PMEM_START..S32_PMEM_END DRAM area only to
+ *    secure privileged contexts;
+ *  - lock XRDC until the next reset
+ */
+void bl31_plat_runtime_setup(void)
+{
+}
+
diff --git a/plat/nxp/s32/s32_common.mk b/plat/nxp/s32/s32_common.mk
index 29caec283..6230faf5a 100644
--- a/plat/nxp/s32/s32_common.mk
+++ b/plat/nxp/s32/s32_common.mk
@@ -95,6 +95,8 @@ BL31_SOURCES += \
 			plat/common/plat_gicv3.c \
 			plat/common/plat_psci_common.c \
 			plat/nxp/s32/include/plat_macros.S \
+			plat/nxp/s32/s32_bl31.c \
+			plat/nxp/s32/s32_lowlevel_bl31.S
 
 DTC_FLAGS		+= -Wno-unit_address_vs_reg
 
@@ -146,6 +148,11 @@ LOG_LEVEL		?= 50
 S32_USE_LINFLEX_IN_BL31	?= 0
 $(eval $(call add_define_val,S32_USE_LINFLEX_IN_BL31,$(S32_USE_LINFLEX_IN_BL31)))
 
+# Whether we're going to run a hypervisor (EL2) or jump straight into the
+# bootloader (EL1)
+S32_HAS_HV		?= 0
+$(eval $(call add_define_val,S32_HAS_HV,$(S32_HAS_HV)))
+
 # Reserve some space at the end of SRAM for external apps and include it
 # in the calculation of FIP_BASE address.
 EXT_APP_SIZE		:= 0x100000
diff --git a/plat/nxp/s32/s32g/bl31_lowlevel.S b/plat/nxp/s32/s32_lowlevel_bl31.S
similarity index 94%
rename from plat/nxp/s32/s32g/bl31_lowlevel.S
rename to plat/nxp/s32/s32_lowlevel_bl31.S
index 58bbeab06..04dafe93c 100644
--- a/plat/nxp/s32/s32g/bl31_lowlevel.S
+++ b/plat/nxp/s32/s32_lowlevel_bl31.S
@@ -9,23 +9,23 @@
 #include "platform_def.h"
 #include "s32_ncore.h"
 
-.globl s32g_smp_fixup
+.globl s32_smp_fixup
 .globl plat_secondary_cold_boot_setup
 
-.globl s32g_core_release_var
+.globl s32_core_release_var
 
 
 /* Set SMPEN bit on u-boot's behalf */
 /* TODO check whether this function is still necessary in BL31; in cortex_a53.S
  * there's a cortex_a53_rest_func doing the same. */
-func s32g_smp_fixup
+func s32_smp_fixup
 	mrs x14, S3_1_c15_c2_1
 	orr x14, x14, #(1 << 6)
 	msr S3_1_c15_c2_1, x14
 	isb
 
 	ret
-endfunc s32g_smp_fixup
+endfunc s32_smp_fixup
 
 
 /* Clear GICR_WAKER[ProcessorSleep] bit.
@@ -194,10 +194,10 @@ func plat_secondary_cold_boot_setup
 	bl	s32g_gic_fixups_for_secondary
 	bl	plat_my_core_pos
 	lsl	x0, x0, #2	/* array elements are of size 32-bit*/
-	ldr	x7, =s32g_core_release_var
+	ldr	x7, =s32_core_release_var
 wfi_pen:
 	dsb	sy
-	/* Invalidate cache before reading s32g_core_release_var[my_core_pos];
+	/* Invalidate cache before reading s32_core_release_var[my_core_pos];
 	 * Save x0, x1 first.
 	 */
 	mov	x9, x0
@@ -207,7 +207,7 @@ wfi_pen:
 	bl	inv_dcache_range
 	mov	x0, x9
 	mov	x1, x10
-	/* index s32g_core_release_var with current core id */
+	/* index s32_core_release_var with current core id */
 	ldr	w8, [x7, x0]
 	cbnz	w8, wfi_done
 
@@ -233,3 +233,4 @@ wfi_done:
 	ldr	x7, [x7]
 	br	x7
 endfunc plat_secondary_cold_boot_setup
+
diff --git a/plat/nxp/s32/s32g/include/s32g_bl_common.h b/plat/nxp/s32/s32g/include/s32g_bl_common.h
index 189d207e3..a3d7dfc84 100644
--- a/plat/nxp/s32/s32g/include/s32g_bl_common.h
+++ b/plat/nxp/s32/s32g/include/s32g_bl_common.h
@@ -11,20 +11,11 @@
 #include <stdint.h>
 #include "s32_bl_common.h"
 
-void s32g_gic_setup(void);
-void plat_gic_save(void);
-void plat_gic_restore(void);
-
 int pmic_prepare_for_suspend(void);
 void pmic_system_off(void);
 int pmic_disable_wdg(vr5510_t fsu);
 int pmic_setup(void);
 
-void update_core_state(uint32_t core, uint32_t state);
-bool is_last_core(void);
-bool is_cluster0_off(void);
-bool is_cluster1_off(void);
-
 void s32g_reinit_i2c(void);
 
 bool s32gen1_is_wkp_short_boot(void);
diff --git a/plat/nxp/s32/s32g/include/s32g_lowlevel.h b/plat/nxp/s32/s32g/include/s32g_lowlevel.h
index f1caf59e5..3e51f0212 100644
--- a/plat/nxp/s32/s32g/include/s32g_lowlevel.h
+++ b/plat/nxp/s32/s32g/include/s32g_lowlevel.h
@@ -7,11 +7,9 @@
 #ifndef S32G_LOWLEVEL_H
 #define S32G_LOWLEVEL_H
 
-#include <stdbool.h>
-#include <stdint.h>
+#include "s32_lowlevel.h"
 
 int plat_is_my_cpu_primary(void);
-void s32g_smp_fixup(void);
 void reset_registers_for_lockstep(void);
 
 #endif /* S32G_LOWLEVEL_H */
diff --git a/plat/nxp/s32/s32g/include/s32g_platform_def.h b/plat/nxp/s32/s32g/include/s32g_platform_def.h
index e4a8c8644..655aad149 100644
--- a/plat/nxp/s32/s32g/include/s32g_platform_def.h
+++ b/plat/nxp/s32/s32g/include/s32g_platform_def.h
@@ -56,11 +56,9 @@
 #define BL31SSRAM_MAX_CODE_SIZE	(S32G_SSRAM_LIMIT - BL31SSRAM_BASE)
 #define BL31SSRAM_STACK_SIZE	0x1000
 
-#define DTB_SIZE		(BL2_BASE - DTB_BASE)
-
 #if defined IMAGE_BL31
-/* To limit usage, keep these in sync with sizeof(s32g_mmap) */
-#define MAX_MMAP_REGIONS		17
+/* To limit usage, keep these in sync with sizeof(s32_mmap) */
+#define MAX_MMAP_REGIONS		16
 #define MAX_XLAT_TABLES			(MAX_MMAP_REGIONS + BL31SRAM_MAX_PAGES)
 #endif
 
diff --git a/plat/nxp/s32/s32g/s32g_bl31.c b/plat/nxp/s32/s32g/s32g_bl31.c
index 6b97c4e17..896e4eaae 100644
--- a/plat/nxp/s32/s32g/s32g_bl31.c
+++ b/plat/nxp/s32/s32g/s32g_bl31.c
@@ -20,251 +20,14 @@
 #include "s32g_pm.h"
 #include "s32g_clocks.h"
 #include "s32_dt.h"
-#include "s32_linflexuart.h"
 #include "s32g_lowlevel.h"
 #include "s32g_mc_me.h"
 #include "s32g_mc_rgm.h"
-#include "s32_ncore.h"
 #include "s32g_pinctrl.h"
 #include "s32gen1-wkpu.h"
 #include "s32g_bl_common.h"
-#include "s32_sramc.h"
 #include "clk/clk.h"
 
-#define MMU_ROUND_UP_TO_4K(x)	\
-			(((x) & ~0xfff) == (x) ? (x) : ((x) & ~0xfff) + 0x1000)
-
-IMPORT_SYM(uintptr_t, __RW_START__, BL31_RW_START);
-
-static gicv3_redist_ctx_t rdisif_ctxs[PLATFORM_CORE_COUNT];
-static gicv3_dist_ctx_t dist_ctx;
-
-static const mmap_region_t s32g_mmap[] = {
-	MAP_REGION_FLAT(S32G_SSRAM_BASE, S32G_SSRAM_LIMIT - S32G_SSRAM_BASE,
-			 MT_MEMORY | MT_RW | MT_SECURE),
-	MAP_REGION_FLAT(S32_UART_BASE, S32_UART_SIZE,
-			MT_DEVICE | MT_RW | MT_NS),
-	MAP_REGION_FLAT(S32GEN1_GIC_BASE, S32GEN1_GIC_SIZE,
-			MT_DEVICE | MT_RW),
-	MAP_REGION_FLAT(S32_MC_ME_BASE_ADDR, S32_MC_ME_SIZE,
-			MT_DEVICE | MT_RW),
-	MAP_REGION_FLAT(MC_CGM0_BASE_ADDR,
-			MMU_ROUND_UP_TO_4K(S32_DFS_ADDR(S32_DFS_NR)),
-			MT_DEVICE | MT_RW),
-	/* This will cover both the MC_RGM and the GPR accesses, while reducing
-	 * the number of used up MMU regions.
-	 */
-	MAP_REGION_FLAT(S32_MC_RGM_BASE_ADDR, S32_MC_RGM_SIZE,
-			MT_DEVICE | MT_RW),
-	/* When we execute at System Monitor on behalf of EL2/EL1, we might
-	 * have to reconfigure Ncore
-	 */
-	MAP_REGION_FLAT(NCORE_BASE_ADDR, S32_NCORE_SIZE,
-			MT_DEVICE | MT_RW),
-	MAP_REGION_FLAT(SRAMC0_BASE_ADDR, SRAMC_SIZE,
-			MT_DEVICE | MT_RW),
-	MAP_REGION_FLAT(SSRAMC_BASE_ADDR, SRAMC_SIZE,
-			MT_DEVICE | MT_RW),
-	MAP_REGION2(BL31SRAM_BASE, BL31SRAM_BASE,
-		    MMU_ROUND_UP_TO_4K(BL31SRAM_SIZE),
-		    MT_MEMORY | MT_RW, PAGE_SIZE),
-	MAP_REGION2(S32_BL33_IMAGE_BASE, S32_BL33_IMAGE_BASE,
-			MMU_ROUND_UP_TO_4K(S32_BL33_IMAGE_SIZE),
-			MT_MEMORY | MT_RW, PAGE_SIZE),
-	MAP_REGION2(DTB_BASE, DTB_BASE, MMU_ROUND_UP_TO_4K(DTB_SIZE),
-			MT_MEMORY | MT_RW, PAGE_SIZE),
-	MAP_REGION_FLAT(S32_PMEM_START, S32_PMEM_LEN,
-			MT_MEMORY | MT_RW | MT_SECURE),
-	MAP_REGION_FLAT(S32_SCMI_SHARED_MEM, S32_SCMI_SHARED_MEM_SIZE,
-			MT_NON_CACHEABLE | MT_RW | MT_SECURE),
-	{0},
-};
-
-static entry_point_info_t bl33_image_ep_info;
-static entry_point_info_t bl32_image_ep_info;
-
-static uintptr_t rdistif_base_addrs[PLATFORM_CORE_COUNT];
-
-static const interrupt_prop_t interrupt_props[] = {
-	INTR_PROP_DESC(S32_SECONDARY_WAKE_SGI, GIC_HIGHEST_SEC_PRIORITY,
-		       INTR_GROUP0, GIC_INTR_CFG_EDGE),
-};
-
-static unsigned int plat_s32g274a_mpidr_to_core_pos(unsigned long mpidr);
-
-const gicv3_driver_data_t s32g274a_gic_data = {
-	.gicd_base = PLAT_GICD_BASE,
-	.gicr_base = PLAT_GICR_BASE,
-	.rdistif_num = PLATFORM_CORE_COUNT,
-	.rdistif_base_addrs = rdistif_base_addrs,
-	.interrupt_props = interrupt_props,
-	.interrupt_props_num = ARRAY_SIZE(interrupt_props),
-	.mpidr_to_core_pos = plat_s32g274a_mpidr_to_core_pos,
-};
-
-volatile uint32_t s32g_core_release_var[PLATFORM_CORE_COUNT];
-
-void update_core_state(uint32_t core, uint32_t state)
-{
-	s32g_core_release_var[core] = state;
-	flush_dcache_range((uintptr_t)&s32g_core_release_var[core],
-			   sizeof(s32g_core_release_var[core]));
-}
-
-bool is_last_core(void)
-{
-	size_t i, on = 0U;
-
-	inv_dcache_range((uintptr_t)s32g_core_release_var,
-			 sizeof(s32g_core_release_var));
-	for (i = 0U; i < ARRAY_SIZE(s32g_core_release_var); i++)
-		if (s32g_core_release_var[i])
-			on++;
-
-	return (on == 1);
-}
-
-bool is_cluster0_off(void)
-{
-	size_t i;
-
-	inv_dcache_range((uintptr_t)s32g_core_release_var,
-			 sizeof(s32g_core_release_var));
-	for (i = 0U; i < PLATFORM_CORE_COUNT / 2; i++)
-		if (s32g_core_release_var[i])
-			return false;
-
-	return true;
-}
-
-bool is_cluster1_off(void)
-{
-	size_t i;
-
-	inv_dcache_range((uintptr_t)s32g_core_release_var,
-			 sizeof(s32g_core_release_var));
-	for (i = PLATFORM_CORE_COUNT / 2; i < PLATFORM_CORE_COUNT; i++)
-		if (s32g_core_release_var[i])
-			return false;
-
-	return true;
-}
-
-static uint32_t s32g_get_spsr_for_bl33_entry(void)
-{
-	uint32_t spsr;
-	unsigned long el_status, mode;
-
-	/* figure out what mode we enter the non-secure world */
-	el_status = read_id_aa64pfr0_el1() >> ID_AA64PFR0_EL2_SHIFT;
-	el_status &= ID_AA64PFR0_ELX_MASK;
-#if (S32G_HAS_HV == 0)
-	mode = MODE_EL1;
-#else
-	mode = (el_status) ? MODE_EL2 : MODE_EL1;
-#endif
-	spsr = SPSR_64(mode, MODE_SP_ELX, DISABLE_ALL_EXCEPTIONS);
-
-	return spsr;
-}
-
-entry_point_info_t *bl31_plat_get_next_image_ep_info(uint32_t type)
-{
-	assert(sec_state_is_valid(type));
-	if (type == NON_SECURE)
-		return &bl33_image_ep_info;
-	else
-		return &bl32_image_ep_info;
-}
-
-void bl31_early_platform_setup2(u_register_t arg0, u_register_t arg1,
-		u_register_t arg2, u_register_t arg3)
-{
-	SET_PARAM_HEAD(&bl33_image_ep_info, PARAM_EP, VERSION_1, 0);
-	bl33_image_ep_info.pc = BL33_ENTRYPOINT;
-	bl33_image_ep_info.spsr = s32g_get_spsr_for_bl33_entry();
-	SET_SECURITY_STATE(bl33_image_ep_info.h.attr, NON_SECURE);
-
-#ifdef SPD_opteed
-	SET_PARAM_HEAD(&bl32_image_ep_info, PARAM_EP, VERSION_2, 0);
-	SET_SECURITY_STATE(bl32_image_ep_info.h.attr, SECURE);
-	bl32_image_ep_info.pc = S32_BL32_BASE;
-	bl32_image_ep_info.spsr = 0;
-	bl32_image_ep_info.args.arg0 = MODE_RW_64;
-	bl32_image_ep_info.args.arg3 = BL33_DTB;
-#endif
-}
-
-static void s32g_el3_mmu_fixup(void)
-{
-	const unsigned long code_start = BL_CODE_BASE;
-	const unsigned long code_size = BL_CODE_END - BL_CODE_BASE;
-	const unsigned long rw_start = BL31_RW_START;
-	const unsigned long rw_size = BL_END - BL31_RW_START;
-	mmap_region_t regions[] = {
-		{
-			.base_pa = code_start,
-			.base_va = code_start,
-			.size = code_size,
-			.attr = MT_CODE | MT_SECURE,
-		},
-		{
-			.base_pa = rw_start,
-			.base_va = rw_start,
-			.size = rw_size,
-			.attr = MT_RW | MT_MEMORY | MT_SECURE,
-		},
-	};
-	int i;
-
-	/* The calls to mmap_add_region() consume mmap regions,
-	 * so they must be counted in the static asserts
-	 */
-	_Static_assert(ARRAY_SIZE(s32g_mmap) + ARRAY_SIZE(regions) - 1 <=
-		       MAX_MMAP_REGIONS,
-		       "Fewer MAX_MMAP_REGIONS than in s32g_mmap will likely "
-		       "result in a MMU exception at runtime");
-	_Static_assert(ARRAY_SIZE(s32g_mmap) + ARRAY_SIZE(regions) - 1 +
-		       BL31SRAM_MAX_PAGES <= MAX_XLAT_TABLES,
-		       "Fewer MAX_XLAT_TABLES than in s32g_mmap will likely "
-		       "result in a MMU exception at runtime");
-	/* MMU initialization; while technically not necessary on cold boot,
-	 * it is required for warm boot path processing
-	 */
-	for (i = 0; i < ARRAY_SIZE(regions); i++)
-		mmap_add_region(regions[i].base_pa, regions[i].base_va,
-				regions[i].size, regions[i].attr);
-
-	mmap_add(s32g_mmap);
-
-	init_xlat_tables();
-	enable_mmu_el3(0);
-}
-
-void s32g_gic_setup(void)
-{
-	gicv3_driver_init(&s32g274a_gic_data);
-	gicv3_distif_init();
-	gicv3_rdistif_init(plat_my_core_pos());
-	gicv3_cpuif_enable(plat_my_core_pos());
-}
-
-void plat_gic_save(void)
-{
-	for (int i = 0; i < PLATFORM_CORE_COUNT; i++)
-		gicv3_rdistif_save(i, &rdisif_ctxs[i]);
-
-	gicv3_distif_save(&dist_ctx);
-}
-
-void plat_gic_restore(void)
-{
-	gicv3_distif_init_restore(&dist_ctx);
-
-	for (int i = 0; i < PLATFORM_CORE_COUNT; i++)
-		gicv3_rdistif_init_restore(i, &rdisif_ctxs[i]);
-}
-
 #if S32G_EMU == 0
 static void dt_init_wkpu(void)
 {
@@ -296,21 +59,6 @@ static void dt_init_wkpu(void)
 }
 #endif
 
-void bl31_plat_arch_setup(void)
-{
-	s32g_smp_fixup();
-	s32g_el3_mmu_fixup();
-
-#if (S32_USE_LINFLEX_IN_BL31 == 1)
-	console_s32_register();
-#endif
-}
-
-static unsigned int plat_s32g274a_mpidr_to_core_pos(unsigned long mpidr)
-{
-	return (unsigned int)plat_core_pos_by_mpidr(mpidr);
-}
-
 static int check_clock_node(const void *fdt, int nodeoffset)
 {
 	const void *prop;
@@ -375,17 +123,9 @@ void bl31_platform_setup(void)
 #endif
 
 	update_core_state(plat_my_core_pos(), 1);
-	s32g_gic_setup();
+	s32_gic_setup();
 
 	s32_enable_a53_clock();
 	dt_clk_init();
 }
 
-/* TODO: Last-minute modifications before exiting BL31:
- *  - restrict the S32_PMEM_START..S32_PMEM_END DRAM area only to
- *    secure privileged contexts;
- *  - lock XRDC until the next reset
- */
-void bl31_plat_runtime_setup(void)
-{
-}
diff --git a/plat/nxp/s32/s32g/s32g_common.mk b/plat/nxp/s32/s32g/s32g_common.mk
index 9e45005ad..a485dc645 100644
--- a/plat/nxp/s32/s32g/s32g_common.mk
+++ b/plat/nxp/s32/s32g/s32g_common.mk
@@ -58,8 +58,6 @@ BL31_SOURCES		+= plat/nxp/s32/s32g/s32g_bl31.c \
 			   drivers/scmi-msg/entry.c \
 			   drivers/scmi-msg/reset_domain.c \
 
-BL31_SOURCES		+= plat/nxp/s32/s32g/bl31_lowlevel.S \
-
 ### Platform-specific defines ###
 # Which LinFlexD to use as a UART device
 ifeq ($(S32G_EMU),0)
@@ -69,7 +67,3 @@ S32_LINFLEX_MODULE	:= 1
 endif
 $(eval $(call add_define_val,S32_LINFLEX_MODULE,$(S32_LINFLEX_MODULE)))
 
-# Whether we're going to run a hypervisor (EL2) or jump straight into the
-# bootloader (EL1)
-S32G_HAS_HV		?= 0
-$(eval $(call add_define_val,S32G_HAS_HV,$(S32G_HAS_HV)))
-- 
2.17.1

