From db2b57c619c201cdbdb8bcffb38a2024c8cf0777 Mon Sep 17 00:00:00 2001
From: Andra-Teodora Ilie <andra.ilie@nxp.com>
Date: Thu, 25 Nov 2021 15:05:52 +0200
Subject: [PATCH 31/50] s32: bl2: Move bl2_plat_handle_post_image_load to
 generic s32 layer

Issue: ALB-7411
Upstream-Status: Pending 

Signed-off-by: Andra-Teodora Ilie <andra.ilie@nxp.com>
Signed-off-by: Zhantao Tang <zhantao.tang@windriver.com>
---
 plat/nxp/s32/s32_bl2_el3.c       | 270 +++++++++++++++++++++++++++++-
 plat/nxp/s32/s32_common.mk       |   1 +
 plat/nxp/s32/s32g/s32g_bl2_el3.c | 279 -------------------------------
 plat/nxp/s32/s32g/s32g_common.mk |   1 -
 4 files changed, 270 insertions(+), 281 deletions(-)

diff --git a/plat/nxp/s32/s32_bl2_el3.c b/plat/nxp/s32/s32_bl2_el3.c
index b3868bbea..16502e723 100644
--- a/plat/nxp/s32/s32_bl2_el3.c
+++ b/plat/nxp/s32/s32_bl2_el3.c
@@ -6,11 +6,17 @@
 #include <assert.h>
 
 #include <common/bl_common.h>
+#include <common/debug.h>
 #include <common/desc_image_load.h>
-#include <lib/xlat_tables/xlat_tables_v2.h>
+#include <common/fdt_fixup.h>
+#include <ddr/ddr_utils.h>
 #include <lib/libc/errno.h>
 #include <lib/libfdt/libfdt.h>
+#include <lib/mmio.h>
+#include <lib/optee_utils.h>
+#include <lib/xlat_tables/xlat_tables_v2.h>
 #include <platform.h>
+#include <tools_share/firmware_image_package.h>
 
 #include "s32_dt.h"
 #include "s32_clocks.h"
@@ -19,6 +25,12 @@
 #include "s32_sramc.h"
 #include "s32_storage.h"
 
+#define S32_FDT_UPDATES_SPACE		100U
+
+#define AARCH64_UNCOND_BRANCH_MASK	(0x7c000000)
+#define AARCH64_UNCOND_BRANCH_OP	(BIT(26) | BIT(28))
+#define BL33_DTB_MAGIC				(0xedfe0dd0)
+
 void add_fip_img_to_mem_params_descs(bl_mem_params_node_t *params,
 					    size_t *index)
 {
@@ -309,3 +321,259 @@ void plat_flush_next_bl_params(void)
 	flush_bl_params_desc();
 }
 
+static bool is_branch_op(uint32_t op)
+{
+	return (op & AARCH64_UNCOND_BRANCH_MASK) == AARCH64_UNCOND_BRANCH_OP;
+}
+
+#if (ERRATA_S32_050543 == 1 && S32G_EMU == 0)
+static int ft_fixup_ddr_errata(void *blob)
+{
+	int nodeoff, ret;
+
+	if (polling_needed != 1) {
+		return 0;
+	}
+
+	nodeoff = fdt_node_offset_by_compatible(blob, -1, "fsl,s32gen1-ddr-err050543");
+	if (nodeoff < 0) {
+		ERROR("Failed to get offset of 'fsl,s32gen1-ddr-err050543' node\n");
+		return nodeoff;
+	}
+
+	ret = fdt_setprop_string(blob, nodeoff, "status", "okay");
+	if (ret) {
+		ERROR("Failed to enable 'fsl,s32gen1-ddr-err050543' node\n");
+		return ret;
+	}
+
+	return 0;
+}
+#endif
+
+static int disable_clk_node(void *blob, uint32_t *phandle)
+{
+	const char *clk_path;
+	int nodeoff, ret;
+
+	clk_path = fdt_get_alias(blob, "clks");
+	if (!clk_path) {
+		ERROR("Failed to get the path of 'clks' alias\n");
+		return -EIO;
+	}
+
+	nodeoff = fdt_path_offset(blob, clk_path);
+	if (nodeoff < 0) {
+		ERROR("Failed to get offset of '%s' node\n", clk_path);
+		return nodeoff;
+	}
+
+	*phandle = fdt_get_phandle(blob, nodeoff);
+	if (*phandle == 0) {
+		ERROR("Failed to get phandle of '%s' node\n", clk_path);
+		return *phandle;
+	}
+
+	ret = fdt_setprop_string(blob, nodeoff, "status", "disabled");
+	if (ret) {
+		ERROR("Failed to disable '%s' node\n", clk_path);
+		return ret;
+	}
+
+	ret = fdt_delprop(blob, nodeoff, "phandle");
+	if (ret) {
+		ERROR("Failed to remove phandle property of '%s' node\n",
+		       clk_path);
+		return ret;
+	}
+
+	return 0;
+}
+
+static int enable_scmi_clk_node(void *blob, uint32_t phandle)
+{
+	int nodeoff, ret;
+
+	nodeoff = fdt_path_offset(blob, "/firmware/scmi/protocol@14");
+	if (nodeoff < 0) {
+		ERROR("Failed to get offset of '/firmware/scmi/protocol@14' node\n");
+		return nodeoff;
+	}
+
+	ret = fdt_setprop_cell(blob, nodeoff, "phandle", phandle);
+	if (ret) {
+		ERROR("Failed to set phandle property of '/firmware/scmi/protocol@14' node\n");
+		return ret;
+	}
+
+	ret = fdt_setprop_string(blob, nodeoff, "status", "okay");
+	if (ret) {
+		ERROR("Failed to enable '/firmware/scmi/protocol@14' node\n");
+		return ret;
+	}
+
+	return 0;
+}
+
+static int enable_scmi_mbox(void *blob)
+{
+	int nodeoff, ret;
+
+	nodeoff = fdt_node_offset_by_compatible(blob, -1, "arm,scmi-smc");
+	if (nodeoff < 0) {
+		ERROR("Failed to get offset of 'arm,scmi-smc' node\n");
+		return nodeoff;
+	}
+
+	ret = fdt_setprop_string(blob, nodeoff, "status", "okay");
+	if (ret) {
+		ERROR("Failed to enable 'arm,scmi-smc' node\n");
+		return nodeoff;
+	}
+
+	return 0;
+}
+
+static int ft_fixup_scmi_clks(void *blob)
+{
+	uint32_t phandle;
+	int ret;
+
+	ret = disable_clk_node(blob, &phandle);
+	if (ret)
+		return ret;
+
+	ret = enable_scmi_clk_node(blob, phandle);
+	if (ret)
+		return ret;
+
+	ret = enable_scmi_mbox(blob);
+	if (ret)
+		return ret;
+
+	return 0;
+}
+
+static int ft_fixup_resmem_node(void *blob)
+{
+	int ret;
+	char nodename[21];
+
+	snprintf(nodename, sizeof(nodename), "atf@%x", BL31_BASE);
+
+	ret = fdt_add_reserved_memory(blob, nodename, BL31_BASE, BL31_SIZE);
+	if (ret) {
+		ERROR("Failed to add 'atf' /reserved-memory node");
+		return ret;
+	}
+
+	return 0;
+}
+
+static int ft_fixups(void *blob)
+{
+	size_t size = fdt_totalsize(blob);
+	int ret;
+
+	size += S32_FDT_UPDATES_SPACE;
+	fdt_set_totalsize(blob, size);
+
+	ret = ft_fixup_scmi_clks(blob);
+	if (ret)
+		goto out;
+
+#if (ERRATA_S32_050543 == 1 && S32G_EMU == 0)
+	ret = ft_fixup_ddr_errata(blob);
+	if (ret)
+		goto out;
+#endif
+
+	ret = ft_fixup_resmem_node(blob);
+
+out:
+	flush_dcache_range((uintptr_t)blob, size);
+	return ret;
+}
+
+/* Computes the size of the images inside FIP and updates image io_block spec.
+ * Only FIP header was read from storage to SRAM so we can walk through all
+ * fip_toc_entry_t entries until the last one.
+ * For each images it is updated the real size and offset as read from the
+ * FIP header.
+ */
+static int set_fip_images_size(bl_mem_params_node_t *fip_params)
+{
+	static const uuid_t uuid_null = { {0} };
+	image_info_t *image_info = &fip_params->image_info;
+	char *buf = (char *)image_info->image_base;
+	char *buf_end = buf + image_info->image_size;
+	fip_toc_header_t *toc_header = (fip_toc_header_t *)buf;
+	fip_toc_entry_t *toc_entry = (fip_toc_entry_t *)(toc_header + 1);
+
+	while ((char *)toc_entry < buf_end) {
+		if (compare_uuids(&toc_entry->uuid, &uuid_null) == 0)
+			break;
+
+		set_image_spec(&toc_entry->uuid, toc_entry->size,
+			       toc_entry->offset_address);
+		toc_entry++;
+	}
+
+	return 0;
+}
+
+int bl2_plat_handle_post_image_load(unsigned int image_id)
+{
+	uint32_t magic;
+	int ret;
+
+	bl_mem_params_node_t *bl_mem_params = NULL;
+	bl_mem_params_node_t *pager_mem_params = NULL;
+	bl_mem_params_node_t *paged_mem_params = NULL;
+
+	if (image_id == FIP_IMAGE_ID) {
+		bl_mem_params = get_bl_mem_params_node(image_id);
+		assert(bl_mem_params && "FIP params cannot be NULL");
+
+		set_fip_images_size(bl_mem_params);
+	}
+
+	if (image_id == BL33_IMAGE_ID) {
+		magic = mmio_read_32(BL33_ENTRYPOINT);
+		if (!is_branch_op(magic)) {
+			printf("Warning: Instruction at BL33_ENTRYPOINT");
+			printf(" is 0x%x, which is not a B or BL!\n", magic);
+		}
+
+		magic = mmio_read_32(BL33_DTB);
+		if (magic != BL33_DTB_MAGIC) {
+			printf("Error: Instruction at BL33_DTB is 0x%x", magic);
+			printf(", which is not the expected 0x%x!\n",
+			       BL33_DTB_MAGIC);
+			return -EINVAL;
+		}
+
+		ret = ft_fixups((void *)BL33_DTB);
+		if (ret)
+			return ret;
+	}
+
+	if (image_id == BL32_IMAGE_ID) {
+		bl_mem_params = get_bl_mem_params_node(image_id);
+		assert(bl_mem_params && "bl_mem_params cannot be NULL");
+
+		pager_mem_params = get_bl_mem_params_node(BL32_EXTRA1_IMAGE_ID);
+		assert(pager_mem_params && "pager_mem_params cannot be NULL");
+
+		ret = parse_optee_header(&bl_mem_params->ep_info,
+					 &pager_mem_params->image_info,
+					 &paged_mem_params->image_info);
+		if (ret != 0) {
+			WARN("OPTEE header parse error.\n");
+			return ret;
+		}
+	}
+
+	return 0;
+}
+
diff --git a/plat/nxp/s32/s32_common.mk b/plat/nxp/s32/s32_common.mk
index 9732655ee..29caec283 100644
--- a/plat/nxp/s32/s32_common.mk
+++ b/plat/nxp/s32/s32_common.mk
@@ -85,6 +85,7 @@ BL2_SOURCES += \
 			drivers/nxp/s32/io/io_mmc.c \
 			drivers/nxp/s32/io/io_memmap.c \
 			drivers/nxp/s32/mmc/s32_mmc.c \
+			lib/optee/optee_utils.c \
 			plat/nxp/s32/s32_bl2_el3.c \
 			plat/nxp/s32/s32_storage.c \
 			plat/nxp/s32/s32_lowlevel_bl2.S \
diff --git a/plat/nxp/s32/s32g/s32g_bl2_el3.c b/plat/nxp/s32/s32g/s32g_bl2_el3.c
index bf36acd08..cc338498c 100644
--- a/plat/nxp/s32/s32g/s32g_bl2_el3.c
+++ b/plat/nxp/s32/s32g/s32g_bl2_el3.c
@@ -4,34 +4,17 @@
  * SPDX-License-Identifier: BSD-3-Clause
  */
 
-#include <assert.h>
-
-#include <platform.h>
-#include <common/bl_common.h>
-#include <common/desc_image_load.h>
-#include <common/debug.h>
-#include <common/fdt_fixup.h>
-#include <drivers/console.h>
 #include <lib/mmio.h>
-#include <lib/optee_utils.h>
-#include <lib/xlat_tables/xlat_tables_v2.h>
 #include "s32g_clocks.h"
 #include "s32_linflexuart.h"
 #include "s32_storage.h"
 #include "s32g_mc_rgm.h"
 #include "s32g_mc_me.h"
 #include "bl31_ssram.h"
-#include "s32g_lowlevel.h"
 #include "s32_bl2_el3.h"
 #include "s32g_bl_common.h"
-#include <drivers/generic_delay_timer.h>
 #include <plat/nxp/s32g/bl31_ssram/ssram_mailbox.h>
 #include "s32_sramc.h"
-#include <lib/libc/errno.h>
-#include <lib/libfdt/libfdt.h>
-#include <drivers/io/io_storage.h>
-#include <tools_share/firmware_image_package.h>
-#include <s32_dt.h>
 #if S32G_EMU == 1
 #include <ddr/ddrss.h>
 #else
@@ -39,12 +22,6 @@
 #include <drivers/nxp/s32/ddr/ddr_lp.h>
 #endif
 
-#define S32G_FDT_UPDATES_SPACE		100U
-
-#define AARCH64_UNCOND_BRANCH_MASK	(0x7c000000)
-#define AARCH64_UNCOND_BRANCH_OP	(BIT(26) | BIT(28))
-#define BL33_DTB_MAGIC			(0xedfe0dd0)
-
 #define PER_GROUP3_BASE		(0x40300000UL)
 #define FCCU_BASE_ADDR		(PER_GROUP3_BASE + 0x0000C000)
 #define FCCU_NCF_S1			(FCCU_BASE_ADDR + 0x84)
@@ -54,262 +31,6 @@
 static bl_mem_params_node_t s32g_bl2_mem_params_descs[6];
 REGISTER_BL_IMAGE_DESCS(s32g_bl2_mem_params_descs)
 
-static int disable_clk_node(void *blob, uint32_t *phandle)
-{
-	const char *clk_path;
-	int nodeoff, ret;
-
-	clk_path = fdt_get_alias(blob, "clks");
-	if (!clk_path) {
-		ERROR("Failed to get the path of 'clks' alias\n");
-		return -EIO;
-	}
-
-	nodeoff = fdt_path_offset(blob, clk_path);
-	if (nodeoff < 0) {
-		ERROR("Failed to get offset of '%s' node\n", clk_path);
-		return nodeoff;
-	}
-
-	*phandle = fdt_get_phandle(blob, nodeoff);
-	if (*phandle < 0) {
-		ERROR("Failed to get phandle of '%s' node\n", clk_path);
-		return *phandle;
-	}
-
-	ret = fdt_setprop_string(blob, nodeoff, "status", "disabled");
-	if (ret) {
-		ERROR("Failed to disable '%s' node\n", clk_path);
-		return ret;
-	}
-
-	ret = fdt_delprop(blob, nodeoff, "phandle");
-	if (ret) {
-		ERROR("Failed to remove phandle property of '%s' node\n",
-		       clk_path);
-		return ret;
-	}
-
-	return 0;
-}
-
-static int enable_scmi_clk_node(void *blob, uint32_t phandle)
-{
-	int nodeoff, ret;
-
-	nodeoff = fdt_path_offset(blob, "/firmware/scmi/protocol@14");
-	if (nodeoff < 0) {
-		ERROR("Failed to get offset of '/firmware/scmi/protocol@14' node\n");
-		return nodeoff;
-	}
-
-	ret = fdt_setprop_cell(blob, nodeoff, "phandle", phandle);
-	if (ret) {
-		ERROR("Failed to set phandle property of '/firmware/scmi/protocol@14' node\n");
-		return ret;
-	}
-
-	ret = fdt_setprop_string(blob, nodeoff, "status", "okay");
-	if (ret) {
-		ERROR("Failed to enable '/firmware/scmi/protocol@14' node\n");
-		return ret;
-	}
-
-	return 0;
-}
-
-static int enable_scmi_mbox(void *blob)
-{
-	int nodeoff, ret;
-
-	nodeoff = fdt_node_offset_by_compatible(blob, -1, "arm,scmi-smc");
-	if (nodeoff < 0) {
-		ERROR("Failed to get offset of 'arm,scmi-smc' node\n");
-		return nodeoff;
-	}
-
-	ret = fdt_setprop_string(blob, nodeoff, "status", "okay");
-	if (ret) {
-		ERROR("Failed to enable 'arm,scmi-smc' node\n");
-		return nodeoff;
-	}
-
-	return 0;
-}
-
-static int ft_fixup_scmi_clks(void *blob)
-{
-	uint32_t phandle;
-	int ret;
-
-	ret = disable_clk_node(blob, &phandle);
-	if (ret)
-		return ret;
-
-	ret = enable_scmi_clk_node(blob, phandle);
-	if (ret)
-		return ret;
-
-	ret = enable_scmi_mbox(blob);
-	if (ret)
-		return ret;
-
-	return 0;
-}
-
-#if (ERRATA_S32_050543 == 1 && S32G_EMU == 0)
-static int ft_fixup_ddr_errata(void *blob)
-{
-	int nodeoff, ret;
-
-	if (polling_needed != 1) {
-		return 0;
-	}
-
-	nodeoff = fdt_node_offset_by_compatible(blob, -1, "fsl,s32gen1-ddr-err050543");
-	if (nodeoff < 0) {
-		ERROR("Failed to get offset of 'fsl,s32gen1-ddr-err050543' node\n");
-		return nodeoff;
-	}
-
-	ret = fdt_setprop_string(blob, nodeoff, "status", "okay");
-	if (ret) {
-		ERROR("Failed to enable 'fsl,s32gen1-ddr-err050543' node\n");
-		return ret;
-	}
-
-	return 0;
-}
-#endif
-
-static int ft_fixup_resmem_node(void *blob)
-{
-	int ret;
-	char nodename[21];
-
-	snprintf(nodename, sizeof(nodename), "atf@%x", BL31_BASE);
-
-	ret = fdt_add_reserved_memory(blob, nodename, BL31_BASE, BL31_SIZE);
-	if (ret) {
-		ERROR("Failed to add 'atf' /reserved-memory node");
-		return ret;
-	}
-
-	return 0;
-}
-
-static int ft_fixups(void *blob)
-{
-	size_t size = fdt_totalsize(blob);
-	int ret;
-
-	size += S32G_FDT_UPDATES_SPACE;
-	fdt_set_totalsize(blob, size);
-
-	ret = ft_fixup_scmi_clks(blob);
-	if (ret)
-		goto out;
-
-#if (ERRATA_S32_050543 == 1 && S32G_EMU == 0)
-	ret = ft_fixup_ddr_errata(blob);
-	if (ret)
-		goto out;
-#endif
-
-	ret = ft_fixup_resmem_node(blob);
-
-out:
-	flush_dcache_range((uintptr_t)blob, size);
-	return ret;
-}
-
-static bool is_branch_op(uint32_t op)
-{
-	return (op & AARCH64_UNCOND_BRANCH_MASK) == AARCH64_UNCOND_BRANCH_OP;
-}
-
-/* Computes the size of the images inside FIP and updates image io_block spec.
- * Only FIP header was read from storage to SRAM so we can walk through all
- * fip_toc_entry_t entries until the last one.
- * For each images it is updated the real size and offset as read from the
- * FIP header.
- */
-static int set_fip_images_size(bl_mem_params_node_t *fip_params)
-{
-	static const uuid_t uuid_null = { {0} };
-	image_info_t *image_info = &fip_params->image_info;
-	char *buf = (char *)image_info->image_base;
-	char *buf_end = buf + image_info->image_size;
-	fip_toc_header_t *toc_header = (fip_toc_header_t *)buf;
-	fip_toc_entry_t *toc_entry = (fip_toc_entry_t *)(toc_header + 1);
-
-	while((char *)toc_entry < buf_end) {
-		if (compare_uuids(&toc_entry->uuid, &uuid_null) == 0)
-			break;
-
-		set_image_spec(&toc_entry->uuid, toc_entry->size,
-			       toc_entry->offset_address);
-		toc_entry++;
-	}
-
-	return 0;
-}
-
-int bl2_plat_handle_post_image_load(unsigned int image_id)
-{
-	uint32_t magic;
-	int ret;
-
-	bl_mem_params_node_t *bl_mem_params = NULL;
-	bl_mem_params_node_t *pager_mem_params = NULL;
-	bl_mem_params_node_t *paged_mem_params = NULL;
-
-	if (image_id == FIP_IMAGE_ID) {
-		bl_mem_params = get_bl_mem_params_node(image_id);
-		assert(bl_mem_params && "FIP params cannot be NULL");
-
-		set_fip_images_size(bl_mem_params);
-	}
-
-	if (image_id == BL33_IMAGE_ID) {
-		magic = mmio_read_32(BL33_ENTRYPOINT);
-		if (!is_branch_op(magic))
-			printf("Warning: Instruction at BL33_ENTRYPOINT"
-			       " is 0x%x, which is not a B or BL!\n",
-			       magic);
-
-		magic = mmio_read_32(BL33_DTB);
-		if (magic != BL33_DTB_MAGIC) {
-			printf("Error: Instruction at BL33_DTB is 0x%x"
-			       ", which is not the expected 0x%x!\n",
-			       magic, BL33_DTB_MAGIC);
-			return -EINVAL;
-		}
-
-		ret = ft_fixups((void *)BL33_DTB);
-		if (ret)
-			return ret;
-	}
-
-	if (image_id == BL32_IMAGE_ID) {
-		bl_mem_params = get_bl_mem_params_node(image_id);
-		assert(bl_mem_params && "bl_mem_params cannot be NULL");
-
-		pager_mem_params = get_bl_mem_params_node(BL32_EXTRA1_IMAGE_ID);
-		assert(pager_mem_params && "pager_mem_params cannot be NULL");
-
-		ret = parse_optee_header(&bl_mem_params->ep_info,
-					 &pager_mem_params->image_info,
-					 &paged_mem_params->image_info);
-		if (ret != 0) {
-			WARN("OPTEE header parse error.\n");
-			return ret;
-		}
-	}
-
-	return 0;
-}
-
 /**
  * Clear non-critical faults generated by SWT (software watchdog timer)
  * All SWT faults are placed in NCF_S1 (33-38)
diff --git a/plat/nxp/s32/s32g/s32g_common.mk b/plat/nxp/s32/s32g/s32g_common.mk
index 03afec5ec..9e45005ad 100644
--- a/plat/nxp/s32/s32g/s32g_common.mk
+++ b/plat/nxp/s32/s32g/s32g_common.mk
@@ -39,7 +39,6 @@ PLAT_BL_COMMON_SOURCES	+= \
 BL2_SOURCES		+= \
 			   plat/nxp/s32/s32g/s32g_bl2_el3.c \
 			   ${BL31SSRAM_SRC_DUMP} \
-			   lib/optee/optee_utils.c \
 
 BL31_SOURCES		+= plat/nxp/s32/s32g/s32g_bl31.c \
 			   plat/nxp/s32/s32g/s32g_psci.c \
-- 
2.17.1

