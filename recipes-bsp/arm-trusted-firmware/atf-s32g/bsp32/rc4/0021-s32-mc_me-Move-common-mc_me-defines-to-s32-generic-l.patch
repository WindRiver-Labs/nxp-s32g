From 27e829728fd4506463002995f168fb85ff58cc41 Mon Sep 17 00:00:00 2001
From: Andra-Teodora Ilie <andra.ilie@nxp.com>
Date: Tue, 23 Nov 2021 13:30:49 +0200
Subject: [PATCH 21/50] s32: mc_me: Move common mc_me defines to s32 generic
 layer

Issue: ALB-7411
Upstream-Status: Pending 

Signed-off-by: Andra-Teodora Ilie <andra.ilie@nxp.com>
Signed-off-by: Zhantao Tang <zhantao.tang@windriver.com>
---
 plat/nxp/s32/include/s32_mc_me.h              | 104 ++++++++++++++
 plat/nxp/s32/include/s32_platform_def.h       |   4 +-
 plat/nxp/s32/s32g/bl31_sram/bl31sram_main.c   |   2 +-
 plat/nxp/s32/s32g/bl31_ssram/ddr_clk.c        |   6 +-
 plat/nxp/s32/s32g/include/s32g_mc_me.h        |  97 +------------
 plat/nxp/s32/s32g/include/s32g_platform_def.h |   2 +-
 plat/nxp/s32/s32g/s32g2/platform.mk           |   2 +-
 plat/nxp/s32/s32g/s32g3/s32g3_mc_me.c         |  16 +--
 plat/nxp/s32/s32g/s32g_bl2_el3.c              |   2 +-
 plat/nxp/s32/s32g/s32g_bl31.c                 |   4 +-
 plat/nxp/s32/s32g/s32g_mc_me.c                | 132 +++++++++---------
 plat/nxp/s32/s32g/s32g_psci.c                 |   8 +-
 .../s32g2/s32g2_mc_me.c => s32gen1_mc_me.c}   |  13 +-
 13 files changed, 204 insertions(+), 188 deletions(-)
 create mode 100644 plat/nxp/s32/include/s32_mc_me.h
 rename plat/nxp/s32/{s32g/s32g2/s32g2_mc_me.c => s32gen1_mc_me.c} (75%)

diff --git a/plat/nxp/s32/include/s32_mc_me.h b/plat/nxp/s32/include/s32_mc_me.h
new file mode 100644
index 000000000..20afbd524
--- /dev/null
+++ b/plat/nxp/s32/include/s32_mc_me.h
@@ -0,0 +1,104 @@
+/*
+ * MC Mode Entry definitions for S32GEN1 and compatible SoCs
+ *
+ * Copyright 2021 NXP
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ */
+#ifndef __S32_MC_ME_H__
+#define __S32_MC_ME_H__
+
+#include "platform_def.h"
+
+#define S32_MC_ME_BASE_ADDR	0x40088000ul
+#define S32_MC_ME_SIZE		0x1000ul
+
+#define MC_ME_MODE_CONF		(S32_MC_ME_BASE_ADDR + 0x4)
+#define MC_ME_MODE_CONF_DRST	BIT(0)
+#define MC_ME_MODE_CONF_FRST	BIT(1)
+
+#define MC_ME_MODE_UPD		(S32_MC_ME_BASE_ADDR + 0x8)
+#define MC_ME_MODE_UPD_UPD	BIT(0)
+
+/* CTL_KEY register */
+#define S32_MC_ME_CTL_KEY  (S32_MC_ME_BASE_ADDR)
+#define S32_MC_ME_CTL_KEY_KEY		    0x00005AF0
+#define S32_MC_ME_CTL_KEY_INVERTEDKEY	0x0000A50F
+
+/* PRTNn registers */
+#define S32_MC_ME_PRTN_N_PCONF_OFF	0x0
+#define S32_MC_ME_PRTN_N_PUPD_OFF	0x4
+#define S32_MC_ME_PRTN_N_STAT_OFF	0x8
+
+#define S32_MC_ME_PRTN_N_BASE(n) \
+	(S32_MC_ME_BASE_ADDR + 0x100ul + (n) * 0x200ul)
+#define S32_MC_ME_PRTN_N_PCONF(n) \
+	(S32_MC_ME_PRTN_N_BASE(n) + S32_MC_ME_PRTN_N_PCONF_OFF)
+#define S32_MC_ME_PRTN_N_PUPD(n) \
+	(S32_MC_ME_PRTN_N_BASE(n) + S32_MC_ME_PRTN_N_PUPD_OFF)
+#define S32_MC_ME_PRTN_N_STAT(n) \
+	(S32_MC_ME_PRTN_N_BASE(n) + S32_MC_ME_PRTN_N_STAT_OFF)
+
+/* COFB0 */
+#define S32_MC_ME_PRTN_N_COFB0_STAT(n) \
+	(S32_MC_ME_PRTN_N_BASE(n) + 0x10)
+#define S32_MC_ME_PRTN_N_COFB0_CLKEN(n) \
+	(S32_MC_ME_PRTN_N_BASE(n) + 0x30)
+
+#define S32_MC_ME_PRTN_N_PCONF_PCE_MASK     BIT(0)
+#define S32_MC_ME_PRTN_N_PCONF_OSSE_MASK	BIT(2)
+#define S32_MC_ME_PRTN_N_PUPD_PCUD_MASK     BIT(0)
+#define S32_MC_ME_PRTN_N_PUPD_OSSUD_MASK	BIT(2)
+#define S32_MC_ME_PRTN_N_REQ(n)             BIT(n)
+
+/* PRTNn_COREm registers */
+#define MC_ME_PRTN_PART(n, m) \
+	(S32_MC_ME_BASE_ADDR + 0x140ul + (n) * 0x200ul + \
+	 (m) * 0x20ul)
+#define S32_MC_ME_PRTN_N_CORE_M_BASE(n, m) \
+	MC_ME_PRTN_PART(n, mc_me_core2prtn_core_id((n), (m)))
+#define S32_MC_ME_PRTN_N_CORE_M_ADDR(n, m) \
+	(S32_MC_ME_PRTN_N_CORE_M_BASE(n, m) + 0xc)
+#define S32_MC_ME_PRTN_N_CORE_M_PCONF(n, m) \
+	(S32_MC_ME_PRTN_N_CORE_M_BASE(n, m) + S32_MC_ME_PRTN_N_PCONF_OFF)
+#define S32_MC_ME_PRTN_N_CORE_M_PUPD(n, m) \
+	(S32_MC_ME_PRTN_N_CORE_M_BASE(n, m) + S32_MC_ME_PRTN_N_PUPD_OFF)
+#define S32_MC_ME_PRTN_N_CORE_M_STAT(n, m) \
+	(S32_MC_ME_PRTN_N_CORE_M_BASE(n, m) + S32_MC_ME_PRTN_N_STAT_OFF)
+#define S32_MC_ME_PRTN_N_CORE_M_PCONF_CCE_MASK		0x1ul
+#define S32_MC_ME_PRTN_N_CORE_M_PUPD_CCUPD_MASK	0x1ul
+#define S32_MC_ME_PRTN_N_CORE_M_STAT_CCS_MASK		BIT(0)
+#define S32_MC_ME_PRTN_N_CORE_M_STAT_WFI_MASK		BIT(31)
+
+/* PRTNn_COFBm registers */
+#define S32_MC_ME_PRTN_N_COFB_0_CLKEN(n) \
+	(S32_MC_ME_PRTN_N_BASE(n) + 0x30)
+
+enum s32_mc_me_part_no {
+	S32_MC_ME_PRTN0 = 0,
+	S32_MC_ME_PRTN1,
+	S32_MC_ME_PRTN2,
+	S32_MC_ME_PRTN3,
+};
+#define S32_MC_ME_CA53_PART     S32_MC_ME_PRTN1
+#define S32_MC_ME_CM7_PART		S32_MC_ME_PRTN0
+#define S32_MC_ME_DDR_0_PART	S32_MC_ME_PRTN0
+#define S32_MC_ME_USDHC_PART	S32_MC_ME_PRTN0
+
+#define S32_MC_ME_DDR_0_REQ	1
+#define S32_MC_ME_USDHC_REQ	0
+
+struct a53_haddr_mapping {
+	uint32_t reg; /** GPR register offset */
+	uint32_t field_off; /** Field offset */
+};
+
+void s32_turn_off_mcores(void);
+void s32_turn_off_core(uint8_t part, uint8_t core);
+const struct a53_haddr_mapping *s32_get_a53_haddr_mappings(size_t *size);
+
+uint8_t mc_me_core2prtn_core_id(uint8_t part, uint8_t id);
+uint32_t mc_me_get_cluster_ptrn(uint32_t core);
+
+#endif /* __S32_MC_ME_H__ */
+
diff --git a/plat/nxp/s32/include/s32_platform_def.h b/plat/nxp/s32/include/s32_platform_def.h
index cd670ead2..7b9c5f007 100644
--- a/plat/nxp/s32/include/s32_platform_def.h
+++ b/plat/nxp/s32/include/s32_platform_def.h
@@ -51,6 +51,8 @@
  */
 #define COUNTER_FREQUENCY	    0x004C4B40
 
+#define SIUL2_0_BASE_ADDR		0x4009C000UL
+
 #define GPR_BASE_ADDR		0x4007C400UL
 #define GPR06_OFF			0x18U
 #define GPR09_OFF			0x24U
@@ -148,7 +150,5 @@
 #define S32_UART_SIZE		S32_LINFLEX0_SIZE
 #endif
 
-#define SIUL2_0_BASE_ADDR	0x4009C000UL
-
 #endif /* S32_PLATFORM_H */
 
diff --git a/plat/nxp/s32/s32g/bl31_sram/bl31sram_main.c b/plat/nxp/s32/s32g/bl31_sram/bl31sram_main.c
index d1c361ed6..82a438114 100644
--- a/plat/nxp/s32/s32g/bl31_sram/bl31sram_main.c
+++ b/plat/nxp/s32/s32g/bl31_sram/bl31sram_main.c
@@ -13,7 +13,7 @@
 
 static void disable_ddr_clk(void)
 {
-	s32g_disable_cofb_clk(S32G_MC_ME_USDHC_PART, 0);
+	s32g_disable_cofb_clk(S32_MC_ME_USDHC_PART, 0);
 	s32g_ddr2firc();
 	s32g_disable_pll(S32_DDR_PLL, 1);
 }
diff --git a/plat/nxp/s32/s32g/bl31_ssram/ddr_clk.c b/plat/nxp/s32/s32g/bl31_ssram/ddr_clk.c
index 5641f882f..3c79dc695 100644
--- a/plat/nxp/s32/s32g/bl31_ssram/ddr_clk.c
+++ b/plat/nxp/s32/s32g/bl31_ssram/ddr_clk.c
@@ -173,9 +173,9 @@ void s32g_plat_ddr_clock_init(void)
 	       s32g_pll_phi_nr[S32_DDR_PLL]);
 
 	start_fxosc();
-	mc_me_enable_partition(S32G_MC_ME_PRTN0);
-	mc_me_enable_partition_block(S32G_MC_ME_DDR_0_PART,
-				     S32G_MC_ME_DDR_0_REQ);
+	mc_me_enable_partition(S32_MC_ME_PRTN0);
+	mc_me_enable_partition_block(S32_MC_ME_DDR_0_PART,
+				     S32_MC_ME_DDR_0_REQ);
 	program_pll(S32_DDR_PLL, S32G_REFCLK_FXOSC, s32g_ddr_pll_phi_freq,
 		    s32g_pll_rdiv[S32_DDR_PLL], s32g_pll_mfi[S32_DDR_PLL],
 		    s32g_pll_mfn[S32_DDR_PLL]);
diff --git a/plat/nxp/s32/s32g/include/s32g_mc_me.h b/plat/nxp/s32/s32g/include/s32g_mc_me.h
index cd075a042..ae0122579 100644
--- a/plat/nxp/s32/s32g/include/s32g_mc_me.h
+++ b/plat/nxp/s32/s32g/include/s32g_mc_me.h
@@ -8,120 +8,33 @@
 #ifndef __S32G_MC_ME_H__
 #define __S32G_MC_ME_H__
 
-#include "platform_def.h"
+#include "s32_mc_me.h"
 
-
-#define S32G_MC_ME_BASE_ADDR	0x40088000ul
-#define S32G_MC_ME_SIZE		0x1000ul
-
-#define MC_ME_MODE_CONF		(S32G_MC_ME_BASE_ADDR + 0x4)
-#define MC_ME_MODE_CONF_DRST	BIT(0)
-#define MC_ME_MODE_CONF_FRST	BIT(1)
 #define MC_ME_MODE_CONF_STANDBY	BIT(15)
 
-#define MC_ME_MODE_UPD		(S32G_MC_ME_BASE_ADDR + 0x8)
-#define MC_ME_MODE_UPD_UPD	BIT(0)
-
-#define MC_ME_MODE_STAT		(S32G_MC_ME_BASE_ADDR + 0xc)
+#define MC_ME_MODE_STAT		(S32_MC_ME_BASE_ADDR + 0xc)
 #define MODE_STAT_PREV_MODE	BIT(0)
 
-#define MC_ME_MAIN_COREID	(S32G_MC_ME_BASE_ADDR + 0x10)
+#define MC_ME_MAIN_COREID	(S32_MC_ME_BASE_ADDR + 0x10)
 #define MC_ME_COREID_PIDX(n)	((n) << 8)
 #define MC_ME_COREID_CIDX(n)	((n) << 0)
 
-#define S32G_MC_ME_PRIMARY_CORE_MASK	((1ul << S32G_PLAT_PRIMARY_CPU) & 0xF)
+#define S32G_MC_ME_PRIMARY_CORE_MASK	((1ul << S32_PLAT_PRIMARY_CPU) & 0xF)
 #define S32G_MC_ME_SECONDARY_CORE_MASK	(~S32G_MC_ME_PRIMARY_CORE_MASK & 0xF)
 
-/* CTL_KEY register */
-#define S32G_MC_ME_CTL_KEY		(S32G_MC_ME_BASE_ADDR)
-#define S32G_MC_ME_CTL_KEY_KEY		0x00005AF0
-#define S32G_MC_ME_CTL_KEY_INVERTEDKEY	0x0000A50F
-
-/* PRTNn registers */
-#define S32G_MC_ME_PRTN_N_PCONF_OFF	0x0
-#define S32G_MC_ME_PRTN_N_PUPD_OFF	0x4
-#define S32G_MC_ME_PRTN_N_STAT_OFF	0x8
-
-#define S32G_MC_ME_PRTN_N_BASE(n) \
-	(S32G_MC_ME_BASE_ADDR + 0x100 + (n) * 0x200)
-#define S32G_MC_ME_PRTN_N_PCONF(n) \
-	(S32G_MC_ME_PRTN_N_BASE(n) + S32G_MC_ME_PRTN_N_PCONF_OFF)
-#define S32G_MC_ME_PRTN_N_PUPD(n) \
-	(S32G_MC_ME_PRTN_N_BASE(n) + S32G_MC_ME_PRTN_N_PUPD_OFF)
-#define S32G_MC_ME_PRTN_N_STAT(n) \
-	(S32G_MC_ME_PRTN_N_BASE(n) + S32G_MC_ME_PRTN_N_STAT_OFF)
-
-/* COFB0 */
-#define S32G_MC_ME_PRTN_N_COFB0_STAT(n) \
-	(S32G_MC_ME_PRTN_N_BASE(n) + 0x10)
-#define S32G_MC_ME_PRTN_N_COFB0_CLKEN(n) \
-	(S32G_MC_ME_PRTN_N_BASE(n) + 0x30)
-
-#define S32G_MC_ME_PRTN_N_PCONF_PCE_MASK	BIT(0)
-#define S32G_MC_ME_PRTN_N_PCONF_OSSE_MASK	BIT(2)
-#define S32G_MC_ME_PRTN_N_PUPD_PCUD_MASK	BIT(0)
-#define S32G_MC_ME_PRTN_N_PUPD_OSSUD_MASK	BIT(2)
-#define S32G_MC_ME_PRTN_N_REQ(n)		BIT(n)
-
-/* PRTNn_COREm registers */
-#define MC_ME_PRTN_PART(n, m) \
-	(S32G_MC_ME_BASE_ADDR + 0x140 + (n) * 0x200 + \
-	 (m) * 0x20)
-#define S32G_MC_ME_PRTN_N_CORE_M_BASE(n, m) \
-	MC_ME_PRTN_PART(n, mc_me_core2prtn_core_id((n), (m)))
-#define S32G_MC_ME_PRTN_N_CORE_M_ADDR(n, m) \
-	(S32G_MC_ME_PRTN_N_CORE_M_BASE(n, m) + 0xc)
-#define S32G_MC_ME_PRTN_N_CORE_M_PCONF(n, m) \
-	(S32G_MC_ME_PRTN_N_CORE_M_BASE(n, m) + S32G_MC_ME_PRTN_N_PCONF_OFF)
-#define S32G_MC_ME_PRTN_N_CORE_M_PUPD(n, m) \
-	(S32G_MC_ME_PRTN_N_CORE_M_BASE(n, m) + S32G_MC_ME_PRTN_N_PUPD_OFF)
-#define S32G_MC_ME_PRTN_N_CORE_M_STAT(n, m) \
-	(S32G_MC_ME_PRTN_N_CORE_M_BASE(n, m) + S32G_MC_ME_PRTN_N_STAT_OFF)
-#define S32G_MC_ME_PRTN_N_CORE_M_PCONF_CCE_MASK		0x1ul
-#define S32G_MC_ME_PRTN_N_CORE_M_PUPD_CCUPD_MASK	0x1ul
-#define S32G_MC_ME_PRTN_N_CORE_M_STAT_CCS_MASK		BIT(0)
-#define S32G_MC_ME_PRTN_N_CORE_M_STAT_WFI_MASK		BIT(31)
-
-/* PRTNn_COFBm registers */
-#define S32G_MC_ME_PRTN_N_COFB_0_CLKEN(n) \
-	(S32G_MC_ME_PRTN_N_BASE(n) + 0x30)
-
-enum s32g_mc_me_part_no {
-	S32G_MC_ME_PRTN0 = 0,
-	S32G_MC_ME_PRTN1,
-	S32G_MC_ME_PRTN2,
-	S32G_MC_ME_PRTN3,
-};
-#define S32G_MC_ME_CA53_PART	S32G_MC_ME_PRTN1
-#define S32G_MC_ME_CM7_PART	S32G_MC_ME_PRTN0
-#define S32G_MC_ME_DDR_0_PART	S32G_MC_ME_PRTN0
-#define S32G_MC_ME_USDHC_PART	S32G_MC_ME_PRTN0
-#define S32G_MC_ME_PFE_PART	S32G_MC_ME_PRTN2
-
-#define S32G_MC_ME_DDR_0_REQ	1
-#define S32G_MC_ME_USDHC_REQ	0
+#define S32G_MC_ME_PFE_PART	S32_MC_ME_PRTN2
 
 /* Standby master core: A53, cluster 0, core 0*/
 #define S32G_STBY_MASTER_CORE	0
 #define S32G_STBY_MASTER_PART	1
 
-struct a53_haddr_mapping {
-	uint32_t reg; /** GPR register offset */
-	uint32_t field_off; /** Field offset */
-};
-
 bool s32g_core_in_reset(uint32_t core);
 void s32g_kick_secondary_ca53_core(uint32_t core, uintptr_t entrypoint);
-void s32g_turn_off_core(uint8_t part, uint8_t core);
-void s32g_turn_off_mcores(void);
 void s32g_reset_core(uint8_t part, uint8_t core);
 void s32g_disable_cofb_clk(uint8_t part, uint32_t keep_blocks);
 void s32g_set_stby_master_core(uint8_t part, uint8_t core);
-const struct a53_haddr_mapping *s32g_get_a53_haddr_mappings(size_t *size);
 void mc_me_enable_partition_block(uint32_t part, uint32_t block);
 void mc_me_enable_partition(uint32_t part);
-uint8_t mc_me_core2prtn_core_id(uint8_t part, uint8_t id);
-uint32_t mc_me_get_cluster_ptrn(uint32_t core);
 
 void s32g_destructive_reset(void);
 
diff --git a/plat/nxp/s32/s32g/include/s32g_platform_def.h b/plat/nxp/s32/s32g/include/s32g_platform_def.h
index eb56a3cda..fce50af75 100644
--- a/plat/nxp/s32/s32g/include/s32g_platform_def.h
+++ b/plat/nxp/s32/s32g/include/s32g_platform_def.h
@@ -83,7 +83,7 @@
 #pragma warning "BL33 image is being built; you should configure it out."
 #endif
 
-#define S32G_SCMI_SHARED_MEM		0xd0000000U
+#define S32G_SCMI_SHARED_MEM			0xd0000000U
 #define S32G_SCMI_SHARED_MEM_SIZE	0x400000U
 
 #define S32G_QSPI_BASE		(0x40134000ul)
diff --git a/plat/nxp/s32/s32g/s32g2/platform.mk b/plat/nxp/s32/s32g/s32g2/platform.mk
index 6084c8e2b..579320b95 100644
--- a/plat/nxp/s32/s32g/s32g2/platform.mk
+++ b/plat/nxp/s32/s32g/s32g2/platform.mk
@@ -15,7 +15,7 @@ include plat/nxp/s32/s32g/s32g_common.mk
 PLAT_INCLUDES		+= -Iplat/nxp/s32/s32g/s32g2/include \
 
 PLAT_BL_COMMON_SOURCES	+= drivers/nxp/s32/clk/s32g274a_clk.c \
-			   plat/nxp/s32/s32g/s32g2/s32g2_mc_me.c \
+			   plat/nxp/s32/s32gen1_mc_me.c \
 			   plat/nxp/s32/s32g/s32g2/s32g2_mc_rgm.c \
 			   plat/nxp/s32/s32gen1_sramc.c \
 			   plat/nxp/s32/s32g/s32g2/s32g2_vr5510.c \
diff --git a/plat/nxp/s32/s32g/s32g3/s32g3_mc_me.c b/plat/nxp/s32/s32g/s32g3/s32g3_mc_me.c
index cb429f6f4..0b82bce5c 100644
--- a/plat/nxp/s32/s32g/s32g3/s32g3_mc_me.c
+++ b/plat/nxp/s32/s32g/s32g3/s32g3_mc_me.c
@@ -18,7 +18,7 @@ static const struct a53_haddr_mapping haddr_map[] = {
 	[7] = { .reg = GPR36_OFF, .field_off = CA53_1_3_RVBARADDR_39_32_OFF, },
 };
 
-const struct a53_haddr_mapping *s32g_get_a53_haddr_mappings(size_t *size)
+const struct a53_haddr_mapping *s32_get_a53_haddr_mappings(size_t *size)
 {
 	*size = ARRAY_SIZE(haddr_map);
 	return &haddr_map[0];
@@ -58,18 +58,18 @@ uint8_t mc_me_core2prtn_core_id(uint8_t part, uint8_t id)
 		[3] = 4,
 	};
 
-	if (part == S32G_MC_ME_CA53_PART)
+	if (part == S32_MC_ME_CA53_PART)
 		return mc_me_a53_core_id[id];
 
 	return mc_me_m7_core_id[id];
 }
 
-void s32g_turn_off_mcores(void)
+void s32_turn_off_mcores(void)
 {
-	s32g_turn_off_core(S32G_MC_ME_CM7_PART, 3);
-	s32g_turn_off_core(S32G_MC_ME_CM7_PART, 2);
-	s32g_turn_off_core(S32G_MC_ME_CM7_PART, 1);
-	s32g_turn_off_core(S32G_MC_ME_CM7_PART, 0);
+	s32_turn_off_core(S32_MC_ME_CM7_PART, 3);
+	s32_turn_off_core(S32_MC_ME_CM7_PART, 2);
+	s32_turn_off_core(S32_MC_ME_CM7_PART, 1);
+	s32_turn_off_core(S32_MC_ME_CM7_PART, 0);
 }
 
 uint32_t mc_me_get_cluster_ptrn(uint32_t core)
@@ -79,6 +79,6 @@ uint32_t mc_me_get_cluster_ptrn(uint32_t core)
 	 *     MC_ME_PRTN1_CORE0_* -> CA53 cluster0 core0/1/2/3
 	 *     MC_ME_PRTN1_CORE2_* -> CA53 cluster1 core0/1/2/3
 	 */
-	return mc_me_core2prtn_core_id(S32G_MC_ME_CA53_PART, core) & 2;
+	return mc_me_core2prtn_core_id(S32_MC_ME_CA53_PART, core) & 2;
 }
 
diff --git a/plat/nxp/s32/s32g/s32g_bl2_el3.c b/plat/nxp/s32/s32g/s32g_bl2_el3.c
index fff4a265a..f7e3c4518 100644
--- a/plat/nxp/s32/s32g/s32g_bl2_el3.c
+++ b/plat/nxp/s32/s32g/s32g_bl2_el3.c
@@ -534,7 +534,7 @@ static mmap_region_t s32g_mmap[] = {
 			 MT_MEMORY | MT_RW | MT_SECURE),
 	MAP_REGION_FLAT(S32_UART_BASE, S32_UART_SIZE,
 			MT_DEVICE | MT_RW | MT_NS),
-	MAP_REGION_FLAT(S32G_MC_ME_BASE_ADDR, S32G_MC_ME_SIZE,
+	MAP_REGION_FLAT(S32_MC_ME_BASE_ADDR, S32_MC_ME_SIZE,
 			MT_DEVICE | MT_RW),
 	MAP_REGION_FLAT(MC_CGM0_BASE_ADDR,
 			MMU_ROUND_UP_TO_4K(S32_DFS_ADDR(S32_DFS_NR)),
diff --git a/plat/nxp/s32/s32g/s32g_bl31.c b/plat/nxp/s32/s32g/s32g_bl31.c
index f30cbba12..890f2b5a7 100644
--- a/plat/nxp/s32/s32g/s32g_bl31.c
+++ b/plat/nxp/s32/s32g/s32g_bl31.c
@@ -46,7 +46,7 @@ static const mmap_region_t s32g_mmap[] = {
 			MT_DEVICE | MT_RW | MT_NS),
 	MAP_REGION_FLAT(S32GEN1_GIC_BASE, S32GEN1_GIC_SIZE,
 			MT_DEVICE | MT_RW),
-	MAP_REGION_FLAT(S32G_MC_ME_BASE_ADDR, S32G_MC_ME_SIZE,
+	MAP_REGION_FLAT(S32_MC_ME_BASE_ADDR, S32_MC_ME_SIZE,
 			MT_DEVICE | MT_RW),
 	MAP_REGION_FLAT(MC_CGM0_BASE_ADDR,
 			MMU_ROUND_UP_TO_4K(S32_DFS_ADDR(S32_DFS_NR)),
@@ -188,7 +188,7 @@ void bl31_early_platform_setup2(u_register_t arg0, u_register_t arg1,
 #ifdef SPD_opteed
 	SET_PARAM_HEAD(&bl32_image_ep_info, PARAM_EP, VERSION_2, 0);
 	SET_SECURITY_STATE(bl32_image_ep_info.h.attr, SECURE);
-	bl32_image_ep_info.pc = S32G_BL32_BASE;
+	bl32_image_ep_info.pc = S32_BL32_BASE;
 	bl32_image_ep_info.spsr = 0;
 	bl32_image_ep_info.args.arg0 = MODE_RW_64;
 	bl32_image_ep_info.args.arg3 = BL33_DTB;
diff --git a/plat/nxp/s32/s32g/s32g_mc_me.c b/plat/nxp/s32/s32g/s32g_mc_me.c
index 17e9bda25..1546a9d9c 100644
--- a/plat/nxp/s32/s32g/s32g_mc_me.c
+++ b/plat/nxp/s32/s32g/s32g_mc_me.c
@@ -12,8 +12,8 @@
 /* Apply changes to MC_ME partitions */
 static void mc_me_apply_hw_changes(void)
 {
-	mmio_write_32(S32G_MC_ME_CTL_KEY, S32G_MC_ME_CTL_KEY_KEY);
-	mmio_write_32(S32G_MC_ME_CTL_KEY, S32G_MC_ME_CTL_KEY_INVERTEDKEY);
+	mmio_write_32(S32_MC_ME_CTL_KEY, S32_MC_ME_CTL_KEY_KEY);
+	mmio_write_32(S32_MC_ME_CTL_KEY, S32_MC_ME_CTL_KEY_INVERTEDKEY);
 }
 
 /*
@@ -26,7 +26,7 @@ static void mc_me_part_core_addr_write(uintptr_t addr, uint32_t part,
 	uint32_t addr_lo;
 
 	addr_lo = (uint32_t)(addr & 0xFFFFFFFC);
-	mmio_write_32(S32G_MC_ME_PRTN_N_CORE_M_ADDR(part, core), addr_lo);
+	mmio_write_32(S32_MC_ME_PRTN_N_CORE_M_ADDR(part, core), addr_lo);
 }
 
 static void mc_me_part_core_pconf_write_cce(uint32_t cce_bit, uint32_t p,
@@ -34,10 +34,10 @@ static void mc_me_part_core_pconf_write_cce(uint32_t cce_bit, uint32_t p,
 {
 	uint32_t pconf;
 
-	pconf = mmio_read_32(S32G_MC_ME_PRTN_N_CORE_M_PCONF(p, c)) &
-			~S32G_MC_ME_PRTN_N_CORE_M_PCONF_CCE_MASK;
-	pconf |= (cce_bit & S32G_MC_ME_PRTN_N_CORE_M_PCONF_CCE_MASK);
-	mmio_write_32(S32G_MC_ME_PRTN_N_CORE_M_PCONF(p, c), pconf);
+	pconf = mmio_read_32(S32_MC_ME_PRTN_N_CORE_M_PCONF(p, c)) &
+			~S32_MC_ME_PRTN_N_CORE_M_PCONF_CCE_MASK;
+	pconf |= (cce_bit & S32_MC_ME_PRTN_N_CORE_M_PCONF_CCE_MASK);
+	mmio_write_32(S32_MC_ME_PRTN_N_CORE_M_PCONF(p, c), pconf);
 }
 
 static void mc_me_part_core_pupd_write_ccupd(uint32_t ccupd_bit, uint32_t p,
@@ -45,10 +45,10 @@ static void mc_me_part_core_pupd_write_ccupd(uint32_t ccupd_bit, uint32_t p,
 {
 	uint32_t pupd;
 
-	pupd = mmio_read_32(S32G_MC_ME_PRTN_N_CORE_M_PUPD(p, c)) &
-			~S32G_MC_ME_PRTN_N_CORE_M_PUPD_CCUPD_MASK;
-	pupd |= (ccupd_bit & S32G_MC_ME_PRTN_N_CORE_M_PUPD_CCUPD_MASK);
-	mmio_write_32(S32G_MC_ME_PRTN_N_CORE_M_PUPD(p, c), pupd);
+	pupd = mmio_read_32(S32_MC_ME_PRTN_N_CORE_M_PUPD(p, c)) &
+			~S32_MC_ME_PRTN_N_CORE_M_PUPD_CCUPD_MASK;
+	pupd |= (ccupd_bit & S32_MC_ME_PRTN_N_CORE_M_PUPD_CCUPD_MASK);
+	mmio_write_32(S32_MC_ME_PRTN_N_CORE_M_PUPD(p, c), pupd);
 }
 
 /*
@@ -59,46 +59,46 @@ static void mc_me_part_pconf_write_pce(uint32_t pce_bit, uint32_t p)
 {
 	uint32_t pconf;
 
-	pconf = mmio_read_32(S32G_MC_ME_PRTN_N_PCONF(p)) &
-			~S32G_MC_ME_PRTN_N_PCONF_PCE_MASK;
-	pconf |= (pce_bit & S32G_MC_ME_PRTN_N_PCONF_PCE_MASK);
-	mmio_write_32(S32G_MC_ME_PRTN_N_PCONF(p), pconf);
+	pconf = mmio_read_32(S32_MC_ME_PRTN_N_PCONF(p)) &
+			~S32_MC_ME_PRTN_N_PCONF_PCE_MASK;
+	pconf |= (pce_bit & S32_MC_ME_PRTN_N_PCONF_PCE_MASK);
+	mmio_write_32(S32_MC_ME_PRTN_N_PCONF(p), pconf);
 }
 
 static void mc_me_part_pconf_write_osse(uint32_t osse_bit, uint32_t p)
 {
 	uint32_t pconf;
 
-	pconf = mmio_read_32(S32G_MC_ME_PRTN_N_PCONF(p)) &
-			~S32G_MC_ME_PRTN_N_PCONF_OSSE_MASK;
-	pconf |= (osse_bit & S32G_MC_ME_PRTN_N_PCONF_OSSE_MASK);
-	mmio_write_32(S32G_MC_ME_PRTN_N_PCONF(p), pconf);
+	pconf = mmio_read_32(S32_MC_ME_PRTN_N_PCONF(p)) &
+			~S32_MC_ME_PRTN_N_PCONF_OSSE_MASK;
+	pconf |= (osse_bit & S32_MC_ME_PRTN_N_PCONF_OSSE_MASK);
+	mmio_write_32(S32_MC_ME_PRTN_N_PCONF(p), pconf);
 }
 
 static void mc_me_part_pupd_write_pcud(uint32_t pcud_bit, uint32_t p)
 {
 	uint32_t pupd;
 
-	pupd = mmio_read_32(S32G_MC_ME_PRTN_N_PUPD(p)) &
-			~S32G_MC_ME_PRTN_N_PUPD_PCUD_MASK;
-	pupd |= (pcud_bit & S32G_MC_ME_PRTN_N_PUPD_PCUD_MASK);
-	mmio_write_32(S32G_MC_ME_PRTN_N_PUPD(p), pupd);
+	pupd = mmio_read_32(S32_MC_ME_PRTN_N_PUPD(p)) &
+			~S32_MC_ME_PRTN_N_PUPD_PCUD_MASK;
+	pupd |= (pcud_bit & S32_MC_ME_PRTN_N_PUPD_PCUD_MASK);
+	mmio_write_32(S32_MC_ME_PRTN_N_PUPD(p), pupd);
 }
 
 static void mc_me_part_pupd_update_and_wait(uint32_t mask, uint32_t p)
 {
 	uint32_t pupd, pconf, stat;
 
-	pupd = mmio_read_32(S32G_MC_ME_PRTN_N_PUPD(p));
+	pupd = mmio_read_32(S32_MC_ME_PRTN_N_PUPD(p));
 	pupd |= mask;
-	mmio_write_32(S32G_MC_ME_PRTN_N_PUPD(p), pupd);
+	mmio_write_32(S32_MC_ME_PRTN_N_PUPD(p), pupd);
 
 	mc_me_apply_hw_changes();
 
 	/* wait for the updates to apply */
-	pconf = mmio_read_32(S32G_MC_ME_PRTN_N_PCONF(p));
+	pconf = mmio_read_32(S32_MC_ME_PRTN_N_PCONF(p));
 	do {
-		stat = mmio_read_32(S32G_MC_ME_PRTN_N_STAT(p));
+		stat = mmio_read_32(S32_MC_ME_PRTN_N_STAT(p));
 	} while ((stat & mask) != (pconf & mask));
 }
 
@@ -111,9 +111,9 @@ static void mc_me_part_cofb_clken_write_req(uint32_t req, uint32_t val,
 {
 	uint32_t clken;
 
-	clken = mmio_read_32(S32G_MC_ME_PRTN_N_COFB_0_CLKEN(part));
+	clken = mmio_read_32(S32_MC_ME_PRTN_N_COFB_0_CLKEN(part));
 	clken |= ((val & 0x1) << req);
-	mmio_write_32(S32G_MC_ME_PRTN_N_COFB_0_CLKEN(part), clken);
+	mmio_write_32(S32_MC_ME_PRTN_N_COFB_0_CLKEN(part), clken);
 }
 
 /*
@@ -131,8 +131,8 @@ void mc_me_enable_partition(uint32_t part)
 	if (part == 0)
 		return;
 
-	mc_me_part_pconf_write_pce(S32G_MC_ME_PRTN_N_PCONF_PCE_MASK, part);
-	mc_me_part_pupd_update_and_wait(S32G_MC_ME_PRTN_N_PUPD_PCUD_MASK, part);
+	mc_me_part_pconf_write_pce(S32_MC_ME_PRTN_N_PCONF_PCE_MASK, part);
+	mc_me_part_pupd_update_and_wait(S32_MC_ME_PRTN_N_PUPD_PCUD_MASK, part);
 
 	/* Unlock RDC register write */
 	mmio_write_32(RDC_RD_CTRL(part), RDC_CTRL_UNLOCK);
@@ -150,7 +150,7 @@ void mc_me_enable_partition(uint32_t part)
 	/* Clear OSSE bit */
 	mc_me_part_pconf_write_osse(0, part);
 
-	mc_me_part_pupd_update_and_wait(S32G_MC_ME_PRTN_N_PUPD_OSSUD_MASK,
+	mc_me_part_pupd_update_and_wait(S32_MC_ME_PRTN_N_PUPD_OSSUD_MASK,
 					part);
 	while (mmio_read_32(S32G_MC_RGM_PSTAT(part)) &
 			    MC_RGM_STAT_PERIPH_N_STAT(0))
@@ -170,7 +170,7 @@ void mc_me_enable_partition(uint32_t part)
 void mc_me_enable_partition_block(uint32_t part, uint32_t block)
 {
 	mc_me_part_cofb_clken_write_req(block, 1, part);
-	mc_me_part_pupd_update_and_wait(S32G_MC_ME_PRTN_N_PUPD_PCUD_MASK, part);
+	mc_me_part_pupd_update_and_wait(S32_MC_ME_PRTN_N_PUPD_PCUD_MASK, part);
 }
 
 bool s32g_core_in_reset(uint32_t core)
@@ -186,38 +186,38 @@ static bool s32g_core_clock_running(uint32_t part, uint32_t core)
 {
 	uint32_t stat;
 
-	stat = mmio_read_32(S32G_MC_ME_PRTN_N_CORE_M_STAT(part, core));
-	return ((stat & S32G_MC_ME_PRTN_N_CORE_M_STAT_CCS_MASK) != 0);
+	stat = mmio_read_32(S32_MC_ME_PRTN_N_CORE_M_STAT(part, core));
+	return ((stat & S32_MC_ME_PRTN_N_CORE_M_STAT_CCS_MASK) != 0);
 }
 
 static void enable_a53_partition(void)
 {
 	uint32_t pconf;
 
-	pconf = mmio_read_32(S32G_MC_ME_PRTN_N_STAT(S32G_MC_ME_CA53_PART));
+	pconf = mmio_read_32(S32_MC_ME_PRTN_N_STAT(S32_MC_ME_CA53_PART));
 
 	/* Already enabled */
-	if (pconf & S32G_MC_ME_PRTN_N_PCONF_PCE_MASK)
+	if (pconf & S32_MC_ME_PRTN_N_PCONF_PCE_MASK)
 		return;
 
-	mc_me_part_pconf_write_pce(S32G_MC_ME_PRTN_N_PCONF_PCE_MASK,
-				   S32G_MC_ME_CA53_PART);
-	mc_me_part_pupd_write_pcud(S32G_MC_ME_PRTN_N_PUPD_PCUD_MASK,
-				   S32G_MC_ME_CA53_PART);
+	mc_me_part_pconf_write_pce(S32_MC_ME_PRTN_N_PCONF_PCE_MASK,
+				   S32_MC_ME_CA53_PART);
+	mc_me_part_pupd_write_pcud(S32_MC_ME_PRTN_N_PUPD_PCUD_MASK,
+				   S32_MC_ME_CA53_PART);
 	mc_me_apply_hw_changes();
 }
 
 static void enable_a53_core_cluster(uint32_t core)
 {
 	uint32_t pconf_cluster = mc_me_get_cluster_ptrn(core);
-	uint32_t stat, part = S32G_MC_ME_CA53_PART;
+	uint32_t stat, part = S32_MC_ME_CA53_PART;
 	uint64_t addr;
 
 	addr = MC_ME_PRTN_PART(part, pconf_cluster) +
-	    S32G_MC_ME_PRTN_N_STAT_OFF;
+	    S32_MC_ME_PRTN_N_STAT_OFF;
 	stat = mmio_read_32(addr);
 
-	if (stat & S32G_MC_ME_PRTN_N_CORE_M_STAT_CCS_MASK)
+	if (stat & S32_MC_ME_PRTN_N_CORE_M_STAT_CCS_MASK)
 		return;
 
 	/* When in performance (i.e., not in lockstep) mode, the following
@@ -227,22 +227,22 @@ static void enable_a53_core_cluster(uint32_t core)
 	 */
 	/* Enable clock and make changes effective */
 	addr = MC_ME_PRTN_PART(part, pconf_cluster) +
-	    S32G_MC_ME_PRTN_N_PCONF_OFF;
-	mmio_write_32(addr, S32G_MC_ME_PRTN_N_CORE_M_PCONF_CCE_MASK);
+	    S32_MC_ME_PRTN_N_PCONF_OFF;
+	mmio_write_32(addr, S32_MC_ME_PRTN_N_CORE_M_PCONF_CCE_MASK);
 
 	addr = MC_ME_PRTN_PART(part, pconf_cluster) +
-	    S32G_MC_ME_PRTN_N_PUPD_OFF;
-	mmio_write_32(addr, S32G_MC_ME_PRTN_N_CORE_M_PUPD_CCUPD_MASK);
+	    S32_MC_ME_PRTN_N_PUPD_OFF;
+	mmio_write_32(addr, S32_MC_ME_PRTN_N_CORE_M_PUPD_CCUPD_MASK);
 
 	mc_me_apply_hw_changes();
 
 	/* Wait for the core clock to become active */
 	addr = MC_ME_PRTN_PART(part, pconf_cluster) +
-	    S32G_MC_ME_PRTN_N_STAT_OFF;
+	    S32_MC_ME_PRTN_N_STAT_OFF;
 	do {
 		stat = mmio_read_32(addr);
-		stat &= S32G_MC_ME_PRTN_N_CORE_M_STAT_CCS_MASK;
-	} while (stat != S32G_MC_ME_PRTN_N_CORE_M_STAT_CCS_MASK);
+		stat &= S32_MC_ME_PRTN_N_CORE_M_STAT_CCS_MASK;
+	} while (stat != S32_MC_ME_PRTN_N_CORE_M_STAT_CCS_MASK);
 }
 
 static void set_core_high_addr(uintptr_t addr, uint32_t core)
@@ -251,7 +251,7 @@ static void set_core_high_addr(uintptr_t addr, uint32_t core)
 	uint32_t addr_hi, reg_val, field_off, reg_off;
 	size_t size;
 
-	map = s32g_get_a53_haddr_mappings(&size);
+	map = s32_get_a53_haddr_mappings(&size);
 
 	if (core >= size)
 		panic();
@@ -273,7 +273,7 @@ void s32g_kick_secondary_ca53_core(uint32_t core, uintptr_t entrypoint)
 {
 	uint32_t rst;
 	uint32_t rst_mask = BIT(get_rgm_a53_bit(core));
-	const uint32_t part = S32G_MC_ME_CA53_PART;
+	const uint32_t part = S32_MC_ME_CA53_PART;
 
 	enable_a53_partition();
 
@@ -312,7 +312,7 @@ void s32g_reset_core(uint8_t part, uint8_t core)
 	uintptr_t prst;
 	uintptr_t pstat;
 
-	if (part == S32G_MC_ME_CA53_PART) {
+	if (part == S32_MC_ME_CA53_PART) {
 		resetc = BIT(get_rgm_a53_bit(core));
 		prst = S32G_MC_RGM_PRST(S32G_MC_RGM_RST_DOMAIN_CA53);
 		pstat = S32G_MC_RGM_PSTAT(S32G_MC_RGM_RST_DOMAIN_CA53);
@@ -333,21 +333,21 @@ void s32g_reset_core(uint8_t part, uint8_t core)
 		;
 }
 
-void s32g_turn_off_core(uint8_t part, uint8_t core)
+void s32_turn_off_core(uint8_t part, uint8_t core)
 {
 	uint32_t stat;
 
 	/* Assumption : The core is already in WFI */
-	stat = mmio_read_32(S32G_MC_ME_PRTN_N_CORE_M_STAT(part, core));
+	stat = mmio_read_32(S32_MC_ME_PRTN_N_CORE_M_STAT(part, core));
 
 	/* The clock isn't enabled */
-	if (!(stat & S32G_MC_ME_PRTN_N_CORE_M_STAT_CCS_MASK))
+	if (!(stat & S32_MC_ME_PRTN_N_CORE_M_STAT_CCS_MASK))
 		return;
 
 	/* Wait for WFI */
 	do {
-		stat = mmio_read_32(S32G_MC_ME_PRTN_N_CORE_M_STAT(part, core));
-	} while (!(stat & S32G_MC_ME_PRTN_N_CORE_M_STAT_WFI_MASK));
+		stat = mmio_read_32(S32_MC_ME_PRTN_N_CORE_M_STAT(part, core));
+	} while (!(stat & S32_MC_ME_PRTN_N_CORE_M_STAT_WFI_MASK));
 
 	/* Disable the core clock */
 	mc_me_part_core_pconf_write_cce(0, part, core);
@@ -367,29 +367,29 @@ void s32g_disable_cofb_clk(uint8_t part, uint32_t keep_blocks)
 {
 	uint32_t pconf;
 
-	if (!mmio_read_32(S32G_MC_ME_PRTN_N_COFB0_CLKEN(part)))
+	if (!mmio_read_32(S32_MC_ME_PRTN_N_COFB0_CLKEN(part)))
 		return;
 
 	/* Disable all blocks */
-	mmio_write_32(S32G_MC_ME_PRTN_N_COFB0_CLKEN(part), keep_blocks);
+	mmio_write_32(S32_MC_ME_PRTN_N_COFB0_CLKEN(part), keep_blocks);
 
-	pconf = mmio_read_32(S32G_MC_ME_PRTN_N_PCONF(part));
+	pconf = mmio_read_32(S32_MC_ME_PRTN_N_PCONF(part));
 
 	/* Keep the partition on if not all the blocks are disabled */
 	if (keep_blocks == 0)
-		pconf &= ~S32G_MC_ME_PRTN_N_PCONF_PCE_MASK;
+		pconf &= ~S32_MC_ME_PRTN_N_PCONF_PCE_MASK;
 
 	/* Disable the clock to IPs */
-	mmio_write_32(S32G_MC_ME_PRTN_N_PCONF(part), pconf);
+	mmio_write_32(S32_MC_ME_PRTN_N_PCONF(part), pconf);
 
 	/* Initiate the clock hardware process */
-	mc_me_part_pupd_write_pcud(S32G_MC_ME_PRTN_N_PUPD_PCUD_MASK, part);
+	mc_me_part_pupd_write_pcud(S32_MC_ME_PRTN_N_PUPD_PCUD_MASK, part);
 
 	/* Write valid key sequence to trigger the update. */
 	mc_me_apply_hw_changes();
 
 	/* Make sure the COFB clock is gated */
-	while (mmio_read_32(S32G_MC_ME_PRTN_N_COFB0_STAT(part)) != keep_blocks)
+	while (mmio_read_32(S32_MC_ME_PRTN_N_COFB0_STAT(part)) != keep_blocks)
 		;
 }
 
diff --git a/plat/nxp/s32/s32g/s32g_psci.c b/plat/nxp/s32/s32g/s32g_psci.c
index a4d83ec12..79c315b3d 100644
--- a/plat/nxp/s32/s32g/s32g_psci.c
+++ b/plat/nxp/s32/s32g/s32g_psci.c
@@ -174,7 +174,7 @@ static void __dead2 platform_suspend(unsigned int current_cpu)
 
 	/* Shutting down cores */
 	/* M7 cores */
-	s32g_turn_off_mcores();
+	s32_turn_off_mcores();
 
 	if (is_lockstep_enabled())
 		ncores /= 2;
@@ -182,14 +182,14 @@ static void __dead2 platform_suspend(unsigned int current_cpu)
 	/* A53 cores */
 	for (i = 0; i < ncores; i++) {
 		if (i != current_cpu)
-			s32g_turn_off_core(S32G_MC_ME_CA53_PART, i);
+			s32_turn_off_core(S32_MC_ME_CA53_PART, i);
 	}
 
 	/* PFE blocks */
 	s32g_disable_cofb_clk(S32G_MC_ME_PFE_PART, 0);
 	/* Keep the DDR clock */
-	s32g_disable_cofb_clk(S32G_MC_ME_USDHC_PART,
-			      S32G_MC_ME_PRTN_N_REQ(S32G_MC_ME_DDR_0_REQ));
+	s32g_disable_cofb_clk(S32_MC_ME_USDHC_PART,
+			      S32_MC_ME_PRTN_N_REQ(S32_MC_ME_DDR_0_REQ));
 
 	/* Switching all MC_CGM muxes to FIRC */
 	s32g_sw_clks2firc();
diff --git a/plat/nxp/s32/s32g/s32g2/s32g2_mc_me.c b/plat/nxp/s32/s32gen1_mc_me.c
similarity index 75%
rename from plat/nxp/s32/s32g/s32g2/s32g2_mc_me.c
rename to plat/nxp/s32/s32gen1_mc_me.c
index 8baab50ba..2681ea980 100644
--- a/plat/nxp/s32/s32g/s32g2/s32g2_mc_me.c
+++ b/plat/nxp/s32/s32gen1_mc_me.c
@@ -5,7 +5,7 @@
  */
 
 #include <lib/mmio.h>
-#include <s32g_mc_me.h>
+#include <s32_mc_me.h>
 
 static const struct a53_haddr_mapping haddr_map[] = {
 	[0] = { .reg = GPR09_OFF, .field_off = CA53_0_0_RVBARADDR_39_32_OFF, },
@@ -14,7 +14,7 @@ static const struct a53_haddr_mapping haddr_map[] = {
 	[3] = { .reg = GPR09_OFF, .field_off = CA53_1_1_RVBARADDR_39_32_OFF, },
 };
 
-const struct a53_haddr_mapping *s32g_get_a53_haddr_mappings(size_t *size)
+const struct a53_haddr_mapping *s32_get_a53_haddr_mappings(size_t *size)
 {
 	*size = ARRAY_SIZE(haddr_map);
 	return &haddr_map[0];
@@ -25,11 +25,11 @@ uint8_t mc_me_core2prtn_core_id(uint8_t part, uint8_t id)
 	return id;
 }
 
-void s32g_turn_off_mcores(void)
+void s32_turn_off_mcores(void)
 {
-	s32g_turn_off_core(S32G_MC_ME_CM7_PART, 2);
-	s32g_turn_off_core(S32G_MC_ME_CM7_PART, 1);
-	s32g_turn_off_core(S32G_MC_ME_CM7_PART, 0);
+	s32_turn_off_core(S32_MC_ME_CM7_PART, 2);
+	s32_turn_off_core(S32_MC_ME_CM7_PART, 1);
+	s32_turn_off_core(S32_MC_ME_CM7_PART, 0);
 }
 
 uint32_t mc_me_get_cluster_ptrn(uint32_t core)
@@ -41,4 +41,3 @@ uint32_t mc_me_get_cluster_ptrn(uint32_t core)
 	 */
 	return (core % 4) & ~1;
 }
-
-- 
2.17.1

