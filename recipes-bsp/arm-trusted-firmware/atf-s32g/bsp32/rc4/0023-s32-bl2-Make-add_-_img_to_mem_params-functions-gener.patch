From 58c14b3f8caa04250622dd6825339e9eff1cc6fc Mon Sep 17 00:00:00 2001
From: Andra-Teodora Ilie <andra.ilie@nxp.com>
Date: Tue, 23 Nov 2021 17:28:53 +0200
Subject: [PATCH 23/50] s32: bl2: Make add_*_img_to_mem_params functions
 generic

Issue: ALB-7411
Upstream-Status: Pending 

Signed-off-by: Andra-Teodora Ilie <andra.ilie@nxp.com>
Signed-off-by: Zhantao Tang <zhantao.tang@windriver.com>
---
 plat/nxp/s32/include/s32_bl2_el3.h            |  18 +++
 plat/nxp/s32/include/s32_platform_def.h       |  11 ++
 plat/nxp/s32/s32_bl2_el3.c                    | 135 +++++++++++++++++
 plat/nxp/s32/s32g/include/s32g_platform_def.h |  11 --
 plat/nxp/s32/s32g/s32g_bl2_el3.c              | 139 +-----------------
 5 files changed, 168 insertions(+), 146 deletions(-)
 create mode 100644 plat/nxp/s32/include/s32_bl2_el3.h

diff --git a/plat/nxp/s32/include/s32_bl2_el3.h b/plat/nxp/s32/include/s32_bl2_el3.h
new file mode 100644
index 000000000..6cad5b0c0
--- /dev/null
+++ b/plat/nxp/s32/include/s32_bl2_el3.h
@@ -0,0 +1,18 @@
+/*
+ * Copyright 2021 NXP
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ */
+#ifndef S32_BL2_EL3_H
+#define S32_BL2_EL3_H
+
+#include <common/desc_image_load.h>
+
+void add_fip_img_to_mem_params_descs(bl_mem_params_node_t *params, size_t *index);
+void add_bl31_img_to_mem_params_descs(bl_mem_params_node_t *params, size_t *index);
+void add_bl32_img_to_mem_params_descs(bl_mem_params_node_t *params, size_t *index);
+void add_bl32_extra1_img_to_mem_params_descs(bl_mem_params_node_t *params, size_t *index);
+void add_bl33_img_to_mem_params_descs(bl_mem_params_node_t *params, size_t *index);
+void add_invalid_img_to_mem_params_descs(bl_mem_params_node_t *params, size_t *index);
+
+#endif /* S32_BL2_EL3_H */
diff --git a/plat/nxp/s32/include/s32_platform_def.h b/plat/nxp/s32/include/s32_platform_def.h
index 7b9c5f007..40a34a04f 100644
--- a/plat/nxp/s32/include/s32_platform_def.h
+++ b/plat/nxp/s32/include/s32_platform_def.h
@@ -127,6 +127,17 @@
 #define BL31_LIMIT		(S32_PMEM_END)
 #define BL31_SIZE		(BL31_LIMIT - BL31_BASE + 1)
 
+/* BL32 location in DDR - 22MB
+ * 20 MB for optee_os (optee_os itself + TA mappings during their execution)
+ * 2 MB for shared memory between optee and linux kernel
+ *
+ * Depending on the intensity of usage of TAs and their sizes,
+ * these values can be further shrunk. The current values are preliminary.
+ */
+#define S32_BL32_SIZE		0x01600000
+#define S32_BL32_BASE		(BL31_BASE - S32_BL32_SIZE)
+#define S32_BL32_LIMIT		(BL31_BASE)
+
 #define FIP_BASE		(S32_SRAM_END - FIP_ROFFSET)
 
 /* FIXME value randomly chosen; should probably be revisited */
diff --git a/plat/nxp/s32/s32_bl2_el3.c b/plat/nxp/s32/s32_bl2_el3.c
index b0a89c3c8..0840c884b 100644
--- a/plat/nxp/s32/s32_bl2_el3.c
+++ b/plat/nxp/s32/s32_bl2_el3.c
@@ -3,9 +3,144 @@
  *
  * SPDX-License-Identifier: BSD-3-Clause
  */
+#include <assert.h>
 #include <common/desc_image_load.h>
 #include <platform.h>
 
+#include "s32_storage.h"
+
+void add_fip_img_to_mem_params_descs(bl_mem_params_node_t *params,
+					    size_t *index)
+{
+	params[(*index)++] = (bl_mem_params_node_t) {
+		.image_id = FIP_IMAGE_ID,
+
+		SET_STATIC_PARAM_HEAD(ep_info, PARAM_EP, VERSION_2,
+				      entry_point_info_t,
+				      NON_SECURE | EXECUTABLE),
+
+		SET_STATIC_PARAM_HEAD(image_info, PARAM_EP, VERSION_2,
+				      image_info_t, IMAGE_ATTRIB_PLAT_SETUP),
+		.image_info.image_max_size = FIP_MAXIMUM_SIZE,
+		.image_info.image_size = FIP_HEADER_SIZE,
+		.image_info.image_base = FIP_BASE,
+		.next_handoff_image_id = BL31_IMAGE_ID,
+	};
+}
+
+void add_bl31_img_to_mem_params_descs(bl_mem_params_node_t *params,
+					     size_t *index)
+{
+	params[(*index)++] = (bl_mem_params_node_t) {
+		.image_id = BL31_IMAGE_ID,
+
+		SET_STATIC_PARAM_HEAD(ep_info, PARAM_EP, VERSION_2,
+				      entry_point_info_t,
+				      SECURE | EXECUTABLE | EP_FIRST_EXE),
+		.ep_info.spsr = SPSR_64(MODE_EL3, MODE_SP_ELX,
+					DISABLE_ALL_EXCEPTIONS),
+		.ep_info.pc = BL31_BASE,
+
+		SET_STATIC_PARAM_HEAD(image_info, PARAM_EP, VERSION_2,
+				      image_info_t, 0),
+		.image_info.image_max_size = BL31_LIMIT - BL31_BASE,
+		.image_info.image_base = BL31_BASE,
+#ifdef SPD_opteed
+		.next_handoff_image_id = BL32_IMAGE_ID,
+#else
+		.next_handoff_image_id = BL33_IMAGE_ID,
+#endif
+	};
+}
+
+#ifdef SPD_opteed
+void add_bl32_img_to_mem_params_descs(bl_mem_params_node_t *params,
+					     size_t *index)
+{
+	params[(*index)++] = (bl_mem_params_node_t) {
+		.image_id = BL32_IMAGE_ID,
+
+		SET_STATIC_PARAM_HEAD(ep_info, PARAM_EP, VERSION_2,
+				      entry_point_info_t,
+				      SECURE | EXECUTABLE),
+		.ep_info.pc = S32_BL32_BASE,
+
+		SET_STATIC_PARAM_HEAD(image_info, PARAM_EP, VERSION_2,
+				      image_info_t, 0),
+		.image_info.image_max_size = S32_BL32_SIZE,
+		.image_info.image_base = S32_BL32_BASE,
+		.next_handoff_image_id = BL33_IMAGE_ID,
+	};
+}
+
+void add_bl32_extra1_img_to_mem_params_descs(
+	bl_mem_params_node_t *params,
+	size_t *index)
+{
+	params[(*index)++] = (bl_mem_params_node_t) {
+
+		.image_id = BL32_EXTRA1_IMAGE_ID,
+
+		SET_STATIC_PARAM_HEAD(ep_info, PARAM_EP, VERSION_2,
+				      entry_point_info_t,
+				      SECURE | NON_EXECUTABLE),
+
+		SET_STATIC_PARAM_HEAD(image_info, PARAM_EP, VERSION_2,
+				      image_info_t, IMAGE_ATTRIB_SKIP_LOADING),
+		.image_info.image_base = S32_BL32_BASE,
+		.image_info.image_max_size = S32_BL32_SIZE,
+
+		.next_handoff_image_id = INVALID_IMAGE_ID,
+	};
+}
+
+#else
+void add_bl32_img_to_mem_params_descs(bl_mem_params_node_t *params,
+					     size_t *index)
+{
+
+}
+
+void add_bl32_extra1_img_to_mem_params_descs(
+	bl_mem_params_node_t *params,
+	size_t *index)
+{
+
+}
+#endif /* SPD_opteed */
+
+void add_bl33_img_to_mem_params_descs(bl_mem_params_node_t *params,
+					     size_t *index)
+{
+	bl_mem_params_node_t node = {
+		.image_id = BL33_IMAGE_ID,
+
+		SET_STATIC_PARAM_HEAD(ep_info, PARAM_EP, VERSION_2,
+				      entry_point_info_t,
+				      NON_SECURE | EXECUTABLE),
+
+		SET_STATIC_PARAM_HEAD(image_info, PARAM_EP, VERSION_2,
+				      image_info_t, 0),
+		.image_info.image_max_size = S32_BL33_IMAGE_SIZE,
+		.image_info.image_base = S32_BL33_IMAGE_BASE,
+		.next_handoff_image_id = INVALID_IMAGE_ID,
+	};
+
+	params[(*index)++] = node;
+}
+
+void add_invalid_img_to_mem_params_descs(bl_mem_params_node_t *params,
+						size_t *index)
+{
+	bl_mem_params_node_t node = {
+		.image_id = INVALID_IMAGE_ID,
+		SET_STATIC_PARAM_HEAD(image_info, PARAM_EP, VERSION_2,
+				      image_info_t, IMAGE_ATTRIB_SKIP_LOADING),
+	};
+
+	params[(*index)++] = node;
+}
+
 struct bl_load_info *plat_get_bl_image_load_info(void)
 {
 	return get_bl_load_info_from_mem_params_desc();
diff --git a/plat/nxp/s32/s32g/include/s32g_platform_def.h b/plat/nxp/s32/s32g/include/s32g_platform_def.h
index fce50af75..0738521f0 100644
--- a/plat/nxp/s32/s32g/include/s32g_platform_def.h
+++ b/plat/nxp/s32/s32g/include/s32g_platform_def.h
@@ -58,17 +58,6 @@
 
 #define DTB_SIZE		(BL2_BASE - DTB_BASE)
 
-/* BL32 location in DDR - 22MB
- * 20 MB for optee_os (optee_os itself + TA mappings during their execution)
- * 2 MB for shared memory between optee and linux kernel
- *
- * Depending on the intensity of usage of TAs and their sizes,
- * these values can be further shrunk. The current values are preliminary.
- */
-#define S32G_BL32_SIZE		0x01600000
-#define S32G_BL32_BASE		(BL31_BASE - S32G_BL32_SIZE)
-#define S32G_BL32_LIMIT		(BL31_BASE)
-
 #if defined IMAGE_BL31
 /* To limit usage, keep these in sync with sizeof(s32g_mmap) */
 #define MAX_MMAP_REGIONS		17
diff --git a/plat/nxp/s32/s32g/s32g_bl2_el3.c b/plat/nxp/s32/s32g/s32g_bl2_el3.c
index eaf6870ef..191583080 100644
--- a/plat/nxp/s32/s32g/s32g_bl2_el3.c
+++ b/plat/nxp/s32/s32g/s32g_bl2_el3.c
@@ -22,6 +22,7 @@
 #include "s32g_mc_me.h"
 #include "bl31_ssram.h"
 #include "s32g_lowlevel.h"
+#include "s32_bl2_el3.h"
 #include "s32g_bl_common.h"
 #include <drivers/generic_delay_timer.h>
 #include <plat/nxp/s32g/bl31_ssram/ssram_mailbox.h>
@@ -53,138 +54,6 @@
 static bl_mem_params_node_t s32g_bl2_mem_params_descs[6];
 REGISTER_BL_IMAGE_DESCS(s32g_bl2_mem_params_descs)
 
-static void add_fip_img_to_mem_params_descs(bl_mem_params_node_t *params,
-					    size_t *index)
-{
-	params[(*index)++] = (bl_mem_params_node_t) {
-		.image_id = FIP_IMAGE_ID,
-
-		SET_STATIC_PARAM_HEAD(ep_info, PARAM_EP, VERSION_2,
-				      entry_point_info_t,
-				      NON_SECURE | EXECUTABLE),
-
-		SET_STATIC_PARAM_HEAD(image_info, PARAM_EP, VERSION_2,
-				      image_info_t, IMAGE_ATTRIB_PLAT_SETUP),
-		.image_info.image_max_size = FIP_MAXIMUM_SIZE,
-		.image_info.image_size = FIP_HEADER_SIZE,
-		.image_info.image_base = FIP_BASE,
-		.next_handoff_image_id = BL31_IMAGE_ID,
-	};
-}
-
-static void add_bl31_img_to_mem_params_descs(bl_mem_params_node_t *params,
-					     size_t *index)
-{
-	params[(*index)++] = (bl_mem_params_node_t) {
-		.image_id = BL31_IMAGE_ID,
-
-		SET_STATIC_PARAM_HEAD(ep_info, PARAM_EP, VERSION_2,
-				      entry_point_info_t,
-				      SECURE | EXECUTABLE | EP_FIRST_EXE),
-		.ep_info.spsr = SPSR_64(MODE_EL3, MODE_SP_ELX,
-					DISABLE_ALL_EXCEPTIONS),
-		.ep_info.pc = BL31_BASE,
-
-		SET_STATIC_PARAM_HEAD(image_info, PARAM_EP, VERSION_2,
-				      image_info_t, 0),
-		.image_info.image_max_size = BL31_LIMIT - BL31_BASE,
-		.image_info.image_base = BL31_BASE,
-#ifdef SPD_opteed
-		.next_handoff_image_id = BL32_IMAGE_ID,
-#else
-		.next_handoff_image_id = BL33_IMAGE_ID,
-#endif
-	};
-}
-
-#ifdef SPD_opteed
-static void add_bl32_img_to_mem_params_descs(bl_mem_params_node_t *params,
-					     size_t *index)
-{
-	params[(*index)++] = (bl_mem_params_node_t) {
-		.image_id = BL32_IMAGE_ID,
-
-		SET_STATIC_PARAM_HEAD(ep_info, PARAM_EP, VERSION_2,
-				      entry_point_info_t,
-				      SECURE | EXECUTABLE),
-		.ep_info.pc = S32G_BL32_BASE,
-
-		SET_STATIC_PARAM_HEAD(image_info, PARAM_EP, VERSION_2,
-				      image_info_t, 0),
-		.image_info.image_max_size = S32G_BL32_SIZE,
-		.image_info.image_base = S32G_BL32_BASE,
-		.next_handoff_image_id = BL33_IMAGE_ID,
-	};
-}
-
-static void add_bl32_extra1_img_to_mem_params_descs(
-	bl_mem_params_node_t *params,
-	size_t *index)
-{
-	params[(*index)++] = (bl_mem_params_node_t) {
-
-		.image_id = BL32_EXTRA1_IMAGE_ID,
-
-		SET_STATIC_PARAM_HEAD(ep_info, PARAM_EP, VERSION_2,
-				      entry_point_info_t,
-				      SECURE | NON_EXECUTABLE),
-
-		SET_STATIC_PARAM_HEAD(image_info, PARAM_EP, VERSION_2,
-				      image_info_t, IMAGE_ATTRIB_SKIP_LOADING),
-		.image_info.image_base = S32G_BL32_BASE,
-		.image_info.image_max_size = S32G_BL32_SIZE,
-
-		.next_handoff_image_id = INVALID_IMAGE_ID,
-	};
-}
-
-#else
-static void add_bl32_img_to_mem_params_descs(bl_mem_params_node_t *params,
-					     size_t *index)
-{
-
-}
-
-static void add_bl32_extra1_img_to_mem_params_descs(
-	bl_mem_params_node_t *params,
-	size_t *index)
-{
-
-}
-#endif /* SPD_opteed */
-
-static void add_bl33_img_to_mem_params_descs(bl_mem_params_node_t *params,
-					     size_t *index)
-{
-	bl_mem_params_node_t node = {
-		.image_id = BL33_IMAGE_ID,
-
-		SET_STATIC_PARAM_HEAD(ep_info, PARAM_EP, VERSION_2,
-				      entry_point_info_t,
-				      NON_SECURE | EXECUTABLE),
-
-		SET_STATIC_PARAM_HEAD(image_info, PARAM_EP, VERSION_2,
-				      image_info_t, 0),
-		.image_info.image_max_size = S32_BL33_IMAGE_SIZE,
-		.image_info.image_base = S32_BL33_IMAGE_BASE,
-		.next_handoff_image_id = INVALID_IMAGE_ID,
-	};
-
-	params[(*index)++] = node;
-}
-
-static void add_invalid_img_to_mem_params_descs(bl_mem_params_node_t *params,
-						size_t *index)
-{
-	bl_mem_params_node_t node = {
-		.image_id = INVALID_IMAGE_ID,
-		SET_STATIC_PARAM_HEAD(image_info, PARAM_EP, VERSION_2,
-				      image_info_t, IMAGE_ATTRIB_SKIP_LOADING),
-	};
-
-	params[(*index)++] = node;
-}
-
 static int disable_clk_node(void *blob, uint32_t *phandle)
 {
 	const char *clk_path;
@@ -548,8 +417,8 @@ static mmap_region_t s32g_mmap[] = {
 			MT_DEVICE | MT_RW),
 	MAP_REGION_FLAT(SSRAMC_BASE_ADDR, SRAMC_SIZE,
 			MT_DEVICE | MT_RW),
-	MAP_REGION2(S32G_BL32_BASE, S32G_BL32_BASE,
-			MMU_ROUND_UP_TO_4K(S32G_BL32_SIZE),
+	MAP_REGION2(S32_BL32_BASE, S32_BL32_BASE,
+			MMU_ROUND_UP_TO_4K(S32_BL32_SIZE),
 			MT_MEMORY | MT_RW, PAGE_SIZE),
 	MAP_REGION2(S32_BL33_IMAGE_BASE, S32_BL33_IMAGE_BASE,
 			MMU_ROUND_UP_TO_4K(S32_BL33_IMAGE_SIZE),
@@ -624,7 +493,7 @@ static int s32g_el3_mmu_fixup(void)
 		return ret;
 
 	/* Check the BL31/BL32/BL33 memory ranges for overlapping */
-	_Static_assert(S32G_BL32_BASE + S32G_BL32_SIZE <= BL31_BASE,
+	_Static_assert(S32_BL32_BASE + S32_BL32_SIZE <= BL31_BASE,
 				"BL32 and BL31 memory ranges overlap!");
 	_Static_assert(BL31_BASE + BL31_SIZE <= BL33_BASE,
 				"BL31 and BL33 memory ranges overlap!");
-- 
2.17.1

