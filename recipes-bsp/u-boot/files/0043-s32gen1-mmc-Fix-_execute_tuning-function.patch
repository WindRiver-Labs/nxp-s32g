From f8ae8cc26c8116cd55d6923f89df9f6581625afb Mon Sep 17 00:00:00 2001
From: Dan Nica <dan.nica@nxp.com>
Date: Tue, 19 Jan 2021 12:03:35 +0200
Subject: [PATCH 43/76] s32gen1: mmc: Fix _execute_tuning function

Issue: ALB-5955
Signed-off-by: Dan Nica <dan.nica@nxp.com>
---
 drivers/mmc/fsl_esdhc_imx.c | 75 +++++++++++++++++++++++++++++++++++++
 include/fsl_esdhc_imx.h     | 18 ++++++++-
 2 files changed, 92 insertions(+), 1 deletion(-)

diff --git a/drivers/mmc/fsl_esdhc_imx.c b/drivers/mmc/fsl_esdhc_imx.c
index cf67bbf15d..39eb3bbcd1 100644
--- a/drivers/mmc/fsl_esdhc_imx.c
+++ b/drivers/mmc/fsl_esdhc_imx.c
@@ -861,6 +861,74 @@ static int esdhc_set_voltage(struct mmc *mmc)
 	}
 }
 
+static int fsl_s32gen1_esdhc_execute_tuning(struct udevice *dev,
+					    uint32_t opcode)
+{
+	struct fsl_esdhc_priv *priv = dev_get_priv(dev);
+	struct fsl_esdhc *regs = priv->esdhc_regs;
+	u32 val, ret;
+
+	val = readl(&regs->irqstaten);
+	val |= IRQSTATEN_BRR;
+	writel(val, &regs->irqstaten);
+
+	val = readl(&regs->vendorspec);
+	val |= VENDORSPEC_FRC_SDCLK_ON;
+	writel(val, &regs->vendorspec);
+
+	val = readl(&regs->tuning_ctrl);
+	val |= ESDHC_STD_TUNING_EN;
+	val |= ESDHC_TUNING_WINDOW(3);
+	val |= ESDHC_TUNING_STEP(1);
+	val |= ESDHC_TUNING_COUNTER(127);
+	val |= ESDHC_TUNING_START_TAP(0x81);
+	writel(val, &regs->tuning_ctrl);
+
+	val = readl(&regs->autoc12err);
+	val |= AUTOC12ERR_EXECUTE_TUNING;
+	writel(val, &regs->autoc12err);
+
+	while (readl(&regs->autoc12err) & AUTOC12ERR_EXECUTE_TUNING) {
+		writel(BLKATTR_CNT(1) | BLKATTR_SIZE(0x80), &regs->blkattr);
+
+		while (readl(&regs->prsstat) & (PRSSTAT_CICHB | PRSSTAT_CIDHB))
+			;
+		writel(0xffffffff, &regs->irqstat);
+		writel(0, &regs->cmdarg);
+
+		val = readl(&regs->mixctrl);
+		val |= MIX_CTRL_DTDSEL_READ;
+		val &= ~MIX_CTRL_BCEN;
+		writel(val, &regs->mixctrl);
+
+		val = XFERTYP_CMD(opcode) | XFERTYP_RSPTYP_48;
+		val |= XFERTYP_DPSEL | XFERTYP_CICEN | XFERTYP_CCCEN;
+		writel(val, &regs->xfertyp);
+
+		while (!(readl(&regs->irqstat) & IRQSTAT_BRR))
+			;
+
+		val = readl(&regs->irqstat);
+		val |= IRQSTAT_BRR;
+		writel(val, &regs->irqstat);
+	}
+
+	if (readl(&regs->autoc12err) & AUTOC12ERR_SMP_CLK_SEL) {
+		val = readl(&regs->mixctrl);
+		val |= MIX_CTRL_AUTO_TUNE_EN;
+		writel(val, &regs->mixctrl);
+		ret = 0;
+	} else {
+		ret = -ETIMEDOUT;
+	}
+
+	val = readl(&regs->vendorspec);
+	val &= ~VENDORSPEC_FRC_SDCLK_ON;
+	writel(val, &regs->vendorspec);
+
+	return ret;
+}
+
 static void esdhc_stop_tuning(struct mmc *mmc)
 {
 	struct mmc_cmd cmd;
@@ -872,6 +940,8 @@ static void esdhc_stop_tuning(struct mmc *mmc)
 	dm_mmc_send_cmd(mmc->dev, &cmd, NULL);
 }
 
+static struct esdhc_soc_data usdhc_s32gen1_data;
+
 static int fsl_esdhc_execute_tuning(struct udevice *dev, uint32_t opcode)
 {
 	struct fsl_esdhc_plat *plat = dev_get_platdata(dev);
@@ -882,6 +952,11 @@ static int fsl_esdhc_execute_tuning(struct udevice *dev, uint32_t opcode)
 	u32 irqsigen = readl(&regs->irqsigen);
 	int i, ret = -ETIMEDOUT;
 	u32 val, mixctrl;
+	struct esdhc_soc_data *soc_data =
+		(struct esdhc_soc_data *)dev_get_driver_data(dev);
+
+	if (soc_data == &usdhc_s32gen1_data)
+		return fsl_s32gen1_esdhc_execute_tuning(dev, opcode);
 
 	/* clock tuning is not needed for upto 52MHz */
 	if (mmc->clock <= 52000000)
diff --git a/include/fsl_esdhc_imx.h b/include/fsl_esdhc_imx.h
index 4de9829d54..874498db5b 100644
--- a/include/fsl_esdhc_imx.h
+++ b/include/fsl_esdhc_imx.h
@@ -3,7 +3,7 @@
  * FSL SD/MMC Defines
  *-------------------------------------------------------------------
  *
- * Copyright 2019-2020 NXP
+ * Copyright 2019-2021 NXP
  * Yangbo Lu <yangbo.lu@nxp.com>
  *
  * Copyright 2007-2008,2010-2011 Freescale Semiconductor, Inc
@@ -39,6 +39,7 @@
 #define VENDORSPEC_HCKEN	0x00001000
 #define VENDORSPEC_IPGEN	0x00000800
 #define VENDORSPEC_INIT		0x20007809
+#define VENDORSPEC_FRC_SDCLK_ON	BIT(8)
 
 #define IRQSTAT			0x0002e030
 #define IRQSTAT_DMAE		(0x10000000)
@@ -85,6 +86,9 @@
 #define IRQSTATEN_TC		(0x00000002)
 #define IRQSTATEN_CC		(0x00000001)
 
+#define AUTOC12ERR_EXECUTE_TUNING	BIT(22)
+#define AUTOC12ERR_SMP_CLK_SEL		BIT(23)
+
 #define ESDHCCTL		0x0002e40c
 #define ESDHCCTL_PCS		(0x00080000)
 
@@ -174,6 +178,7 @@
 #define ESDHC_VENDORSPEC_VSELECT 0x00000002 /* Use 1.8V */
 
 /* Imported from Linux Kernel drivers/mmc/host/sdhci-esdhc-imx.c */
+#define	MIX_CTRL_BCEN		BIT(1)
 #define	MIX_CTRL_DDREN		BIT(3)
 #define MIX_CTRL_DTDSEL_READ	BIT(4)
 #define	MIX_CTRL_AC23EN		BIT(7)
@@ -204,8 +209,19 @@
 /* NOTE: the minimum valid tuning start tap for mx6sl is 1 */
 #define ESDHC_TUNING_START_TAP_DEFAULT	0x1
 #define ESDHC_TUNING_START_TAP_MASK	0xff
+#define ESDHC_TUNING_START_TAP(x)	((x) & ESDHC_TUNING_START_TAP_MASK)
+#define ESDHC_TUNING_COUNTER_MASK	0xff00
+#define ESDHC_TUNING_COUNTER_SHIFT	8
+#define ESDHC_TUNING_COUNTER(x)		(((x) << ESDHC_TUNING_COUNTER_SHIFT) \
+						& ESDHC_TUNING_COUNTER_MASK)
 #define ESDHC_TUNING_STEP_MASK		0x00070000
 #define ESDHC_TUNING_STEP_SHIFT		16
+#define ESDHC_TUNING_STEP(x)		(((x) << ESDHC_TUNING_STEP_SHIFT) \
+						& ESDHC_TUNING_STEP_MASK)
+#define ESDHC_TUNING_WINDOW_MASK	0x700000
+#define ESDHC_TUNING_WINDOW_SHIFT	20
+#define ESDHC_TUNING_WINDOW(x)		(((x) << ESDHC_TUNING_WINDOW_SHIFT) \
+						& ESDHC_TUNING_WINDOW_MASK)
 
 #define	ESDHC_FLAG_MULTIBLK_NO_INT	BIT(1)
 #define	ESDHC_FLAG_ENGCM07207		BIT(2)
-- 
2.17.1

