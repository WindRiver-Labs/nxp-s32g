From d2aec62968af8f521fc87d6fd1f71738e2754ff5 Mon Sep 17 00:00:00 2001
From: Dan Nica <dan.nica@nxp.com>
Date: Sat, 12 Dec 2020 13:09:33 +0200
Subject: [PATCH 21/76] s32-gen1: Set SDHC_CLK to 400MHz

The maximum internal USDHC frequency when running in MMC HS400 mode
is 200MHz, but in that case dual data rate mode will be selected and
SDHC_CLK will be divided by at least 2. Therefore, in order to
reach the maximum supported frequency of 200MHz, SDHC_CLK must be at
least 400MHz.

Issue: ALB-5959
Signed-off-by: Dan Nica <dan.nica@nxp.com>
---
 arch/arm/cpu/armv8/s32/s32-gen1/cmu.c |  4 ++--
 arch/arm/dts/fsl-s32-gen1.dtsi        |  2 +-
 drivers/mmc/fsl_esdhc_imx.c           | 18 +++++++++++++++++-
 3 files changed, 20 insertions(+), 4 deletions(-)

diff --git a/arch/arm/cpu/armv8/s32/s32-gen1/cmu.c b/arch/arm/cpu/armv8/s32/s32-gen1/cmu.c
index bf8ad77445..298650b8c9 100644
--- a/arch/arm/cpu/armv8/s32/s32-gen1/cmu.c
+++ b/arch/arm/cpu/armv8/s32/s32-gen1/cmu.c
@@ -174,7 +174,7 @@ static struct cmu cmu_blocks[] = {
 	FXOSC_PERIPH_CMU_FC(15, GMAC_TS_CLK, 200),
 	FXOSC_PERIPH_CMU_FC(16, LIN_CLK, 125),
 	FXOSC_PERIPH_CMU_FC(17, QSPI_1X_CLK, 133.33),
-	FXOSC_PERIPH_CMU_FC(18, SDHC_CLK, 200),
+	FXOSC_PERIPH_CMU_FC(18, SDHC_CLK, 400),
 	FIRC_PERIPH_CMU_FC(20, DDR_CLK, 800),
 	FXOSC_PERIPH_CMU_FC(21, GMAC_0_RX_CLK, 125),
 	FXOSC_PERIPH_CMU_FC(22, SPI_CLK, 100),
@@ -209,7 +209,7 @@ static struct cmu cmu_blocks[] = {
 	FXOSC_PERIPH_CMU_FC(15, GMAC_TS_CLK, 200),
 	FXOSC_PERIPH_CMU_FC(16, LIN_CLK, 125),
 	FXOSC_PERIPH_CMU_FC(17, QSPI_1X_CLK, 200),
-	FXOSC_PERIPH_CMU_FC(18, SDHC_CLK, 200),
+	FXOSC_PERIPH_CMU_FC(18, SDHC_CLK, 400),
 	FIRC_PERIPH_CMU_FC(20, DDR_CLK, 666.66),
 	FXOSC_PERIPH_CMU_FC(21, GMAC_0_RX_CLK, 125),
 	FXOSC_PERIPH_CMU_FC(22, SPI_CLK, 100),
diff --git a/arch/arm/dts/fsl-s32-gen1.dtsi b/arch/arm/dts/fsl-s32-gen1.dtsi
index 878bd1729c..b43fdc7941 100644
--- a/arch/arm/dts/fsl-s32-gen1.dtsi
+++ b/arch/arm/dts/fsl-s32-gen1.dtsi
@@ -357,7 +357,7 @@
 				 * value can be 266666666.
 				 */
 				<400000000>,
-				<200000000>,
+				<400000000>,
 				<200000000>;
 		};
 
diff --git a/drivers/mmc/fsl_esdhc_imx.c b/drivers/mmc/fsl_esdhc_imx.c
index 5c27b4b9aa..c488bf27e2 100644
--- a/drivers/mmc/fsl_esdhc_imx.c
+++ b/drivers/mmc/fsl_esdhc_imx.c
@@ -164,6 +164,8 @@ struct fsl_esdhc_priv {
 #endif
 };
 
+static bool is_s32gen1_usdhc(struct fsl_esdhc_priv *priv);
+
 /* Return the XFERTYP flags for a given command and data packet */
 static uint esdhc_xfertyp(struct mmc_cmd *cmd, struct mmc_data *data)
 {
@@ -1286,7 +1288,10 @@ static int fsl_esdhc_init(struct fsl_esdhc_priv *priv,
 	cfg->host_caps |= priv->caps;
 
 	cfg->f_min = 400000;
-	priv->sdhc_clk = min(priv->sdhc_clk, (u32)200000000);
+#if CONFIG_IS_ENABLED(DM_MMC)
+	if (!is_s32gen1_usdhc(priv))
+		priv->sdhc_clk = min(priv->sdhc_clk, (u32)200000000);
+#endif
 	cfg->f_max = priv->sdhc_clk;
 
 	cfg->b_max = CONFIG_SYS_MMC_MAX_BLK_COUNT;
@@ -1650,6 +1655,15 @@ static struct esdhc_soc_data usdhc_imx8qm_data = {
 		ESDHC_FLAG_HS400 | ESDHC_FLAG_HS400_ES,
 };
 
+static struct esdhc_soc_data usdhc_s32gen1_data = {
+	.flags = ESDHC_FLAG_USDHC,
+};
+
+static bool is_s32gen1_usdhc(struct fsl_esdhc_priv *priv)
+{
+	return (ulong)priv == (ulong)&usdhc_s32gen1_data;
+}
+
 static const struct udevice_id fsl_esdhc_ids[] = {
 	{ .compatible = "fsl,imx53-esdhc", },
 	{ .compatible = "fsl,imx6ul-usdhc", },
@@ -1663,6 +1677,8 @@ static const struct udevice_id fsl_esdhc_ids[] = {
 	{ .compatible = "fsl,imx8mn-usdhc", .data = (ulong)&usdhc_imx8qm_data,},
 	{ .compatible = "fsl,imx8mq-usdhc", .data = (ulong)&usdhc_imx8qm_data,},
 	{ .compatible = "fsl,imxrt-usdhc", },
+	{ .compatible = "fsl,s32gen1-usdhc",
+	  .data = (ulong)&usdhc_s32gen1_data,},
 	{ .compatible = "fsl,esdhc", },
 	{ /* sentinel */ }
 };
-- 
2.17.1

