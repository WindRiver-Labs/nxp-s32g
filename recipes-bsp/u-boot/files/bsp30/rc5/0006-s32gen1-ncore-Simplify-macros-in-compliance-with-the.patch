From 7b057c9dfa471404edde765b557bd554ed7493ad Mon Sep 17 00:00:00 2001
From: Ghennadi Procopciuc <ghennadi.procopciuc@nxp.com>
Date: Thu, 5 Aug 2021 15:48:33 +0300
Subject: [PATCH 6/8] s32gen1: ncore: Simplify macros in compliance with the
 refman

Upstream-Status: Pending

Issue: ALB-4504
Signed-off-by: Ghennadi Procopciuc <ghennadi.procopciuc@nxp.com>
Signed-off-by: Zhantao Tang <zhantao.tang@windriver.com>
---
 arch/arm/cpu/armv8/s32/s32-gen1/ncore.c | 244 ++++++++++++------------
 1 file changed, 126 insertions(+), 118 deletions(-)

diff --git a/arch/arm/cpu/armv8/s32/s32-gen1/ncore.c b/arch/arm/cpu/armv8/s32/s32-gen1/ncore.c
index 0fba50420e..f4d6cafc9e 100644
--- a/arch/arm/cpu/armv8/s32/s32-gen1/ncore.c
+++ b/arch/arm/cpu/armv8/s32/s32-gen1/ncore.c
@@ -11,143 +11,151 @@
 #include <asm/arch/s32-gen1/a53_cluster_gpr.h>
 #include <asm/arch/s32-gen1/ncore.h>
 
-#define NCORE_BASE_ADDR		(0x50400000ul)
+#define NCORE_BASE_ADDR		(0x50400000UL)
+
+#define A53_CLUSTER0_CAIU	(0)
+#define A53_CLUSTER1_CAIU	(1)
+
+#define DIRU(n)			(NCORE_BASE_ADDR + 0x80000)
+#define DIRUSFER(n)		(DIRU(n) + 0x10)
+#define DIRUSFER_SFEN		BIT(0)
+#define DIRUCASER(n) (DIRU(n) + 0x40)
+#define DIRUCASER_CASNPEN(caiu)	BIT(caiu)
+#define DIRUSFMAR(n)		(DIRU(n) + 0x84)
+#define DIRUSFMAR_MNTOPACTV	BIT(0)
+#define DIRUSFMCR(n)		(DIRU(n) + 0x80)
+#define DIRUSFMCR_SFID(sf)	((sf) << 16)
+#define DIRUSFMCR_SFMNTOP_INITIALIZE_ALL_ENTRIES	(0x0)
+
+#define CAIU(n)                 (NCORE_BASE_ADDR + (n * 0x1000))
+#define CAIUIDR(n)		(CAIU(n) + 0xffc)
+#define CAIUIDR_TYPE		(0xf << 16)
+#define CAIUIDR_TYPE_ACE_DVM	(0x0 << 16)
 
 #define CSR			(NCORE_BASE_ADDR + 0xff000)
-#define CSADSE(m)		(CSR + 0x40 + (m * 0x4))
-#define CSSFIDR(m)		(CSR + 0xf00 + (m * 0x4))
-#define CSSFIDR_TYPE_MASK	(0xf)
-#define CSSFIDR_TYPE_OFFSET	(26)
-#define CSID			(CSR + 0xffc)
-#define CSID_NUMSFS		(0x1f << 18)
-#define CSUID			(CSR + 0xff8)
-#define CSUID_NUMCAIUS_MASK	(0x7f)
-#define CSUID_NUMCAIUS_OFFSET	(0)
-#define CSUID_NUMNCBUS_MASK	(0x3f)
-#define CSUID_NUMNCBUS_OFFSET	(8)
-#define CSUID_NUMDIRUS_MASK	(0x3f)
-#define CSUID_NUMDIRUS_OFFSET	(16)
-#define CSUID_NUMCMIUS_MASK	(0x3f)
-#define CSUID_NUMCMIUS_OFFSET	(24)
-
-#define CAIU(n)			(NCORE_BASE_ADDR + (n * 0x1000))
-#define CAIUCEC(n)		(CAIU(n) + 0x100)
-#define CAIUUEC(n)		(CAIU(n) + 0x140)
-#define CAIUID(n)		(CAIU(n) + 0xffc)
-#define CAIUID_CA		BIT(15)
-#define CAIUID_TYPE_MASK	(0xf)
-#define CAIUID_TYPE_OFFSET	(16)
-
-#define NCBU(n)			(NCORE_BASE_ADDR + 0x60000 + (n * 0x1000))
-#define NCBUCEC(n)		(NCBU(n) + 0x100)
-#define NCBUUEC(n)		(NCBU(n) + 0x140)
-#define NCBUID(n)		(NCBU(n) + 0xffc)
-#define NCBUID_CA		BIT(15)
-#define NCBUID_TYPE_MASK	(0xf)
-#define NCBUID_TYPE_OFFSET	(16)
-
-#define DIRU(n)			(NCORE_BASE_ADDR + 0x80000 + (n * 0x1000))
-#define DIRUSFE(n)		(DIRU(n) + 0x10)
-#define DIRUCASER(n,m)		(DIRU(n) + 0x40 + (m * 0x4))
-#define DIRUSFMC(n)		(DIRU(n) + 0x80ul)
-#define DIRUSFMC_SFID_OFFSET	(16)
-#define DIRUSFMA(n)		(DIRU(n) + 0x84)
-#define DIRUSFMA_MNTOPACTIV	BIT(0)
-#define DIRUCEC(n)		(DIRU(n) + 0x100)
-#define DIRUUEC(n)		(DIRU(n) + 0x140)
-
-#define CMIU(n)			(NCORE_BASE_ADDR + 0xc0000 + (n * 0x1000))
-#define CMIUCEC(n)		(CMIU(n) + 0x100)
-#define CMIUUEC(n)		(CMIU(n) + 0x140)
-
-#define ERRDETEN		BIT(0)
-#define ERRINTEN		BIT(1)
+#define CSADSER			(CSR + 0x40)
+#define CSADSER_DVMSNPEN(caiu)	BIT(caiu)
+#define CSIDR			(CSR + 0xffc)
+#define CSIDR_NUMSFS_SHIFT	(18)
+#define CSIDR_NUMSFS_MASK	(0x1f << CSIDR_NUMSFS_SHIFT)
+#define CSIDR_NUMSFS(csidr)	(((csidr) & CSIDR_NUMSFS_MASK) \
+				 >> CSIDR_NUMSFS_SHIFT)
+#define CSUIDR			(CSR + 0xff8)
+#define CSUIDR_NUMCMIUS_SHIFT	(24)
+#define CSUIDR_NUMCMIUS_MASK	(0x3f << CSUIDR_NUMCMIUS_SHIFT)
+#define CSUIDR_NUMCMIUS(csuidr)	(((csuidr) & CSUIDR_NUMCMIUS_MASK) \
+				 >> CSUIDR_NUMCMIUS_SHIFT)
+#define CSUIDR_NUMDIRUS_SHIFT	(16)
+#define CSUIDR_NUMDIRUS_MASK	(0x3f << CSUIDR_NUMDIRUS_SHIFT)
+#define CSUIDR_NUMDIRUS(csuidr)	(((csuidr) & CSUIDR_NUMDIRUS_MASK) \
+				 >> CSUIDR_NUMDIRUS_SHIFT)
+#define CSUIDR_NUMNCBUS_SHIFT	(8)
+#define CSUIDR_NUMNCBUS_MASK	(0x3f << CSUIDR_NUMNCBUS_SHIFT)
+#define CSUIDR_NUMNCBUS(csuidr)	(((csuidr) & CSUIDR_NUMNCBUS_MASK) \
+				 >> CSUIDR_NUMNCBUS_SHIFT)
+
+static void ncore_diru_online(uint32_t diru)
+{
+	int numsfs, sf;
+
+	numsfs = CSIDR_NUMSFS(readl(CSIDR)) + 1;
+	for (sf = 0; sf < numsfs; sf++) {
+		writel(DIRUSFMCR_SFID(sf) |
+		       DIRUSFMCR_SFMNTOP_INITIALIZE_ALL_ENTRIES,
+		       DIRUSFMCR(diru));
+		while (readl(DIRUSFMAR(diru)) & DIRUSFMAR_MNTOPACTV)
+			;
+		writel(readl(DIRUSFER(diru)) | DIRUSFER_SFEN,
+		       DIRUSFER(diru));
+	}
+}
 
-void ncore_init(u32 cpumask)
+static void ncore_cmiu_online(uint32_t cmiu)
 {
-	int i, j;
-	u32 regdata;
-	u32 csid_numsfs;
-	u32 csuid_numcaius, csuid_numncbus, csuid_numdirus, csuid_numcmius;
-	u32 dirucase[4] = {0,0,0,0};
-	u32 csadse[4] = {0,0,0,0};
-
-	csid_numsfs = (readl(CSID) & CSID_NUMSFS) + 1;
-	regdata = readl(CSUID);
-	csuid_numcaius = regdata >> CSUID_NUMCAIUS_OFFSET & CSUID_NUMCAIUS_MASK;
-	csuid_numncbus = regdata >> CSUID_NUMNCBUS_OFFSET & CSUID_NUMNCBUS_MASK;
-	csuid_numdirus = regdata >> CSUID_NUMDIRUS_OFFSET & CSUID_NUMDIRUS_MASK;
-	csuid_numcmius = regdata >> CSUID_NUMCMIUS_OFFSET & CSUID_NUMCMIUS_MASK;
+	/* Nothing to be done since the hardware implementation
+	 * does not have a coherent memory cache
+	 */
+}
 
-	if (((cpumask & cpu_pos_mask_cluster0()) == cpumask) ||
-	    ((cpumask & cpu_pos_mask_cluster1()) == cpumask) ||
-	    is_a53_lockstep_enabled()) {
-		csuid_numcaius  = 1;
-		csuid_numncbus  = 1;
-	}
+static void ncore_ncbu_online(uint32_t ncbu)
+{
+	/* Nothing to be done since the hardware implementation
+	 * does not have a proxy cache
+	 */
+}
 
-	for (i = 0; i < csuid_numdirus; i++) {
-		writel(0, DIRUSFMC(i));
-		while (readl(DIRUSFMA(i)) & DIRUSFMA_MNTOPACTIV)
-			;
-	}
+static void set_caiu(uint32_t caiu, bool on)
+{
+	int numdirus, diru;
+	uint32_t dirucase, csadser, caiuidr;
 
-	for (i = 0; i < csid_numsfs; i++) {
-		regdata = readl(CSSFIDR(i)) & CSSFIDR_TYPE_MASK >> CSSFIDR_TYPE_OFFSET;
-		if ((regdata >= 2) && (regdata <= 7))
-			for (j = 0; j < csuid_numdirus; j++)
-				writel(BIT(i) << DIRUSFMC_SFID_OFFSET, DIRUSFMC(j));
-	}
+	numdirus = CSUIDR_NUMDIRUS(readl(CSUIDR));
+	for (diru = 0; diru < numdirus; diru++) {
+		dirucase = readl(DIRUCASER(diru));
 
-	for (i = 0; i < csuid_numdirus; i++)
-		while (readl(DIRUSFMA(i)) & DIRUSFMA_MNTOPACTIV)
-			;
+		if (on)
+			dirucase |= DIRUCASER_CASNPEN(caiu);
+		else
+			dirucase &= ~DIRUCASER_CASNPEN(caiu);
 
-	for (i=0; i<csuid_numdirus; i++) {
-		writel(0xffffffff, DIRUSFE(i));
-		writel(ERRDETEN | ERRINTEN, DIRUCEC(i));
-		writel(ERRDETEN | ERRINTEN, DIRUUEC(i));
+		writel(dirucase, DIRUCASER(diru));
 	}
 
-	for (i = 0; i < csuid_numcmius; i++) {
-		writel(ERRDETEN | ERRINTEN, CMIUCEC(i));
-		writel(ERRDETEN | ERRINTEN, CMIUUEC(i));
+	caiuidr = readl(CAIUIDR(caiu));
+
+	if ((caiuidr & CAIUIDR_TYPE) == CAIUIDR_TYPE_ACE_DVM) {
+		csadser = readl(CSADSER);
+
+		if (on)
+			csadser |= CSADSER_DVMSNPEN(caiu);
+		else
+			csadser &= ~CSADSER_DVMSNPEN(caiu);
+
+		writel(csadser, CSADSER);
 	}
+}
 
-	for (i = 0; i < csuid_numcaius; i++)
-		if (readl(CAIUID(i)) & CAIUID_CA)
-			dirucase[i / 32] |= BIT(i % 32);
+static void ncore_caiu_online(uint32_t caiu)
+{
+	set_caiu(caiu, true);
+}
 
-	for (i = 0; i < csuid_numncbus; i++)
-		if (readl(NCBUID(i)) & NCBUID_CA)
-			dirucase[3] |= BIT(i % 32);
+static void ncore_common_init(void)
+{
+	uint32_t numdirus, diru;
+	uint32_t numcmius, cmiu;
+	uint32_t numncbus, ncbu;
+	uint32_t csuidr = readl(CSUIDR);
+
+	numdirus = CSUIDR_NUMDIRUS(csuidr);
+	for (diru = 0; diru < numdirus; diru++)
+		ncore_diru_online(diru);
+
+	numcmius = CSUIDR_NUMCMIUS(csuidr);
+	for (cmiu = 0; cmiu < numcmius; cmiu++)
+		ncore_cmiu_online(cmiu);
+
+	numncbus = CSUIDR_NUMNCBUS(csuidr);
+	for (ncbu = 0; ncbu < numncbus; ncbu++)
+		ncore_ncbu_online(ncbu);
+}
 
-	for (i = 0; i < csuid_numdirus; i++)
-		for (j = 0; j < 4; j++)
-			writel(dirucase[j], DIRUCASER(i, j));
+void ncore_init(u32 cpumask)
+{
 
-	for (i = 0; i < csuid_numcaius; i++) {
-		writel(ERRDETEN | ERRINTEN, CAIUCEC(i));
-		writel(ERRDETEN | ERRINTEN, CAIUUEC(i));
-	}
+	static bool is_common_init;
 
-	for (i = 0; i < csuid_numncbus; i++) {
-		writel(ERRDETEN | ERRINTEN, NCBUCEC(i));
-		writel(ERRDETEN | ERRINTEN, NCBUUEC(i));
+	if (!is_common_init) {
+		is_common_init = true;
+		ncore_common_init();
 	}
 
-	for (i = 0; i < csuid_numcaius; i++) {
-		regdata = readl(CAIUID(i)) & CAIUID_TYPE_MASK >> CAIUID_TYPE_OFFSET;
-		if (regdata < 2)
-			csadse[i / 32] += BIT(i % 32);
-	}
+	ncore_caiu_online(A53_CLUSTER0_CAIU);
 
-	for (i=0; i<csuid_numncbus; i++) {
-		regdata = readl(NCBUID(i)) & NCBUID_TYPE_MASK >> NCBUID_TYPE_OFFSET;
-		if (regdata < 2)
-			csadse[3] += BIT(i % 32);
-	}
+	if (((cpumask & cpu_pos_mask_cluster0()) == cpumask) ||
+	    ((cpumask & cpu_pos_mask_cluster1()) == cpumask) ||
+	    is_a53_lockstep_enabled())
+		return;
 
-	for (i = 0; i < 4; i++)
-		writel(csadse[i], CSADSE(i));
+	ncore_caiu_online(A53_CLUSTER1_CAIU);
 }
-- 
2.17.1

