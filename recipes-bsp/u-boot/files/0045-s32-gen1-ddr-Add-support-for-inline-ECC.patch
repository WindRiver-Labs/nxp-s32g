From f534afdbb83f38d34f80f1245ab3adcd8acf5164 Mon Sep 17 00:00:00 2001
From: Ghennadi Procopciuc <Ghennadi.Procopciuc@nxp.com>
Date: Fri, 22 Jan 2021 17:04:41 +0200
Subject: [PATCH 45/76] s32-gen1: ddr: Add support for inline ECC

Issue: ALB-5845
Signed-off-by: Ghennadi Procopciuc <Ghennadi.Procopciuc@nxp.com>
---
 arch/arm/cpu/armv8/s32/Makefile              |   3 +-
 arch/arm/cpu/armv8/s32/cpu.c                 |  94 ++++++++++
 board/freescale/s32-gen1/Kconfig             |   7 +
 board/freescale/s32-gen1/Makefile            |  24 ++-
 board/freescale/s32-gen1/ddr_density.c       | 170 +++++++++++++++++++
 board/freescale/s32-gen1/ddr_density.h       |  56 ++++++
 board/freescale/s32-gen1/s32g274a/ddrc_cfg.c |  23 +++
 board/freescale/s32-gen1/s32r45/ddrc_cfg.c   |  23 +++
 8 files changed, 397 insertions(+), 3 deletions(-)
 create mode 100644 board/freescale/s32-gen1/ddr_density.c
 create mode 100644 board/freescale/s32-gen1/ddr_density.h

diff --git a/arch/arm/cpu/armv8/s32/Makefile b/arch/arm/cpu/armv8/s32/Makefile
index 08d10cc061..dcc1bf415b 100644
--- a/arch/arm/cpu/armv8/s32/Makefile
+++ b/arch/arm/cpu/armv8/s32/Makefile
@@ -1,7 +1,7 @@
 # SPDX-License-Identifier:	GPL-2.0+
 #
 # (C) Copyright 2013-2016 Freescale Semiconductor, Inc.
-# (C) Copyright 2016-2018, 2020 NXP
+# (C) Copyright 2016-2018, 2020-2021 NXP
 #
 ccflags-y += -I./board/freescale/common/
 ccflags-y += -Iarch/arm/cpu/armv8/s32/
@@ -22,3 +22,4 @@ obj-$(CONFIG_OF_LIBFDT)		+= fdt.o
 obj-$(CONFIG_FSL_DCU_FB)	+= dcu.o
 obj-y				+= initsram.o
 ccflags-y			+= -Idrivers/clk/s32/include
+ccflags-y			+= -Iboard/freescale/s32-gen1
diff --git a/arch/arm/cpu/armv8/s32/cpu.c b/arch/arm/cpu/armv8/s32/cpu.c
index 13b5ad3dcc..32e1815b7c 100644
--- a/arch/arm/cpu/armv8/s32/cpu.c
+++ b/arch/arm/cpu/armv8/s32/cpu.c
@@ -26,6 +26,9 @@
 #include <power/pmic.h>
 #include <power/vr5510.h>
 
+#define S32GEN1_DRAM_STD_ADDR	0x80000000ULL
+#define S32GEN1_DRAM_EXT_ADDR	0x800000000ULL
+
 DECLARE_GLOBAL_DATA_PTR;
 
 #if defined(CONFIG_S32_STANDALONE_BOOT_FLOW)
@@ -546,6 +549,92 @@ static int s32_gentimer_init(void)
 #endif
 #endif /* CONFIG_S32_STANDALONE_BOOT_FLOW */
 
+#if defined(CONFIG_S32GEN1_DRAM_INLINE_ECC)
+#include "ddr_density.h"
+
+static inline bool get_intersection(unsigned long s1, unsigned long e1,
+				    unsigned long s2, unsigned long e2,
+				    unsigned long *s3, unsigned long *e3)
+{
+	if (s2 > e1 || s1 > e2)
+		return false;
+
+	*s3 = max(s1, s2);
+	*e3 = min(e1, e2);
+
+	return true;
+}
+
+static bool is_ext_addr(unsigned long addr)
+{
+	return addr >= S32GEN1_DRAM_EXT_ADDR;
+}
+
+static unsigned long to_ext_addr(unsigned long addr)
+{
+	return addr - S32GEN1_DRAM_STD_ADDR + S32GEN1_DRAM_EXT_ADDR;
+}
+
+static unsigned long to_std_addr(unsigned long addr)
+{
+	return addr + S32GEN1_DRAM_STD_ADDR - S32GEN1_DRAM_EXT_ADDR;
+}
+
+static void s32_exclude_ecc_region(void)
+{
+	static struct s32_ddr_region pages[S32GEN1_DDR_MAX_NO_PAGES];
+	unsigned long start, size;
+	unsigned long pg_start, pg_end;
+	unsigned long r_start, r_end;
+	int active_pages;
+	bool std_map;
+	u32 i, j;
+
+	if (!gd->bd) {
+		pr_err("gd->bd isn't initialized\n");
+		return;
+	}
+
+	s32gen1_get_ddr_regions(pages, &active_pages);
+
+	for (i = 0; i < CONFIG_NR_DRAM_BANKS; i++) {
+		start = gd->bd->bi_dram[i].start;
+		size = gd->bd->bi_dram[i].size;
+
+		/* Skip SRAM */
+		if (start == S32_SRAM_BASE)
+			continue;
+
+		/* Use extended addresses */
+		if (!is_ext_addr(start)) {
+			start = to_ext_addr(start);
+			std_map = true;
+		} else {
+			std_map = false;
+		}
+
+		for (j = 0; j < active_pages; j++) {
+			pg_start = pages[j].address;
+			pg_end = pg_start + pages[j].size;
+
+			if (!get_intersection(start, start + size,
+					      pg_start, pg_end,
+					      &r_start, &r_end))
+				continue;
+
+			start = r_start;
+			size = r_end - r_start;
+		}
+
+		if (std_map)
+			start = to_std_addr(start);
+
+		gd->bd->bi_dram[i].start = start;
+		gd->bd->bi_dram[i].size = size;
+	}
+}
+#endif
+
 static void s32_init_ram_size(void)
 {
 	int i;
@@ -602,6 +691,11 @@ int dram_init_banksize(void)
 #endif
 #endif
 	s32_init_ram_size();
+
+#if defined(CONFIG_S32GEN1_DRAM_INLINE_ECC)
+	s32_exclude_ecc_region();
+#endif
+
 	return 0;
 }
 
diff --git a/board/freescale/s32-gen1/Kconfig b/board/freescale/s32-gen1/Kconfig
index 360c012f7f..a135ac9cb4 100644
--- a/board/freescale/s32-gen1/Kconfig
+++ b/board/freescale/s32-gen1/Kconfig
@@ -18,6 +18,13 @@ config TARGET_TYPE_S32GEN1_SIMULATOR
 
 endif
 
+config S32GEN1_DRAM_INLINE_ECC
+	bool "S32 GEN1 inline ECC"
+	default y if !TARGET_TYPE_S32GEN1_EMULATOR
+	help
+	  Select this config if you want to use inline ECC feature for
+	  S32 Gen1 boards.
+
 config SYS_DATA_BASE
 	hex "Data Base" if !S32_ATF_BOOT_FLOW
 	default 0xff800000 if S32_ATF_BOOT_FLOW
diff --git a/board/freescale/s32-gen1/Makefile b/board/freescale/s32-gen1/Makefile
index bd6f15d0f1..e05db91314 100644
--- a/board/freescale/s32-gen1/Makefile
+++ b/board/freescale/s32-gen1/Makefile
@@ -31,11 +31,31 @@ obj-$(CONFIG_SYS_FSL_DDRSS) += ddrss_regconf_emu.o ddrss_firmware_emu.o
 else
 
 ifneq ($(filter y,$(CONFIG_TARGET_S32G274ARDB) $(CONFIG_TARGET_S32G274AEVB) $(CONFIG_TARGET_S32G274ABLUEBOX3)),)
-obj-$(CONFIG_SYS_FSL_DDRSS) += s32g274a/phy_cfg.o s32g274a/pie_cfg.o s32g274a/ddrc_cfg.o ddr_utils.o ddrss_cfg.o s32g274a/dq_swap_cfg.o imem_cfg.o s32g274a/dmem_cfg.o ddr_init.o
+obj-$(CONFIG_SYS_FSL_DDRSS) +=	ddr_density.o \
+				ddr_init.o \
+				ddr_utils.o \
+				ddrss_cfg.o \
+				imem_cfg.o \
+				s32g274a/ddrc_cfg.o \
+				s32g274a/dmem_cfg.o \
+				s32g274a/dq_swap_cfg.o \
+				s32g274a/pie_cfg.o \
+				s32g274a/phy_cfg.o \
+
 endif
 
 ifneq ($(filter y,$(CONFIG_TARGET_S32R45EVB)),)
-obj-$(CONFIG_SYS_FSL_DDRSS) += s32r45/phy_cfg.o s32r45/pie_cfg.o s32r45/ddrc_cfg.o ddr_utils.o ddrss_cfg.o s32r45/dq_swap_cfg.o imem_cfg.o s32r45/dmem_cfg.o ddr_init.o
+obj-$(CONFIG_SYS_FSL_DDRSS) +=	ddr_density.o \
+				ddr_init.o \
+				ddr_utils.o \
+				ddrss_cfg.o \
+				imem_cfg.o \
+				s32r45/ddrc_cfg.o \
+				s32r45/dmem_cfg.o \
+				s32r45/dq_swap_cfg.o \
+				s32r45/phy_cfg.o \
+				s32r45/pie_cfg.o \
+
 endif
 
 ifdef CONFIG_TARGET_S32G274AEVB
diff --git a/board/freescale/s32-gen1/ddr_density.c b/board/freescale/s32-gen1/ddr_density.c
new file mode 100644
index 0000000000..1edc2dd1e5
--- /dev/null
+++ b/board/freescale/s32-gen1/ddr_density.c
@@ -0,0 +1,170 @@
+// SPDX-License-Identifier:     GPL-2.0+
+/*
+ * Copyright 2021 NXP
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ * this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ * this list of conditions and the following disclaimer in the documentation
+ * and/or other materials provided with the distribution.
+ *
+ * 3. Neither the name of the copyright holder nor the names of its
+ * contributors may be used to endorse or promote products derived from this
+ * software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include "ddr_density.h"
+#include "ddr_utils.h"
+
+#include <linux/bitops.h>
+#include <bitfield.h>
+#include <linux/kernel.h>
+
+#define OFFSET_DDRC_START_ADDRMAP	0x21C
+
+#define NO_ADDRMAP_REGS			8
+
+/* ECC */
+#define ECC_MODE_MASK	0x00000007
+#define ECC_MODE_SHIFT	0x00000000
+#define ECC_DISABLE	0x00000000
+#define ECC_FLAG_MASK	0x00000001
+
+enum addr_map_masks {
+	ADDRMAP7 = 0x00000f0f,
+	ADDRMAP6 = 0x0f0f0f0f,
+	ADDRMAP5 = 0x0f0f0f00,
+	ADDRMAP4 = 0x00001f1f,
+	ADDRMAP3 = 0x1f1f1f1f,
+	ADDRMAP2 = 0x0f0f1f0f,
+	ADDRMAP1 = 0x003f3f3f,
+	ADDRMAP0 = 0x0000001f,
+};
+
+enum addr_map_internal_base {
+	ADDRMAP7_BASE = 0x00001716,
+	ADDRMAP6_BASE = 0x15141312,
+	ADDRMAP5_BASE = 0x11060706,
+	ADDRMAP4_BASE = 0x00000b0a,
+	ADDRMAP3_BASE = 0x09080706,
+	ADDRMAP2_BASE = 0x05040302,
+	ADDRMAP1_BASE = 0x00040302,
+	ADDRMAP0_BASE = 0x00000006,
+};
+
+enum addr_map_shift {
+	ADDRMAP7_SHIFT = 0x00000800,
+	ADDRMAP6_SHIFT = 0x18100800,
+	ADDRMAP5_SHIFT = 0x18100800,
+	ADDRMAP4_SHIFT = 0x00000800,
+	ADDRMAP3_SHIFT = 0x18100800,
+	ADDRMAP2_SHIFT = 0x18100800,
+	ADDRMAP1_SHIFT = 0x00100800,
+	ADDRMAP0_SHIFT = 0x00000000,
+};
+
+static const enum addr_map_masks addr_map_masks_map[] = {
+	ADDRMAP7, ADDRMAP6, ADDRMAP5, ADDRMAP4,
+	ADDRMAP3, ADDRMAP2, ADDRMAP1, ADDRMAP0
+};
+
+static const enum addr_map_shift addr_map_shift_map[] = {
+	ADDRMAP7_SHIFT, ADDRMAP6_SHIFT, ADDRMAP5_SHIFT,
+	ADDRMAP4_SHIFT, ADDRMAP3_SHIFT, ADDRMAP2_SHIFT,
+	ADDRMAP1_SHIFT, ADDRMAP0_SHIFT
+};
+
+static const enum addr_map_internal_base addr_map_internal_base_map[] = {
+	ADDRMAP7_BASE, ADDRMAP6_BASE, ADDRMAP5_BASE, ADDRMAP4_BASE,
+	ADDRMAP3_BASE, ADDRMAP2_BASE, ADDRMAP1_BASE, ADDRMAP0_BASE
+};
+
+static inline u32 get_byte(u32 val, u32 nr)
+{
+	return bitfield_extract(val, 8 * nr, 8);
+}
+
+void s32gen1_get_ddr_regions(struct s32_ddr_region
+			     pages[S32GEN1_DDR_MAX_NO_PAGES],
+			     int *active_pages)
+{
+	u32 i, sh, mk;
+	u32 *reg = (u32 *)(DDRC_BASE_ADDR + OFFSET_DDRC_START_ADDRMAP);
+	u32 idx, tmp, reg_val, max_hif = 0;
+	struct s32_ddr_region curr_page = {
+		.address = 0x800000000,
+		/* Reset value */
+		.flags = 0x0,
+	};
+
+	reg_val = readl(DDRC_BASE_ADDR + OFFSET_DDRC_ECCCFG0);
+	reg_val = (reg_val & ECC_MODE_MASK) >> ECC_MODE_SHIFT;
+
+	if (reg_val != ECC_DISABLE)
+		curr_page.flags |= ECC_ON;
+
+	/**
+	 * Calculate the size.
+	 * Use HIF address bit number to determine total density
+	 */
+	for (idx = 0; idx < NO_ADDRMAP_REGS ; idx++, reg--) {
+		/* We start with highest reg */
+		reg_val = readl(reg);
+
+		if ((reg_val & addr_map_masks_map[idx]) ==
+		    addr_map_masks_map[idx])
+			continue;
+
+		for (i = 0; i < 4; i++) {
+			sh = get_byte(addr_map_shift_map[idx], i);
+			mk = get_byte(addr_map_masks_map[idx], i);
+			/**
+			 * If is equals to mask value it means it is disabled so
+			 * we don't need to process it
+			 */
+			tmp = ((reg_val >> sh) & mk);
+			if (tmp != mk) {
+				tmp += get_byte(addr_map_internal_base_map[idx],
+						i);
+				max_hif = max(tmp, max_hif);
+			}
+		}
+	}
+
+	max_hif++;
+	curr_page.size =  (1 << max_hif);
+
+	/**
+	 * Convert to AXI
+	 * See details in System Address to Physical Address Mapping
+	 */
+	curr_page.size <<= 2;
+
+	/**
+	 * If ECC is used we need to exclude the ECC region
+	 * ECC is always the last 1/8 of the memory
+	 */
+	if (curr_page.flags & ECC_FLAG_MASK)
+		curr_page.size = (curr_page.size * 7) / 8;
+
+	*active_pages = 1;
+
+	pages[0] =  curr_page;
+}
+
diff --git a/board/freescale/s32-gen1/ddr_density.h b/board/freescale/s32-gen1/ddr_density.h
new file mode 100644
index 0000000000..be4711f02c
--- /dev/null
+++ b/board/freescale/s32-gen1/ddr_density.h
@@ -0,0 +1,56 @@
+/* SPDX-License-Identifier: GPL-2.0+ */
+/*
+ * Copyright 2021 NXP
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ * this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ * this list of conditions and the following disclaimer in the documentation
+ * and/or other materials provided with the distribution.
+ *
+ * 3. Neither the name of the copyright holder nor the names of its
+ * contributors may be used to endorse or promote products derived from this
+ * software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+#ifndef DDR_DENSITY_H
+#define DDR_DENSITY_H
+
+#define ECC_FLAG_SHIFT	0
+#define ECC_ON		1
+#define ECC_OFF		0
+
+/* Hardware limitation */
+#define S32GEN1_DDR_MAX_NO_PAGES	5
+
+struct s32_ddr_region {
+	unsigned long flags; // e.g. ECC ON/OFF
+	unsigned long address; // start address
+	unsigned long size; // memory region size - total density
+};
+
+/**
+ * Gets all DDR memory region based on Address Mapping registers
+ * and ECC s32_ddr_regions
+ */
+void s32gen1_get_ddr_regions(struct s32_ddr_region
+			     pages[S32GEN1_DDR_MAX_NO_PAGES],
+			     int *active_pages);
+
+#endif /* DDR_DENSITY_H */
+
diff --git a/board/freescale/s32-gen1/s32g274a/ddrc_cfg.c b/board/freescale/s32-gen1/s32g274a/ddrc_cfg.c
index 23277b6192..fd1d64dc94 100644
--- a/board/freescale/s32-gen1/s32g274a/ddrc_cfg.c
+++ b/board/freescale/s32-gen1/s32g274a/ddrc_cfg.c
@@ -33,7 +33,11 @@
 
 struct regconf ddrc_cfg[] = {
 	{0x4007c604, 0x00000000},
+#ifdef CONFIG_S32GEN1_DRAM_INLINE_ECC
+	{0x4007c608, 0x37ffffff},
+#else
 	{0x4007c608, 0x00000000},
+#endif
 	{0x403c0000, 0x83080020},
 	{0x403c0010, 0x00000030},
 	{0x403c0014, 0x00000000},
@@ -49,8 +53,13 @@ struct regconf ddrc_cfg[] = {
 	{0x403c0060, 0x00000000},
 	{0x403c0064, 0x005100bb},
 	{0x403c0068, 0x008c0000},
+#ifdef CONFIG_S32GEN1_DRAM_INLINE_ECC
+	{0x403c0070, 0x033f7f54},
+	{0x403c0074, 0x00000780},
+#else
 	{0x403c0070, 0x033f7f40},
 	{0x403c0074, 0x000007b0},
+#endif
 	{0x403c007c, 0x00000700},
 	{0x403c00b8, 0x00000000},
 	{0x403c00bc, 0x00000000},
@@ -97,13 +106,27 @@ struct regconf ddrc_cfg[] = {
 	{0x403c01b8, 0x00000000},
 	{0x403c01c0, 0x00000001},
 	{0x403c01c4, 0x00000001},
+#ifdef CONFIG_S32GEN1_DRAM_INLINE_ECC
+	{0x403c0200, 0x00000014},
+	{0x403c0204, 0x00050505},
+#else
 	{0x403c0200, 0x00000017},
 	{0x403c0204, 0x00080808},
+#endif
 	{0x403c0208, 0x00000000},
+#ifdef CONFIG_S32GEN1_DRAM_INLINE_ECC
+	{0x403c020c, 0x14141400},
+#else
 	{0x403c020c, 0x00000000},
+#endif
 	{0x403c0210, 0x00001f1f},
+#ifdef CONFIG_S32GEN1_DRAM_INLINE_ECC
+	{0x403c0214, 0x04040404},
+	{0x403c0218, 0x04040404},
+#else
 	{0x403c0214, 0x07070707},
 	{0x403c0218, 0x07070707},
+#endif
 	{0x403c021c, 0x0000000f},
 	{0x403c0220, 0x00003f3f},
 	{0x403c0224, 0x00000000},
diff --git a/board/freescale/s32-gen1/s32r45/ddrc_cfg.c b/board/freescale/s32-gen1/s32r45/ddrc_cfg.c
index 88561caaf8..c1ba1f917e 100644
--- a/board/freescale/s32-gen1/s32r45/ddrc_cfg.c
+++ b/board/freescale/s32-gen1/s32r45/ddrc_cfg.c
@@ -33,7 +33,11 @@
 
 struct regconf ddrc_cfg[] = {
 	{0x4007c604, 0x00000000},
+#ifdef CONFIG_S32GEN1_DRAM_INLINE_ECC
+	{0x4007c608, 0x37ffffff},
+#else
 	{0x4007c608, 0x00000000},
+#endif
 	{0x403c0000, 0x83080020},
 	{0x403c0010, 0x00000030},
 	{0x403c0014, 0x00000000},
@@ -49,8 +53,13 @@ struct regconf ddrc_cfg[] = {
 	{0x403c0060, 0x00000000},
 	{0x403c0064, 0x006100e0},
 	{0x403c0068, 0x008c0000},
+#ifdef CONFIG_S32GEN1_DRAM_INLINE_ECC
+	{0x403c0070, 0x033f7f54},
+	{0x403c0074, 0x00000780},
+#else
 	{0x403c0070, 0x033f7f40},
 	{0x403c0074, 0x000007b0},
+#endif
 	{0x403c007c, 0x00000700},
 	{0x403c00b8, 0x00000000},
 	{0x403c00bc, 0x00000000},
@@ -97,13 +106,27 @@ struct regconf ddrc_cfg[] = {
 	{0x403c01b8, 0x00000000},
 	{0x403c01c0, 0x00000001},
 	{0x403c01c4, 0x00000001},
+#ifdef CONFIG_S32GEN1_DRAM_INLINE_ECC
+	{0x403c0200, 0x00000014},
+	{0x403c0204, 0x00050505},
+#else
 	{0x403c0200, 0x00000017},
 	{0x403c0204, 0x00080808},
+#endif
 	{0x403c0208, 0x00000000},
+#ifdef CONFIG_S32GEN1_DRAM_INLINE_ECC
+	{0x403c020c, 0x14141400},
+#else
 	{0x403c020c, 0x00000000},
+#endif
 	{0x403c0210, 0x00001f1f},
+#ifdef CONFIG_S32GEN1_DRAM_INLINE_ECC
+	{0x403c0214, 0x04040404},
+	{0x403c0218, 0x04040404},
+#else
 	{0x403c0214, 0x07070707},
 	{0x403c0218, 0x07070707},
+#endif
 	{0x403c021c, 0x0000000f},
 	{0x403c0220, 0x00003f3f},
 	{0x403c0224, 0x00000000},
-- 
2.17.1

