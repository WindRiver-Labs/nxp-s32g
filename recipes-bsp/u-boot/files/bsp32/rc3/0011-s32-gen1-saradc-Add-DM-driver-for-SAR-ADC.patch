From e1160d1d117ad78cf9d2aab7f7b68969842b336f Mon Sep 17 00:00:00 2001
From: Ciprian Costea <ciprianmarian.costea@nxp.com>
Date: Mon, 10 Jan 2022 18:20:57 +0200
Subject: [PATCH 11/25] s32-gen1: saradc: Add DM driver for SAR-ADC

Issue: ALB-8328
Upstream-Status: Pending 

Signed-off-by: Ciprian Costea <ciprianmarian.costea@nxp.com>
Signed-off-by: Zhantao Tang <zhantao.tang@windriver.com>
---
 arch/arm/cpu/armv8/s32/Kconfig |   2 +
 arch/arm/dts/fsl-s32-gen1.dtsi |  21 ++-
 board/freescale/Kconfig        |   3 +
 drivers/adc/Kconfig            |   8 +
 drivers/adc/Makefile           |   1 +
 drivers/adc/s32-saradc.c       | 265 +++++++++++++++++++++++++++++++++
 6 files changed, 299 insertions(+), 1 deletion(-)
 create mode 100644 drivers/adc/s32-saradc.c

diff --git a/arch/arm/cpu/armv8/s32/Kconfig b/arch/arm/cpu/armv8/s32/Kconfig
index 17afe93a31..4862104968 100644
--- a/arch/arm/cpu/armv8/s32/Kconfig
+++ b/arch/arm/cpu/armv8/s32/Kconfig
@@ -52,6 +52,8 @@ config TARGET_S32G2XXAEVB
 config TARGET_S32G274ARDB
 	bool "Support s32g274ardb"
 	select NXP_S32G2XX
+	select ADC
+	select S32_SARADC
 
 config TARGET_S32G274ABLUEBOX3
 	bool "Support s32g274abluebox3"
diff --git a/arch/arm/dts/fsl-s32-gen1.dtsi b/arch/arm/dts/fsl-s32-gen1.dtsi
index 764187acaa..5e40bd9572 100644
--- a/arch/arm/dts/fsl-s32-gen1.dtsi
+++ b/arch/arm/dts/fsl-s32-gen1.dtsi
@@ -2,9 +2,10 @@
 /*
  * Device Tree Include file for Freescale S32Gen1 family SoC.
  *
- * Copyright 2019-2021 NXP
+ * Copyright 2019-2022 NXP
  */
 
+#include <dt-bindings/interrupt-controller/irq.h>
 #include <dt-bindings/clock/s32gen1-clock-freq.h>
 #include <dt-bindings/clock/s32gen1-clock.h>
 #include <dt-bindings/clock/s32gen1-scmi-clock.h>
@@ -589,5 +590,23 @@
 		reg = <0x0 0x400A4000 0x0 0x400>;
 		status = "okay";
 	};
+
+	saradc0: saradc0 {
+		compatible = "fsl,s32gen1-adc";
+		reg = <0x0 0x401f8000 0x0 0x1000>;
+		interrupts = <0 70 IRQ_TYPE_LEVEL_HIGH>;
+		clocks = <&clks S32GEN1_SCMI_CLK_SAR_ADC_BUS>;
+		clock-names = "adc";
+		status = "okay";
+	};
+
+	saradc1: saradc1 {
+		compatible = "fsl,s32gen1-adc";
+		reg = <0x0 0x402e8000 0x0 0x1000>;
+		interrupts = <0 71 IRQ_TYPE_LEVEL_HIGH>;
+		clocks = <&clks S32GEN1_SCMI_CLK_SAR_ADC_BUS>;
+		clock-names = "adc";
+		status = "okay";
+	};
 };
 
diff --git a/board/freescale/Kconfig b/board/freescale/Kconfig
index 7d7aa4cb30..66838f6513 100644
--- a/board/freescale/Kconfig
+++ b/board/freescale/Kconfig
@@ -4,8 +4,11 @@ config SYS_VENDOR
 
 config S32_GEN1
 	bool "S32 GEN1 Common Chassis"
+	imply CMD_ADC
 	imply CMD_GPIO
 	imply CMD_FUSE
+	imply ADC if !TARGET_S32G274ARDB
+	imply S32_SARADC if !TARGET_S32G274ARDB
 	imply MISC
 	select ARM_SMCCC
 	select CLK
diff --git a/drivers/adc/Kconfig b/drivers/adc/Kconfig
index e719c38bb3..4020fd01b4 100644
--- a/drivers/adc/Kconfig
+++ b/drivers/adc/Kconfig
@@ -48,6 +48,14 @@ config SARADC_ROCKCHIP
 	  - 1O or 12 bits resolution
 	  - Up to 1MSPS of sample rate
 
+config S32_SARADC
+	bool "Enable NXP S32 SARADC driver"
+	help
+	  This enables driver for NXP S32 SARADC
+	  It provides:
+	  - 8 analog input channels
+	  - 12-bit resolution
+
 config STM32_ADC
 	bool "Enable STMicroelectronics STM32 ADC driver"
 	depends on ADC && (STM32H7 || ARCH_STM32MP)
diff --git a/drivers/adc/Makefile b/drivers/adc/Makefile
index c1387f3a34..9c87de8246 100644
--- a/drivers/adc/Makefile
+++ b/drivers/adc/Makefile
@@ -9,4 +9,5 @@ obj-$(CONFIG_ADC_EXYNOS) += exynos-adc.o
 obj-$(CONFIG_ADC_SANDBOX) += sandbox.o
 obj-$(CONFIG_SARADC_ROCKCHIP) += rockchip-saradc.o
 obj-$(CONFIG_SARADC_MESON) += meson-saradc.o
+obj-$(CONFIG_S32_SARADC) += s32-saradc.o
 obj-$(CONFIG_STM32_ADC) += stm32-adc.o stm32-adc-core.o
diff --git a/drivers/adc/s32-saradc.c b/drivers/adc/s32-saradc.c
new file mode 100644
index 0000000000..2fb258ed2c
--- /dev/null
+++ b/drivers/adc/s32-saradc.c
@@ -0,0 +1,265 @@
+// SPDX-License-Identifier: GPL-2.0+
+/*
+ * Copyright 2022 NXP
+ * S32Gen1 SAR-ADC driver
+ */
+
+#include <common.h>
+#include <adc.h>
+#include <clk.h>
+#include <dm.h>
+#include <errno.h>
+#include <asm/io.h>
+
+#define SARADC_MCR	0x0
+#define SARADC_MSR	0x4
+#define SARADC_ISR	0x10
+#define SARADC_CTR0	0x94
+#define SARADC_NCMR0	0xA4
+#define SARADC_PCDR(x)	(0x100 + (x) * 4)
+
+#define SARADC_MCR_PWDN			BIT(0)
+#define SARADC_MCR_ADCLKSE		BIT(8)
+#define SARADC_MCR_TSAMP_MASK	(BIT(10) | BIT(9))
+#define SARADC_MCR_AVGEN		BIT(13)
+#define SARADC_MCR_CALSTART		BIT(14)
+#define SARADC_MCR_NSTART		BIT(24)
+#define SARADC_MCR_SCAN_MODE	BIT(29)
+#define SARADC_MCR_WLSIDE		BIT(30)
+#define SARADC_MCR_OWREN		BIT(31)
+
+#define SARADC_MSR_CALBUSY		BIT(29)
+#define SARADC_MSR_CALFAIL		BIT(30)
+
+#define SARADC_ISR_ECH			BIT(0)
+
+#define SARADC_CTR0_INPSAMP(x)	(x)
+
+#define SARADC_PCDR_VALID		BIT(19)
+#define SARADC_PCDR_CDATA(x)	((x) & 0xfff)
+
+#define SARADC_NSEC_PER_SEC	1000000000
+#define RDB_CHECK_REV_CH	5
+#define SARADC_TIMEOUT_VALUE 0x100000
+
+struct s32_saradc_data {
+	int num_bits;
+	int num_channels;
+};
+
+static const struct s32_saradc_data saradc_data = {
+	.num_bits = 12,
+	.num_channels = 8,
+};
+
+struct s32_saradc_priv {
+	int active_channel;
+	const struct s32_saradc_data *data;
+	ulong base;
+	ulong clk_rate;
+};
+
+static void s32_saradc_powerdown(ulong base)
+{
+	u32 tmp;
+
+	tmp = readl(base + SARADC_MCR) | SARADC_MCR_PWDN;
+	writel(tmp, base + SARADC_MCR);
+}
+
+static void s32_saradc_powerup(ulong base)
+{
+	u32 tmp;
+
+	tmp = readl(base + SARADC_MCR) & ~SARADC_MCR_PWDN;
+	writel(tmp, base + SARADC_MCR);
+}
+
+static int s32_saradc_calibration(ulong base)
+{
+	u32 tmp;
+
+	s32_saradc_powerdown(base);
+
+	/* Configure clock = bus_clock / 2 */
+	tmp = readl(base + SARADC_MCR) & ~SARADC_MCR_ADCLKSE;
+	writel(tmp, base + SARADC_MCR);
+
+	s32_saradc_powerup(base);
+
+	tmp = readl(base + SARADC_MCR);
+	tmp |= SARADC_MCR_AVGEN;
+	tmp &= ~SARADC_MCR_TSAMP_MASK;
+	tmp |= SARADC_MCR_CALSTART;
+	writel(tmp, base + SARADC_MCR);
+
+	do {
+		tmp = readl(base + SARADC_MSR);
+	} while (tmp & SARADC_MSR_CALBUSY);
+
+	if (tmp & SARADC_MSR_CALFAIL)
+		return -EINVAL;
+
+	return 0;
+}
+
+static int s32_adc_channel_data(struct udevice *dev, int channel,
+				unsigned int *data)
+{
+	u32 tmp;
+	struct s32_saradc_priv *priv = dev_get_priv(dev);
+	struct adc_uclass_platdata *uc_pdata = dev_get_uclass_platdata(dev);
+
+	if (!priv)
+		return -EINVAL;
+
+	if (channel != priv->active_channel) {
+		printf("Requested channel: %d is not active!\n", channel);
+		return -EINVAL;
+	}
+
+	if (!(readl(priv->base + SARADC_ISR) & SARADC_ISR_ECH))
+		return -EBUSY;
+
+	/* clear status */
+	writel(SARADC_ISR_ECH, priv->base + SARADC_ISR);
+
+	tmp = readl(priv->base + SARADC_PCDR(channel));
+	if (!(tmp & SARADC_PCDR_VALID))
+		return -EBUSY;
+
+	/* Read value */
+	*data = SARADC_PCDR_CDATA(tmp);
+	*data &= uc_pdata->data_mask;
+
+	return 0;
+}
+
+static int s32_adc_start_channel(struct udevice *dev, int channel)
+{
+	struct s32_saradc_priv *priv = dev_get_priv(dev);
+	u32 tmp;
+
+	if (!priv)
+		return -EINVAL;
+
+	if (channel < 0 || channel >= priv->data->num_channels) {
+		printf("Requested channel: %d is invalid\n", channel);
+		return -EINVAL;
+	}
+
+	s32_saradc_powerup(priv->base);
+
+	writel(BIT(channel), priv->base + SARADC_NCMR0);
+
+	/* Ensure there are at least three cycles between the
+	 * configuration of NCMR and the setting of NSTART
+	 */
+	ndelay((SARADC_NSEC_PER_SEC / (priv->clk_rate >> 1)) * 3);
+
+	tmp = readl(priv->base + SARADC_MCR);
+	tmp |= SARADC_MCR_OWREN;
+	tmp &= ~SARADC_MCR_WLSIDE;
+	tmp &= ~SARADC_MCR_SCAN_MODE;
+
+	tmp |= SARADC_MCR_NSTART;
+	writel(tmp, priv->base + SARADC_MCR);
+
+	priv->active_channel = channel;
+
+	return 0;
+}
+
+static int s32_adc_stop(struct udevice *dev)
+{
+	struct s32_saradc_priv *priv = dev_get_priv(dev);
+
+	if (!priv)
+		return -EINVAL;
+
+	s32_saradc_powerdown(priv->base);
+	priv->active_channel = -1;
+
+	return 0;
+}
+
+static int s32_saradc_probe(struct udevice *dev)
+{
+	struct s32_saradc_priv *priv = dev_get_priv(dev);
+	struct clk clk;
+	u32 tmp;
+	int ret;
+
+	if (!priv)
+		return -EINVAL;
+
+	ret = clk_get_by_index(dev, 0, &clk);
+	if (ret)
+		return ret;
+
+	priv->clk_rate = clk_get_rate(&clk);
+	if (!priv->clk_rate) {
+		printf("Invalid clk rate: %lu\n", priv->clk_rate);
+		return -EINVAL;
+	}
+
+	ret = s32_saradc_calibration(priv->base);
+	s32_saradc_powerdown(priv->base);
+	if (ret) {
+		printf("SARADC calibration failed\n");
+		return ret;
+	}
+
+	tmp = readl(priv->base + SARADC_MCR) | SARADC_MCR_ADCLKSE;
+	writel(tmp, priv->base + SARADC_MCR);
+
+	writel(SARADC_CTR0_INPSAMP(0xFF), priv->base + SARADC_CTR0);
+
+	priv->active_channel = -1;
+
+	return 0;
+}
+
+static int s32_saradc_ofdata_to_platdata(struct udevice *dev)
+{
+	struct adc_uclass_platdata *uc_pdata = dev_get_uclass_platdata(dev);
+	struct s32_saradc_priv *priv = dev_get_priv(dev);
+
+	if (!priv)
+		return -EINVAL;
+
+	priv->base = (ulong)devfdt_get_addr(dev);
+	if (priv->base == (ulong)FDT_ADDR_T_NONE)
+		return -EINVAL;
+
+	priv->data = (struct s32_saradc_data *)dev_get_driver_data(dev);
+
+	uc_pdata->data_mask = (1 << priv->data->num_bits) - 1;
+	uc_pdata->data_format = ADC_DATA_FORMAT_BIN;
+	uc_pdata->data_timeout_us = SARADC_TIMEOUT_VALUE;
+	uc_pdata->channel_mask = (1 << priv->data->num_channels) - 1;
+
+	return 0;
+}
+
+static const struct adc_ops s32_saradc_ops = {
+	.start_channel = s32_adc_start_channel,
+	.channel_data = s32_adc_channel_data,
+	.stop = s32_adc_stop,
+};
+
+static const struct udevice_id s32_saradc_ids[] = {
+	{ .compatible = "fsl,s32gen1-adc",
+	  .data = (ulong)&saradc_data },
+	{ }
+};
+
+U_BOOT_DRIVER(s32_saradc) = {
+	.name = "s32-saradc",
+	.id = UCLASS_ADC,
+	.of_match = s32_saradc_ids,
+	.ops = &s32_saradc_ops,
+	.probe = s32_saradc_probe,
+	.ofdata_to_platdata = s32_saradc_ofdata_to_platdata,
+	.priv_auto_alloc_size = sizeof(struct s32_saradc_priv),
+};
-- 
2.17.1

