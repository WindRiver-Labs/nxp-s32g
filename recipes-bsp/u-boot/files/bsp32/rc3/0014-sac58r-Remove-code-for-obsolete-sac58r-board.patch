From e3b62ae2a192f507da620c5d9a6155e4c9153be4 Mon Sep 17 00:00:00 2001
From: Andrei Botila <andrei.botila@nxp.com>
Date: Fri, 14 Jan 2022 21:35:47 +0200
Subject: [PATCH 14/25] sac58r: Remove code for obsolete sac58r board

Removed code for sac58r obsolete board. This is part of the
upstreaming process of u-boot.

Issue: ALB-8332
Upstream-Status: Pending 

Signed-off-by: Andrei Botila <andrei.botila@nxp.com>
Signed-off-by: Zhantao Tang <zhantao.tang@windriver.com>
---
 Makefile                                      |    2 +-
 arch/arm/Kconfig                              |    8 -
 arch/arm/cpu/armv7/sac58r/Makefile            |    9 -
 arch/arm/cpu/armv7/sac58r/generic.c           | 1146 -----------------
 arch/arm/cpu/armv7/sac58r/soc.c               |  258 ----
 arch/arm/cpu/armv7/sac58r/timer.c             |   90 --
 arch/arm/include/asm/arch-sac58r/clock.h      |   60 -
 arch/arm/include/asm/arch-sac58r/crm_regs.h   |  450 -------
 .../include/asm/arch-sac58r/dmachmux-sac58r.h |  120 --
 arch/arm/include/asm/arch-sac58r/gpio.h       |   14 -
 arch/arm/include/asm/arch-sac58r/imx-regs.h   |  538 --------
 .../include/asm/arch-sac58r/iomux-sac58r.h    |  318 -----
 .../include/asm/arch-sac58r/sac58r_secure.h   |   69 -
 arch/arm/include/asm/mach-imx/iomux-v3.h      |    2 +-
 arch/arm/mach-imx/i2c-mxv7.c                  |    3 -
 board/freescale/sac58r/Kconfig                |   23 -
 board/freescale/sac58r/MAINTAINERS            |    6 -
 board/freescale/sac58r/Makefile               |    7 -
 board/freescale/sac58r/sac58r.c               |  500 -------
 board/freescale/sac58r/sac58r.cfg             |   30 -
 board/freescale/sac58r/sac58r_int_routing.h   |  121 --
 board/freescale/sac58revb/Makefile            |    7 -
 board/freescale/sac58revb/sac58r_mt41j64.cfg  |   48 -
 board/freescale/sac58revb/sac58revb.c         |  887 -------------
 .../sac58revb/sac58revb_int_routing.h         |  121 --
 board/freescale/sac58rfvb/Kconfig             |   23 -
 board/freescale/sac58rfvb/MAINTAINERS         |    6 -
 board/freescale/sac58rfvb/Makefile            |    7 -
 board/freescale/sac58rfvb/sac58r_mt41j64.cfg  |   71 -
 board/freescale/sac58rfvb/sac58rfvb.c         |  567 --------
 .../sac58rfvb/sac58rfvb_int_routing.h         |  121 --
 configs/sac58revb_defconfig                   |    3 -
 configs/sac58rfvb_defconfig                   |    3 -
 drivers/gpio/Makefile                         |    1 -
 drivers/gpio/mvf_gpio.c                       |  161 ---
 drivers/i2c/mxc_i2c.c                         |    2 +-
 drivers/mmc/fsl_esdhc_imx.c                   |    7 -
 include/configs/sac58r.h                      |  250 ----
 include/configs/sac58revb.h                   |  283 ----
 include/configs/sac58rfvb.h                   |  264 ----
 40 files changed, 3 insertions(+), 6603 deletions(-)
 delete mode 100644 arch/arm/cpu/armv7/sac58r/Makefile
 delete mode 100644 arch/arm/cpu/armv7/sac58r/generic.c
 delete mode 100644 arch/arm/cpu/armv7/sac58r/soc.c
 delete mode 100644 arch/arm/cpu/armv7/sac58r/timer.c
 delete mode 100644 arch/arm/include/asm/arch-sac58r/clock.h
 delete mode 100644 arch/arm/include/asm/arch-sac58r/crm_regs.h
 delete mode 100644 arch/arm/include/asm/arch-sac58r/dmachmux-sac58r.h
 delete mode 100644 arch/arm/include/asm/arch-sac58r/gpio.h
 delete mode 100644 arch/arm/include/asm/arch-sac58r/imx-regs.h
 delete mode 100644 arch/arm/include/asm/arch-sac58r/iomux-sac58r.h
 delete mode 100644 arch/arm/include/asm/arch-sac58r/sac58r_secure.h
 delete mode 100644 board/freescale/sac58r/Kconfig
 delete mode 100644 board/freescale/sac58r/MAINTAINERS
 delete mode 100644 board/freescale/sac58r/Makefile
 delete mode 100644 board/freescale/sac58r/sac58r.c
 delete mode 100644 board/freescale/sac58r/sac58r.cfg
 delete mode 100644 board/freescale/sac58r/sac58r_int_routing.h
 delete mode 100644 board/freescale/sac58revb/Makefile
 delete mode 100644 board/freescale/sac58revb/sac58r_mt41j64.cfg
 delete mode 100644 board/freescale/sac58revb/sac58revb.c
 delete mode 100644 board/freescale/sac58revb/sac58revb_int_routing.h
 delete mode 100644 board/freescale/sac58rfvb/Kconfig
 delete mode 100644 board/freescale/sac58rfvb/MAINTAINERS
 delete mode 100644 board/freescale/sac58rfvb/Makefile
 delete mode 100644 board/freescale/sac58rfvb/sac58r_mt41j64.cfg
 delete mode 100644 board/freescale/sac58rfvb/sac58rfvb.c
 delete mode 100644 board/freescale/sac58rfvb/sac58rfvb_int_routing.h
 delete mode 100644 configs/sac58revb_defconfig
 delete mode 100644 configs/sac58rfvb_defconfig
 delete mode 100644 drivers/gpio/mvf_gpio.c
 delete mode 100644 include/configs/sac58r.h
 delete mode 100644 include/configs/sac58revb.h
 delete mode 100644 include/configs/sac58rfvb.h

diff --git a/Makefile b/Makefile
index d97c2ae84e..fb58fa3cb0 100644
--- a/Makefile
+++ b/Makefile
@@ -771,7 +771,7 @@ libs-$(CONFIG_UT_ENV) += test/env/
 libs-$(CONFIG_UT_OPTEE) += test/optee/
 libs-$(CONFIG_UT_OVERLAY) += test/overlay/
 
-ifneq (,$(filter $(SOC), mx25 mx27 mx5 mx6 mx31 mx35 mxs vf610 sac58r mac57d5xh))
+ifneq (,$(filter $(SOC), mx25 mx27 mx5 mx6 mx31 mx35 mxs vf610 mac57d5xh))
 libs-y += arch/$(ARCH)/mach-imx/
 endif
 
diff --git a/arch/arm/Kconfig b/arch/arm/Kconfig
index 9cb23614ec..1f352f2191 100644
--- a/arch/arm/Kconfig
+++ b/arch/arm/Kconfig
@@ -913,12 +913,6 @@ config ARCH_SNAPDRAGON
 	select SPMI
 	imply CMD_DM
 
-config TARGET_SAC58R
-	bool "Support sac58r"
-
-config TARGET_SAC58RFVB
-	bool "Support sac58rfvb"
-
 config ARCH_SOCFPGA
 	bool "Altera SOCFPGA family"
 	select ARCH_EARLY_INIT_R
@@ -1864,8 +1858,6 @@ source "board/freescale/ls1012ardb/Kconfig"
 source "board/freescale/ls1012afrdm/Kconfig"
 source "board/freescale/lx2160a/Kconfig"
 source "board/freescale/mx35pdk/Kconfig"
-source "board/freescale/sac58r/Kconfig"
-source "board/freescale/sac58rfvb/Kconfig"
 source "board/grinn/chiliboard/Kconfig"
 source "board/gumstix/pepper/Kconfig"
 source "board/hisilicon/hikey/Kconfig"
diff --git a/arch/arm/cpu/armv7/sac58r/Makefile b/arch/arm/cpu/armv7/sac58r/Makefile
deleted file mode 100644
index 511e0cabbf..0000000000
--- a/arch/arm/cpu/armv7/sac58r/Makefile
+++ /dev/null
@@ -1,9 +0,0 @@
-#
-# (C) Copyright 2013 Freescale Semiconductor, Inc.
-#
-# SPDX-License-Identifier:	GPL-2.0+
-#
-
-obj-y	+= generic.o
-obj-y	+= timer.o
-obj-y	+= soc.o
diff --git a/arch/arm/cpu/armv7/sac58r/generic.c b/arch/arm/cpu/armv7/sac58r/generic.c
deleted file mode 100644
index 0d5673b1ee..0000000000
--- a/arch/arm/cpu/armv7/sac58r/generic.c
+++ /dev/null
@@ -1,1146 +0,0 @@
-/*
- * (C) Copyright 2013 Freescale Semiconductor, Inc.
- *
- * SPDX-License-Identifier:	GPL-2.0+
- */
-
-#include <common.h>
-#include <asm/io.h>
-#include <asm/arch/imx-regs.h>
-#include <asm/arch/clock.h>
-#include <asm/arch/crm_regs.h>
-#include <netdev.h>
-#include <div64.h>
-#ifdef CONFIG_FSL_ESDHC
-#include <fsl_esdhc.h>
-#endif
-
-#ifdef CONFIG_FSL_ESDHC
-DECLARE_GLOBAL_DATA_PTR;
-#endif
-
-void enable_periph_clk(u32 aips_num, u32 periph_number)
-{
-	u32 periph_num, reg_addr, bit_pos;
-	struct gpc_reg *gpc = (struct gpc_reg *)GPC_BASE_ADDR;
-
-	if (periph_number >= 0 && periph_number < 32) {
-		printf("Incorrect peripheral number:%d - expecting periph number between 32 -127\n",periph_number);
-	}
-	else {
-		periph_num = (periph_number - 32);
-		reg_addr=periph_num/16;
-		bit_pos=periph_num%16;
-		bit_pos=bit_pos*2;
-		switch(aips_num){
-		case AIPS0:
-			setbits_le32((&gpc->aips0_offpf_pctl0) + reg_addr, 0x3<<bit_pos);
-			break;
-		case AIPS1:
-			setbits_le32((&gpc->aips1_offpf_pctl0) + reg_addr, 0x3<<bit_pos);
-			break;
-		case AIPS2:
-			setbits_le32((&gpc->aips2_offpf_pctl0) + reg_addr, 0x3<<bit_pos);
-			break;
-		default:
-			printf("wrong aips_id:%d\n",aips_num);
-		}
-	}
-}
-
-void disable_periph_clk(u32 aips_num, u32 periph_number)
-{
-	u32 periph_num, reg_addr, bit_pos;
-	struct gpc_reg *gpc = (struct gpc_reg *)GPC_BASE_ADDR;
-
-	if (periph_number >= 0 && periph_number < 32) {
-		printf("Incorrect peripheral number:%d - expecting periph number between 32 -127\n",periph_number);
-	}
-	else {
-		periph_num = (periph_number - 32);
-		reg_addr=periph_num/16;
-		bit_pos=periph_num%16;
-		bit_pos=bit_pos*2;
-		switch(aips_num){
-		case AIPS0:
-			clrbits_le32((&gpc->aips0_offpf_pctl0) + reg_addr, 0x3<<bit_pos);
-			break;
-		case AIPS1:
-			clrbits_le32((&gpc->aips1_offpf_pctl0) + reg_addr, 0x3<<bit_pos);
-			break;
-		case AIPS2:
-			clrbits_le32((&gpc->aips2_offpf_pctl0) + reg_addr, 0x3<<bit_pos);
-			break;
-		default:
-			printf("wrong aips_id:%d\n",aips_num);
-		}
-	}
-}
-
-#ifdef CONFIG_MXC_OCOTP
-void enable_ocotp_clk(unsigned char enable)
-{
-	if (enable) {
-		enable_periph_clk(0,AIPS0_OFF_OCOTP0);
-		enable_periph_clk(0,AIPS0_OFF_OCOTP1);
-	} else {
-		disable_periph_clk(0,AIPS0_OFF_OCOTP0);
-		disable_periph_clk(0,AIPS0_OFF_OCOTP1);
-	}
-}
-#endif
-
-int enable_fec_clock(void)
-{
-	u32 reg = 0;
-	s32 timeout = 100000;
-	struct anadig_reg *anadig = (struct anadig_reg *)ANADIG_BASE_ADDR;
-
-	reg = readl(&anadig->pll5_ctrl);
-	if ((reg & ANADIG_PLL_CTRL_POWERDOWN) ||
-		(!(reg & ANADIG_PLL_CTRL_LOCK))) {
-		reg &= ~ANADIG_PLL_CTRL_POWERDOWN;
-		writel(reg, &anadig->pll5_ctrl);
-		while (timeout--) {
-			if (readl(&anadig->pll5_ctrl) &
-					ANADIG_PLL_CTRL_LOCK)
-				break;
-		}
-		if (timeout <= 0)
-			return -1;
-	}
-
-	/* Enable FEC clock */
-	reg |= ANADIG_PLL_CTRL_ENABLE;
-	reg &= ~ANADIG_PLL_CTRL_BYPASS;
-	writel(reg, &anadig->pll5_ctrl);
-
-	return 0;
-}
-
-
-/* This function makes sure the multiplier value is either
- 20 or 22 that are the only valid values for PLL2, PLL3 and PLL7.
- If the MULT value is correct, then is it converted to the
- value valid in the register (0=20, 1=22)
- */
-static int get_pll2_mult_value(int mult)
-{
-	int div_select = -1;
-
-	switch (mult)
-	{
-	case 20:
-		div_select = 0;
-		break;
-	case 22:
-		div_select = 1;
-		break;
-	default:
-		break;
-	}
-
-	return div_select;
-}
-
-/* This function verifies the validity of the MULT value for PLL1,
-   PLL4, PLL6 and PLL8 */
-static int check_pll1_mult_value(int mult)
-{
-	if ((mult>127)||(mult<1))
-		return -1;
-	else
-		return 0;
-}
-
-/* This function configures the different PLLs' DIV_SELECT, MFN and MFD parameters */
-int config_pll(enum pll_clocks pll, int mult, int mfn, int mfd)
-{
-	struct anadig_reg *anadig = (struct anadig_reg *)ANADIG_BASE_ADDR;
-	u32 pll_ctrl_reg;
-	u32 pll_num_reg = -1;
-	u32 pll_denom_reg = -1;
-	u32 value;
-	u32 pll_div_select_value;
-
-	switch(pll)
-	{
-	case PLL_ARM: /* PLL1 */
-		if (check_pll1_mult_value(mult) < 0)
-			return -1;
-		pll_div_select_value = mult;
-		pll_ctrl_reg = &anadig->pll1_ctrl;
-		pll_num_reg = &anadig->pll1_num;
-		pll_denom_reg = &anadig->pll1_denom;
-		break;
-
-	case PLL_SYS: /* PLL2 */
-		pll_div_select_value = get_pll2_mult_value(mult);
-		if (pll_div_select_value < 0)
-			return -1;
-		pll_ctrl_reg = &anadig->pll2_ctrl;
-		pll_num_reg = &anadig->pll2_num;
-		pll_denom_reg = &anadig->pll2_denom;
-		break;
-
-	case PLL_USBOTG0: /* PLL3 */
-		pll_div_select_value = get_pll2_mult_value(mult);
-		if (pll_div_select_value < 0)
-			return -1;
-		pll_ctrl_reg = &anadig->pll3_ctrl;
-		break;
-
-	case PLL_USBOTG1: /* PLL7 */
-		pll_div_select_value = get_pll2_mult_value(mult);
-		if (pll_div_select_value < 0)
-			return -1;
-		pll_ctrl_reg = &anadig->pll7_ctrl;
-		break;
-
-	case PLL_AUDIO0: /* PLL4 */
-		if (check_pll1_mult_value(mult) < 0)
-			return -1;
-		pll_div_select_value = mult;
-		pll_ctrl_reg = &anadig->pll4_ctrl;
-		pll_num_reg = &anadig->pll4_num;
-		pll_denom_reg = &anadig->pll4_denom;
-		break;
-
-	case PLL_AUDIO1: /* PLL8 */
-		if (check_pll1_mult_value(mult) < 0)
-			return -1;
-		pll_div_select_value = mult;
-		pll_ctrl_reg = &anadig->pll8_ctrl;
-		pll_num_reg = &anadig->pll8_num;
-		pll_denom_reg = &anadig->pll8_denom;
-		break;
-
-	case PLL_VIDEO: /* PLL6 */
-		if (check_pll1_mult_value(mult) < 0)
-			return -1;
-		pll_div_select_value = mult;
-		pll_ctrl_reg = &anadig->pll6_ctrl;
-		pll_num_reg = &anadig->pll6_num;
-		pll_denom_reg = &anadig->pll6_denom;
-		break;
-
-	case PLL_ENET: /*PLL5 */
-		return 0;
-		break;
-
-	default:
-		return -1;
-		break;
-	}
-
-	/* Write frequency multiplier in PLL_CTRL_REG, DIV_SELECT field */
-	value = readl(pll_ctrl_reg);
-	value &= ~ANADIG_PLL1_CTRL_DIV_SELECT_MASK;
-	writel(value | pll_div_select_value, pll_ctrl_reg);
-
-	/* Set MFN and MFD */
-	if (pll_num_reg != -1)
-		writel(mfn, pll_num_reg);
-
-	if (pll_denom_reg != -1)
-		writel(mfd, pll_denom_reg);
-
-	return 0;
-}
-
-int enable_pll(enum pll_clocks pll)
-{
-	u32 reg = 0;
-	u32 value;
-	s32 timeout = 100000;
-	struct anadig_reg *anadig = (struct anadig_reg *)ANADIG_BASE_ADDR;
-
-	switch(pll)
-	{
-	case PLL_ARM: /* PLL1 */
-		reg = &anadig->pll1_ctrl;
-		break;
-	case PLL_SYS: /* PLL2 */
-		reg = &anadig->pll2_ctrl;
-		break;
-	case PLL_USBOTG0: /* PLL3 */
-		reg = &anadig->pll3_ctrl;
-		break;
-	case PLL_USBOTG1: /* PLL7 */
-		reg = &anadig->pll7_ctrl;
-		break;
-	case PLL_AUDIO0: /* PLL4 */
-		reg = &anadig->pll4_ctrl;
-		break;
-	case PLL_AUDIO1: /* PLL8 */
-		reg = &anadig->pll8_ctrl;
-		break;
-	case PLL_VIDEO: /* PLL6 */
-		reg = &anadig->pll6_ctrl;
-		break;
-	case PLL_ENET: /*PLL5 */
-		reg = &anadig->pll5_ctrl;
-		break;
-	default:
-		return -1;
-		break;
-	}
-
-	value = readl(reg);
-	if ((value & ANADIG_PLL_CTRL_POWERDOWN) ||
-		(!(value & ANADIG_PLL_CTRL_LOCK))) {
-		value &= ~ANADIG_PLL_CTRL_POWERDOWN;
-		writel(value, reg);
-		while (timeout--) {
-			if (readl(reg) &
-					ANADIG_PLL_CTRL_LOCK)
-				break;
-		}
-		if (timeout <= 0)
-			return -1;
-	}
-
-	/* Enable FEC clock */
-	value |= ANADIG_PLL_CTRL_ENABLE;
-	value &= ~ANADIG_PLL_CTRL_BYPASS;
-	writel(value, reg);
-
-	return 0;
-}
-
-/* PLL frequency decoding for pll_pfd in KHz                                                  */
-/* Only works for PLL_ARM, PLL_SYS, PLL_USB0, PLL_USB1, PLL_AUDIO0, PLL_AUDIO1, PLL_VIDEO     */
-/* PLL_ENET not implemented                                                                   */
-static u32 decode_pll(enum pll_clocks pll, u32 infreq, u8 pfd)
-{
-	u32 freq_main=0;
-	u32 mfi=0, pfd_frac=0;
-	u32 pll_ctrl, pll_num , pll_denom, pll_pfd;
-
-	struct anadig_reg *anadig = (struct anadig_reg *)ANADIG_BASE_ADDR;
-
-	switch (pll) {
-	case PLL_ARM: /* PLL1 */
-		pll_ctrl = readl(&anadig->pll1_ctrl);
-		pll_num = readl(&anadig->pll1_num);
-		pll_denom = readl(&anadig->pll1_denom);
-
-		mfi = pll_ctrl & ANADIG_PLL1_CTRL_DIV_SELECT_MASK;
-		return lldiv( (u64)infreq * ((u64)mfi*(u64)pll_denom + (u64)pll_num), pll_denom);
-	case PLL_SYS: /* PLL2 */
-		pll_ctrl = readl(&anadig->pll2_ctrl);
-		pll_num = readl(&anadig->pll2_num);
-		pll_denom = readl(&anadig->pll2_denom);
-		pll_pfd = readl(&anadig->pll2_pfd);
-
-		mfi = pll_ctrl & ANADIG_PLL2_CTRL_DIV_SELECT_MASK; /* bit 0*/
-		if (mfi == 0)
-			freq_main = infreq * 20; /* 480 Mhz */
-		else
-			freq_main = infreq * 22; /* 528 Mhz */
-		switch(pfd){
-		case 0:
-			return freq_main;
-		case 1:
-			pfd_frac = (pll_pfd & ANADIG_PLL_PFD1_FRAC_MASK) >> ANADIG_PLL_PFD1_OFFSET;
-			return freq_main*18/pfd_frac;
-		case 2:
-			pfd_frac = (pll_pfd & ANADIG_PLL_PFD2_FRAC_MASK) >> ANADIG_PLL_PFD2_OFFSET;
-			return freq_main*18/pfd_frac;
-		case 3:
-			pfd_frac = (pll_pfd & ANADIG_PLL_PFD3_FRAC_MASK) >> ANADIG_PLL_PFD3_OFFSET;
-			return freq_main*18/pfd_frac;
-		case 4:
-			pfd_frac = (pll_pfd & ANADIG_PLL_PFD4_FRAC_MASK) >> ANADIG_PLL_PFD4_OFFSET;
-			return freq_main*18/pfd_frac;
-		default:
-			printf("pfd id not supported:%d\n",pfd);
-			return -1;
-		} /* switch(pfd) */
-	case PLL_USBOTG0: /* PLL3 */
-		pll_ctrl = readl(&anadig->pll3_ctrl);
-		pll_pfd = readl(&anadig->pll3_pfd);
-
-		mfi = (pll_ctrl & ANADIG_PLL3_CTRL_DIV_SELECT_MASK); /*bit 0*/
-		if (mfi == 0)
-			freq_main = infreq * 20; /* 480 Mhz */
-		else
-			freq_main = infreq * 22; /* 528 Mhz */
-
-		switch(pfd){
-		case 0:
-			return freq_main;
-		case 1:
-			pfd_frac = (pll_pfd & ANADIG_PLL_PFD1_FRAC_MASK) >> ANADIG_PLL_PFD1_OFFSET;
-			return freq_main*18/pfd_frac;
-		case 2:
-			pfd_frac = (pll_pfd & ANADIG_PLL_PFD2_FRAC_MASK) >> ANADIG_PLL_PFD2_OFFSET;
-			return freq_main*18/pfd_frac;
-		case 3:
-			pfd_frac = (pll_pfd & ANADIG_PLL_PFD3_FRAC_MASK) >> ANADIG_PLL_PFD3_OFFSET;
-			return freq_main*18/pfd_frac;
-		case 4:
-			pfd_frac = (pll_pfd & ANADIG_PLL_PFD4_FRAC_MASK) >> ANADIG_PLL_PFD4_OFFSET;
-			return freq_main*18/pfd_frac;
-		default:
-			printf("pfd id not supported:%d\n",pfd);
-			return -1;
-		} /* switch(pfd) */
-	case PLL_USBOTG1: /* PLL7 */
-		pll_ctrl = readl(&anadig->pll7_ctrl);
-
-		mfi = pll_ctrl & ANADIG_PLL7_CTRL_DIV_SELECT_MASK; /*bit 0 */
-
-		if (mfi == 0)
-			freq_main = infreq * 20; /* 480 Mhz */
-		else
-			freq_main = infreq * 22; /* 528 Mhz */
-		return freq_main;
-	case PLL_AUDIO0: /* PLL4 */
-		pll_ctrl = readl(&anadig->pll4_ctrl);
-		pll_num = (readl(&anadig->pll4_num) & ANADIG_PLL_NUM_MASK);
-		pll_denom = (readl(&anadig->pll4_denom) & ANADIG_PLL_DENOM_MASK);
-		
-		mfi = pll_ctrl & ANADIG_PLL4_CTRL_DIV_SELECT_MASK;
-
-		return lldiv( (u64)infreq * ((u64)mfi*(u64)pll_denom + (u64)pll_num), pll_denom);
-	case PLL_AUDIO1: /* PLL8 */
-		pll_ctrl = readl(&anadig->pll8_ctrl);
-		pll_num = (readl(&anadig->pll8_num) & ANADIG_PLL_NUM_MASK);
-		pll_denom = (readl(&anadig->pll8_denom) & ANADIG_PLL_DENOM_MASK);
-
-		mfi = pll_ctrl & ANADIG_PLL8_CTRL_DIV_SELECT_MASK;
-
-		return lldiv( (u64)infreq * ((u64)mfi*(u64)pll_denom + (u64)pll_num), pll_denom);
-	case PLL_VIDEO: /* PLL6 */
-		pll_ctrl = readl(&anadig->pll6_ctrl);
-		pll_num = (readl(&anadig->pll6_num) & ANADIG_PLL_NUM_MASK);
-		pll_denom = (readl(&anadig->pll6_denom) & ANADIG_PLL_DENOM_MASK);
-
-		mfi = pll_ctrl & ANADIG_PLL6_CTRL_DIV_SELECT_MASK;
-
-		return lldiv( (u64)infreq * ((u64)mfi*(u64)pll_denom + (u64)pll_num), pll_denom);
-	case PLL_ENET: /*PLL5 */
-		printf("PLL decode not supported for PLL_ENET\n");
-		return -1;
-	default:
-		printf("not able to decode the PLL frequency - PLL ID doesn't exist\n");
-		return -1;
-	} /* switch(pll) */
-}
-
-
-int is_pll_locked(enum pll_clocks pll)
-{
-	struct anadig_reg *anadig = (struct anadig_reg *)ANADIG_BASE_ADDR;
-	u32 anadig_pll_lock;
-	u32 mask;
-
-	anadig_pll_lock = readl(&anadig->pll_lock);
-
-	switch(pll)
-	{
-	case PLL_ARM: /* PLL1 */
-		mask = ANADIG_PLL1_LOCKED;
-		break;
-	case PLL_SYS: /* PLL2 */
-		mask = ANADIG_PLL2_LOCKED;
-		break;
-	case PLL_USBOTG0: /* PLL3 */
-		mask = ANADIG_PLL3_LOCKED;
-		break;
-	case PLL_USBOTG1: /* PLL7 */
-		mask = ANADIG_PLL7_LOCKED;
-		break;
-	case PLL_AUDIO0: /* PLL4 */
-		mask = ANADIG_PLL4_LOCKED;
-		break;
-	case PLL_AUDIO1: /* PLL8 */
-		mask = ANADIG_PLL8_LOCKED;
-		break;
-	case PLL_VIDEO: /* PLL6 */
-		mask = ANADIG_PLL6_LOCKED;
-		break;
-	case PLL_ENET: /*PLL5 */
-		mask = ANADIG_PLL5_LOCKED;
-		break;
-	default:
-		return 0;
-		break;
-	}
-
-	return ( (anadig_pll_lock & mask) == mask);
-}
-
-#define MIN_PFD_FRAC_VALUE	12
-#define MAX_PFD_FRAC_VALUE	35
-int config_pll_pfd_frac(enum pll_clocks pll, enum pll_pfds pfd, u8 frac)
-{
-	struct anadig_reg *anadig = (struct anadig_reg *)ANADIG_BASE_ADDR;
-	u32 pll_ctrl_reg;
-	u32 pfd_mask;
-	u32 pfd_offset;
-	u32 value;
-
-	/* Only PLL2 and PLL3 have PFDs */
-	if (pll == PLL_SYS)
-		pll_ctrl_reg = &anadig->pll2_pfd;
-	else if (pll == PLL_USBOTG0)
-		pll_ctrl_reg = &anadig->pll3_pfd;
-	else
-		return -1;
-
-	/* Verify FRAC value is valid */
-	if ((frac>MAX_PFD_FRAC_VALUE)||(frac<MIN_PFD_FRAC_VALUE))
-		return -1;
-
-	switch(pfd)
-	{
-	case PLL_PFD1:
-		pfd_mask = ANADIG_PLL_PFD1_FRAC_MASK;
-		pfd_offset = ANADIG_PLL_PFD1_OFFSET;
-		break;
-
-	case PLL_PFD2:
-		pfd_mask = ANADIG_PLL_PFD2_FRAC_MASK;
-		pfd_offset = ANADIG_PLL_PFD2_OFFSET;
-		break;
-
-	case PLL_PFD3:
-		pfd_mask = ANADIG_PLL_PFD3_FRAC_MASK;
-		pfd_offset = ANADIG_PLL_PFD3_OFFSET;
-		break;
-
-	case PLL_PFD4:
-		pfd_mask = ANADIG_PLL_PFD4_FRAC_MASK;
-		pfd_offset = ANADIG_PLL_PFD4_OFFSET;
-		break;
-
-	default:
-		return -1;
-		break;
-	}
-
-	/* Write PFD frac in PFD register */
-	value = readl(pll_ctrl_reg);
-	value &= ~pfd_mask;
-	writel(value | (frac<<pfd_offset), pll_ctrl_reg);
-
-	return 0;
-}
-
-int enable_pll_pfd(enum pll_clocks pll, enum pll_pfds pfd, u8 enable)
-{
-	struct anadig_reg *anadig = (struct anadig_reg *)ANADIG_BASE_ADDR;
-	u32 pll_ctrl_reg;
-	u32 pfd_clkgate_mask;
-	u32 value;
-
-	/* Only PLL2 and PLL3 have PFDs */
-	if (pll == PLL_SYS)
-		pll_ctrl_reg = &anadig->pll2_pfd;
-	else if (pll == PLL_USBOTG0)
-		pll_ctrl_reg = &anadig->pll3_pfd;
-	else
-		return -1;
-
-	switch(pfd)
-	{
-	case PLL_PFD1:
-		pfd_clkgate_mask = ANADIG_PLL_PFD1_CLKGATE_MASK;
-		break;
-
-	case PLL_PFD2:
-		pfd_clkgate_mask = ANADIG_PLL_PFD2_CLKGATE_MASK;
-		break;
-
-	case PLL_PFD3:
-		pfd_clkgate_mask = ANADIG_PLL_PFD3_CLKGATE_MASK;
-		break;
-
-	case PLL_PFD4:
-		pfd_clkgate_mask = ANADIG_PLL_PFD4_CLKGATE_MASK;
-		break;
-
-	default:
-		return -1;
-		break;
-	}
-
-	/* Enable/disable PFD in PFD register */
-	value = readl(pll_ctrl_reg);
-
-	if (enable)
-		value &= ~pfd_clkgate_mask;
-	else
-		value |= pfd_clkgate_mask;
-
-	writel(value, pll_ctrl_reg);
-
-	return 0;
-}
-
-
-
-/* return ARM A7 clock frequency in Hz                         */
-static u32 get_mcu_main_clk(void)
-{
-	struct ccm_reg *ccm = (struct ccm_reg *)CCM_BASE_ADDR;
-	u32 ccm_a7_clk, armclk_div;
-	u32 a7clk_sel;
-	u32 freq = 0;
-
-	ccm_a7_clk = readl(&ccm->a7_clk);
-	a7clk_sel = ccm_a7_clk & CCM_MUX4_CTL_MASK;
-	armclk_div = ((ccm_a7_clk & CCM_PREDIV3_CTRL_MASK) >> CCM_PREDIV_CTRL_OFFSET)+1;
-
-	switch (a7clk_sel) {
-	case 1:
-		freq = FIRC_CLK_FREQ;
-		break;
-	case 2:
-		freq = FAST_CLK_FREQ;
-		break;
-	case 3:
-		freq = decode_pll(PLL_ARM,24000,0); /* arm_pll_clk */
-		break;
-	case 4:
-		freq = decode_pll(PLL_SYS,24000,0); /* sys_pll_main */
-		break;
-	case 5:
-		freq = decode_pll(PLL_SYS,24000,1); /* sys_pll_pfd0 */
-		break;
-	case 6:
-		freq = decode_pll(PLL_SYS,24000,2); /* sys_pll_pfd1 */
-		break;
-	case 7:
-		freq = decode_pll(PLL_SYS,24000,3); /* sys_pll_pfd2 */
-		break;
-	case 8:
-		freq = decode_pll(PLL_SYS,24000,4); /* sys_pll_pfd3 */
-		break;
-	case 9:
-		freq = decode_pll(PLL_USBOTG0,24000,0); /* usb0_pll_main */
-		break;
-	case 10:
-		freq = decode_pll(PLL_USBOTG0,24000,1); /* usb0_pll_pfd0 */
-		break;
-	case 11:
-		freq = decode_pll(PLL_ARM,24000,0)/2; /* arm_pll_clk/2 */
-		break;
-	default:
-		printf("unsupported arm clock select\n");
-		return -1;
-	}
-
-	return ((freq * 1000) / armclk_div);
-}
-
-/* return the qos301, DDR or bus clock  frequency in Hz depending on id */
-/* id==0 => get the qos301_clk                                          */
-/* id==1 => get the bus_clk                                             */
-/* id==2 => get the DDR_clk                                             */
-static u32 get_bus_clk(u8 id)
-{
-	struct ccm_reg *ccm = (struct ccm_reg *)CCM_BASE_ADDR;
-	u32 ccm_qos_ddr_clk, ccm_qos_clk, ccm_bus_clk, qosclk_div, busclk_div;
-	u32 qosclk_sel;
-	u32 freq = 0;
-
-	ccm_qos_ddr_clk = readl(&ccm->QoS_DDR_root);
-	qosclk_sel = ccm_qos_ddr_clk & CCM_MUX4_CTL_MASK;
-	ccm_qos_clk = readl(&ccm->QoS301_clk);
-	qosclk_div = ((ccm_qos_clk & CCM_PREDIV3_CTRL_MASK) >> CCM_PREDIV_CTRL_OFFSET)+1;
-	ccm_bus_clk = readl(&ccm->BUS_clk);
-	busclk_div = ((ccm_bus_clk & CCM_PREDIV3_CTRL_MASK) >> CCM_PREDIV_CTRL_OFFSET)+1;
-
-	switch (qosclk_sel) {
-	case 1:
-		freq = FIRC_CLK_FREQ;
-		break;
-	case 2:
-		freq = FAST_CLK_FREQ;
-		break;
-	case 3:
-		freq = decode_pll(PLL_ARM,24000,0); /* arm_pll_clk */
-		break;
-	case 4:
-		freq = decode_pll(PLL_SYS,24000,0); /* sys_pll_main */
-		break;
-	case 5:
-		freq = decode_pll(PLL_SYS,24000,1); /* sys_pll_pfd0 */
-		break;
-	case 6:
-		freq = decode_pll(PLL_SYS,24000,2); /* sys_pll_pfd1 */
-		break;
-	case 7:
-		freq = decode_pll(PLL_SYS,24000,3); /* sys_pll_pfd2 */
-		break;
-	case 8:
-		freq = decode_pll(PLL_SYS,24000,4); /* sys_pll_pfd3 */
-		break;
-	case 9:
-		freq = decode_pll(PLL_USBOTG0,24000,0); /* usb0_pll_main */
-		break;
-	case 10:
-		freq = decode_pll(PLL_USBOTG0,24000,1); /* usb0_pll_pfd0 */
-		break;
-	case 11:
-		freq = decode_pll(PLL_ARM,24000,0)/2; /* arm_pll_clk/2 */
-		break;
-	default:
-		printf("unsupported qos301 clock select\n");
-		return -1;
-	}
-
-	switch(id) {
-	case 0:
-		return ((freq*1000) / qosclk_div); /* qos301_clk */
-	case 1:
-		return ((freq*1000) / qosclk_div / busclk_div); /* bus_clk */
-	case 2:
-		return ((freq*1000) / qosclk_div); /* DDR_clk */
-	default:
-		printf("unsupported id:%d for get_bus_clk()\n",id);
-		return -1;
-	}
-}
-
-/* return ipg_clk frequency in Hz                         */
-static u32 get_ipg_clk(void)
-{
-	struct ccm_reg *ccm = (struct ccm_reg *)CCM_BASE_ADDR;
-	u32 ccm_per_clk, ipgclk_div;
-
-	ccm_per_clk = readl(&ccm->PER_clk);
-	ipgclk_div = ((ccm_per_clk & CCM_PREDIV3_CTRL_MASK) >> CCM_PREDIV_CTRL_OFFSET)+1;
-
-	return (get_bus_clk(1) / ipgclk_div);
-}
-
-static u32 get_uart_clk(void)
-{
-	return get_ipg_clk();
-}
-
-/* return the sdhc clock frequency for the SDHC(id) controller with id=[0..2] in Hz */
-static u32 get_sdhc_clk(u8 id)
-{
-	struct ccm_reg *ccm = (struct ccm_reg *)CCM_BASE_ADDR;
-	u32 ccm_sdhc_clk, sdhcclk_sel, sdhcclk_div, sdhcclk_fracdiv;
-	u32 freq = 0;
-
-	switch (id) {
-	case 0:
-	ccm_sdhc_clk = readl(&ccm->uSDHC0_perclk);
-		break;
-	case 1:
-	ccm_sdhc_clk = readl(&ccm->uSDHC1_perclk);
-		break;
-	case 2:
-	ccm_sdhc_clk = readl(&ccm->uSDHC2_perclk);
-		break;
-	default:
-		printf("uSDHC not defined\n");
-		return -1;
-	}
-
-	sdhcclk_sel = ccm_sdhc_clk & CCM_MUX3_CTL_MASK;
-	sdhcclk_div = ((ccm_sdhc_clk & CCM_PREDIV3_CTRL_MASK) >> CCM_PREDIV_CTRL_OFFSET)+1;
-	sdhcclk_fracdiv = ((ccm_sdhc_clk & CCM_PREDIV_FRAC_DIV_CTRL_MASK) >>CCM_PREDIV_FRAC_DIV_CTRL_OFFSET)+1;
-	
-	switch (sdhcclk_sel) {
-	case 0:
-		freq = decode_pll(PLL_ARM,24000,0); /* arm_pll_clk */
-		break;
-	case 1:
-		freq = decode_pll(PLL_SYS,24000,0); /* sys_pll_clk */
-		break;
-	case 2:
-		freq = decode_pll(PLL_SYS,24000,2); /* sys_pll_pfd1 */
-		break;
-	case 3:
-		freq = decode_pll(PLL_USBOTG0,24000,0); /* usb0_pll_main */
-		break;
-	case 4:
-		freq = decode_pll(PLL_USBOTG0,24000,1); /* usb0_pll_pfd0 */
-		break;
-	case 5:
-		freq = decode_pll(PLL_ARM,24000,0)/2; /* arm_pll_clk/2 */
-		break;
-	case 6:
-		freq = get_bus_clk(0)/1000; /* QoS301_clk */
-		break;
-	default:
-		printf("unsupported sdhc clock select\n");
-		return -1;
-	}
-	return ((freq*1000) / sdhcclk_div / sdhcclk_fracdiv);
-}
-
-/* return ENET_clk in Hz                         */
-u32 get_fec_clk(void)
-{
-	return 50000000;
-}
-
-/* return I2C_clk frequency in Hz                         */
-static u32 get_i2c_clk(void)
-{
-	return get_ipg_clk();
-}
-
-#ifdef CONFIG_SYS_I2C_MXC
-/* i2c_num can be from 0 - 3 */
-int enable_i2c_clk(unsigned char enable, unsigned i2c_num)
-{
-	u32 aips_num, periph_number;
-
-	if (i2c_num > 3)
-		return -EINVAL;
-
-	switch (i2c_num) {
-		case 0:
-			aips_num = AIPS1;
-			periph_number = AIPS1_OFF_I2C0;
-			break;
-		case 1:
-			aips_num = AIPS1;
-			periph_number = AIPS1_OFF_I2C1;
-			break;
-		case 2:
-			aips_num = AIPS2;
-			periph_number = AIPS2_OFF_I2C2;
-			break;
-		case 3:
-			aips_num = AIPS2;
-			periph_number = AIPS2_OFF_I2C3;
-			break;
-	}
-
-	if (enable)
-		enable_periph_clk(aips_num, periph_number);
-	else
-		disable_periph_clk(aips_num, periph_number);
-
-	return 0;
-}
-#endif
-
-
-/* return NFC_clk frequency in Hz                         */
-static u32 get_nfc_clk(void)
-{
-	struct ccm_reg *ccm = (struct ccm_reg *)CCM_BASE_ADDR;
-	u32 freq, ccm_nfc_clk, nfc_clk_sel, nfcclk_div, nfcclk_fracdiv;
-
-	ccm_nfc_clk = readl(&ccm->nfc_flash_clk_div);
-	nfc_clk_sel = ccm_nfc_clk & CCM_MUX3_CTL_MASK;
-	nfcclk_div = ((ccm_nfc_clk & CCM_PREDIV4_CTRL_MASK) >> CCM_PREDIV_CTRL_OFFSET)+1;
-	nfcclk_fracdiv = ((ccm_nfc_clk & CCM_PREDIV_FRAC_DIV_CTRL_MASK) >> CCM_PREDIV_FRAC_DIV_CTRL_OFFSET)+1;
-
-	switch(nfc_clk_sel)
-	{
-	case 0:
-		freq = decode_pll(PLL_SYS,24000,0); /* sys_pll_clk */
-		break;
-	case 1:
-		freq = decode_pll(PLL_SYS,24000,2); /* sys_pll_pfd1 */
-		break;
-	case 2:
-		freq = decode_pll(PLL_SYS,24000,3); /* sys_pll_pfd2 */
-		break;
-	case 3:
-		freq = decode_pll(PLL_SYS,24000,4); /* sys_pll_pfd3 */
-		break;
-	case 4:
-		freq = decode_pll(PLL_USBOTG0,24000,0); /* usb0_pll_main */
-		break;
-	case 5:
-		freq = decode_pll(PLL_USBOTG0,24000,3); /* usb0_pll_pfd2 */
-		break;
-	case 6:
-		freq = decode_pll(PLL_USBOTG0,24000,4); /* usb0_pll_pfd3 */
-		break;
-	case 7:
-		freq = get_bus_clk(0)/1000; /* QoS301_clk */
-		break;
-	} /* switch(nfc_clk_sel) */
-	return ((freq*1000)/nfcclk_fracdiv/nfcclk_div);
-}
-
-unsigned int mxc_get_clock(enum mxc_clock clk)
-{
-	switch (clk) {
-	case MXC_ARM_CLK:
-		return get_mcu_main_clk();
-	case MXC_BUS_CLK:
-		return get_bus_clk(1);
-	case MXC_IPG_CLK:
-		return get_ipg_clk();
-	case MXC_UART_CLK:
-		return get_uart_clk();
-	case MXC_USDHC0_CLK:
-		return get_sdhc_clk(0);
-	case MXC_USDHC1_CLK:
-		return get_sdhc_clk(1);
-	case MXC_USDHC2_CLK:
-		return get_sdhc_clk(2);
-	case MXC_FEC_CLK:
-		return get_fec_clk();
-	case MXC_I2C_CLK:
-		return get_i2c_clk();
-	case MXC_DDR_CLK:
-		return get_bus_clk(2);
-	case MXC_NFC_CLK:
-		return get_nfc_clk();
-	default:
-		printf("Not able to get the clock freq - unsupported clk id:%d\n",clk);
-		return -1;
-	}
-}	
-
-/* Dump some core clocks */
-int do_sac58r_showclocks(cmd_tbl_t *cmdtp, int flag, int argc,
-			 char * const argv[])
-{
-	printf("\n");
-	printf("-------------------------------------------------------------------------------------------------------\n");
-	printf("DPLLs settings:\n");
-	printf("PLL_ARM  main: %5d MHz (locked: %d)\n",
-		decode_pll(PLL_ARM, 24000,0)/1000,
-		is_pll_locked(PLL_ARM) );
-	printf("PLL_SYS  main: %5d MHz (locked: %d) - PFD1:%5d MHz - PFD2:%5d MHz - PFD3:%5d MHz - PFD4:%5d MHz\n",
-		decode_pll(PLL_SYS, 24000,0)/1000,
-		is_pll_locked(PLL_SYS),
-		decode_pll(PLL_SYS, 24000,1)/1000,
-		decode_pll(PLL_SYS, 24000,2)/1000,
-		decode_pll(PLL_SYS, 24000,3)/1000,
-		decode_pll(PLL_SYS, 24000,4)/1000);
-	printf("PLL_USB0 main: %5d MHz (locked: %d) - PFD1:%5d MHz - PFD2:%5d MHz - PFD3:%5d MHz - PFD4:%5d MHz\n",
-		decode_pll(PLL_USBOTG0, 24000,0)/1000,
-		is_pll_locked(PLL_USBOTG0),
-		decode_pll(PLL_USBOTG0, 24000,1)/1000,
-		decode_pll(PLL_USBOTG0, 24000,2)/1000,
-		decode_pll(PLL_USBOTG0, 24000,3)/1000,
-		decode_pll(PLL_USBOTG0, 24000,4)/1000);
-	printf("PLL_USB1 main: %5d MHz (locked: %d)\n",
-		decode_pll(PLL_USBOTG1, 24000,0)/1000,
-		is_pll_locked(PLL_USBOTG1) );
-	printf("PLL_AUD0 main: %5d MHz (locked: %d)\n",
-		decode_pll(PLL_AUDIO0, 24000,0)/1000,
-		is_pll_locked(PLL_AUDIO0) );
-	printf("PLL_AUD1 main: %5d MHz (locked: %d)\n",
-		decode_pll(PLL_AUDIO1, 24000,0)/1000,
-		is_pll_locked(PLL_AUDIO1) );
-	printf("PLL_VID  main: %5d MHz (locked: %d)\n",
-		decode_pll(PLL_VIDEO, 24000,0)/1000,
-		is_pll_locked(PLL_VIDEO) );
-	printf("-------------------------------------------------------------------------------------------------------\n");
-	printf("Root clocks:\n");
-	printf("CPU A7 clock:  %5d MHz\n", mxc_get_clock(MXC_ARM_CLK) / 1000000);
-	printf("BUS clock:     %5d MHz\n", mxc_get_clock(MXC_BUS_CLK) / 1000000);
-	printf("IPG clock:     %5d MHz\n", mxc_get_clock(MXC_IPG_CLK) / 1000000);
-	printf("DDR clock:     %5d MHz\n", mxc_get_clock(MXC_DDR_CLK) / 1000000);
-	printf("uSDHC0 clock:  %5d MHz\n", mxc_get_clock(MXC_USDHC0_CLK) / 1000000);
-	printf("uSDHC1 clock:  %5d MHz\n", mxc_get_clock(MXC_USDHC1_CLK) / 1000000);
-	printf("uSDHC2 clock:  %5d MHz\n", mxc_get_clock(MXC_USDHC2_CLK) / 1000000);
-	printf("ENET clock:    %5d MHz\n", mxc_get_clock(MXC_FEC_CLK) / 1000000);
-	printf("UART clock:    %5d MHz\n", mxc_get_clock(MXC_UART_CLK) / 1000000);
-	printf("I2C clock:     %5d MHz\n", mxc_get_clock(MXC_I2C_CLK) / 1000000);
-	printf("NFC clock:     %5d MHz\n", mxc_get_clock(MXC_NFC_CLK) /1000000);
-	return 0;
-}
-
-U_BOOT_CMD(
-	clocks, CONFIG_SYS_MAXARGS, 1, do_sac58r_showclocks,
-	"display clocks",
-	""
-);
-
-#ifdef CONFIG_FEC_MXC
-void imx_get_mac_from_fuse(int dev_id, unsigned char *mac)
-{
-	struct ocotp_regs *ocotp = (struct ocotp_regs *)OCOTP_BASE_ADDR;
-	struct fuse_bank *bank = &ocotp->bank[4];
-	struct fuse_bank4_regs *fuse =
-		(struct fuse_bank4_regs *)bank->fuse_regs;
-
-	u32 value = readl(&fuse->mac_addr0);
-	mac[0] = (value >> 8);
-	mac[1] = value;
-
-	value = readl(&fuse->mac_addr1);
-	mac[2] = value >> 24;
-	mac[3] = value >> 16;
-	mac[4] = value >> 8;
-	mac[5] = value;
-}
-#endif
-
-#if defined(CONFIG_DISPLAY_CPUINFO)
-
-
-static const char* sac58r_reset_cause[] =
-{
-	"POR reset",
-	"watchdog0 timer",
-	"unknown",
-	"watchdog2",
-	"watchdog1",
-	"JTAG HIGH-Z",
-	"unknown",
-	"external reset",
-	"unknown",
-	"HP LVD",
-	"ULP LVD",
-	"unknown",
-	"LP_LVD",
-	"unknown",
-	"unknown",
-	"unknown",
-	"MDM SYS RST",
-	"SNVS hard reset",
-	"SW reset",
-	"SNVS WDOG",
-	"LVD memory brownout",
-	"ULPVDD HVD",
-	"LPVDD HVD",
-	"HPVDD HVD",
-	"1.1V unstable",
-	"2.5V unstable",
-	"3.0V unstable",
-	"FOSC freq < 40 MHz",
-	"BUS freq out of range",
-	"No clock on FOSC",
-	"No clock on SOSC",
-	"CM4 in lockup",
-};
-
-#define RESET_CAUSE_POR			(1<<0)
-#define RESET_CAUSE_EXTERNAL	(1<<7)
-#define RESET_CAUSE_SOFTWARE	(1<<18)
-#define RESET_CAUSE_WDOG		(1<<1)
-#define SRC_SCR_SW_RST			(1<<12)
-
-static void print_reset_cause(void)
-{
-	u32 cause;
-	int i;
-
-	struct src *src_regs = (struct src *)SRC_BASE_ADDR;
-
-	cause = readl(&src_regs->srsr);
-	writel(cause, &src_regs->srsr);
-
-
-	/* Reset cause register returns a lot of information that
-		are not needed in most reset cases:
-		- watchdog
-		- POR
-		- external reset
-		- software reset
-		The routine catches the most common causes of reset
-		and ignore the others.
-		If these common cases are not detected, we then
-		print all reset cases
-	*/
-
-	if (cause & RESET_CAUSE_WDOG) {
-		printf ("Reset cause (0x%08x): %s\n", cause, sac58r_reset_cause[1]);
-		return;
-	}
-
-
-	if (cause & RESET_CAUSE_POR) {
-		printf ("Reset cause (0x%08x): %s\n", cause, sac58r_reset_cause[0]);
-		return;
-	}
-
-	if (cause & RESET_CAUSE_EXTERNAL) {
-		printf ("Reset cause (0x%08x): %s\n", cause, sac58r_reset_cause[7]);
-		return;
-	}
-
-	if (cause & RESET_CAUSE_SOFTWARE) {
-		printf ("Reset cause (0x%08x): %s\n", cause, sac58r_reset_cause[18]);
-		return;
-	}
-
-	printf("Reset cause (0x%08x): \n", cause);
-	i = 0;
-	while (cause != 0) {
-		if ((cause & 0x1) == 1) {
-			if (strcmp(sac58r_reset_cause[i], "unknown")) {
-				printf("- %s\n", sac58r_reset_cause[i]);
-				}
-			}
-		cause = cause >> 1;
-		i++;
-	}
-}
-
-void reset_cpu(ulong addr)
-{
-	struct src *src_regs = (struct src *)SRC_BASE_ADDR;
-
-	/* Generate a SW reset from SRC SCR register */
-	writel(SRC_SCR_SW_RST, &src_regs->scr);
-
-	/* If we get there, we are not in good shape */
-	mdelay(1000);
-	printf("FATAL: Reset Failed!\n");
-	hang();
-};
-
-int print_cpuinfo(void)
-{
-	printf("CPU:   Freescale SAC58R at %d MHz\n",
-		mxc_get_clock(MXC_ARM_CLK) / 1000000);
-	print_reset_cause();
-
-	return 0;
-}
-#endif
-
-int cpu_eth_init(bd_t *bis)
-{
-	int rc = -ENODEV;
-
-#if defined(CONFIG_FEC_MXC)
-	rc = fecmxc_initialize(bis);
-#endif
-
-	return rc;
-}
-
-#ifdef CONFIG_FSL_ESDHC
-int cpu_mmc_init(bd_t *bis)
-{
-	return fsl_esdhc_mmc_init(bis);
-}
-#endif
-
-int get_clocks(void)
-{
-#ifdef CONFIG_FSL_ESDHC
-#ifdef CONFIG_FSL_USDHC
-#if CONFIG_SYS_FSL_ESDHC_ADDR == USDHC0_BASE_ADDR
-	gd->arch.sdhc_clk = mxc_get_clock(MXC_USDHC0_CLK);
-#elif CONFIG_SYS_FSL_ESDHC_ADDR == USDHC1_BASE_ADDR
-	gd->arch.sdhc_clk = mxc_get_clock(MXC_USDHC1_CLK);
-#elif CONFIG_SYS_FSL_ESDHC_ADDR == USDHC1_BASE_ADDR
-	gd->arch.sdhc_clk = mxc_get_clock(MXC_USDHC2_CLK);
-#endif /* #if CONFIG_SYS_FSL_ESDHC_ADDR */
-#endif /* #ifdef CONFIG_FSL_USDHC */
-#endif /* #ifdef CONFIG_FSL_ESDHC */
-	return 0;
-}
-
-#ifndef CONFIG_SYS_DCACHE_OFF
-void enable_caches(void)
-{
-	/* Enable D-cache. I-cache is already enabled in start.S */
-	dcache_enable();
-}
-#endif
diff --git a/arch/arm/cpu/armv7/sac58r/soc.c b/arch/arm/cpu/armv7/sac58r/soc.c
deleted file mode 100644
index 4c29d650e5..0000000000
--- a/arch/arm/cpu/armv7/sac58r/soc.c
+++ /dev/null
@@ -1,258 +0,0 @@
-/*
- * (C) Copyright 2007,
- * Sascha Hauer, Pengutronix
- *
- * (C) Copyright 2009-2013 Freescale Semiconductor, Inc.
- *
- * SPDX-License-Identifier:	GPL-2.0+
- */
-
-#include <common.h> 
-#include <asm/armv7.h> 
-#include <asm/pl310.h> 
-#include <asm/errno.h> 
-#include <asm/io.h> 
-#include <linux/libfdt.h>
-#include <stdbool.h> 
-
-#if defined(CONFIG_SECURE_BOOT) 
-#include <asm/arch-sac58r/sac58r_secure.h> 
-#endif 
-
-#ifdef CONFIG_ARCH_MISC_INIT 
-int arch_misc_init(void) 
-{ 
-#ifdef CONFIG_SECURE_BOOT 
-	get_hab_status(); 
-#endif 
-	return 0; 
-} 
-#endif /* !CONFIG_ARCH_MISC_INIT */ 
-
-#ifdef CONFIG_SECURE_BOOT 
-
-#define hab_rvt_report_event_p	HAB_RVT_REPORT_EVENT				 
-
-
-#define hab_rvt_report_status_p	HAB_RVT_REPORT_STATUS
-
-
-#define hab_rvt_authenticate_image_p	HAB_RVT_AUTHENTICATE_IMAGE			
-
-
-#define hab_rvt_entry_p	HAB_RVT_ENTRY						 
- 
-
-#define hab_rvt_exit_p	HAB_RVT_EXIT
-									 
-
-
-#define IVT_SIZE		0x20 
-#define ALIGN_SIZE		0x1000 
-#define CSF_PAD_SIZE		0x2000 
-
-/* 
- * +------------+  0x0 (DDR_UIMAGE_START) - 
- * |   Header   |                          | 
- * +------------+  0x40                    | 
- * |            |                          | 
- * |            |                          | 
- * |            |                          | 
- * |            |                          | 
- * | Image Data |                          | 
- * .            |                          | 
- * .            |                           > Stuff to be authenticated ----+ 
- * .            |                          |                                | 
- * |            |                          |                                | 
- * |            |                          |                                | 
- * +------------+                          |                                | 
- * |            |                          |                                | 
- * | Fill Data  |                          |                                | 
- * |            |                          |                                | 
- * +------------+ Align to ALIGN_SIZE      |                                | 
- * |    IVT     |                          |                                | 
- * +------------+ + IVT_SIZE              -                                 | 
- * |            |                                                           | 
- * |  CSF DATA  | <---------------------------------------------------------+ 
- * |            | 
- * +------------+ 
- * |            | 
- * | Fill Data  | 
- * |            | 
- * +------------+ + CSF_PAD_SIZE 
- */ 
-
-int check_hab_enable(void) 
-{ 
-	u32 reg; 
-	int result = 0; 
-	struct iim_regs *iim = (struct iim_regs *)IMX_IIM_BASE; 
-	struct fuse_bank *bank = &iim->bank[0]; 
-	struct fuse_bank0_regs *fuse_bank0 = 
-			(struct fuse_bank0_regs *)bank->fuse_regs; 
-
-	reg = readl(&fuse_bank0->cfg5); 
-	if (reg & 0x2) 
-		result = 1; 
-
-	return result; 
-} 
-
-void display_event(uint8_t *event_data, size_t bytes) 
-{ 
-	uint32_t i; 
-	if ((event_data) && (bytes > 0)) { 
-		for (i = 0; i < bytes; i++) { 
-			if (i == 0) 
-				printf("\t0x%02x", event_data[i]); 
-			else if ((i % 8) == 0) 
-				printf("\n\t0x%02x", event_data[i]); 
-			else 
-				printf(" 0x%02x", event_data[i]); 
-		} 
-	} 
-} 
-
-int get_hab_status(void) 
-{ 
-	uint32_t index = 0; /* Loop index */ 
-	uint8_t event_data[128]; /* Event data buffer */ 
-	size_t bytes = sizeof(event_data); /* Event size in bytes */ 
-	hab_config_t config = 0; 
-	hab_state_t state = 0; 
-	hab_rvt_report_event_t *hab_rvt_report_event; 
-	hab_rvt_report_status_t *hab_rvt_report_status; 
-
-	hab_rvt_report_event = hab_rvt_report_event_p; 
-	hab_rvt_report_status = hab_rvt_report_status_p; 
-
-	/* Check HAB status */ 
-	if (hab_rvt_report_status(&config, &state) != HAB_SUCCESS) { 
-		printf("\nHAB Configuration: 0x%02x, HAB State: 0x%02x\n", 
-			config, state); 
-
-		/* Display HAB Error events */ 
-		while (hab_rvt_report_event(HAB_FAILURE, index, event_data, 
-				&bytes) == HAB_SUCCESS) { 
-			printf("\n"); 
-			printf("--------- HAB Event %d -----------------\n", 
-					index + 1); 
-			printf("event data:\n"); 
-			display_event(event_data, bytes); 
-			printf("\n"); 
-			bytes = sizeof(event_data); 
-			index++; 
-		} 
-	} 
-	/* Display message if no HAB events are found */ 
-	else { 
-		printf("\nHAB Configuration: 0x%02x, HAB State: 0x%02x\n", 
-			config, state); 
-		printf("No HAB Events Found!\n\n"); 
-	} 
-	return 0; 
-} 
-
-void hab_caam_clock_enable(void) 
-{ 
-	writel(0xFFFFFFFF, GPC_BASE_ADDR + GPC_AIPS1_OFFPF_PCTL_3); 
-} 
-
-
-void hab_caam_clock_disable(void) 
-{ 
-	writel(0x00000000, GPC_BASE_ADDR + GPC_AIPS1_OFFPF_PCTL_3); 
-} 
-
-#ifdef DEBUG_AUTHENTICATE_IMAGE 
-void dump_mem(uint32_t addr, int size) 
-{ 
-	int i; 
-
-	for (i = 0; i < size; i += 4) { 
-		if (i != 0) { 
-			if (i % 16 == 0) 
-				printf("\n"); 
-			else 
-				printf(" "); 
-		} 
-
-		printf("0x%08x", *(uint32_t *)addr); 
-		addr += 4; 
-	} 
-
-	printf("\n"); 
-
-	return; 
-} 
-#endif 
-
-uint32_t authenticate_image(uint32_t ddr_start, uint32_t image_size) 
-{ 
-	uint32_t load_addr = 0; 
-	size_t bytes; 
-	ptrdiff_t ivt_offset = 0; 
-	int result = 0; 
-	ulong start; 
-	hab_rvt_authenticate_image_t *hab_rvt_authenticate_image; 
-	hab_rvt_entry_t *hab_rvt_entry; 
-	hab_rvt_exit_t *hab_rvt_exit; 
-
-	hab_rvt_authenticate_image = hab_rvt_authenticate_image_p; 
-	hab_rvt_entry = hab_rvt_entry_p; 
-	hab_rvt_exit = hab_rvt_exit_p; 
-
-	if (check_hab_enable() == 1) { 
-		printf("\nAuthenticate uImage from DDR location 0x%x...\n", 
-			ddr_start); 
-
-		hab_caam_clock_enable(); 
-
-		if (hab_rvt_entry() == HAB_SUCCESS) { 
-			/* If not already aligned, Align to ALIGN_SIZE */ 
-			ivt_offset = (image_size + ALIGN_SIZE - 1) & 
-					~(ALIGN_SIZE - 1); 
-
-			start = ddr_start; 
-			bytes = ivt_offset + IVT_SIZE + CSF_PAD_SIZE; 
-
-#ifdef DEBUG_AUTHENTICATE_IMAGE 
-			printf("\nivt_offset = 0x%x, ivt addr = 0x%x\n", 
-			       ivt_offset, ddr_start + ivt_offset); 
-			printf("Dumping IVT\n"); 
-			dump_mem(ddr_start + ivt_offset, 0x20); 
-
-			printf("Dumping CSF Header\n"); 
-			dump_mem(ddr_start + ivt_offset + 0x20, 0x40); 
-
-			get_hab_status(); 
-
-			printf("\nCalling authenticate_image in ROM\n"); 
-			printf("\tivt_offset = 0x%x\n\tstart = 0x%08x" 
-			       "\n\tbytes = 0x%x\n", ivt_offset, start, bytes); 
-#endif 
-
-			load_addr = (uint32_t)hab_rvt_authenticate_image( 
-					HAB_CID_UBOOT, 
-					ivt_offset, (void **)&start, 
-					(size_t *)&bytes, NULL); 
-			if (hab_rvt_exit() != HAB_SUCCESS) { 
-				printf("hab exit function fail\n"); 
-				load_addr = 0; 
-			} 
-		} else 
-			printf("hab entry function fail\n"); 
-
-		hab_caam_clock_disable(); 
-
-		get_hab_status(); 
-	} 
-
-	if ((!check_hab_enable()) || (load_addr != 0)) 
-		result = 1; 
-
-	return result; 
-} 
-/* ----------- end of HAB API updates ------------*/ 
-#endif 
-
diff --git a/arch/arm/cpu/armv7/sac58r/timer.c b/arch/arm/cpu/armv7/sac58r/timer.c
deleted file mode 100644
index cc4622e81b..0000000000
--- a/arch/arm/cpu/armv7/sac58r/timer.c
+++ /dev/null
@@ -1,90 +0,0 @@
-/*
- * (C) Copyright 2013 Freescale Semiconductor, Inc.
- *
- * SPDX-License-Identifier:	GPL-2.0+
- */
-
-#include <common.h>
-#include <asm/io.h>
-#include <div64.h>
-#include <asm/arch/imx-regs.h>
-#include <asm/arch/clock.h>
-
-static struct pit_reg *cur_pit = (struct pit_reg *)PIT_BASE_ADDR;
-
-DECLARE_GLOBAL_DATA_PTR;
-
-#define TIMER_LOAD_VAL	0xffffffff
-
-static inline unsigned long long tick_to_time(unsigned long long tick)
-{
-	tick *= CONFIG_SYS_HZ;
-	do_div(tick, mxc_get_clock(MXC_BUS_CLK));
-
-	return tick;
-}
-
-static inline unsigned long long us_to_tick(unsigned long long usec)
-{
-	usec = usec * mxc_get_clock(MXC_BUS_CLK)  + 999999;
-	do_div(usec, 1000000);
-
-	return usec;
-}
-
-int timer_init(void)
-{
-	__raw_writel(0, &cur_pit->mcr);
-
-	__raw_writel(TIMER_LOAD_VAL, &cur_pit->ldval1);
-	__raw_writel(0, &cur_pit->tctrl1);
-	__raw_writel(1, &cur_pit->tctrl1);
-
-	gd->arch.tbl = 0;
-	gd->arch.tbu = 0;
-
-	return 0;
-}
-
-unsigned long long get_ticks(void)
-{
-	ulong now = TIMER_LOAD_VAL - __raw_readl(&cur_pit->cval1);
-
-	/* increment tbu if tbl has rolled over */
-	if (now < gd->arch.tbl)
-		gd->arch.tbu++;
-	gd->arch.tbl = now;
-
-	return (((unsigned long long)gd->arch.tbu) << 32) | gd->arch.tbl;
-}
-
-ulong get_timer_masked(void)
-{
-	return tick_to_time(get_ticks());
-}
-
-ulong get_timer(ulong base)
-{
-	return get_timer_masked() - base;
-}
-
-/* delay x useconds AND preserve advance timstamp value */
-void __udelay(unsigned long usec)
-{
-	unsigned long long start;
-	ulong tmo;
-
-	start = get_ticks();			/* get current timestamp */
-	tmo = us_to_tick(usec);			/* convert usecs to ticks */
-	while ((get_ticks() - start) < tmo)
-		;				/* loop till time has passed */
-}
-
-/*
- * This function is derived from PowerPC code (timebase clock frequency).
- * On ARM it returns the number of timer ticks per second.
- */
-ulong get_tbclk(void)
-{
-	return mxc_get_clock(MXC_BUS_CLK);
-}
diff --git a/arch/arm/include/asm/arch-sac58r/clock.h b/arch/arm/include/asm/arch-sac58r/clock.h
deleted file mode 100644
index cb0143a802..0000000000
--- a/arch/arm/include/asm/arch-sac58r/clock.h
+++ /dev/null
@@ -1,60 +0,0 @@
-/*
- * (C) Copyright 2013 Freescale Semiconductor, Inc.
- *
- * SPDX-License-Identifier:	GPL-2.0+
- */
-
-#ifndef __ASM_ARCH_CLOCK_H
-#define __ASM_ARCH_CLOCK_H
-
-#include <common.h>
-
-enum mxc_clock {
-	MXC_ARM_CLK = 0,
-	MXC_BUS_CLK,
-	MXC_DDR_CLK,
-	MXC_IPG_CLK,
-	MXC_UART_CLK,
-	MXC_USDHC0_CLK,
-	MXC_USDHC1_CLK,
-	MXC_USDHC2_CLK,
-	MXC_FEC_CLK,
-	MXC_I2C_CLK,
-	MXC_NFC_CLK,
-};
-
-enum pll_clocks {
-	PLL_ARM = 0,	/* ARM PLL         => PLL1 */
-	PLL_SYS,		/* System Bus PLL  => PLL2 */
-	PLL_USBOTG0,	/* OTG USB0 PLL    => PLL3 */
-	PLL_USBOTG1,	/* OTG USB1 PLL    => PLL4 */
-	PLL_AUDIO0,		/* AUDIO0 PLL      => PLL5 */
-	PLL_AUDIO1,     /* AUDIO1 PLL      => PLL6 */
-	PLL_VIDEO,		/* VIDEO PLL       => PLL7 */
-	PLL_ENET,		/* ENET PLL        => PLL8 */
-};
-
-enum pll_pfds {
-	PLL_PFD1,
-	PLL_PFD2,
-	PLL_PFD3,
-	PLL_PFD4,
-};
-
-int enable_i2c_clk(unsigned char enable, unsigned i2c_num);
-void enable_periph_clk(u32 aips_num, u32 periph_number);
-void disable_periph_clk(u32 aips_num, u32 periph_number);
-void enable_ocotp_clk(unsigned char enable);
-int enable_fec_clock(void);
-int enable_pll(enum pll_clocks pll);
-int config_pll(enum pll_clocks pll, int mult, int mfn, int mfd);
-int is_pll_locked(enum pll_clocks pll);
-int config_pll_pfd_frac(enum pll_clocks pll, enum pll_pfds pfd, u8 frac);
-int enable_pll_pfd(enum pll_clocks pll, enum pll_pfds pfd, u8 enable);
-
-unsigned int mxc_get_clock(enum mxc_clock clk);
-
-#define imx_get_fecclk() mxc_get_clock(MXC_FEC_CLK)
-
-#endif /* __ASM_ARCH_CLOCK_H */
-
diff --git a/arch/arm/include/asm/arch-sac58r/crm_regs.h b/arch/arm/include/asm/arch-sac58r/crm_regs.h
deleted file mode 100644
index a988339496..0000000000
--- a/arch/arm/include/asm/arch-sac58r/crm_regs.h
+++ /dev/null
@@ -1,450 +0,0 @@
-/*
- * (C) Copyright 2013 Freescale Semiconductor, Inc.
- *
- * SPDX-License-Identifier:	GPL-2.0+
- */
-
-#ifndef __ARCH_ARM_MACH_SAC58R_CCM_REGS_H__
-#define __ARCH_ARM_MACH_SAC58R_CCM_REGS_H__
-
-#ifndef __ASSEMBLY__
-
-/* Clock Controller Module (CCM) */
-struct ccm_reg {
-	u32 muxed_fast_osc_clk; 
-	u32 muxed_slow_osc_clk;
-	u32 resv1;
-	u32 a7_clk;
-	u32 QoS_DDR_root;
-	u32 QoS301_clk;
-	u32 resv2;
-	u32 BUS2x_clk;
-	u32 BUS_clk;
-	u32 PER_clk;
-	u32 dap_clk;
-	u32 resv3;
-	u32 AUDIO0_pll_div_clk;
-	u32 AUDIO1_pll_div_clk;
-	u32 VIDEO_pll_div_clk;
-	u32 VSPA_clk;
- 	u32 AXIQ_clk;
-	u32 resv0;
-	u32 DCU_LDI_pix_clk_src;
-	u32 GCC_clk2x;
-	u32 vidadc_proc_clk;
-	u32 resv4;
-	u32 resv5;
-	u32 resv6;
-	u32 flextimer0_extclk;
-	u32 flextimer0_ff_clk;
-	u32 enet_time_clk;
-	u32 resv7;
-	u32 uSDHC0_perclk;
-	u32 uSDHC1_perclk;
-	u32 uSDHC2_perclk;
-	u32 qspi_4x_clk;
-	u32 nfc_flash_clk_div;
-	u32 AUD_CLK_0;
-	u32 AUD_CLK_1;
-	u32 sai0_mclk;
-	u32 sai1_mclk;
-	u32 sai2_mclk;
-	u32 sai3_mclk;
-	u32 esai0_mclk;
-	u32 esai1_mclk;
-	u32 spdif_tx_clk;
-	u32 tun12_rx_bclk_div;
-	u32 tun34_rx_bclk_div;
-	u32 asrc0_mux_clk;
-	u32 asrc1_mux_clk;
-	u32 OBS_CLK_OUT0;
-	u32 OBS_CLK_OUT1;
-	u32 trace_clk;
-	u32 codec_sai_bclk0;
-	u32 codec_sai_bclk1;
-	u32 codec_dac_tdm_src0;
-	u32 codec_dac_tdm_src1;
-	u32 codec_mclk;
-	u32 viu_clk;
-	u32 vpu_clk;
-	u32 tuner_mclk_sai8;
-	u32 tuner_mclk_sai9;
-	u32 tuner_mclk_sai10;
-	u32 tuner_mclk_sai11;
-	u32 audio_codec_ipg_clk;
-	u32 mipi_24M_ref_clk;
-	u32 mipi_escape_mode_clk;
-	u32 mipi_viu_intf_clk;
-	u32 spdif1_tx_clk;
-	u32 adc_conv_clk;
-	u32 xrdc_ipg_clk;
-	u32 ccr;
-	u32 csr;
-	u32 ccsr;
-	u32 clpcr;
-};
-
-/* Analog components control digital interface (ANADIG) */
-struct anadig_reg {
-	u32 resv0[4];
-	u32 pll3_ctrl;
-	u32 resv1[3];
-	u32 pll7_ctrl;
-	u32 resv2[3];
-	u32 pll2_ctrl;
-	u32 resv3[3];
-	u32 pll2_ss;
-	u32 resv4[3];
-	u32 pll2_num;
-	u32 resv5[3];
-	u32 pll2_denom;
-	u32 resv6[3];
-	u32 pll4_ctrl;
-	u32 resv7[3];
-	u32 pll4_num;
-	u32 resv8[3];
-	u32 pll4_denom;
-	u32 resv9[3];
-	u32 pll6_ctrl;
-	u32 resv10[3];
-	u32 pll6_num;
-	u32 resv11[3];
-	u32 pll6_denom;
-	u32 resv12[7];
-	u32 pll5_ctrl;
-	u32 resv13[3];
-	u32 pll3_pfd;
-	u32 resv14[3];
-	u32 pll2_pfd;
-	u32 resv15[3];
-	u32 reg_1p1;
-	u32 resv16[3];
-	u32 reg_3p0;
-	u32 resv17[3];
-	u32 reg_2p5;
-	u32 resv18[7];
-	u32 ana_misc0;
-	u32 resv19[3];
-	u32 ana_misc1;
-	u32 resv20[63];
-	u32 digprog;
-	u32 resv21[3];
-	u32 pll1_ctrl;
-	u32 resv22[3];
-	u32 pll1_num;
-	u32 resv23[3];
-	u32 pll1_denom;
-	u32 resv24[11];
-	u32 pll_lock;
-	u32 resv25[3];
-	u32 pll8_ctrl;
-	u32 resv26[3];
-	u32 pll8_num;
-	u32 resv27[3];
-	u32 pll8_denom;
-};
-
-/* Global Power Controller (GPC) */
-struct gpc_reg {
-	u32 reserved[16];
-	u32 lpmr;
-	u32 imr1;
-	u32 imr2;
-	u32 imr3;
-	u32 imr4;
-	u32 isr0;
-	u32 isr1;
-	u32 isr2;
-	u32 isr3;
-	u32 resv0[7];
-	u32 aips0_onpf_pctl0;
-	u32 aips0_onpf_pctl1;
-	u32 aips0_offpf_pctl0;
-	u32 aips0_offpf_pctl1;
-	u32 aips0_offpf_pctl2;
-	u32 aips0_offpf_pctl3;
-	u32 aips0_offpf_pctl4;
-	u32 resv1[25];
-	u32 aips1_onpf_pctl0;
-	u32 aips1_onpf_pctl1;
-	u32 aips1_offpf_pctl0;
-	u32 aips1_offpf_pctl1;
-	u32 aips1_offpf_pctl2;
-	u32 aips1_offpf_pctl3;
-	u32 aips1_offpf_pctl4;
-	u32 resv2[25];
-	u32 aips2_onpf_pctl0;
-	u32 aips2_onpf_pctl1;
-	u32 aips2_offpf_pctl0;
-	u32 aips2_offpf_pctl1;
-	u32 aips2_offpf_pctl2;
-	u32 aips2_offpf_pctl3;
-	u32 aips2_offpf_pctl4;
-	u32 aips2_offpf_pctl5;
-	u32 resv3[24];
-	u32 pgcr;
-	u32 pupscr;
-	u32 pdnscr;
-	u32 pgsr;
-	u32 pgdr;
-	u32 pmc_ctrl;
-	u32 hpreg_ctrl;
-	u32 hpvd_ctrl;
-	u32 resv4[1];
-	u32 lpvd_ctrl;
-	u32 resv5[1];
-	u32 ulpvd_ctrl;
-	u32 rstcnt_ctrl;
-	u32 lpm_ctrl;
-	u32 mem_mon_ctrl;
-};
-
-/* Slow Clock Source Controller (SCSC) */
-struct scsc_reg {
-	u32 irc_ctrl;
-	u32 osc_ctrl;
-	u32 clk_src_ctrl_stat;
-};
-#endif
-
-/* CCM register fields */
-#define CCM_MODULE_ENABLE_CTL_OFFSET	31
-#define CCM_MODULE_ENABLE_CTL_EN	(1 << 31)
-
-#define CCM_PREDIV_UPD_IN_PROGRESS_CTRL_OFFSET	28
-#define CCM_PREDIV_UPD_IN_PROGRESS_CTRL_MASK	(0x1 << 28)
-
-#define CCM_PREDIV_FRAC_DIV_CTRL_OFFSET	27
-#define CCM_PREDIV_FRAC_DIV_CTRL_MASK	(0x1 << 27)
-#define CCM_PREDIV_FRAC_DIV_CTRL(v)	(((v) & 0x1) << 27)
-
-#define CCM_PREDIV_CTRL_OFFSET		16
-#define CCM_PREDIV2_CTRL_MASK		(0x3 << 16)
-#define CCM_PREDIV2_CTRL(v)		(((v) & 0x3) << 16)
-#define CCM_PREDIV3_CTRL_MASK		(0x7 << 16)
-#define CCM_PREDIV3_CTRL(v)		(((v) & 0x7) << 16)
-#define CCM_PREDIV4_CTRL_MASK		(0x1f << 16)
-#define CCM_PREDIV4_CTRL(v)		(((v) & 0xf) << 16)
-#define CCM_PREDIV5_CTRL_MASK		(0x1f << 16)
-#define CCM_PREDIV5_CTRL(v)		(((v) & 0x1f) << 16)
-#define CCM_PREDIV8_CTRL_MASK		(0xff << 16)
-#define CCM_PREDIV8_CTRL(v)		(((v) & 0xff) << 16)
-#define CCM_PREDIV10_CTRL_MASK		(0x3FF << 16)
-#define CCM_PREDIV10_CTRL(v)		(((v) & 0x3FF) << 16)
-
-#define CCM_MUX_CTL_OFFSET	0
-#define CCM_MUX1_CTL_MASK	0x1
-#define CCM_MUX1_CTL(v)		(v & 0x1)
-#define CCM_MUX2_CTL_MASK	0x3
-#define CCM_MUX2_CTL(v)		(v & 0x3)
-#define CCM_MUX3_CTL_MASK	0x7
-#define CCM_MUX3_CTL(v)		(v & 0x7)
-#define CCM_MUX4_CTL_MASK	0xf
-#define CCM_MUX4_CTL(v)		(v & 0xf)
-#define CCM_MUX5_CTL_MASK	0x1f
-#define CCM_MUX5_CTL(v)		(v & 0x1f)
-#define CCM_MUX6_CTL_MASK	0x3f
-#define CCM_MUX6_CTL(v)		(v & 0x3f)
-
-/* Anadig register fields    */
-
-/* PLL definition            */
-/* PLL1 => CORE_PLL/ARM_PLL  */
-/* PLL2 => SYS_PLL           */
-/* PLL3 => USB0_PLL          */
-/* PLL4 => USB1_PLL          */
-/* PLL5 => AUDIO0_PLL        */
-/* PLL6 => AUDIO1_PLL        */
-/* PLL7 => VIDEO_PLL         */
-/* PLL8 => ENET_PLL          */
-
-#define ANADIG_PLL_CTRL_LOCK			(1 << 31)
-#define ANADIG_PLL_CTRL_BYPASS			(1 << 16)
-#define ANADIG_PLL_CTRL_ENABLE			(1 << 13)
-#define ANADIG_PLL_CTRL_POWERDOWN		(1 << 12)
-#define ANADIG_PLL1_CTRL_DIV_SELECT_MASK	0x7F
-#define ANADIG_PLL2_CTRL_DIV_SELECT_MASK	1
-#define ANADIG_PLL2_CTRL_DIV_SELECT		1
-#define ANADIG_PLL3_CTRL_DIV_SELECT		1
-#define ANADIG_PLL3_CTRL_DIV_SELECT_MASK	1
-#define ANADIG_PLL4_CTRL_DIV_SELECT_MASK	0x7F
-#define ANADIG_PLL5_CTRL_DIV_SELECT_MASK	3
-#define ANADIG_PLL6_CTRL_DIV_SELECT_MASK	0x7F
-#define ANADIG_PLL7_CTRL_DIV_SELECT_MASK	1
-#define ANADIG_PLL8_CTRL_DIV_SELECT_MASK	0x7F
-#define ANADIG_PLL_PFD4_CLKGATE_MASK	(0x1 << 31)
-#define ANADIG_PLL_PFD3_CLKGATE_MASK	(0x1 << 23)
-#define ANADIG_PLL_PFD2_CLKGATE_MASK	(0x1 << 15)
-#define ANADIG_PLL_PFD1_CLKGATE_MASK	(0x1 << 7)
-#define ANADIG_PLL_PFD4_FRAC_MASK		0x3F000000
-#define ANADIG_PLL_PFD3_FRAC_MASK		0x003F0000
-#define ANADIG_PLL_PFD2_FRAC_MASK		0x00003F00
-#define ANADIG_PLL_PFD1_FRAC_MASK		0x0000003F
-#define ANADIG_PLL_PFD4_OFFSET			24
-#define ANADIG_PLL_PFD3_OFFSET			16
-#define ANADIG_PLL_PFD2_OFFSET			8
-#define ANADIG_PLL_PFD1_OFFSET			0
-#define ANADIG_PLL_NUM_MASK				0x3FFFFFFF
-#define ANADIG_PLL_DENOM_MASK			0x3FFFFFFF
-
-
-#define SCSC_IRC_FIR_EN				(1 << 16)
-#define SCSC_IRC_SIRC_EN			(1)
-#define SCSC_CTRL_FXOSC_RDY_MASK	(0x1 << 20)
-#define SCSC_OSC_FXOSC_EN			(1 << 16)
-#define SCSC_OSC_SXOSC_EN			(1)
-
-
-/* AIPS numbers */
-#define AIPS0		0
-#define AIPS1		1
-#define AIPS2		2
-
-/* AIPS Off platform Ids */
-#define AIPS0_OFF_GPC	32
-#define AIPS0_OFF_SRC	34
-#define AIPS0_OFF_CCM	35
-#define AIPS0_OFF_SCSC	36
-#define AIPS0_OFF_CMU	37
-#define AIPS0_OFF_ANADIG	38
-#define AIPS0_OFF_IOMUXC	40
-#define AIPS0_OFF_GPIOC	41
-#define AIPS0_OFF_PORTA	42
-#define AIPS0_OFF_PORTB	43
-#define AIPS0_OFF_PORTC	44
-#define AIPS0_OFF_PORTD	45
-#define AIPS0_OFF_PORTE	46
-#define AIPS0_OFF_PORTF	47
-#define AIPS0_OFF_PORTG	48
-#define AIPS0_OFF_PORTH	49
-#define AIPS0_OFF_PORTJ	51
-#define AIPS0_OFF_PORTK	52
-#define AIPS0_OFF_PORTL	53
-#define AIPS0_OFF_OCOTP0	60
-#define AIPS0_OFF_OCOTP1	61
-#define AIPS0_OFF_SNVS	62
-#define AIPS0_OFF_SNVS_WDOG	63
-#define AIPS0_OFF_FLEXCAN0	64
-#define AIPS0_OFF_FLEXCAN1	65
-#define AIPS0_OFF_FLEXCAN2	66
-#define AIPS0_OFF_SPI0	69
-#define AIPS0_OFF_UART2	72
-#define AIPS0_OFF_DMA_CHMUX0	76
-#define AIPS0_OFF_DMA_CHMUX1	77
-#define AIPS0_OFF_WKUP	81
-#define AIPS0_OFF_CRC	83
-#define AIPS0_OFF_LPTIMER	86
-#define AIPS0_OFF_PIT	88
-#define AIPS0_OFF_GPADC	91
-#define AIPS0_OFF_FTM	94
-#define AIPS0_OFF_PDB	97
-#define AIPS0_OFF_REG_BANK_PD0	100
-#define AIPS0_OFF_REG_BANK_PD1	101
-
-#define AIPS1_OFF_AUD_ADC_DAC0	32
-#define AIPS1_OFF_AUD_ADC_DAC1	33
-#define AIPS1_OFF_AUD_ADC_DAC2	34
-#define AIPS1_OFF_AUD_ADC_DAC3	35
-#define AIPS1_OFF_SAI4	38
-#define AIPS1_OFF_SAI5	39
-#define AIPS1_OFF_SAI6	44
-#define AIPS1_OFF_SAI7	45
-#define AIPS1_OFF_REG_BANK_PD2	48
-#define AIPS1_OFF_MISC_PIN_CONTROL	49
-#define AIPS1_OFF_ESAI0	51
-#define AIPS1_OFF_MLB0	54
-#define AIPS1_OFF_SPI1	56
-#define AIPS1_OFF_UART0	59
-#define AIPS1_OFF_UART1	60
-#define AIPS1_OFF_I2C0	63
-#define AIPS1_OFF_I2C1	64
-#define AIPS1_OFF_VSPA	68
-#define AIPS1_OFF_FECA	76
-#define AIPS1_OFF_CAAM0	80
-#define AIPS1_OFF_CAAM1	81
-#define AIPS1_OFF_CAAM2	82
-#define AIPS1_OFF_CAAM3	83
-#define AIPS1_OFF_CAAM4	84
-#define AIPS1_OFF_CAAM5	85
-#define AIPS1_OFF_CAAM6	86
-#define AIPS1_OFF_CAAM7	87
-#define AIPS1_OFF_CAAM8	88
-#define AIPS1_OFF_CAAM9	89
-#define AIPS1_OFF_CAAM10	90
-#define AIPS1_OFF_CAAM11	91
-#define AIPS1_OFF_CAAM12	92
-#define AIPS1_OFF_CAAM13	93
-#define AIPS1_OFF_CAAM14	94
-#define AIPS1_OFF_CAAM15	95
-#define AIPS1_OFF_SAI8	104
-#define AIPS1_OFF_SAI9	105
-#define AIPS1_OFF_SAI10	106
-#define AIPS1_OFF_SAI11	107
-#define AIPS1_OFF_JESD204B0	110
-#define AIPS1_OFF_JESD204B1	111
-
-#define AIPS2_OFF_UART3	32
-#define AIPS2_OFF_UART4	33
-#define AIPS2_OFF_UART5	34
-#define AIPS2_OFF_I2C2	36
-#define AIPS2_OFF_I2C3	37
-#define AIPS2_OFF_ESAI1	39
-#define AIPS2_OFF_SAI0	41
-#define AIPS2_OFF_SAI1	42
-#define AIPS2_OFF_SAI2	43
-#define AIPS2_OFF_SAI3	44
-#define AIPS2_OFF_SPDIF0	48
-#define AIPS2_OFF_SPDIF1	49
-#define AIPS2_OFF_ASRC0	50
-#define AIPS2_OFF_ASRC1	51
-#define AIPS2_OFF_VADC	54
-#define AIPS2_OFF_VDEC	55
-#define AIPS2_OFF_VIU3	56
-#define AIPS2_OFF_MIPI2	60
-#define AIPS2_OFF_DCU0	64
-#define AIPS2_OFF_DCU1	65
-#define AIPS2_OFF_DCU2	66
-#define AIPS2_OFF_DCU3	67
-#define AIPS2_OFF_DCU4	68
-#define AIPS2_OFF_DCU5	69
-#define AIPS2_OFF_DCU6	70
-#define AIPS2_OFF_DCU7	71
-#define AIPS2_OFF_TCON	80
-#define AIPS2_OFF_LDB	82
-#define AIPS2_OFF_RLE	84
-#define AIPS2_OFF_VPU	88
-#define AIPS2_OFF_GC400T0	92
-#define AIPS2_OFF_GC400T1	93
-#define AIPS2_OFF_GC400T2	94
-#define AIPS2_OFF_GC400T3	95
-#define AIPS2_OFF_ENET	96
-#define AIPS2_OFF_USB0	99
-#define AIPS2_OFF_USB1	100
-#define AIPS2_OFF_USB2	101
-#define AIPS2_OFF_DMA_CHMUX2	103
-#define AIPS2_OFF_DMA_CHMUX3	104
-#define AIPS2_OFF_MMDC	105
-#define AIPS2_OFF_QSPI	106
-#define AIPS2_OFF_SDHC0	108
-#define AIPS2_OFF_SDHC1	109
-#define AIPS2_OFF_SDHC2	110
-#define AIPS2_OFF_NFC0	120
-#define AIPS2_OFF_NFC1	121
-#define AIPS2_OFF_NFC2	122
-#define AIPS2_OFF_NFC3	123
-
-/* GPC register fields */
-#define GPC_OFFPF_PCTL_OCOTP0_MASK	0x3 << 12
-#define GPC_OFFPF_PCTL_OCOTP1_MASK	0x3 << 13
-
-#define FIRC_CLK_FREQ		24000000
-#define FAST_CLK_FREQ		24000000
-#define SLOW_CLK_FREQ		32000
-#define PLL8_MAIN_FREQ		500000000
-
-
-#define ENET_EXTERNAL_CLK	50000000
-#define AUDIO_EXTERNAL_CLK	24576000
-
-#endif /*__ARCH_ARM_MACH_SAC58R_CCM_REGS_H__ */
-
diff --git a/arch/arm/include/asm/arch-sac58r/dmachmux-sac58r.h b/arch/arm/include/asm/arch-sac58r/dmachmux-sac58r.h
deleted file mode 100644
index 9dac93a113..0000000000
--- a/arch/arm/include/asm/arch-sac58r/dmachmux-sac58r.h
+++ /dev/null
@@ -1,120 +0,0 @@
-/*
- * (C) Copyright 2014 Freescale Semiconductor, Inc.
- *
- * SPDX-License-Identifier:	GPL-2.0+
- *
- * Author: Gilles Talis <gilles.talis@freescale.com>
- */
-
-#ifndef __DMACHMUX_SAC58R_H__
-#define __DMACHMUX_SAC58R_H__
-
-#include <asm/imx-common/dmachmux.h>
-
-/* DMA Channel sources */
-enum {
-	/* DMA request sources - DMA0(MUX0)/DMA1(MUX3) */
-	SAC58R_DMAREQSRC_UART0_RX = 2,
-	SAC58R_DMAREQSRC_UART0_TX = 3,
-	SAC58R_DMAREQSRC_UART1_RX = 4,
-	SAC58R_DMAREQSRC_UART1_TX = 5,
-	SAC58R_DMAREQSRC_UART2_RX = 6,
-	SAC58R_DMAREQSRC_UART2_TX = 7,
-	SAC58R_DMAREQSRC_UART3_RX = 8,
-	SAC58R_DMAREQSRC_UART3_TX = 9,
-	SAC58R_DMAREQSRC_ESAI1_BFIFO_TX = 10,
-	SAC58R_DMAREQSRC_ESAI1_BFIFO_RX = 11,
-	SAC58R_DMAREQSRC_SPI0_RX = 12,
-	SAC58R_DMAREQSRC_SPI0_TX = 13,
-	SAC58R_DMAREQSRC_SPI1_RX = 14,
-	SAC58R_DMAREQSRC_SPI1_TX = 15,
-	SAC58R_DMAREQSRC_SAI0_RX = 16,
-	SAC58R_DMAREQSRC_SAI0_TX = 17,
-	SAC58R_DMAREQSRC_SAI1_RX = 18,
-	SAC58R_DMAREQSRC_SAI1_TX = 19,
-	SAC58R_DMAREQSRC_SAI2_RX = 20,
-	SAC58R_DMAREQSRC_PDB 	= 22,
-	SAC58R_DMAREQSRC_ENET_1588_CH2 	= 22,
-	SAC58R_DMAREQSRC_FTM0_CH0 = 24,
-	SAC58R_DMAREQSRC_FTM0_CH1 = 25,
-	SAC58R_DMAREQSRC_FTM0_CH2 = 26,
-	SAC58R_DMAREQSRC_FTM0_CH3 = 27,
-	SAC58R_DMAREQSRC_USDHC0 = 28,
-	SAC58R_DMAREQSRC_USDHC1 = 29,
-	SAC58R_DMAREQSRC_ENET_1588_CH0 = 30,
-	SAC58R_DMAREQSRC_ENET_1588_CH1 = 31,
-	SAC58R_DMAREQSRC_FTM1_CH0 = 32,
-	SAC58R_DMAREQSRC_FTM1_CH1 = 33,
-	SAC58R_DMAREQSRC_ADC0 	= 32,
-	SAC58R_DMAREQSRC_ASRC1_1 = 34,
-	SAC58R_DMAREQSRC_ASRC1_2 = 35,
-	SAC58R_DMAREQSRC_ASRC1_3 = 36,
-	SAC58R_DMAREQSRC_ASRC1_4 = 37,
-	SAC58R_DMAREQSRC_PORTA 	= 38,
-	SAC58R_DMAREQSRC_PORTB 	= 39,
-	SAC58R_DMAREQSRC_PORTC 	= 40,
-	SAC58R_DMAREQSRC_PORTD 	= 41,
-	SAC58R_DMAREQSRC_PORTE 	= 42,
-	SAC58R_DMAREQSRC_ASRC1_5	= 43,
-	SAC58R_DMAREQSRC_ASRC1_6	= 44,
-	SAC58R_DMAREQSRC_RLE_RX	= 45,
-	SAC58R_DMAREQSRC_RLE_TX	= 46,
-	SAC58R_DMAREQSRC_SPDIF0_RX = 47,
-	SAC58R_DMAREQSRC_SPDIF0_TX = 48,
-	SAC58R_DMAREQSRC_USDHC2 = 49,
-	SAC58R_DMAREQSRC_I2C0_RX = 50,
-	SAC58R_DMAREQSRC_I2C0_TX = 51,
-	SAC58R_DMAREQSRC_I2C1_RX = 52,
-	SAC58R_DMAREQSRC_I2C1_TX = 53,
-
-	/* DMA request sources - DMA1(MUX2)/DMA0(MUX1) */
-	SAC58R_DMAREQSRC_UART4_RX = 2,
-	SAC58R_DMAREQSRC_UART4_TX = 3,
-	SAC58R_DMAREQSRC_UART5_RX = 4,
-	SAC58R_DMAREQSRC_UART5_TX = 5,
-	SAC58R_DMAREQSRC_SPDIF1_RX = 6,
-	SAC58R_DMAREQSRC_SPDIF1_TX = 7,
-	SAC58R_DMAREQSRC_SAI3_RX = 8,
-	SAC58R_DMAREQSRC_PORTF = 10,
-	SAC58R_DMAREQSRC_PORTG = 11,
-	SAC58R_DMAREQSRC_PORTH = 12,
-	SAC58R_DMAREQSRC_PORTJ = 13,
-	SAC58R_DMAREQSRC_VSPA_GPO11_16 = 15,
-	SAC58R_DMAREQSRC_VSPA_GPO11_17 = 16,
-	SAC58R_DMAREQSRC_PORTK = 17,
-	SAC58R_DMAREQSRC_PORTL = 18,
-	SAC58R_DMAREQSRC_FECA_VITERBI_CMPLT = 19,
-	SAC58R_DMAREQSRC_FECA_TURBO_CODE_CMPLT = 20,
-	SAC58R_DMAREQSRC_FECA_REED_SOLOMON_CMPLT = 21,
-	SAC58R_DMAREQSRC_FECA_DESCR_CMPLT = 22,
-	SAC58R_DMAREQSRC_ENET_1588_CH3 = 23,
-	SAC58R_DMAREQSRC_SAI4_RX = 24,
-	SAC58R_DMAREQSRC_SAI5_RX = 25,
-	SAC58R_DMAREQSRC_SAI6_TX = 26,
-	SAC58R_DMAREQSRC_SAI6_RX = 27,
-	SAC58R_DMAREQSRC_SAI7_TX = 28,
-	SAC58R_DMAREQSRC_FTM0_CH4 = 30,
-	SAC58R_DMAREQSRC_FTM0_CH5 = 31,
-	SAC58R_DMAREQSRC_FTM0_CH6 = 32,
-	SAC58R_DMAREQSRC_FTM0_CH7 = 33,
-	SAC58R_DMAREQSRC_ESAI0_BFIFO_TX = 34,
-	SAC58R_DMAREQSRC_ESAI0_BFIFO_RX = 35,
-	SAC58R_DMAREQSRC_I2C2_RX = 36,
-	SAC58R_DMAREQSRC_I2C2_TX = 37,
-	SAC58R_DMAREQSRC_I2C3_RX = 38,
-	SAC58R_DMAREQSRC_I2C4_TX = 39,
-	SAC58R_DMAREQSRC_ASRC0_1 = 40,
-	SAC58R_DMAREQSRC_ASRC0_4 = 41,
-	SAC58R_DMAREQSRC_ASRC0_2 = 42,
-	SAC58R_DMAREQSRC_ASRC0_5 = 43,
-	SAC58R_DMAREQSRC_QSPIO_RX = 44,
-	SAC58R_DMAREQSRC_QSPIO_TX = 45,
-	SAC58R_DMAREQSRC_FLEXCAN0 = 46,
-	SAC58R_DMAREQSRC_FLEXCAN1 = 48,
-	SAC58R_DMAREQSRC_FLEXCAN2 = 50,
-	SAC58R_DMAREQSRC_ASRC0_3 	= 52,
-	SAC58R_DMAREQSRC_ASRC0_6 	= 53,
-};
-
-
-#endif	/* __IOMUX_SAC58R_H__ */
diff --git a/arch/arm/include/asm/arch-sac58r/gpio.h b/arch/arm/include/asm/arch-sac58r/gpio.h
deleted file mode 100644
index cf0edb385f..0000000000
--- a/arch/arm/include/asm/arch-sac58r/gpio.h
+++ /dev/null
@@ -1,14 +0,0 @@
-/*
- * (C) Copyright 2011,
- * Stefano Babic, DENX Software Engineering, <sbabic@denx.de>
- *
- * SPDX-License-Identifier:	GPL-2.0+
- */
-
-
-#ifndef __ASM_ARCH_SAC58R_GPIO_H
-#define __ASM_ARCH_SAC58R_GPIO_H
-
-#include <asm/imx-common/gpio.h>
-
-#endif
diff --git a/arch/arm/include/asm/arch-sac58r/imx-regs.h b/arch/arm/include/asm/arch-sac58r/imx-regs.h
deleted file mode 100644
index 4883cabb59..0000000000
--- a/arch/arm/include/asm/arch-sac58r/imx-regs.h
+++ /dev/null
@@ -1,538 +0,0 @@
-/*
- * (C) Copyright 2013 Freescale Semiconductor, Inc.
- *
- * SPDX-License-Identifier:	GPL-2.0+
- */
-
-#ifndef __ASM_ARCH_IMX_REGS_H__
-#define __ASM_ARCH_IMX_REGS_H__
-
-#define ARCH_MXC
-
-#define IRAM_BASE_ADDR		0x3E800000	/* internal ram */
-#define IRAM_SIZE		0x00040000	/* 256 KB ECC protected */
-
-#define AIPS0_BASE_ADDR		0x40000000
-#define AIPS1_BASE_ADDR		0x40080000
-#define AIPS2_BASE_ADDR		0x40100000
-#define AIPS3_BASE_ADDR		0x40180000
-
-/* AIPS 0 */
-#define AXBS_BASE_ADDR		(AIPS0_BASE_ADDR + 0x00001000)
-#define MSCM_BASE_ADDR		(AIPS0_BASE_ADDR + 0x00002000)
-#define MSCM_IR_BASE_ADDR	(AIPS0_BASE_ADDR + 0x00002800)
-#define WDOG0_BASE_ADDR		(AIPS0_BASE_ADDR + 0x00003000)
-#define DMA0_BASE_ADDR		(AIPS0_BASE_ADDR + 0x00004000)
-#define DMA0_TCD_BASE_ADDR	(AIPS0_BASE_ADDR + 0x00005000)
-#define STM0_BASE_ADDR		(AIPS0_BASE_ADDR + 0x00006000)
-#define GPC_BASE_ADDR		(AIPS0_BASE_ADDR + 0x00020000)
-#define SRC_BASE_ADDR		(AIPS0_BASE_ADDR + 0x00022000)
-#define CCM_BASE_ADDR		(AIPS0_BASE_ADDR + 0x00023000)
-#define SCSC_BASE_ADDR		(AIPS0_BASE_ADDR + 0x00024000)
-#define CMU_BASE_ADDR		(AIPS0_BASE_ADDR + 0x00025000)
-#define ANADIG_BASE_ADDR	(AIPS0_BASE_ADDR + 0x00026000)
-#define IOMUXC_BASE_ADDR	(AIPS0_BASE_ADDR + 0x00028000)
-#define GPIO_BASE_ADDR		(AIPS0_BASE_ADDR + 0x00029000)
-#define PORTA_BASE_ADDR		(AIPS0_BASE_ADDR + 0x0002A000)
-#define PORTB_BASE_ADDR		(AIPS0_BASE_ADDR + 0x0002B000)
-#define PORTC_BASE_ADDR		(AIPS0_BASE_ADDR + 0x0002C000)
-#define PORTD_BASE_ADDR		(AIPS0_BASE_ADDR + 0x0002D000)
-#define PORTE_BASE_ADDR		(AIPS0_BASE_ADDR + 0x0002E000)
-#define PORTF_BASE_ADDR		(AIPS0_BASE_ADDR + 0x0002F000)
-#define PORTG_BASE_ADDR		(AIPS0_BASE_ADDR + 0x00030000)
-#define PORTH_BASE_ADDR		(AIPS0_BASE_ADDR + 0x00031000)
-#define PORTI_BASE_ADDR		(AIPS0_BASE_ADDR + 0x00032000)
-#define PORTJ_BASE_ADDR		(AIPS0_BASE_ADDR + 0x00033000)
-#define PORTK_BASE_ADDR		(AIPS0_BASE_ADDR + 0x00034000)
-#define PORTL_BASE_ADDR		(AIPS0_BASE_ADDR + 0x00035000)
-#define OCOTP_BASE_ADDR		(AIPS0_BASE_ADDR + 0x0003C000)
-#define SNVS_BASE_ADDR		(AIPS0_BASE_ADDR + 0x0003E000)
-#define SNVS_WDOG_BASE_ADDR	(AIPS0_BASE_ADDR + 0x0003F000)
-#define FLEXCAN0_BASE_ADDR	(AIPS0_BASE_ADDR + 0x00040000)
-#define FLEXCAN1_BASE_ADDR	(AIPS0_BASE_ADDR + 0x00041000)
-#define FLEXCAN2_BASE_ADDR	(AIPS0_BASE_ADDR + 0x00042000)
-#define SPI0_BASE_ADDR		(AIPS0_BASE_ADDR + 0x00045000)
-#define UART2_BASE_ADDR		(AIPS0_BASE_ADDR + 0x00048000)
-#define DMA_MUX0_BASE_ADDR	(AIPS0_BASE_ADDR + 0x0004C000)
-#define DMA_MUX1_BASE_ADDR	(AIPS0_BASE_ADDR + 0x0004D000)
-#define WKPU_BASE_ADDR		(AIPS0_BASE_ADDR + 0x00051000)
-#define CRC_BASE_ADDR		(AIPS0_BASE_ADDR + 0x00053000)
-#define LPTMR_BASE_ADDR		(AIPS0_BASE_ADDR + 0x00056000)
-#define PIT_BASE_ADDR		(AIPS0_BASE_ADDR + 0x00058000)
-#define GPADC_BASE_ADDR		(AIPS0_BASE_ADDR + 0x0005B000)
-#define FTM0_BASE_ADDR		(AIPS0_BASE_ADDR + 0x0005E000)
-#define PDB_BASE_ADDR		(AIPS0_BASE_ADDR + 0x00061000)
-#define REG_BANK_PD0_BASE_ADDR	(AIPS0_BASE_ADDR + 0x00064000)
-#define REG_BANK_PD1_BASE_ADDR	(AIPS0_BASE_ADDR + 0x00065000)
-
-/* AIPS 1 */
-#define WDOG1_BASE_ADDR		(AIPS1_BASE_ADDR + 0x00001000)
-#define WDOG2_BASE_ADDR		(AIPS1_BASE_ADDR + 0x00003000)
-#define DMA1_BASE_ADDR		(AIPS1_BASE_ADDR + 0x00004000)
-#define DMA1_TCD_BASE_ADDR	(AIPS1_BASE_ADDR + 0x00005000)
-#define AUD_ADC_DAC_BASE_ADDR	(AIPS1_BASE_ADDR + 0x00020000)
-#define SAI4_BASE_ADDR		(AIPS1_BASE_ADDR + 0x00026000)
-#define SAI5_BASE_ADDR		(AIPS1_BASE_ADDR + 0x00027000)
-#define SAI6_BASE_ADDR		(AIPS1_BASE_ADDR + 0x0002C000)
-#define SAI7_BASE_ADDR		(AIPS1_BASE_ADDR + 0x0002D000)
-#define REG_BANK_PD2_BASE_ADDR	(AIPS1_BASE_ADDR + 0x00030000)
-#define MISC_PIN_CTRL_BASE_ADDR	(AIPS1_BASE_ADDR + 0x00031000)
-#define ESAI0_BASE_ADDR		(AIPS1_BASE_ADDR + 0x00033000)
-#define MLB_BASE_ADDR		(AIPS1_BASE_ADDR + 0x00036000)
-#define SPI1_BASE_ADDR		(AIPS1_BASE_ADDR + 0x00038000)
-#define UART0_BASE_ADDR		(AIPS1_BASE_ADDR + 0x0003B000)
-#define UART1_BASE_ADDR		(AIPS1_BASE_ADDR + 0x0003C000)
-#define I2C0_BASE_ADDR		(AIPS1_BASE_ADDR + 0x0003F000)
-#define I2C1_BASE_ADDR		(AIPS1_BASE_ADDR + 0x00040000)
-#define VSPA_BASE_ADDR		(AIPS1_BASE_ADDR + 0x00044000)
-#define FECA_BASE_ADDR		(AIPS1_BASE_ADDR + 0x0004C000)
-#define CAAM_BASE_ADDR		(AIPS1_BASE_ADDR + 0x00050000)
-#define SAI8_BASE_ADDR		(AIPS1_BASE_ADDR + 0x00068000)
-#define SAI9_BASE_ADDR		(AIPS1_BASE_ADDR + 0x00069000)
-#define SAI10_BASE_ADDR		(AIPS1_BASE_ADDR + 0x0006A000)
-#define SAI11_BASE_ADDR		(AIPS1_BASE_ADDR + 0x0006B000)
-#define JESD204B_BASE_ADDR	(AIPS1_BASE_ADDR + 0x0006E000)
-
-#define GPC_AIPS1_OFFPF_PCTL_3	0x114
-
-#define IMX_IIM_BASE		OCOTP_BASE_ADDR
-
-/* AIPS 2 */
-#define SEMA4_BASE_ADDR		(AIPS2_BASE_ADDR + 0x00001000)
-#define UART3_BASE_ADDR		(AIPS2_BASE_ADDR + 0x00020000)
-#define UART4_BASE_ADDR		(AIPS2_BASE_ADDR + 0x00021000)
-#define UART5_BASE_ADDR		(AIPS2_BASE_ADDR + 0x00022000)
-#define I2C2_BASE_ADDR		(AIPS2_BASE_ADDR + 0x00024000)
-#define I2C3_BASE_ADDR		(AIPS2_BASE_ADDR + 0x00025000)
-#define ESAI1_BASE_ADDR		(AIPS2_BASE_ADDR + 0x00027000)
-#define SAI0_BASE_ADDR		(AIPS2_BASE_ADDR + 0x00029000)
-#define SAI1_BASE_ADDR		(AIPS2_BASE_ADDR + 0x0002A000)
-#define SAI2_BASE_ADDR		(AIPS2_BASE_ADDR + 0x0002B000)
-#define SAI3_BASE_ADDR		(AIPS2_BASE_ADDR + 0x0002C000)
-#define SPDIF0_BASE_ADDR	(AIPS2_BASE_ADDR + 0x00030000)
-#define SPDIF1_BASE_ADDR	(AIPS2_BASE_ADDR + 0x00031000)
-#define ASRC0_BASE_ADDR		(AIPS2_BASE_ADDR + 0x00032000)
-#define ASRC1_BASE_ADDR		(AIPS2_BASE_ADDR + 0x00033000)
-#define VADC_BASE_ADDR		(AIPS2_BASE_ADDR + 0x00036000)
-#define VDEC_BASE_ADDR		(AIPS2_BASE_ADDR + 0x00037000)
-#define VIU_BASE_ADDR		(AIPS2_BASE_ADDR + 0x00038000)
-#define MIPI_CSI2_BASE_ADDR	(AIPS2_BASE_ADDR + 0x0003C000)
-#define ACE_BASE_ADDR		(AIPS2_BASE_ADDR + 0x00040000)
-#define TCON0_BASE_ADDR		(AIPS2_BASE_ADDR + 0x00050000)
-#define LDB_BASE_ADDR		(AIPS2_BASE_ADDR + 0x00052000)
-#define RLE_BASE_ADDR		(AIPS2_BASE_ADDR + 0x00054000)
-#define VPU_BASE_ADDR		(AIPS2_BASE_ADDR + 0x00058000)
-#define GC400T_BASE_ADDR	(AIPS2_BASE_ADDR + 0x0005C000)
-#define ENET_BASE_ADDR		(AIPS2_BASE_ADDR + 0x00060000)
-#define USB0_BASE_ADDR		(AIPS2_BASE_ADDR + 0x00063000)
-#define USB1_BASE_ADDR		(AIPS2_BASE_ADDR + 0x00064000)
-#define USB2_BASE_ADDR		(AIPS2_BASE_ADDR + 0x00065000)
-#define DMA_MUX2_BASE_ADDR	(AIPS2_BASE_ADDR + 0x00067000)
-#define DMA_MUX3_BASE_ADDR	(AIPS2_BASE_ADDR + 0x00068000)
-#define DDRMC_BASE_ADDR		(AIPS2_BASE_ADDR + 0x00069000)
-#define QSPI0_BASE_ADDR		(AIPS2_BASE_ADDR + 0x0006A000)
-#define USDHC0_BASE_ADDR		(AIPS2_BASE_ADDR + 0x0006C000)
-#define USDHC1_BASE_ADDR		(AIPS2_BASE_ADDR + 0x0006D000)
-#define USDHC2_BASE_ADDR		(AIPS2_BASE_ADDR + 0x0006E000)
-#define NFC_BASE_ADDR		(AIPS2_BASE_ADDR + 0x00078000)
-#define TEMPSENSOR_BASE_ADDR	(AIPS2_BASE_ADDR + 0x0007F000)
-
-/* MUX mode and PAD ctrl are in one register, similar to VYBRID */
-#define CONFIG_IOMUX_SHARE_CONF_REG
-
-#define FEC_QUIRK_ENET_MAC
-#define I2C_QUIRK_REG
-
-/* MSCM interrupt router */
-#define MSCM_IRSPRC_CP0_EN				1
-#define MSCM_IRSPRC_CP1_EN				2
-#define MSCM_IRSPRC_ROUTE_TO_CM4		MSCM_IRSPRC_CP0_EN
-#define MSCM_IRSPRC_ROUTE_TO_CA7		MSCM_IRSPRC_CP1_EN
-#define MSCM_IRSPRC_ROUTE_TO_CA7_CM4	MSCM_IRSPRC_CP1_EN | MSCM_IRSPRC_CP0_EN
-
-#define MSCM_IRSPRC_NUM					112
-
-
-/* ANADIG */
-#define ANADIG_PLL1_LOCKED				(1 << 6)
-#define ANADIG_PLL2_LOCKED				(1 << 5)
-#define ANADIG_PLL3_LOCKED				(1 << 1)
-#define ANADIG_PLL4_LOCKED				(1 << 4)
-#define ANADIG_PLL5_LOCKED				(1 << 2)
-#define ANADIG_PLL6_LOCKED				(1 << 3)
-#define ANADIG_PLL7_LOCKED				(1 << 0)
-#define ANADIG_PLL8_LOCKED				(1 << 7)
-
-
-/* DDRMC */ /* MATT: use imx6 MMDC -> need to change the following and align with DDR memory */
-#define DDRMC_PHY_DQ_TIMING				0x00002613
-#define DDRMC_PHY_DQS_TIMING				0x00002615
-#define DDRMC_PHY_CTRL					0x01210080
-#define DDRMC_PHY_MASTER_CTRL				0x0001012a
-#define DDRMC_PHY_SLAVE_CTRL				0x00012020
-
-#define DDRMC_PHY50_DDR3_MODE				(1 << 12)
-#define DDRMC_PHY50_EN_SW_HALF_CYCLE			(1 << 8)
-
-#define DDRMC_CR00_DRAM_CLASS_DDR3			(0x6 << 8)
-#define DDRMC_CR00_DRAM_CLASS_LPDDR2			(0x5 << 8)
-#define DDRMC_CR00_START				1
-#define DDRMC_CR02_DRAM_TINIT(v)			((v) & 0xffffff)
-#define DDRMC_CR10_TRST_PWRON(v)			(v)
-#define DDRMC_CR11_CKE_INACTIVE(v)			(v)
-#define DDRMC_CR12_WRLAT(v)				(((v) & 0x1f) << 8)
-#define DDRMC_CR12_CASLAT_LIN(v)			((v) & 0x3f)
-#define DDRMC_CR13_TRC(v)				(((v) & 0xff) << 24)
-#define DDRMC_CR13_TRRD(v)				(((v) & 0xff) << 16)
-#define DDRMC_CR13_TCCD(v)				(((v) & 0x1f) << 8)
-#define DDRMC_CR13_TBST_INT_INTERVAL(v)			((v) & 0x7)
-#define DDRMC_CR14_TFAW(v)				(((v) & 0x3f) << 24)
-#define DDRMC_CR14_TRP(v)				(((v) & 0x1f) << 16)
-#define DDRMC_CR14_TWTR(v)				(((v) & 0xf) << 8)
-#define DDRMC_CR14_TRAS_MIN(v)				((v) & 0xff)
-#define DDRMC_CR16_TMRD(v)				(((v) & 0x1f) << 24)
-#define DDRMC_CR16_TRTP(v)				(((v) & 0xf) << 16)
-#define DDRMC_CR17_TRAS_MAX(v)				(((v) & 0x1ffff) << 8)
-#define DDRMC_CR17_TMOD(v)				((v) & 0xff)
-#define DDRMC_CR18_TCKESR(v)				(((v) & 0x1f) << 8)
-#define DDRMC_CR18_TCKE(v)				((v) & 0x7)
-#define DDRMC_CR20_AP_EN				(1 << 24)
-#define DDRMC_CR21_TRCD_INT(v)				(((v) & 0xff) << 16)
-#define DDRMC_CR21_TRAS_LOCKOUT				(1 << 8)
-#define DDRMC_CR21_CCMAP_EN				1
-#define DDRMC_CR22_TDAL(v)				(((v) & 0x3f) << 16)
-#define DDRMC_CR23_BSTLEN(v)				(((v) & 0x7) << 24)
-#define DDRMC_CR23_TDLL(v)				((v) & 0xff)
-#define DDRMC_CR24_TRP_AB(v)				((v) & 0x1f)
-#define DDRMC_CR25_TREF_EN				(1 << 16)
-#define DDRMC_CR26_TREF(v)				(((v) & 0xffff) << 16)
-#define DDRMC_CR26_TRFC(v)				((v) & 0x3ff)
-#define DDRMC_CR28_TREF_INT(v)				((v) & 0xffff)
-#define DDRMC_CR29_TPDEX(v)				((v) & 0xffff)
-#define DDRMC_CR30_TXPDLL(v)				((v) & 0xffff)
-#define DDRMC_CR31_TXSNR(v)				(((v) & 0xffff) << 16)
-#define DDRMC_CR31_TXSR(v)				((v) & 0xffff)
-#define DDRMC_CR33_EN_QK_SREF				(1 << 16)
-#define DDRMC_CR34_CKSRX(v)				(((v) & 0xf) << 16)
-#define DDRMC_CR34_CKSRE(v)				(((v) & 0xf) << 8)
-#define DDRMC_CR38_FREQ_CHG_EN				(1 << 8)
-#define DDRMC_CR39_PHY_INI_COM(v)			(((v) & 0xffff) << 16)
-#define DDRMC_CR39_PHY_INI_STA(v)			(((v) & 0xff) << 8)
-#define DDRMC_CR39_FRQ_CH_DLLOFF(v)			((v) & 0x3)
-#define DDRMC_CR41_PHY_INI_STRT_INI_DIS			1
-#define DDRMC_CR48_MR1_DA_0(v)				(((v) & 0xffff) << 16)
-#define DDRMC_CR48_MR0_DA_0(v)				((v) & 0xffff)
-#define DDRMC_CR66_ZQCL(v)				(((v) & 0xfff) << 16)
-#define DDRMC_CR66_ZQINIT(v)				((v) & 0xfff)
-#define DDRMC_CR67_ZQCS(v)				((v) & 0xfff)
-#define DDRMC_CR69_ZQ_ON_SREF_EX(v)			(((v) & 0xf) << 8)
-#define DDRMC_CR70_REF_PER_ZQ(v)			(v)
-#define DDRMC_CR72_ZQCS_ROTATE				(1 << 24)
-#define DDRMC_CR73_APREBIT(v)				(((v) & 0xf) << 24)
-#define DDRMC_CR73_COL_DIFF(v)				(((v) & 0x7) << 16)
-#define DDRMC_CR73_ROW_DIFF(v)				(((v) & 0x3) << 8)
-#define DDRMC_CR74_BANKSPLT_EN				(1 << 24)
-#define DDRMC_CR74_ADDR_CMP_EN				(1 << 16)
-#define DDRMC_CR74_CMD_AGE_CNT(v)			(((v) & 0xff) << 8)
-#define DDRMC_CR74_AGE_CNT(v)				((v) & 0xff)
-#define DDRMC_CR75_RW_PG_EN				(1 << 24)
-#define DDRMC_CR75_RW_EN				(1 << 16)
-#define DDRMC_CR75_PRI_EN				(1 << 8)
-#define DDRMC_CR75_PLEN					1
-#define DDRMC_CR76_NQENT_ACTDIS(v)			(((v) & 0x7) << 24)
-#define DDRMC_CR76_D_RW_G_BKCN(v)			(((v) & 0x3) << 16)
-#define DDRMC_CR76_W2R_SPLT_EN				(1 << 8)
-#define DDRMC_CR76_CS_EN				1
-#define DDRMC_CR77_CS_MAP				(1 << 24)
-#define DDRMC_CR77_DI_RD_INTLEAVE			(1 << 8)
-#define DDRMC_CR77_SWAP_EN				1
-#define DDRMC_CR78_BUR_ON_FLY_BIT(v)			((v) & 0xf)
-#define DDRMC_CR79_CTLUPD_AREF				(1 << 24)
-#define DDRMC_CR82_INT_MASK				0x1fffffff
-#define DDRMC_CR87_ODT_WR_MAPCS0			(1 << 24)
-#define DDRMC_CR87_ODT_RD_MAPCS0			(1 << 16)
-#define DDRMC_CR88_TODTL_CMD(v)				(((v) & 0x1f) << 16)
-#define DDRMC_CR89_AODT_RWSMCS(v)			((v) & 0xf)
-#define DDRMC_CR91_R2W_SMCSDL(v)			(((v) & 0x7) << 16)
-#define DDRMC_CR96_WLMRD(v)				(((v) & 0x3f) << 8)
-#define DDRMC_CR96_WLDQSEN(v)				((v) & 0x3f)
-#define DDRMC_CR105_RDLVL_DL_0(v)			(((v) & 0xff) << 8)
-#define DDRMC_CR110_RDLVL_DL_1(v)			((v) & 0xff)
-#define DDRMC_CR114_RDLVL_GTDL_2(v)			(((v) & 0xffff) << 8)
-#define DDRMC_CR117_AXI0_W_PRI(v)			(((v) & 0x3) << 8)
-#define DDRMC_CR117_AXI0_R_PRI(v)			((v) & 0x3)
-#define DDRMC_CR118_AXI1_W_PRI(v)			(((v) & 0x3) << 24)
-#define DDRMC_CR118_AXI1_R_PRI(v)			(((v) & 0x3) << 16)
-#define DDRMC_CR120_AXI0_PRI1_RPRI(v)			(((v) & 0xf) << 24)
-#define DDRMC_CR120_AXI0_PRI0_RPRI(v)			(((v) & 0xf) << 16)
-#define DDRMC_CR121_AXI0_PRI3_RPRI(v)			(((v) & 0xf) << 8)
-#define DDRMC_CR121_AXI0_PRI2_RPRI(v)			((v) & 0xf)
-#define DDRMC_CR122_AXI1_PRI1_RPRI(v)			(((v) & 0xf) << 24)
-#define DDRMC_CR122_AXI1_PRI0_RPRI(v)			(((v) & 0xf) << 16)
-#define DDRMC_CR122_AXI0_PRIRLX(v)			((v) & 0x3ff)
-#define DDRMC_CR123_AXI1_PRI3_RPRI(v)			(((v) & 0xf) << 8)
-#define DDRMC_CR123_AXI1_PRI2_RPRI(v)			((v) & 0xf)
-#define DDRMC_CR124_AXI1_PRIRLX(v)			((v) & 0x3ff)
-#define DDRMC_CR126_PHY_RDLAT(v)			(((v) & 0x3f) << 8)
-#define DDRMC_CR132_WRLAT_ADJ(v)			(((v) & 0x1f) << 8)
-#define DDRMC_CR132_RDLAT_ADJ(v)			((v) & 0x3f)
-#define DDRMC_CR139_PHY_WRLV_RESPLAT(v)			(((v) & 0xff) << 24)
-#define DDRMC_CR139_PHY_WRLV_LOAD(v)			(((v) & 0xff) << 16)
-#define DDRMC_CR139_PHY_WRLV_DLL(v)			(((v) & 0xff) << 8)
-#define DDRMC_CR139_PHY_WRLV_EN(v)			((v) & 0xff)
-#define DDRMC_CR154_PAD_ZQ_EARLY_CMP_EN_TIMER(v)	(((v) & 0x1f) << 27)
-#define DDRMC_CR154_PAD_ZQ_MODE(v)			(((v) & 0x3) << 21)
-#define DDRMC_CR155_AXI0_AWCACHE			(1 << 10)
-#define DDRMC_CR155_PAD_ODT_BYTE1(v)			((v) & 0x7)
-#define DDRMC_CR158_TWR(v)				((v) & 0x3f)
-
-#if !(defined(__KERNEL_STRICT_NAMES) || defined(__ASSEMBLY__))
-#include <asm/types.h>
-
-/* System Reset Controller (SRC) */
-struct src {
-	u32 scr;
-	u32 sbmr1;
-	u32 srsr;
-	u32 secr;
-	u32 gpsr;
-	u32 sicr;
-	u32 simr;
-	u32 sbmr2;
-	u32 gpr0;
-	u32 gpr1;
-	u32 gpr2;
-	u32 gpr3;
-	u32 gpr4;
-	u32 hab0;
-	u32 hab1;
-	u32 hab2;
-	u32 hab3;
-	u32 hab4;
-	u32 hab5;
-	u32 misc0;
-	u32 misc1;
-	u32 misc2;
-	u32 misc3;
-	u32 misc4;
-};
-
-/* Periodic Interrupt Timer (PIT) */
-struct pit_reg {
-	u32 mcr;
-	u32 recv0[55];
-	u32 ltmr64h;
-	u32 ltmr64l;
-	u32 recv1[6];
-	u32 ldval0;
-	u32 cval0;
-	u32 tctrl0;
-	u32 tflg0;
-	u32 ldval1;
-	u32 cval1;
-	u32 tctrl1;
-	u32 tflg1;
-	u32 ldval2;
-	u32 cval2;
-	u32 tctrl2;
-	u32 tflg2;
-	u32 ldval3;
-	u32 cval3;
-	u32 tctrl3;
-	u32 tflg3;
-	u32 ldval4;
-	u32 cval4;
-	u32 tctrl4;
-	u32 tflg4;
-	u32 ldval5;
-	u32 cval5;
-	u32 tctrl5;
-	u32 tflg5;
-	u32 ldval6;
-	u32 cval6;
-	u32 tctrl6;
-	u32 tflg6;
-	u32 ldval7;
-	u32 cval7;
-	u32 tctrl7;
-	u32 tflg7;
-};
-
-/* Watchdog Timer (WDOG) */
-struct wdog_regs {
-	u32 wcr;
-	u32 wir;
-	u32 wto;
-	u32 wwn;
-	u32 wsr;
-	u32 wco;
-	u32 wsk;
-};
-
-/* LPDDR2/DDR3 SDRAM Memory Controller (DDRMC) */
-struct ddrmr_regs {
-	u32 cr[162];
-	u32 rsvd[94];
-	u32 phy[53];
-};
-
-/* On-Chip One Time Programmable Controller (OCOTP)#1 */
-struct ocotp_regs {
-	u32 ctrl;
-	u32 ctrl_set;
-	u32 ctrl_clr;
-	u32 ctrl_tog;
-	u32 timing;
-	u32 rsvd0[3];
-	u32 data;
-	u32 rsvd1[3];
-	u32 read_ctrl;
-	u32 rsvd2[3];
-	u32 read_fuse_data;
-	u32 rsvd3[7];
-	u32 scs;
-	u32 scs_set;
-	u32 scs_clr;
-	u32 scs_tog;
-	u32 crc_addr;
-	u32 rsvd4[3];
-	u32 crc_value;
-	u32 rsvd5[3];
-	u32 version;
-	u32 rsvd6[0xdb];
-
-	struct fuse_bank {
-		u32 fuse_regs[0x20];
-	} bank[16];
-};
-
-struct fuse_bank0_regs {
-	u32	lock;
-	u32	rsvd0[3];
-	u32	cfg0;
-	u32	rsvd1[3];
-	u32	cfg1;
-	u32	rsvd2[3];
-	u32	cfg2;
-	u32	rsvd3[3];
-	u32	cfg3;
-	u32	rsvd4[3];
-	u32	cfg4;
-	u32	rsvd5[3];
-	u32	cfg5;
-	u32	rsvd6[3];
-	u32	cfg6;
-	u32	rsvd7[3];
-};
-
-struct fuse_bank1_regs {
-	u32	mem0;
-	u32	rsvd0[3];
-	u32	mem1;
-	u32	rsvd1[3];
-	u32	mem2;
-	u32	rsvd2[3];
-	u32	mem3;
-	u32	rsvd3[3];
-	u32	mem4;
-	u32	rsvd4[3];
-	u32	ana0;
-	u32	rsvd5[3];
-	u32	ana1;
-	u32	rsvd6[3];
-	u32	ana2;
-	u32	rsvd7[3];
-};
-
-struct fuse_bank4_regs {
-	u32 sjc_resp0;
-	u32 rsvd0[3];
-	u32 sjc_resp1;
-	u32 rsvd1[3];
-	u32 mac_addr0;
-	u32 rsvd2[3];
-	u32 mac_addr1;
-	u32 rsvd3[3];
-	u32 mac_addr2;
-	u32 rsvd4[3];
-	u32 mac_addr3;
-	u32 rsvd5[3];
-	u32 gp1;
-	u32 rsvd6[3];
-	u32 gp2;
-	u32 rsvd7[3];
-};
-
-/* UART */
-struct lpuart_fsl {
-	u8 ubdh;
-	u8 ubdl;
-	u8 uc1;
-	u8 uc2;
-	u8 us1;
-	u8 us2;
-	u8 uc3;
-	u8 ud;
-	u8 uma1;
-	u8 uma2;
-	u8 uc4;
-	u8 uc5;
-	u8 ued;
-	u8 umodem;
-	u8 uir;
-	u8 reserved;
-	u8 upfifo;
-	u8 ucfifo;
-	u8 usfifo;
-	u8 utwfifo;
-	u8 utcfifo;
-	u8 urwfifo;
-	u8 urcfifo;
-	u8 rsvd[28];
-};
-
-/* MSCM Interrupt Router */
-struct mscm_ir {
-	u32 ircp0ir;
-	u32 ircp1ir;
-	u32 rsvd1[6];
-	u32 ircpgir;
-	u32 rsvd2[23];
-	u16 irsprc[112];
-};
-
-struct iim_regs {
-	u32	ctrl;
-	u32	ctrl_set;
-	u32     ctrl_clr;
-	u32	ctrl_tog;
-	u32	timing;
-	u32     rsvd0[3];
-	u32     data;
-	u32     rsvd1[3];
-	u32     read_ctrl;
-	u32     rsvd2[3];
-	u32     fuse_data;
-	u32     rsvd3[3];
-	u32     sticky;
-	u32     rsvd4[3];
-	u32     scs;
-	u32     scs_set;
-	u32     scs_clr;
-	u32     scs_tog;
-	u32     crc_addr;
-	u32     rsvd5[3];
-	u32     crc_value;
-	u32     rsvd6[3];
-	u32     version;
-	u32     rsvd7[0xdb];
-
-	struct fuse_bank_sac58r {
-		u32	fuse_regs[0x20];
-	} bank[15];
-};
-
-#endif	/* __ASSEMBLER__*/
-
-#endif	/* __ASM_ARCH_IMX_REGS_H__ */
-
diff --git a/arch/arm/include/asm/arch-sac58r/iomux-sac58r.h b/arch/arm/include/asm/arch-sac58r/iomux-sac58r.h
deleted file mode 100644
index a83d3a6ced..0000000000
--- a/arch/arm/include/asm/arch-sac58r/iomux-sac58r.h
+++ /dev/null
@@ -1,318 +0,0 @@
-/*
- * (C) Copyright 2013 Freescale Semiconductor, Inc.
- *
- * SPDX-License-Identifier:	GPL-2.0+
- */
-
-#ifndef __IOMUX_SAC58R_H__
-#define __IOMUX_SAC58R_H__
-
-#include <asm/imx-common/iomux-v3.h>
-
-
-/* Pad control groupings */
-#define SAC58R_UART_PAD_CTRL	(PAD_CTL_PUS_100K_UP | PAD_CTL_SPEED_MED | \
-			PAD_CTL_DSE_25ohm | PAD_CTL_OBE_IBE_ENABLE)
-#define SAC58R_UART_PAD_CTRL_RX	(PAD_CTL_PUS_100K_UP | PAD_CTL_SPEED_MED | \
-			PAD_CTL_DSE_25ohm | PAD_CTL_IBE_ENABLE)
-#define SAC58R_SDHC_PAD_CTRL	(PAD_CTL_PUS_47K_UP | PAD_CTL_SPEED_HIGH | \
-			PAD_CTL_DSE_75ohm| PAD_CTL_SRE | PAD_CTL_HYS | \
-			PAD_CTL_OBE_IBE_ENABLE)
-#define SAC58R_ENET_PAD_CTRL (PAD_CTL_PUS_47K_UP | PAD_CTL_SPEED_HIGH | \
-			PAD_CTL_DSE_50ohm | PAD_CTL_OBE_IBE_ENABLE)
-#define SAC58R_DDR_PAD_CTRL	PAD_CTL_DSE_25ohm
-#define SAC58R_I2C_PAD_CTRL	(PAD_CTL_PUS_100K_UP | PAD_CTL_DSE_37ohm | \
-				PAD_CTL_SPEED_MED | PAD_CTL_HYS | PAD_CTL_ODE | \
-				PAD_CTL_SRE | PAD_CTL_OBE_IBE_ENABLE)
-
-#define SAC58R_I2C_GPIO_PAD_CTRL	(PAD_CTL_PUS_22K_UP | PAD_CTL_DSE_25ohm | \
-				PAD_CTL_SPEED_MED | PAD_CTL_IBE_ENABLE)
-
-#define SAC58R_NFC_IO_PAD_CTRL (PAD_CTL_SPEED_HIGH | PAD_CTL_SRE | \
-				PAD_CTL_DSE_50ohm | PAD_CTL_PUS_47K_UP | PAD_CTL_OBE_IBE_ENABLE)
-#define SAC58R_NFC_SIG_PAD_CTRL	(PAD_CTL_SPEED_HIGH | PAD_CTL_SRE | \
-				PAD_CTL_DSE_50ohm | PAD_CTL_PUS_47K_UP | PAD_CTL_OBE_ENABLE)
-#define SAC58R_NFC_SIG_RB_PAD_CTRL	(PAD_CTL_SPEED_HIGH | \
-				PAD_CTL_DSE_20ohm | PAD_CTL_IBE_ENABLE)
-#define SAC58R_SAI_PAD_CTRL	(PAD_CTL_PUS_100K_UP | PAD_CTL_SPEED_HIGH | \
-				PAD_CTL_DSE_25ohm | PAD_CTL_OBE_IBE_ENABLE)
-#define SAC58R_ESAI_PAD_CTRL (PAD_CTL_PUS_100K_UP | PAD_CTL_SPEED_HIGH | \
-				PAD_CTL_DSE_25ohm | PAD_CTL_OBE_IBE_ENABLE)
-#define SAC58R_GPIO_PAD_CTRL	(PAD_CTL_PUS_100K_UP | PAD_CTL_SPEED_MED | \
-			PAD_CTL_DSE_25ohm | PAD_CTL_OBE_IBE_ENABLE)
-
-#define SAC58R_SPI_PAD_CTRL	(PAD_CTL_PUS_100K_UP | PAD_CTL_SPEED_HIGH | \
-				PAD_CTL_DSE_25ohm)
-
-#define SAC58R_USBID_PAD_CTRL	(PAD_CTL_PUS_47K_UP | PAD_CTL_SPEED_MED | \
-				PAD_CTL_DSE_75ohm | PAD_CTL_IBE_ENABLE)
-
-#define SAC58R_QSPI_SIG_PAD_CTRL (PAD_CTL_SPEED_HIGH | \
-				PAD_CTL_DSE_20ohm | PAD_CTL_OBE_IBE_ENABLE)
-
-#define SAC58R_QSPI_CS_SIG_PAD_CTRL (PAD_CTL_SPEED_HIGH | \
-				PAD_CTL_DSE_20ohm | PAD_CTL_PUS_22K_UP | PAD_CTL_OBE_IBE_ENABLE)
-
-enum {
-	SAC58R_PAD_PH14__UART0_TX		= IOMUX_PAD(0x03b8, 0x03b8, 1, 0x0b50, 2, SAC58R_UART_PAD_CTRL),
-	SAC58R_PAD_PH15__UART0_RX		= IOMUX_PAD(0x03bc, 0x03bc, 0, 0x0b20, 2, SAC58R_UART_PAD_CTRL_RX),
-	SAC58R_PAD_PF11__UART1_TX		= IOMUX_PAD(0x02ac, 0x02ac, 1, 0x0b54, 2, SAC58R_UART_PAD_CTRL),
-	SAC58R_PAD_PF12__UART1_RX		= IOMUX_PAD(0x02b0, 0x02b0, 0, 0x0b28, 2, SAC58R_UART_PAD_CTRL_RX),
-	SAC58R_PAD_PL5__UART2_TX		= IOMUX_PAD(0x0594, 0x0594, 1, 0x0b58, 2, SAC58R_UART_PAD_CTRL),
-	SAC58R_PAD_PL4__UART2_RX		= IOMUX_PAD(0x03bc, 0x03bc, 0, 0x0b30, 2, SAC58R_UART_PAD_CTRL_RX),
-	SAC58R_PAD_PE28__UART3_TX		= IOMUX_PAD(0x0270, 0x0270, 1, 0x0b38, 2, SAC58R_UART_PAD_CTRL),
-	SAC58R_PAD_PE27__UART3_RX		= IOMUX_PAD(0x026c, 0x026c, 0, 0x0b5c, 2, SAC58R_UART_PAD_CTRL_RX),
-	SAC58R_PAD_PH0__UART4_TX		= IOMUX_PAD(0x0380, 0x0380, 1, 0x0b60, 3, SAC58R_UART_PAD_CTRL),
-	SAC58R_PAD_PH1__UART4_RX		= IOMUX_PAD(0x0384, 0x0384, 0, 0x0b40, 3, SAC58R_UART_PAD_CTRL_RX),
-	SAC58R_PAD_PH9__UART5_TX		= IOMUX_PAD(0x03a4, 0x03a4, 1, 0x0b64, 3, SAC58R_UART_PAD_CTRL),
-	SAC58R_PAD_PH10__UART5_RX		= IOMUX_PAD(0x03a8, 0x03a8, 0, 0x0b48, 3, SAC58R_UART_PAD_CTRL_RX),
-
-	SAC58R_PAD_PF0__SDHC0_CLK		= IOMUX_PAD(0x0280, 0x0280, 1, 0x0dd8, 2, SAC58R_SDHC_PAD_CTRL),
-	SAC58R_PAD_PF1__SDHC0_CMD		= IOMUX_PAD(0x0284, 0x0284, 1, 0x0dc4, 2, SAC58R_SDHC_PAD_CTRL),
-	SAC58R_PAD_PF2__SDHC0_DAT0		= IOMUX_PAD(0x0288, 0x0288, 1, 0x0dc8, 2, SAC58R_SDHC_PAD_CTRL),
-	SAC58R_PAD_PF3__SDHC0_DAT1		= IOMUX_PAD(0x028c, 0x028c, 1, 0x0dcc, 2, SAC58R_SDHC_PAD_CTRL),
-	SAC58R_PAD_PF4__SDHC0_DAT2		= IOMUX_PAD(0x0290, 0x0290, 1, 0x0dd0, 2, SAC58R_SDHC_PAD_CTRL),
-	SAC58R_PAD_PF5__SDHC0_DAT3		= IOMUX_PAD(0x0294, 0x0294, 1, 0x0dd4, 2, SAC58R_SDHC_PAD_CTRL),
-
-	SAC58R_PAD_PF26__SDHC1_CLK		= IOMUX_PAD(0x02e8, 0x02e8, 1, 0x0df8, 2, SAC58R_SDHC_PAD_CTRL),
-	SAC58R_PAD_PF27__SDHC1_CMD		= IOMUX_PAD(0x02ec, 0x02ec, 1, 0x0de4, 2, SAC58R_SDHC_PAD_CTRL),
-	SAC58R_PAD_PF22__SDHC1_DAT0		= IOMUX_PAD(0x02d8, 0x02d8, 1, 0x0de8, 2, SAC58R_SDHC_PAD_CTRL),
-	SAC58R_PAD_PF23__SDHC1_DAT1		= IOMUX_PAD(0x02dc, 0x02dc, 1, 0x0dec, 2, SAC58R_SDHC_PAD_CTRL),
-	SAC58R_PAD_PF19__SDHC1_DAT2		= IOMUX_PAD(0x02cc, 0x02cc, 1, 0x0df0, 2, SAC58R_SDHC_PAD_CTRL),
-	SAC58R_PAD_PF20__SDHC1_DAT3		= IOMUX_PAD(0x02d0, 0x02d0, 1, 0x0df4, 2, SAC58R_SDHC_PAD_CTRL),
-
-	SAC58R_PAD_PC12__SDHC2_CLK		= IOMUX_PAD(0x0130, 0x0130, 2, 0x0e28, 2, SAC58R_SDHC_PAD_CTRL),
-	SAC58R_PAD_PC13__SDHC2_CMD		= IOMUX_PAD(0x0134, 0x0134, 2, 0x0e00, 2, SAC58R_SDHC_PAD_CTRL),
-	SAC58R_PAD_PC9__SDHC2_DAT0		= IOMUX_PAD(0x0124, 0x0124, 2, 0x0e08, 2, SAC58R_SDHC_PAD_CTRL),
-	SAC58R_PAD_PC6__SDHC2_DAT1		= IOMUX_PAD(0x0118, 0x0118, 2, 0x0e0c, 2, SAC58R_SDHC_PAD_CTRL),
-	SAC58R_PAD_PC5__SDHC2_DAT2		= IOMUX_PAD(0x0114, 0x0114, 2, 0x0e10, 2, SAC58R_SDHC_PAD_CTRL),
-	SAC58R_PAD_PC2__SDHC2_DAT3		= IOMUX_PAD(0x0108, 0x0108, 2, 0x0e14, 2, SAC58R_SDHC_PAD_CTRL),
-	SAC58R_PAD_PC10__SDHC2_DAT4		= IOMUX_PAD(0x0128, 0x0128, 2, 0x0e18, 2, SAC58R_SDHC_PAD_CTRL),
-	SAC58R_PAD_PC11__SDHC2_DAT5		= IOMUX_PAD(0x012c, 0x012c, 2, 0x0e1c, 2, SAC58R_SDHC_PAD_CTRL),
-	SAC58R_PAD_PC7__SDHC2_DAT6		= IOMUX_PAD(0x011c, 0x011c, 2, 0x0e20, 2, SAC58R_SDHC_PAD_CTRL),
-	SAC58R_PAD_PC8__SDHC2_DAT7		= IOMUX_PAD(0x0120, 0x0120, 2, 0x0e24, 2, SAC58R_SDHC_PAD_CTRL),
-	
-	SAC58R_PAD_PD12__LVDS0_CLKP		= IOMUX_PAD(0x01B0, 0x01B0, 3, __NA_, 0, 0x0),
-	SAC58R_PAD_PD13__LVDS0_CLKN		= IOMUX_PAD(0x01B4, 0x01B4, 3, __NA_, 0, 0x0),
-	SAC58R_PAD_PD11__LVDS0_TX0P		= IOMUX_PAD(0x01AC, 0x01AC, 5, __NA_, 0, 0x0),
-	SAC58R_PAD_PD14__LVDS0_TX0N		= IOMUX_PAD(0x01B8, 0x01B8, 5, __NA_, 0, 0x0),
-	SAC58R_PAD_PD15__LVDS0_TX1P		= IOMUX_PAD(0x01BC, 0x01BC, 3, __NA_, 0, 0x0),
-	SAC58R_PAD_PD16__LVDS0_TX1N		= IOMUX_PAD(0x01C0, 0x01C0, 3, __NA_, 0, 0x0),
-	SAC58R_PAD_PD17__LVDS0_TX2P		= IOMUX_PAD(0x01C4, 0x01C4, 5, __NA_, 0, 0x0),
-	SAC58R_PAD_PD18__LVDS0_TX2N		= IOMUX_PAD(0x01C8, 0x01C8, 3, __NA_, 0, 0x0),
-	SAC58R_PAD_PD19__LVDS0_TX3P		= IOMUX_PAD(0x01CC, 0x01CC, 4, __NA_, 0, 0x0),
-	SAC58R_PAD_PD20__LVDS0_TX3N		= IOMUX_PAD(0x01D0, 0x01D0, 3, __NA_, 0, 0x0),
-	SAC58R_PAD_PK7__GPIO327			= IOMUX_PAD(0x051C, 0x51C, 0, __NA_, 0, 0x2102),
-	SAC58R_PAD_PK9__GPIO329			= IOMUX_PAD(0x0524, 0x0524, 0, __NA_, 0, 0x2102),
-
-	SAC58R_PAD_DDR_A15__DDR_A15		= IOMUX_PAD(0x006c, 0x006c, 0, __NA_, 0, SAC58R_DDR_PAD_CTRL),
-	SAC58R_PAD_DDR_A14__DDR_A14		= IOMUX_PAD(0x0068, 0x0068, 0, __NA_, 0, SAC58R_DDR_PAD_CTRL),
-	SAC58R_PAD_DDR_A13__DDR_A13		= IOMUX_PAD(0x0064, 0x0064, 0, __NA_, 0, SAC58R_DDR_PAD_CTRL),
-	SAC58R_PAD_DDR_A12__DDR_A12		= IOMUX_PAD(0x0060, 0x0060, 0, __NA_, 0, SAC58R_DDR_PAD_CTRL),
-	SAC58R_PAD_DDR_A11__DDR_A11		= IOMUX_PAD(0x005c, 0x005c, 0, __NA_, 0, SAC58R_DDR_PAD_CTRL),
-	SAC58R_PAD_DDR_A10__DDR_A10		= IOMUX_PAD(0x0058, 0x0058, 0, __NA_, 0, SAC58R_DDR_PAD_CTRL),
-	SAC58R_PAD_DDR_A9__DDR_A9		= IOMUX_PAD(0x0054, 0x0054, 0, __NA_, 0, SAC58R_DDR_PAD_CTRL),
-	SAC58R_PAD_DDR_A8__DDR_A8		= IOMUX_PAD(0x0050, 0x0050, 0, __NA_, 0, SAC58R_DDR_PAD_CTRL),
-	SAC58R_PAD_DDR_A7__DDR_A7		= IOMUX_PAD(0x004c, 0x004c, 0, __NA_, 0, SAC58R_DDR_PAD_CTRL),
-	SAC58R_PAD_DDR_A6__DDR_A6		= IOMUX_PAD(0x0048, 0x0048, 0, __NA_, 0, SAC58R_DDR_PAD_CTRL),
-	SAC58R_PAD_DDR_A5__DDR_A5		= IOMUX_PAD(0x0044, 0x0044, 0, __NA_, 0, SAC58R_DDR_PAD_CTRL),
-	SAC58R_PAD_DDR_A4__DDR_A4		= IOMUX_PAD(0x0040, 0x0040, 0, __NA_, 0, SAC58R_DDR_PAD_CTRL),
-	SAC58R_PAD_DDR_A3__DDR_A3		= IOMUX_PAD(0x003c, 0x003c, 0, __NA_, 0, SAC58R_DDR_PAD_CTRL),
-	SAC58R_PAD_DDR_A2__DDR_A2		= IOMUX_PAD(0x0038, 0x0038, 0, __NA_, 0, SAC58R_DDR_PAD_CTRL),
-	SAC58R_PAD_DDR_A1__DDR_A1		= IOMUX_PAD(0x0034, 0x0034, 0, __NA_, 0, SAC58R_DDR_PAD_CTRL),
-	SAC58R_PAD_DDR_A0__DDR_A0		= IOMUX_PAD(0x0030, 0x0030, 0, __NA_, 0, SAC58R_DDR_PAD_CTRL),
-	SAC58R_PAD_DDR_BA2__DDR_BA_2	= IOMUX_PAD(0x002c, 0x002c, 0, __NA_, 0, SAC58R_DDR_PAD_CTRL),
-	SAC58R_PAD_DDR_BA1__DDR_BA_1	= IOMUX_PAD(0x0028, 0x0028, 0, __NA_, 0, SAC58R_DDR_PAD_CTRL),
-	SAC58R_PAD_DDR_BA0__DDR_BA_0	= IOMUX_PAD(0x0024, 0x0024, 0, __NA_, 0, SAC58R_DDR_PAD_CTRL),
-	SAC58R_PAD_DDR_CAS__DDR_CAS		= IOMUX_PAD(0x0008, 0x0008, 0, __NA_, 0, SAC58R_DDR_PAD_CTRL),
-	SAC58R_PAD_DDR_CKE1__DDR_CKE1	= IOMUX_PAD(0x0018, 0x0018, 0, __NA_, 0, SAC58R_DDR_PAD_CTRL),
-	SAC58R_PAD_DDR_CKE0__DDR_CKE0	= IOMUX_PAD(0x0014, 0x0014, 0, __NA_, 0, SAC58R_DDR_PAD_CTRL),
-	SAC58R_PAD_DDR_CLK0__DDR_CLK0	= IOMUX_PAD(0x0004, 0x0004, 0, __NA_, 0, SAC58R_DDR_PAD_CTRL),
-	SAC58R_PAD_DDR_CS_B1__DDR_CS_B1	= IOMUX_PAD(0x0020, 0x0020, 0, __NA_, 0, SAC58R_DDR_PAD_CTRL),
-	SAC58R_PAD_DDR_CS_B0__DDR_CS_B0	= IOMUX_PAD(0x001c, 0x001c, 0, __NA_, 0, SAC58R_DDR_PAD_CTRL),
-	SAC58R_PAD_DDR_D31__DDR_D31		= IOMUX_PAD(0x010c, 0x010c, 0, __NA_, 0, SAC58R_DDR_PAD_CTRL),
-	SAC58R_PAD_DDR_D30__DDR_D30		= IOMUX_PAD(0x0108, 0x0108, 0, __NA_, 0, SAC58R_DDR_PAD_CTRL),
-	SAC58R_PAD_DDR_D29__DDR_D29		= IOMUX_PAD(0x0104, 0x0104, 0, __NA_, 0, SAC58R_DDR_PAD_CTRL),
-	SAC58R_PAD_DDR_D28__DDR_D28		= IOMUX_PAD(0x0100, 0x0100, 0, __NA_, 0, SAC58R_DDR_PAD_CTRL),
-	SAC58R_PAD_DDR_D27__DDR_D27		= IOMUX_PAD(0x00fc, 0x00fc, 0, __NA_, 0, SAC58R_DDR_PAD_CTRL),
-	SAC58R_PAD_DDR_D26__DDR_D26		= IOMUX_PAD(0x00f8, 0x00f8, 0, __NA_, 0, SAC58R_DDR_PAD_CTRL),
-	SAC58R_PAD_DDR_D25__DDR_D25		= IOMUX_PAD(0x00f4, 0x00f4, 0, __NA_, 0, SAC58R_DDR_PAD_CTRL),
-	SAC58R_PAD_DDR_D24__DDR_D24		= IOMUX_PAD(0x00f0, 0x00f0, 0, __NA_, 0, SAC58R_DDR_PAD_CTRL),
-	SAC58R_PAD_DDR_D23__DDR_D23		= IOMUX_PAD(0x00ec, 0x00ec, 0, __NA_, 0, SAC58R_DDR_PAD_CTRL),
-	SAC58R_PAD_DDR_D22__DDR_D22		= IOMUX_PAD(0x00e8, 0x00e8, 0, __NA_, 0, SAC58R_DDR_PAD_CTRL),
-	SAC58R_PAD_DDR_D21__DDR_D21		= IOMUX_PAD(0x00e4, 0x00e4, 0, __NA_, 0, SAC58R_DDR_PAD_CTRL),
-	SAC58R_PAD_DDR_D20__DDR_D20		= IOMUX_PAD(0x00e0, 0x0ee0, 0, __NA_, 0, SAC58R_DDR_PAD_CTRL),
-	SAC58R_PAD_DDR_D19__DDR_D19		= IOMUX_PAD(0x00dc, 0x00dc, 0, __NA_, 0, SAC58R_DDR_PAD_CTRL),
-	SAC58R_PAD_DDR_D18__DDR_D18		= IOMUX_PAD(0x00d8, 0x00d8, 0, __NA_, 0, SAC58R_DDR_PAD_CTRL),
-	SAC58R_PAD_DDR_D17__DDR_D17		= IOMUX_PAD(0x00d4, 0x00d4, 0, __NA_, 0, SAC58R_DDR_PAD_CTRL),
-	SAC58R_PAD_DDR_D16__DDR_D16		= IOMUX_PAD(0x00d0, 0x00d0, 0, __NA_, 0, SAC58R_DDR_PAD_CTRL),
-	SAC58R_PAD_DDR_D15__DDR_D15		= IOMUX_PAD(0x00cc, 0x00cc, 0, __NA_, 0, SAC58R_DDR_PAD_CTRL),
-	SAC58R_PAD_DDR_D14__DDR_D14		= IOMUX_PAD(0x00c8, 0x00c8, 0, __NA_, 0, SAC58R_DDR_PAD_CTRL),
-	SAC58R_PAD_DDR_D13__DDR_D13		= IOMUX_PAD(0x00c4, 0x00c4, 0, __NA_, 0, SAC58R_DDR_PAD_CTRL),
-	SAC58R_PAD_DDR_D12__DDR_D12		= IOMUX_PAD(0x00c0, 0x00c0, 0, __NA_, 0, SAC58R_DDR_PAD_CTRL),
-	SAC58R_PAD_DDR_D11__DDR_D11		= IOMUX_PAD(0x00bc, 0x00bc, 0, __NA_, 0, SAC58R_DDR_PAD_CTRL),
-	SAC58R_PAD_DDR_D10__DDR_D10		= IOMUX_PAD(0x00b8, 0x00b8, 0, __NA_, 0, SAC58R_DDR_PAD_CTRL),
-	SAC58R_PAD_DDR_D9__DDR_D9		= IOMUX_PAD(0x00b4, 0x00b4, 0, __NA_, 0, SAC58R_DDR_PAD_CTRL),
-	SAC58R_PAD_DDR_D8__DDR_D8		= IOMUX_PAD(0x00b0, 0x00b0, 0, __NA_, 0, SAC58R_DDR_PAD_CTRL),
-	SAC58R_PAD_DDR_D7__DDR_D7		= IOMUX_PAD(0x00ac, 0x00ac, 0, __NA_, 0, SAC58R_DDR_PAD_CTRL),
-	SAC58R_PAD_DDR_D6__DDR_D6		= IOMUX_PAD(0x00a8, 0x00a8, 0, __NA_, 0, SAC58R_DDR_PAD_CTRL),
-	SAC58R_PAD_DDR_D5__DDR_D5		= IOMUX_PAD(0x00a4, 0x00a4, 0, __NA_, 0, SAC58R_DDR_PAD_CTRL),
-	SAC58R_PAD_DDR_D4__DDR_D4		= IOMUX_PAD(0x00a0, 0x00a0, 0, __NA_, 0, SAC58R_DDR_PAD_CTRL),
-	SAC58R_PAD_DDR_D3__DDR_D3		= IOMUX_PAD(0x009c, 0x009c, 0, __NA_, 0, SAC58R_DDR_PAD_CTRL),
-	SAC58R_PAD_DDR_D2__DDR_D2		= IOMUX_PAD(0x0098, 0x0098, 0, __NA_, 0, SAC58R_DDR_PAD_CTRL),
-	SAC58R_PAD_DDR_D1__DDR_D1		= IOMUX_PAD(0x0094, 0x0094, 0, __NA_, 0, SAC58R_DDR_PAD_CTRL),
-	SAC58R_PAD_DDR_D0__DDR_D0		= IOMUX_PAD(0x0090, 0x0090, 0, __NA_, 0, SAC58R_DDR_PAD_CTRL),
-	SAC58R_PAD_DDR_DM1__DDR_DM3		= IOMUX_PAD(0x007c, 0x007c, 0, __NA_, 0, SAC58R_DDR_PAD_CTRL),
-	SAC58R_PAD_DDR_DM0__DDR_DM2		= IOMUX_PAD(0x0078, 0x0078, 0, __NA_, 0, SAC58R_DDR_PAD_CTRL),
-	SAC58R_PAD_DDR_DM1__DDR_DM1		= IOMUX_PAD(0x0074, 0x0074, 0, __NA_, 0, SAC58R_DDR_PAD_CTRL),
-	SAC58R_PAD_DDR_DM0__DDR_DM0		= IOMUX_PAD(0x0070, 0x0070, 0, __NA_, 0, SAC58R_DDR_PAD_CTRL),
-	SAC58R_PAD_DDR_DQS3__DDR_DQS3	= IOMUX_PAD(0x008c, 0x008c, 0, __NA_, 0, SAC58R_DDR_PAD_CTRL),
-	SAC58R_PAD_DDR_DQS0__DDR_DQS2	= IOMUX_PAD(0x0088, 0x0088, 0, __NA_, 0, SAC58R_DDR_PAD_CTRL),
-	SAC58R_PAD_DDR_DQS1__DDR_DQS1	= IOMUX_PAD(0x0084, 0x0084, 0, __NA_, 0, SAC58R_DDR_PAD_CTRL),
-	SAC58R_PAD_DDR_DQS0__DDR_DQS0	= IOMUX_PAD(0x0080, 0x0080, 0, __NA_, 0, SAC58R_DDR_PAD_CTRL),
-	SAC58R_PAD_DDR_RAS__DDR_RAS		= IOMUX_PAD(0x000c, 0x000c, 0, __NA_, 0, SAC58R_DDR_PAD_CTRL),
-	SAC58R_PAD_DDR_WE__DDR_WE_B		= IOMUX_PAD(0x0010, 0x0010, 0, __NA_, 0, SAC58R_DDR_PAD_CTRL),
-	SAC58R_PAD_DDR_ODT1__DDR_ODT0	= IOMUX_PAD(0x0110, 0x0110, 0, __NA_, 0, SAC58R_DDR_PAD_CTRL),
-	SAC58R_PAD_DDR_ODT0__DDR_ODT1	= IOMUX_PAD(0x0114, 0x0114, 0, __NA_, 0, SAC58R_DDR_PAD_CTRL),
-	SAC58R_PAD_DDR_ZQ__DDR_ZQ		= IOMUX_PAD(0x0118, 0x0118, 0, __NA_, 0, SAC58R_DDR_PAD_CTRL),
-
-	SAC58R_PAD_PA0_I2C0_SDA			= IOMUX_PAD(0x0000, 0x0000, 1, 0x0c34, 2, SAC58R_I2C_PAD_CTRL),
-	SAC58R_PAD_PA1_I2C0_SCL			= IOMUX_PAD(0x0004, 0x0004, 1, 0x0c30, 2, SAC58R_I2C_PAD_CTRL),
-	SAC58R_PAD_PE19_I2C1_SCL		= IOMUX_PAD(0x024c, 0x024c, 1, 0x0c38, 2, SAC58R_I2C_PAD_CTRL),
-	SAC58R_PAD_PE10_I2C1_SDA		= IOMUX_PAD(0x0250, 0x0250, 1, 0x0c3c, 2, SAC58R_I2C_PAD_CTRL),
-	SAC58R_PAD_PA8_I2C2_SDA			= IOMUX_PAD(0x0020, 0x0020, 1, 0x0c44, 2, SAC58R_I2C_PAD_CTRL),
-	SAC58R_PAD_PA9_I2C2_SCL			= IOMUX_PAD(0x0024, 0x0024, 1, 0x0c40, 2, SAC58R_I2C_PAD_CTRL),
-	SAC58R_PAD_PH2_I2C3_SCL			= IOMUX_PAD(0x0388, 0x0388, 1, 0x0c48, 2, SAC58R_I2C_PAD_CTRL),
-	SAC58R_PAD_PH4_I2C3_SDA			= IOMUX_PAD(0x0390, 0x0390, 1, 0x0c4c, 2, SAC58R_I2C_PAD_CTRL),
-
-	SAC58R_PAD_PA0_GPIO_0			= IOMUX_PAD(0x0000, 0x0000, 0, __NA_, 2, SAC58R_I2C_GPIO_PAD_CTRL),
-	SAC58R_PAD_PA1_GPIO_1			= IOMUX_PAD(0x0004, 0x0004, 0, __NA_, 2, SAC58R_I2C_GPIO_PAD_CTRL),
-	SAC58R_PAD_PE19_GPIO_148		= IOMUX_PAD(0x024c, 0x024c, 0, __NA_, 2, SAC58R_I2C_GPIO_PAD_CTRL),
-	SAC58R_PAD_PE10_GPIO_147		= IOMUX_PAD(0x0250, 0x0250, 0, __NA_, 2, SAC58R_I2C_GPIO_PAD_CTRL),
-	SAC58R_PAD_PA8_GPIO_8			= IOMUX_PAD(0x0020, 0x0020, 0, __NA_, 2, SAC58R_I2C_GPIO_PAD_CTRL),
-	SAC58R_PAD_PA9_GPIO_9			= IOMUX_PAD(0x0024, 0x0024, 0, __NA_, 2, SAC58R_I2C_GPIO_PAD_CTRL),
-	SAC58R_PAD_PH2_GPIO_226			= IOMUX_PAD(0x0388, 0x0388, 0, __NA_, 2, SAC58R_I2C_GPIO_PAD_CTRL),
-	SAC58R_PAD_PH4_GPIO_228			= IOMUX_PAD(0x0390, 0x0390, 0, __NA_, 2, SAC58R_I2C_GPIO_PAD_CTRL),
-
-
-	SAC58R_PAD_PG5_SAI0_TX_BCLK 	= IOMUX_PAD(0x0314, 0x0314, 2, 0x098C, 2, SAC58R_SAI_PAD_CTRL),
-	SAC58R_PAD_PG6_SAI0_TX_SYNC 	= IOMUX_PAD(0x0318, 0x0318, 2, 0x0988, 2, SAC58R_SAI_PAD_CTRL),
-	SAC58R_PAD_PF10_SAI0_RX_DATA 	= IOMUX_PAD(0x02A8, 0x02A8, 0, 0x0920, 2, SAC58R_SAI_PAD_CTRL),
-	SAC58R_PAD_PF9_SAI0_TX_DATA 	= IOMUX_PAD(0x02A4, 0x02A4, 1,  __NA_, 0, SAC58R_SAI_PAD_CTRL),
-
-
-	SAC58R_PAD_PH11_SAI1_TX_BCLK 	= IOMUX_PAD(0x03AC, 0x03AC, 2, 0x0994, 2, SAC58R_SAI_PAD_CTRL),
-	SAC58R_PAD_PH12_SAI1_TX_SYNC 	= IOMUX_PAD(0x03B0, 0x03B0, 1, 0x0990, 2, SAC58R_SAI_PAD_CTRL),
-	SAC58R_PAD_PH16_SAI1_RX_BCLK 	= IOMUX_PAD(0x03C0, 0x03C0, 1, 0x0928, 2, SAC58R_SAI_PAD_CTRL),
-	SAC58R_PAD_PH17_SAI1_RX_SYNC 	= IOMUX_PAD(0x03C4, 0x03C4, 1, 0x0924, 2, SAC58R_SAI_PAD_CTRL),
-	SAC58R_PAD_PH18_SAI1_RX_DATA 	= IOMUX_PAD(0x03C8, 0x03C8, 1, 0x092c, 2, SAC58R_SAI_PAD_CTRL),
-	SAC58R_PAD_PH19_SAI1_TX_DATA 	= IOMUX_PAD(0x03CC, 0x03CC, 1,  __NA_, 0, SAC58R_SAI_PAD_CTRL),
-
-	SAC58R_PAD_PA5_ESAI0_FSR        = IOMUX_PAD(0x0014, 0x0014, 1, 0x084c, 2, SAC58R_ESAI_PAD_CTRL),
-	SAC58R_PAD_PA6_ESAI0_SCKR       = IOMUX_PAD(0x0018, 0x0018, 1, 0x0848, 2, SAC58R_ESAI_PAD_CTRL),
-	SAC58R_PAD_PA12_ESAI0_SDO5_SDI0 = IOMUX_PAD(0x0030, 0x0030, 1, 0x0864, 3, SAC58R_ESAI_PAD_CTRL),
-	SAC58R_PAD_PA14_ESAI0_SDO2_SDI3 = IOMUX_PAD(0x0038, 0x0038, 1,  __NA_, 0, SAC58R_ESAI_PAD_CTRL),
-	SAC58R_PAD_PA15_ESAI0_SDO4_SDI3 = IOMUX_PAD(0x003c, 0x003c, 1, 0x0868, 2, SAC58R_ESAI_PAD_CTRL),
-	SAC58R_PAD_PA16_ESAI0_SDO3_SDI2 = IOMUX_PAD(0x0040, 0x0040, 1,  __NA_, 0, SAC58R_ESAI_PAD_CTRL),
-	SAC58R_PAD_PA17_ESAI0_SDO1      = IOMUX_PAD(0x0044, 0x0044, 1,  __NA_, 0, SAC58R_ESAI_PAD_CTRL),
-	SAC58R_PAD_PA18_ESAI0_SD00      = IOMUX_PAD(0x0048, 0x0048, 1,  __NA_, 0, SAC58R_ESAI_PAD_CTRL),
-	SAC58R_PAD_PA19_ESAI0_SCKT      = IOMUX_PAD(0x004c, 0x004c, 1, 0x0854, 2, SAC58R_ESAI_PAD_CTRL),
-	SAC58R_PAD_PA20_ESAI0_FST       = IOMUX_PAD(0x0050, 0x0050, 1, 0x0858, 2, SAC58R_ESAI_PAD_CTRL),
-
-	SAC58R_PAD_PA4__GPIO_4			= IOMUX_PAD(0x0010, 0x0010, 0,	__NA_, 0, SAC58R_GPIO_PAD_CTRL),
-
-	SAC58R_PAD_PE25__GPIO_153		= IOMUX_PAD(0x264, 0x264, 0,  __NA_, 0, SAC58R_GPIO_PAD_CTRL),
-	SAC58R_PAD_PE26__GPIO_154		= IOMUX_PAD(0x268, 0x268, 0,  __NA_, 0, SAC58R_GPIO_PAD_CTRL),
-
-	SAC58R_PAD_PF14__GPIO_174		= IOMUX_PAD(0x02B8, 0x02B8, 0,  __NA_, 0, SAC58R_GPIO_PAD_CTRL),
-	SAC58R_PAD_PK12__GPIO_332		= IOMUX_PAD(0x0530, 0x0530, 0,  __NA_, 0, SAC58R_GPIO_PAD_CTRL),
-	SAC58R_PAD_PL8__GPIO_360		= IOMUX_PAD(0x05A0, 0x05A0, 0,  __NA_, 0, SAC58R_GPIO_PAD_CTRL),
-	SAC58R_PAD_PL9__GPIO_361		= IOMUX_PAD(0x05A4, 0x05A4, 0,  __NA_, 0, SAC58R_GPIO_PAD_CTRL),
-
-	SAC58R_PAD_PL1_SPIO_PCS1		= IOMUX_PAD(0x0584, 0x0584, 1,	__NA_, 0, SAC58R_SPI_PAD_CTRL|PAD_CTL_OBE_ENABLE),
-	SAC58R_PAD_PH8_SPIO_PCS2		= IOMUX_PAD(0x03A0, 0x03A0, 1,	__NA_, 0, SAC58R_SPI_PAD_CTRL|PAD_CTL_OBE_ENABLE),
-	SAC58R_PAD_PH3_SPIO_PCS3		= IOMUX_PAD(0x038C, 0x038C, 2,	__NA_, 0, SAC58R_SPI_PAD_CTRL|PAD_CTL_OBE_ENABLE),
-	SAC58R_PAD_PK14_SPIO_SOUT		= IOMUX_PAD(0x0538, 0x0538, 1,	__NA_, 0, SAC58R_SPI_PAD_CTRL|PAD_CTL_OBE_ENABLE),
-	SAC58R_PAD_PK15_SPIO_PCS0		= IOMUX_PAD(0x053C, 0x053C, 1,	__NA_, 0, SAC58R_SPI_PAD_CTRL|PAD_CTL_OBE_ENABLE),
-	SAC58R_PAD_PK16_SPIO_SCK		= IOMUX_PAD(0x0540, 0x0540, 1,	0x0C84, 3, SAC58R_SPI_PAD_CTRL|PAD_CTL_OBE_ENABLE),
-	SAC58R_PAD_PK17_SPIO_SIN		= IOMUX_PAD(0x0544, 0x0544, 0,	0x0C80, 4, SAC58R_SPI_PAD_CTRL|PAD_CTL_IBE_ENABLE),
-
-	SAC58R_PAD_PA10_ENET_RMII_CLKOUT	= IOMUX_PAD(0x0028, 0x0028, 3, __NA_, 0, SAC58R_ENET_PAD_CTRL),
-	SAC58R_PAD_PB0_ENET_RMII_RXD1		= IOMUX_PAD(0x0080, 0x0080, 0, 0x0F0C, 2, SAC58R_ENET_PAD_CTRL),
-	SAC58R_PAD_PB2_ENET_RMII_CRS_DV		= IOMUX_PAD(0x0088, 0x0088, 0, 0x0F04, 2, SAC58R_ENET_PAD_CTRL),
-	SAC58R_PAD_PB3_ENET_RMII_TXDEN 		= IOMUX_PAD(0x008C, 0x008C, 1, __NA_, 0, SAC58R_ENET_PAD_CTRL),
-	SAC58R_PAD_PB4_ENET_RMII_RXD0		= IOMUX_PAD(0x0090, 0x0090, 0, 0x0F08, 2, SAC58R_ENET_PAD_CTRL),
-	SAC58R_PAD_PB7_ENET_RMII_MDIO		= IOMUX_PAD(0x009C, 0x009C, 1, 0x0F24, 2, SAC58R_ENET_PAD_CTRL),
-	SAC58R_PAD_PB8_ENET_RMII_TXD0		= IOMUX_PAD(0x00A0, 0x00A0, 1, __NA_, 0, SAC58R_ENET_PAD_CTRL),
-	SAC58R_PAD_PB9_ENET_RMII_TXD1		= IOMUX_PAD(0x00A4, 0x00A4, 1, __NA_, 0, SAC58R_ENET_PAD_CTRL),
-	SAC58R_PAD_PB10_ENET_RMII_MDC		= IOMUX_PAD(0x00A8, 0x00A8, 1, __NA_, 0, SAC58R_ENET_PAD_CTRL),
-	SAC58R_PAD_PB12_ENET_REF_MII_CLK	= IOMUX_PAD(0x00B0, 0x00B0, 2, 0x0F20, 3, SAC58R_ENET_PAD_CTRL),
-	SAC58R_PAD_PL13_GPIO365 			= IOMUX_PAD(0x05B4, 0x05B4, 0, __NA_, 0, SAC58R_GPIO_PAD_CTRL),
-
-	SAC58R_PAD_PL0_GPIO352 			= IOMUX_PAD(0x0580, 0x0580, 0, __NA_, 0, SAC58R_GPIO_PAD_CTRL),
-	SAC58R_PAD_PF18_GPIO178			= IOMUX_PAD(0x02C8, 0x02C8, 0, __NA_, 0, SAC58R_GPIO_PAD_CTRL),
-
- 	SAC58R_PAD_PF16_USB0_ID			= IOMUX_PAD(0x02C0, 0x02C0, 0, 0x0DA0, 2, SAC58R_USBID_PAD_CTRL),
- 	SAC58R_PAD_PF17_GPIO_177               = IOMUX_PAD(0x02C4, 0x02C4, 0,  __NA_, 0, SAC58R_GPIO_PAD_CTRL),
- 	SAC58R_PAD_PH21_GPIO_245               = IOMUX_PAD(0x02D4, 0x02D4, 0,  __NA_, 0, SAC58R_GPIO_PAD_CTRL),
-
-	SAC58R_PAD_PF29__NFC_IO15		= IOMUX_PAD(0x02f4, 0x02f4, 2, 0x0f8c, 2, SAC58R_NFC_IO_PAD_CTRL),
-	SAC58R_PAD_PF28__NFC_IO14		= IOMUX_PAD(0x02f0, 0x02f0, 2, 0x0f88, 2, SAC58R_NFC_IO_PAD_CTRL),
-	SAC58R_PAD_PF27__NFC_IO13		= IOMUX_PAD(0x02ec, 0x02ec, 2, 0x0f84, 2, SAC58R_NFC_IO_PAD_CTRL),
-	SAC58R_PAD_PF26__NFC_IO12		= IOMUX_PAD(0x02e8, 0x02e8, 2, 0x0f80, 2, SAC58R_NFC_IO_PAD_CTRL),
-	SAC58R_PAD_PF23__NFC_IO11		= IOMUX_PAD(0x02dc, 0x02dc, 2, 0x0f7c, 2, SAC58R_NFC_IO_PAD_CTRL),
-	SAC58R_PAD_PF22__NFC_IO10		= IOMUX_PAD(0x02d8, 0x02d8, 2, 0x0f78, 2, SAC58R_NFC_IO_PAD_CTRL),
-	SAC58R_PAD_PF20__NFC_IO9		= IOMUX_PAD(0x02d0, 0x02d0, 2, 0x0f74, 2, SAC58R_NFC_IO_PAD_CTRL),
-	SAC58R_PAD_PF19__NFC_IO8		= IOMUX_PAD(0x02cc, 0x02cc, 2, 0x0f70, 2, SAC58R_NFC_IO_PAD_CTRL),
-	SAC58R_PAD_PC13__NFC_IO7		= IOMUX_PAD(0x0134, 0x0134, 1, 0x0f6c, 2, SAC58R_NFC_IO_PAD_CTRL),
-	SAC58R_PAD_PC12__NFC_IO6		= IOMUX_PAD(0x0130, 0x0130, 1, 0x0f68, 2, SAC58R_NFC_IO_PAD_CTRL),
-	SAC58R_PAD_PC11__NFC_IO5		= IOMUX_PAD(0x012c, 0x012c, 1, 0x0f64, 2, SAC58R_NFC_IO_PAD_CTRL),
-	SAC58R_PAD_PC10__NFC_IO4		= IOMUX_PAD(0x0128, 0x0128, 1, 0x0f60, 2, SAC58R_NFC_IO_PAD_CTRL),
-	SAC58R_PAD_PC9__NFC_IO3			= IOMUX_PAD(0x0124, 0x0124, 1, 0x0f5c, 2, SAC58R_NFC_IO_PAD_CTRL),
-	SAC58R_PAD_PC6__NFC_IO2			= IOMUX_PAD(0x0118, 0x0118, 1, 0x0f58, 2, SAC58R_NFC_IO_PAD_CTRL),
-	SAC58R_PAD_PC8__NFC_IO1			= IOMUX_PAD(0x0120, 0x0120, 1, 0x0f54, 2, SAC58R_NFC_IO_PAD_CTRL),
-	SAC58R_PAD_PC7__NFC_IO0			= IOMUX_PAD(0x011c, 0x011c, 1, 0x0f50, 2, SAC58R_NFC_IO_PAD_CTRL),
-	SAC58R_PAD_PC5__NFC_WEB			= IOMUX_PAD(0x0114, 0x0114, 1, __NA_, 0, SAC58R_NFC_SIG_PAD_CTRL),
-	SAC58R_PAD_PC2__NFC_CE0B		= IOMUX_PAD(0x0108, 0x0108, 1, __NA_, 0, SAC58R_NFC_SIG_PAD_CTRL),
-	SAC58R_PAD_PA16__NFC_CE1B		= IOMUX_PAD(0x0040, 0x0040, 3, __NA_, 0, SAC58R_NFC_SIG_PAD_CTRL),
-	SAC58R_PAD_PC1__NFC_REB			= IOMUX_PAD(0x0104, 0x0104, 1, __NA_, 0, SAC58R_NFC_SIG_PAD_CTRL),
-	SAC58R_PAD_PC0__NFC_RB0B		= IOMUX_PAD(0x0100, 0x0100, 0, 0x0f90, 2, SAC58R_NFC_SIG_RB_PAD_CTRL), /* Ready/Busy is an input signal with xtal PULLUP */
-	SAC58R_PAD_PF25__NFC_RB1B               = IOMUX_PAD(0x02e4, 0x02e4, 0, 0x0f94, 3, SAC58R_NFC_SIG_RB_PAD_CTRL),
-	SAC58R_PAD_PF25_GPIO_185		= IOMUX_PAD(0x02e4, 0x02e4, 0, __NA_, 0, SAC58R_GPIO_PAD_CTRL),
-	SAC58R_PAD_PC4__NFC_ALE			= IOMUX_PAD(0x0110, 0x0110, 1, __NA_, 0, SAC58R_NFC_SIG_PAD_CTRL),
-	SAC58R_PAD_PC3__NFC_CLE			= IOMUX_PAD(0x010c, 0x010c, 1, __NA_, 0, SAC58R_NFC_SIG_PAD_CTRL),
-
-
-	SAC58R_PAD_PG3__SPDIF0_EXTCLK		= IOMUX_PAD(0x030c, 0x030c, 0, 0x0D94, 2, SAC58R_SPI_PAD_CTRL),
-	SAC58R_PAD_PG4__SPDIF0_IN1		= IOMUX_PAD(0x0310, 0x0310, 0, 0x0D90, 2, SAC58R_SPI_PAD_CTRL),
-	SAC58R_PAD_PG5__SPDIF0_OUT1		= IOMUX_PAD(0x0314, 0x0314, 1, __NA_, 0, SAC58R_SPI_PAD_CTRL),
-	SAC58R_PAD_PG6__SPDIF0_PLOCK		= IOMUX_PAD(0x0318, 0x0318, 1, __NA_, 0, SAC58R_SPI_PAD_CTRL),
-	SAC58R_PAD_PG7__SPDIF0_SRCLK		= IOMUX_PAD(0x031C, 0x031C, 1, __NA_, 0, SAC58R_SPI_PAD_CTRL),
-
-	SAC58R_PAD_PG0__SPDIF1_EXTCLK		= IOMUX_PAD(0x0300, 0x0300, 0, 0x0D9C, 2, SAC58R_SAI_PAD_CTRL),
-	SAC58R_PAD_PG1__SPDIF1_IN1		= IOMUX_PAD(0x0304, 0x0304, 0, 0x0D98, 2, SAC58R_SAI_PAD_CTRL),
-	SAC58R_PAD_PG2__SPDIF1_OUT1		= IOMUX_PAD(0x0308, 0x0308, 1, __NA_, 0, SAC58R_SAI_PAD_CTRL),
-	SAC58R_PAD_PL12__SPDIF1_PLOCK		= IOMUX_PAD(0x05B0, 0x05B0, 1, __NA_, 0, SAC58R_SAI_PAD_CTRL),
-	SAC58R_PAD_PL13__SPDIF1_SRCLK		= IOMUX_PAD(0x05B4, 0x05B4, 1, __NA_, 0, SAC58R_SAI_PAD_CTRL),
-
-	SAC58R_PAD_PC24__QSPI_A_DATA0		= IOMUX_PAD(0x0160, 0x0160, 1, 0x0CA8, 2, SAC58R_QSPI_SIG_PAD_CTRL),
-	SAC58R_PAD_PC21__QSPI_A_DATA1		= IOMUX_PAD(0x0154, 0x0154, 1, 0x0CAC, 2, SAC58R_QSPI_SIG_PAD_CTRL),
-	SAC58R_PAD_PC25__QSPI_A_DATA2		= IOMUX_PAD(0x0164, 0x0164, 1, 0x0CB0, 2, SAC58R_QSPI_SIG_PAD_CTRL),
-	SAC58R_PAD_PC16__QSPI_A_DATA3		= IOMUX_PAD(0x0140, 0x0140, 1, 0x0CB4, 2, SAC58R_QSPI_SIG_PAD_CTRL),
-
-	SAC58R_PAD_PC19__QSPI_B_DATA0		= IOMUX_PAD(0x014c, 0x014c, 1, 0x0CBC, 2, SAC58R_QSPI_SIG_PAD_CTRL),
-	SAC58R_PAD_PC15__QSPI_B_DATA1		= IOMUX_PAD(0x013c, 0x013c, 1, 0x0CC0, 2, SAC58R_QSPI_SIG_PAD_CTRL),
-	SAC58R_PAD_PC23__QSPI_B_DATA2		= IOMUX_PAD(0x015c, 0x015c, 1, 0x0CC4, 2, SAC58R_QSPI_SIG_PAD_CTRL),
-	SAC58R_PAD_PC14__QSPI_B_DATA3		= IOMUX_PAD(0x0138, 0x0138, 1, 0x0CC8, 2, SAC58R_QSPI_SIG_PAD_CTRL),
-
-	SAC58R_PAD_PC17__QSPI_A_CS0		= IOMUX_PAD(0x0144, 0x0144, 1, __NA_, 0, SAC58R_QSPI_CS_SIG_PAD_CTRL),
-	SAC58R_PAD_PC18__QSPI_B_CS0		= IOMUX_PAD(0x0148, 0x0148, 1, __NA_, 0, SAC58R_QSPI_CS_SIG_PAD_CTRL),
-
-	SAC58R_PAD_PD2__QSPI_A_CS1		= IOMUX_PAD(0x0188, 0x0188, 4, __NA_, 0, SAC58R_QSPI_CS_SIG_PAD_CTRL),
-	SAC58R_PAD_PD9__QSPI_B_CS1		= IOMUX_PAD(0x01A4, 0x01A4, 5, __NA_, 0, SAC58R_QSPI_CS_SIG_PAD_CTRL),
-
-	SAC58R_PAD_PC20__QSPI_A_SCK		= IOMUX_PAD(0x0150, 0x0150, 1, __NA_, 0, SAC58R_QSPI_SIG_PAD_CTRL),
-	SAC58R_PAD_PC22__QSPI_B_SCK		= IOMUX_PAD(0x0158, 0x0158, 1, __NA_, 0, SAC58R_QSPI_SIG_PAD_CTRL),
-};
-
-#endif	/* __IOMUX_SAC58R_H__ */
diff --git a/arch/arm/include/asm/arch-sac58r/sac58r_secure.h b/arch/arm/include/asm/arch-sac58r/sac58r_secure.h
deleted file mode 100644
index c185950c4f..0000000000
--- a/arch/arm/include/asm/arch-sac58r/sac58r_secure.h
+++ /dev/null
@@ -1,69 +0,0 @@
-/*
- * (C) Copyright 2012-2013 Freescale Semiconductor, Inc.
- *
- * SPDX-License-Identifier:	GPL-2.0+
- */
-
-/*
- * Auto generated file, please don't edit it
- *
- */
-
-#ifndef __SECURE_SAC58R_H__
-#define __SECURE_SAC58R_H__
-
-#include <linux/types.h>
-
-/* -------- start of HAB API updates ------------*/
-/* The following are taken from HAB4 SIS */
-
-/* Status definitions */
-typedef enum hab_status {
-	HAB_STS_ANY = 0x00,
-	HAB_FAILURE = 0x33,
-	HAB_WARNING = 0x69,
-	HAB_SUCCESS = 0xf0
-} hab_status_t;
-
-/* Security Configuration definitions */
-typedef enum hab_config {
-	HAB_CFG_RETURN = 0x33, /**< Field Return IC */
-	HAB_CFG_OPEN = 0xf0, /**< Non-secure IC */
-	HAB_CFG_CLOSED = 0xcc /**< Secure IC */
-} hab_config_t;
-
-/* State definitions */
-typedef enum hab_state {
-	HAB_STATE_INITIAL = 0x33, /**< Initialising state (transitory) */
-	HAB_STATE_CHECK = 0x55, /**< Check state (non-secure) */
-	HAB_STATE_NONSECURE = 0x66, /**< Non-secure state */
-	HAB_STATE_TRUSTED = 0x99, /**< Trusted state */
-	HAB_STATE_SECURE = 0xaa, /**< Secure state */
-	HAB_STATE_FAIL_SOFT = 0xcc, /**< Soft fail state */
-	HAB_STATE_FAIL_HARD = 0xff, /**< Hard fail state (terminal) */
-	HAB_STATE_NONE = 0xf0, /**< No security state machine */
-	HAB_STATE_MAX
-} hab_state_t;
-
-/*Function prototype description*/
-typedef hab_status_t hab_rvt_report_event_t(hab_status_t, uint32_t, \
-		uint8_t* , size_t*);
-typedef hab_status_t hab_rvt_report_status_t(hab_config_t *, hab_state_t *);
-typedef hab_status_t hab_loader_callback_f_t(void**, size_t*, const void*);
-typedef hab_status_t hab_rvt_entry_t(void);
-typedef hab_status_t hab_rvt_exit_t(void);
-typedef void *hab_rvt_authenticate_image_t(uint8_t, ptrdiff_t, \
-		void **, size_t *, hab_loader_callback_f_t);
-typedef void hapi_clock_init_t(void);
-
-#define HAB_RVT_REPORT_EVENT			(*(uint32_t *) 0x0000021C)
-#define HAB_RVT_REPORT_STATUS			(*(uint32_t *) 0x00000220)
-#define HAB_RVT_AUTHENTICATE_IMAGE		(*(uint32_t *) 0x00000210)
-#define HAB_RVT_ENTRY				(*(uint32_t *) 0x00000204)
-#define HAB_RVT_EXIT				(*(uint32_t *) 0x00000208)
-
-#define HAB_CID_ROM 0 /**< ROM Caller ID */
-#define HAB_CID_UBOOT 1 /**< UBOOT Caller ID*/
-/* ----------- end of HAB API updates ------------*/
-
-#endif
diff --git a/arch/arm/include/asm/mach-imx/iomux-v3.h b/arch/arm/include/asm/mach-imx/iomux-v3.h
index ffa49bc8f9..d2f4db772e 100644
--- a/arch/arm/include/asm/mach-imx/iomux-v3.h
+++ b/arch/arm/include/asm/mach-imx/iomux-v3.h
@@ -182,7 +182,7 @@ typedef u64 iomux_v3_cfg_t;
 /* i.MX6SLL */
 #define PAD_CTL_IPD_BIT		(1 << 27)
 
-#elif defined(CONFIG_VF610) || defined(CONFIG_SAC58R) || \
+#elif defined(CONFIG_VF610) || \
 	defined(CONFIG_MAC57D5XH)
 
 #define PAD_MUX_MODE_SHIFT	20
diff --git a/arch/arm/mach-imx/i2c-mxv7.c b/arch/arm/mach-imx/i2c-mxv7.c
index 3fe9d15e7a..814d834b16 100644
--- a/arch/arm/mach-imx/i2c-mxv7.c
+++ b/arch/arm/mach-imx/i2c-mxv7.c
@@ -61,9 +61,6 @@ exit:
 }
 
 static void * const i2c_bases[] = {
-#ifdef CONFIG_SAC58R
-	(void *)I2C0_BASE_ADDR,
-#endif
 	(void *)I2C1_BASE_ADDR,
 	(void *)I2C2_BASE_ADDR,
 #ifdef I2C3_BASE_ADDR
diff --git a/board/freescale/sac58r/Kconfig b/board/freescale/sac58r/Kconfig
deleted file mode 100644
index d2fe0ca85c..0000000000
--- a/board/freescale/sac58r/Kconfig
+++ /dev/null
@@ -1,23 +0,0 @@
-if TARGET_SAC58R
-
-config SYS_CPU
-	string
-	default "armv7"
-
-config SYS_BOARD
-	string
-	default "sac58r"
-
-config SYS_VENDOR
-	string
-	default "freescale"
-
-config SYS_SOC
-	string
-	default "sac58r"
-
-config SYS_CONFIG_NAME
-	string
-	default "sac58r"
-
-endif
diff --git a/board/freescale/sac58r/MAINTAINERS b/board/freescale/sac58r/MAINTAINERS
deleted file mode 100644
index 5c1524b23c..0000000000
--- a/board/freescale/sac58r/MAINTAINERS
+++ /dev/null
@@ -1,6 +0,0 @@
-SAC58R BOARD
-M:	-
-S:	Maintained
-F:	board/freescale/sac58r/
-F:	include/configs/sac58r.h
-F:	configs/sac58revb_defconfig
diff --git a/board/freescale/sac58r/Makefile b/board/freescale/sac58r/Makefile
deleted file mode 100644
index 7c25899db6..0000000000
--- a/board/freescale/sac58r/Makefile
+++ /dev/null
@@ -1,7 +0,0 @@
-#
-# (C) Copyright 2013 Freescale Semiconductor, Inc.
-#
-# SPDX-License-Identifier:	GPL-2.0+
-#
-
-obj-y	:= sac58r.o
diff --git a/board/freescale/sac58r/sac58r.c b/board/freescale/sac58r/sac58r.c
deleted file mode 100644
index 9852d3a4e5..0000000000
--- a/board/freescale/sac58r/sac58r.c
+++ /dev/null
@@ -1,500 +0,0 @@
-/*
- * (C) Copyright 2013 Freescale Semiconductor, Inc.
- *
- * SPDX-License-Identifier:	GPL-2.0+
- */
-
-#include <common.h>
-#include <asm/io.h>
-#include <asm/arch/imx-regs.h>
-#include <asm/arch/iomux-sac58r.h>
-#include <asm/arch/crm_regs.h>
-#include <asm/arch/clock.h>
-#include <mmc.h>
-#include <fsl_esdhc.h>
-#include <miiphy.h>
-#include <netdev.h>
-#include <i2c.h>
-#include <asm/arch/dmachmux-sac58r.h>
-
-#include "sac58r_int_routing.h"
-
-DECLARE_GLOBAL_DATA_PTR;
-
-void setup_iomux_ddr(void)
-{
-#if 0
-	static const iomux_v3_cfg_t ddr_pads[] = {
-		VF610_PAD_DDR_A15__DDR_A_15,
-		VF610_PAD_DDR_A15__DDR_A_15,
-		VF610_PAD_DDR_A14__DDR_A_14,
-		VF610_PAD_DDR_A13__DDR_A_13,
-		VF610_PAD_DDR_A12__DDR_A_12,
-		VF610_PAD_DDR_A11__DDR_A_11,
-		VF610_PAD_DDR_A10__DDR_A_10,
-		VF610_PAD_DDR_A9__DDR_A_9,
-		VF610_PAD_DDR_A8__DDR_A_8,
-		VF610_PAD_DDR_A7__DDR_A_7,
-		VF610_PAD_DDR_A6__DDR_A_6,
-		VF610_PAD_DDR_A5__DDR_A_5,
-		VF610_PAD_DDR_A4__DDR_A_4,
-		VF610_PAD_DDR_A3__DDR_A_3,
-		VF610_PAD_DDR_A2__DDR_A_2,
-		VF610_PAD_DDR_A1__DDR_A_1,
-		VF610_PAD_DDR_BA2__DDR_BA_2,
-		VF610_PAD_DDR_BA1__DDR_BA_1,
-		VF610_PAD_DDR_BA0__DDR_BA_0,
-		VF610_PAD_DDR_CAS__DDR_CAS_B,
-		VF610_PAD_DDR_CKE__DDR_CKE_0,
-		VF610_PAD_DDR_CLK__DDR_CLK_0,
-		VF610_PAD_DDR_CS__DDR_CS_B_0,
-		VF610_PAD_DDR_D15__DDR_D_15,
-		VF610_PAD_DDR_D14__DDR_D_14,
-		VF610_PAD_DDR_D13__DDR_D_13,
-		VF610_PAD_DDR_D12__DDR_D_12,
-		VF610_PAD_DDR_D11__DDR_D_11,
-		VF610_PAD_DDR_D10__DDR_D_10,
-		VF610_PAD_DDR_D9__DDR_D_9,
-		VF610_PAD_DDR_D8__DDR_D_8,
-		VF610_PAD_DDR_D7__DDR_D_7,
-		VF610_PAD_DDR_D6__DDR_D_6,
-		VF610_PAD_DDR_D5__DDR_D_5,
-		VF610_PAD_DDR_D4__DDR_D_4,
-		VF610_PAD_DDR_D3__DDR_D_3,
-		VF610_PAD_DDR_D2__DDR_D_2,
-		VF610_PAD_DDR_D1__DDR_D_1,
-		VF610_PAD_DDR_D0__DDR_D_0,
-		VF610_PAD_DDR_DQM1__DDR_DQM_1,
-		VF610_PAD_DDR_DQM0__DDR_DQM_0,
-		VF610_PAD_DDR_DQS1__DDR_DQS_1,
-		VF610_PAD_DDR_DQS0__DDR_DQS_0,
-		VF610_PAD_DDR_RAS__DDR_RAS_B,
-		VF610_PAD_DDR_WE__DDR_WE_B,
-		VF610_PAD_DDR_ODT1__DDR_ODT_0,
-		VF610_PAD_DDR_ODT0__DDR_ODT_1,
-	};
-
-	imx_iomux_v3_setup_multiple_pads(ddr_pads, ARRAY_SIZE(ddr_pads));
-#endif
-}
-
-void ddr_phy_init(void)
-{
-#if 0
-	struct ddrmr_regs *ddrmr = (struct ddrmr_regs *)DDR_BASE_ADDR;
-
-	writel(DDRMC_PHY_DQ_TIMING, &ddrmr->phy[0]);
-	writel(DDRMC_PHY_DQ_TIMING, &ddrmr->phy[16]);
-	writel(DDRMC_PHY_DQ_TIMING, &ddrmr->phy[32]);
-	writel(DDRMC_PHY_DQ_TIMING, &ddrmr->phy[48]);
-
-	writel(DDRMC_PHY_DQS_TIMING, &ddrmr->phy[1]);
-	writel(DDRMC_PHY_DQS_TIMING, &ddrmr->phy[17]);
-	writel(DDRMC_PHY_DQS_TIMING, &ddrmr->phy[33]);
-	writel(DDRMC_PHY_DQS_TIMING, &ddrmr->phy[49]);
-
-	writel(DDRMC_PHY_CTRL, &ddrmr->phy[2]);
-	writel(DDRMC_PHY_CTRL, &ddrmr->phy[18]);
-	writel(DDRMC_PHY_CTRL, &ddrmr->phy[34]);
-	writel(DDRMC_PHY_CTRL, &ddrmr->phy[50]);
-
-	writel(DDRMC_PHY_MASTER_CTRL, &ddrmr->phy[3]);
-	writel(DDRMC_PHY_MASTER_CTRL, &ddrmr->phy[19]);
-	writel(DDRMC_PHY_MASTER_CTRL, &ddrmr->phy[35]);
-	writel(DDRMC_PHY_MASTER_CTRL, &ddrmr->phy[51]);
-
-	writel(DDRMC_PHY_SLAVE_CTRL, &ddrmr->phy[4]);
-	writel(DDRMC_PHY_SLAVE_CTRL, &ddrmr->phy[20]);
-	writel(DDRMC_PHY_SLAVE_CTRL, &ddrmr->phy[36]);
-	writel(DDRMC_PHY_SLAVE_CTRL, &ddrmr->phy[52]);
-
-	writel(DDRMC_PHY50_DDR3_MODE | DDRMC_PHY50_EN_SW_HALF_CYCLE,
-		&ddrmr->phy[50]);
-#endif
-}
-
-void ddr_ctrl_init(void)
-{
-#if 0
-	struct ddrmr_regs *ddrmr = (struct ddrmr_regs *)DDR_BASE_ADDR;
-
-	writel(DDRMC_CR00_DRAM_CLASS_DDR3, &ddrmr->cr[0]);
-	writel(DDRMC_CR02_DRAM_TINIT(32), &ddrmr->cr[2]);
-	writel(DDRMC_CR10_TRST_PWRON(124), &ddrmr->cr[10]);
-
-	writel(DDRMC_CR11_CKE_INACTIVE(80000), &ddrmr->cr[11]);
-	writel(DDRMC_CR12_WRLAT(5) | DDRMC_CR12_CASLAT_LIN(12), &ddrmr->cr[12]);
-	writel(DDRMC_CR13_TRC(21) | DDRMC_CR13_TRRD(4) | DDRMC_CR13_TCCD(4) |
-		DDRMC_CR13_TBST_INT_INTERVAL(4), &ddrmr->cr[13]);
-	writel(DDRMC_CR14_TFAW(20) | DDRMC_CR14_TRP(6) | DDRMC_CR14_TWTR(4) |
-		DDRMC_CR14_TRAS_MIN(15), &ddrmr->cr[14]);
-	writel(DDRMC_CR16_TMRD(4) | DDRMC_CR16_TRTP(4), &ddrmr->cr[16]);
-	writel(DDRMC_CR17_TRAS_MAX(28080) | DDRMC_CR17_TMOD(12),
-		&ddrmr->cr[17]);
-	writel(DDRMC_CR18_TCKESR(4) | DDRMC_CR18_TCKE(3), &ddrmr->cr[18]);
-
-	writel(DDRMC_CR20_AP_EN, &ddrmr->cr[20]);
-	writel(DDRMC_CR21_TRCD_INT(6) | DDRMC_CR21_TRAS_LOCKOUT |
-		DDRMC_CR21_CCMAP_EN, &ddrmr->cr[21]);
-
-	writel(DDRMC_CR22_TDAL(11), &ddrmr->cr[22]);
-	writel(DDRMC_CR23_BSTLEN(3) | DDRMC_CR23_TDLL(512), &ddrmr->cr[23]);
-	writel(DDRMC_CR24_TRP_AB(6), &ddrmr->cr[24]);
-
-	writel(DDRMC_CR25_TREF_EN, &ddrmr->cr[25]);
-	writel(DDRMC_CR26_TREF(3112) | DDRMC_CR26_TRFC(44), &ddrmr->cr[26]);
-	writel(DDRMC_CR28_TREF_INT(5), &ddrmr->cr[28]);
-	writel(DDRMC_CR29_TPDEX(3), &ddrmr->cr[29]);
-
-	writel(DDRMC_CR30_TXPDLL(10), &ddrmr->cr[30]);
-	writel(DDRMC_CR31_TXSNR(68) | DDRMC_CR31_TXSR(512), &ddrmr->cr[31]);
-	writel(DDRMC_CR33_EN_QK_SREF, &ddrmr->cr[33]);
-	writel(DDRMC_CR34_CKSRX(5) | DDRMC_CR34_CKSRE(5), &ddrmr->cr[34]);
-
-	writel(DDRMC_CR38_FREQ_CHG_EN, &ddrmr->cr[38]);
-	writel(DDRMC_CR39_PHY_INI_COM(1024) | DDRMC_CR39_PHY_INI_STA(16) |
-		DDRMC_CR39_FRQ_CH_DLLOFF(2), &ddrmr->cr[39]);
-
-	writel(DDRMC_CR41_PHY_INI_STRT_INI_DIS, &ddrmr->cr[41]);
-	writel(DDRMC_CR48_MR1_DA_0(70) | DDRMC_CR48_MR0_DA_0(1056),
-		&ddrmr->cr[48]);
-
-	writel(DDRMC_CR66_ZQCL(256) | DDRMC_CR66_ZQINIT(512), &ddrmr->cr[66]);
-	writel(DDRMC_CR67_ZQCS(64), &ddrmr->cr[67]);
-	writel(DDRMC_CR69_ZQ_ON_SREF_EX(2), &ddrmr->cr[69]);
-
-	writel(DDRMC_CR70_REF_PER_ZQ(64), &ddrmr->cr[70]);
-	writel(DDRMC_CR72_ZQCS_ROTATE, &ddrmr->cr[72]);
-
-	writel(DDRMC_CR73_APREBIT(10) | DDRMC_CR73_COL_DIFF(1) |
-		DDRMC_CR73_ROW_DIFF(3), &ddrmr->cr[73]);
-	writel(DDRMC_CR74_BANKSPLT_EN | DDRMC_CR74_ADDR_CMP_EN |
-		DDRMC_CR74_CMD_AGE_CNT(255) | DDRMC_CR74_AGE_CNT(255),
-		&ddrmr->cr[74]);
-	writel(DDRMC_CR75_RW_PG_EN | DDRMC_CR75_RW_EN | DDRMC_CR75_PRI_EN |
-		DDRMC_CR75_PLEN, &ddrmr->cr[75]);
-	writel(DDRMC_CR76_NQENT_ACTDIS(3) | DDRMC_CR76_D_RW_G_BKCN(3) |
-		DDRMC_CR76_W2R_SPLT_EN | DDRMC_CR76_CS_EN, &ddrmr->cr[76]);
-	writel(DDRMC_CR77_CS_MAP | DDRMC_CR77_DI_RD_INTLEAVE |
-		DDRMC_CR77_SWAP_EN, &ddrmr->cr[77]);
-	writel(DDRMC_CR78_BUR_ON_FLY_BIT(12), &ddrmr->cr[78]);
-	writel(DDRMC_CR79_CTLUPD_AREF, &ddrmr->cr[79]);
-
-	writel(DDRMC_CR82_INT_MASK, &ddrmr->cr[82]);
-
-	writel(DDRMC_CR87_ODT_WR_MAPCS0 | DDRMC_CR87_ODT_RD_MAPCS0,
-		&ddrmr->cr[87]);
-	writel(DDRMC_CR88_TODTL_CMD(4), &ddrmr->cr[88]);
-	writel(DDRMC_CR89_AODT_RWSMCS(2), &ddrmr->cr[89]);
-
-	writel(DDRMC_CR91_R2W_SMCSDL(2), &ddrmr->cr[91]);
-	writel(DDRMC_CR96_WLMRD(40) | DDRMC_CR96_WLDQSEN(25), &ddrmr->cr[96]);
-
-	writel(DDRMC_CR105_RDLVL_DL_0(32), &ddrmr->cr[105]);
-	writel(DDRMC_CR110_RDLVL_DL_1(32), &ddrmr->cr[110]);
-	writel(DDRMC_CR114_RDLVL_GTDL_2(8224), &ddrmr->cr[114]);
-
-	writel(DDRMC_CR117_AXI0_W_PRI(1) | DDRMC_CR117_AXI0_R_PRI(1),
-		&ddrmr->cr[117]);
-	writel(DDRMC_CR118_AXI1_W_PRI(1) | DDRMC_CR118_AXI1_R_PRI(1),
-		&ddrmr->cr[118]);
-
-	writel(DDRMC_CR120_AXI0_PRI1_RPRI(2) | DDRMC_CR120_AXI0_PRI0_RPRI(2),
-		&ddrmr->cr[120]);
-	writel(DDRMC_CR121_AXI0_PRI3_RPRI(2) | DDRMC_CR121_AXI0_PRI2_RPRI(2),
-		&ddrmr->cr[121]);
-	writel(DDRMC_CR122_AXI1_PRI1_RPRI(1) | DDRMC_CR122_AXI1_PRI0_RPRI(1) |
-		DDRMC_CR122_AXI0_PRIRLX(100), &ddrmr->cr[122]);
-	writel(DDRMC_CR123_AXI1_PRI3_RPRI(1) | DDRMC_CR123_AXI1_PRI2_RPRI(1),
-		&ddrmr->cr[123]);
-	writel(DDRMC_CR124_AXI1_PRIRLX(100), &ddrmr->cr[124]);
-
-	writel(DDRMC_CR126_PHY_RDLAT(11), &ddrmr->cr[126]);
-	writel(DDRMC_CR132_WRLAT_ADJ(5) | DDRMC_CR132_RDLAT_ADJ(6),
-		&ddrmr->cr[132]);
-	writel(DDRMC_CR139_PHY_WRLV_RESPLAT(4) | DDRMC_CR139_PHY_WRLV_LOAD(7) |
-		DDRMC_CR139_PHY_WRLV_DLL(3) | DDRMC_CR139_PHY_WRLV_EN(3),
-		&ddrmr->cr[139]);
-
-	writel(DDRMC_CR154_PAD_ZQ_EARLY_CMP_EN_TIMER(13) |
-		DDRMC_CR154_PAD_ZQ_MODE(1), &ddrmr->cr[154]);
-	writel(DDRMC_CR155_AXI0_AWCACHE | DDRMC_CR155_PAD_ODT_BYTE1(2),
-		&ddrmr->cr[155]);
-	writel(DDRMC_CR158_TWR(6), &ddrmr->cr[158]);
-
-	ddr_phy_init();
-
-	writel(DDRMC_CR00_DRAM_CLASS_DDR3 | DDRMC_CR00_START, &ddrmr->cr[0]);
-
-	udelay(200);
-#endif
-}
-
-int dram_init(void)
-{
-	setup_iomux_ddr();
-
-	ddr_ctrl_init();
-	gd->ram_size = get_ram_size((void *)PHYS_SDRAM, PHYS_SDRAM_SIZE);
-
-	return 0;
-}
-
-static void setup_iomux_uart(void)
-{
-#if 0
-	static const iomux_v3_cfg_t uart1_pads[] = {
-		VF610_PAD_PTB4__UART1_TX,
-		VF610_PAD_PTB5__UART1_RX,
-	};
-
-	imx_iomux_v3_setup_multiple_pads(uart1_pads, ARRAY_SIZE(uart1_pads));
-#endif
-}
-
-static void setup_iomux_enet(void)
-{
-#if 0
-	static const iomux_v3_cfg_t enet0_pads[] = {
-		VF610_PAD_PTA6__RMII0_CLKIN,
-		VF610_PAD_PTC1__RMII0_MDIO,
-		VF610_PAD_PTC0__RMII0_MDC,
-		VF610_PAD_PTC2__RMII0_CRS_DV,
-		VF610_PAD_PTC3__RMII0_RD1,
-		VF610_PAD_PTC4__RMII0_RD0,
-		VF610_PAD_PTC5__RMII0_RXER,
-		VF610_PAD_PTC6__RMII0_TD1,
-		VF610_PAD_PTC7__RMII0_TD0,
-		VF610_PAD_PTC8__RMII0_TXEN,
-	};
-
-	imx_iomux_v3_setup_multiple_pads(enet0_pads, ARRAY_SIZE(enet0_pads));
-#endif
-}
-
-static void setup_iomux_i2c(void)
-{
-#if 0
-	static const iomux_v3_cfg_t i2c0_pads[] = {
-		VF610_PAD_PTB14__I2C0_SCL,
-		VF610_PAD_PTB15__I2C0_SDA,
-	};
-
-	imx_iomux_v3_setup_multiple_pads(i2c0_pads, ARRAY_SIZE(i2c0_pads));
-#endif
-}
-
-#ifdef CONFIG_SYS_USE_NAND
-void setup_iomux_nfc(void)
-{
-#if 0
-	static const iomux_v3_cfg_t nfc_pads[] = {
-		VF610_PAD_PTD31__NFC_IO15,
-		VF610_PAD_PTD30__NFC_IO14,
-		VF610_PAD_PTD29__NFC_IO13,
-		VF610_PAD_PTD28__NFC_IO12,
-		VF610_PAD_PTD27__NFC_IO11,
-		VF610_PAD_PTD26__NFC_IO10,
-		VF610_PAD_PTD25__NFC_IO9,
-		VF610_PAD_PTD24__NFC_IO8,
-		VF610_PAD_PTD23__NFC_IO7,
-		VF610_PAD_PTD22__NFC_IO6,
-		VF610_PAD_PTD21__NFC_IO5,
-		VF610_PAD_PTD20__NFC_IO4,
-		VF610_PAD_PTD19__NFC_IO3,
-		VF610_PAD_PTD18__NFC_IO2,
-		VF610_PAD_PTD17__NFC_IO1,
-		VF610_PAD_PTD16__NFC_IO0,
-		VF610_PAD_PTB24__NFC_WEB,
-		VF610_PAD_PTB25__NFC_CE0B,
-		VF610_PAD_PTB27__NFC_REB,
-		VF610_PAD_PTC26__NFC_RBB,
-		VF610_PAD_PTC27__NFC_ALE,
-		VF610_PAD_PTC28__NFC_CLE,
-	};
-	imx_iomux_v3_setup_multiple_pads(nfc_pads, ARRAY_SIZE(nfc_pads));
-#endif
-}
-#endif
-
-#ifdef CONFIG_FSL_ESDHC
-struct fsl_esdhc_cfg esdhc_cfg[1] = {
-	{USDHC1_BASE_ADDR},
-};
-
-int board_mmc_getcd(struct mmc *mmc)
-{
-	/* eSDHC1 is always present */
-	return 1;
-}
-
-int board_mmc_init(bd_t *bis)
-{
-#if 0
-	static const iomux_v3_cfg_t esdhc1_pads[] = {
-		VF610_PAD_PTA24__ESDHC1_CLK,
-		VF610_PAD_PTA25__ESDHC1_CMD,
-		VF610_PAD_PTA26__ESDHC1_DAT0,
-		VF610_PAD_PTA27__ESDHC1_DAT1,
-		VF610_PAD_PTA28__ESDHC1_DAT2,
-		VF610_PAD_PTA29__ESDHC1_DAT3,
-	};
-
-	imx_iomux_v3_setup_multiple_pads(
-		esdhc1_pads, ARRAY_SIZE(esdhc1_pads));
-#endif
-	esdhc_cfg[0].sdhc_clk = mxc_get_clock(MXC_USDHC1_CLK);
-
-	return fsl_esdhc_initialize(bis, &esdhc_cfg[0]);
-}
-#endif
-
-static void clock_init(void)
-{
-	struct ccm_reg *ccm = (struct ccm_reg *)CCM_BASE_ADDR;
-	struct anadig_reg *anadig = (struct anadig_reg *)ANADIG_BASE_ADDR;
-	struct scsc_reg *scsc = (struct scsc_reg *)SCSC_BASE_ADDR;
-	
-	enable_periph_clk(0,AIPS0_OFF_GPC);
-	enable_periph_clk(0,AIPS0_OFF_SRC);
-	enable_periph_clk(0,AIPS0_OFF_CCM);
-	enable_periph_clk(0,AIPS0_OFF_SCSC);
-	enable_periph_clk(0,AIPS0_OFF_ANADIG);
-	enable_periph_clk(0,AIPS0_OFF_IOMUXC);
-	enable_periph_clk(0,AIPS0_OFF_WKUP);
-	enable_periph_clk(0,AIPS0_OFF_PIT);
-	enable_periph_clk(0,AIPS0_OFF_OCOTP0);
-	enable_periph_clk(0,AIPS0_OFF_OCOTP1);
-	enable_periph_clk(1,AIPS1_OFF_UART0); // To refine with schematics
-	enable_periph_clk(0,AIPS0_OFF_PORTA);
-	enable_periph_clk(0,AIPS0_OFF_PORTB);
-	enable_periph_clk(0,AIPS0_OFF_PORTC);
-	enable_periph_clk(0,AIPS0_OFF_PORTD);
-	enable_periph_clk(0,AIPS0_OFF_PORTE);
-	enable_periph_clk(0,AIPS0_OFF_PORTF);
-	enable_periph_clk(0,AIPS0_OFF_PORTG);
-	enable_periph_clk(0,AIPS0_OFF_PORTH);
-	enable_periph_clk(0,AIPS0_OFF_PORTJ);
-	enable_periph_clk(0,AIPS0_OFF_PORTK);
-	enable_periph_clk(0,AIPS0_OFF_PORTL);
-#if 0
-	enable_periph_clk(2,AIPS2_OFF_MMDC);
-	enable_periph_clk(0,AIPS0_OFF_SNVS_WDOG);
-	enable_periph_clk(0,AIPS0_OFF_GPIOC);
-	enable_periph_clk(1,AIPS1_OFF_I2C0); // To refine with schematics
-	enable_periph_clk(2,AIPS2_OFF_ENET);
-	enable_periph_clk(2,AIPS2_OFF_SDHC0);
-	enable_periph_clk(2,AIPS2_OFF_NFC0);
-#endif
-	
-#ifdef CONFIG_PALLADIUM
-	/* enable FXOSC and SXOSC clocks */
-	setbits_le32(&scsc->irc_ctrl,SCSC_IRC_FIR_EN | SCSC_IRC_SIRC_EN);
-	/* wait for FXOSC to be enabled */
-	while(!(readl(&scsc->osc_ctrl) & SCSC_CTRL_FXOSC_RDY_MASK));
-
-	/* enable PLL1 = PLL_CORE/ARM */
-	clrsetbits_le32(&anadig->pll1_ctrl,ANADIG_PLL_CTRL_POWERDOWN | ANADIG_PLL_CTRL_BYPASS, ANADIG_PLL_CTRL_ENABLE);
-	/* wait for PLL1 to be locked */
-	while(!(readl(&anadig->pll1_ctrl) & ANADIG_PLL_CTRL_LOCK));
-	/* enable PLL2 = PLL_SYS528 */
-	clrsetbits_le32(&anadig->pll2_ctrl, ANADIG_PLL_CTRL_POWERDOWN | ANADIG_PLL_CTRL_BYPASS, ANADIG_PLL_CTRL_ENABLE | ANADIG_PLL2_CTRL_DIV_SELECT);
-	/* configure PLL2_PFD3 @ 413MHz = 528*(18/23) */
-	clrsetbits_le32(&anadig->pll2_pfd, ANADIG_PLL_PFD3_CLKGATE_MASK, (0x17 << ANADIG_PLL_PFD3_FRAC_MASK));
-	/* wait for PLL to be locked */
-	while(!(readl(&anadig->pll2_ctrl) & ANADIG_PLL_CTRL_LOCK));
-
-	/* configure ARM A7 clock => From PLL1 (PLL_CORE) = 1200/2 = 600MHz */
-	setbits_le32(&ccm->a7_clk, (0x1 << CCM_MODULE_ENABLE_CTL_OFFSET) | (0x1 << CCM_PREDIV_CTRL_OFFSET) | (0x3 << CCM_MUX_CTL_OFFSET));
-	/* configure QoS_DDR clock => From PLL_SYS_PFD3 @ 413MHz */
-	setbits_le32(&ccm->QoS_DDR_root, (0x1 << CCM_MODULE_ENABLE_CTL_OFFSET) | (0x8 << CCM_MUX_CTL_OFFSET));
-	/* configure BUS clock = PLL_SYS_PFD3 / 3 = 413/3=137MHz */
-	setbits_le32(&ccm->BUS_clk, (0x1 << CCM_MODULE_ENABLE_CTL_OFFSET) | (0x2 << CCM_PREDIV_CTRL_OFFSET));
-	/* configure PER clock = BUS clock / 2 = 137/2 = 68MHz */
-	setbits_le32(&ccm->PER_clk, (0x1 << CCM_MODULE_ENABLE_CTL_OFFSET) | (0x1 << CCM_PREDIV_CTRL_OFFSET));
-#endif
-#if 0	
-	clrsetbits_le32(&ccm->ccr, CCM_CCR_OSCNT_MASK,
-		CCM_CCR_FIRC_EN | CCM_CCR_OSCNT(5));
-	clrsetbits_le32(&ccm->ccsr, CCM_REG_CTRL_MASK,
-		CCM_CCSR_PLL1_PFD_CLK_SEL(3) | CCM_CCSR_PLL2_PFD4_EN |
-		CCM_CCSR_PLL2_PFD3_EN | CCM_CCSR_PLL2_PFD2_EN |
-		CCM_CCSR_PLL2_PFD1_EN | CCM_CCSR_PLL1_PFD4_EN |
-		CCM_CCSR_PLL1_PFD3_EN | CCM_CCSR_PLL1_PFD2_EN |
-		CCM_CCSR_PLL1_PFD1_EN | CCM_CCSR_DDRC_CLK_SEL(1) |
-		CCM_CCSR_FAST_CLK_SEL(1) | CCM_CCSR_SYS_CLK_SEL(4));
-	clrsetbits_le32(&ccm->cacrr, CCM_REG_CTRL_MASK,
-		CCM_CACRR_IPG_CLK_DIV(1) | CCM_CACRR_BUS_CLK_DIV(2) |
-		CCM_CACRR_ARM_CLK_DIV(0));
-	clrsetbits_le32(&ccm->cscmr1, CCM_REG_CTRL_MASK,
-		CCM_CSCMR1_ESDHC1_CLK_SEL(3));
-	clrsetbits_le32(&ccm->cscdr1, CCM_REG_CTRL_MASK,
-		CCM_CSCDR1_RMII_CLK_EN);
-	clrsetbits_le32(&ccm->cscdr2, CCM_REG_CTRL_MASK,
-		CCM_CSCDR2_ESDHC1_EN | CCM_CSCDR2_ESDHC1_CLK_DIV(0) |
-		CCM_CSCDR2_NFC_CLK_INV | CCM_CSCDR2_NFC_EN | CCM_CSCDR2_NFC_CLK_FRAC_DIV(4));
-	clrsetbits_le32(&ccm->cscdr3,CCM_CSCDR3_NFC_PRE_DIV_MASK,
-		CCM_CSCDR3_NFC_PRE_DIV(1));
-	clrsetbits_le32(&ccm->cscmr2, CCM_REG_CTRL_MASK,
-		CCM_CSCMR2_RMII_CLK_SEL(0));
-#endif
-}
-
-static void mscm_init(void)
-{
-	struct mscm_ir *mscmir = (struct mscm_ir *)MSCM_IR_BASE_ADDR;
-	int i;
-
-	/* Interrupt Routing Configuration */
-	for (i = 0; i < MSCM_IRSPRC_NUM; i++)
-		writew(int_routing_conf[i], &mscmir->irsprc[i]);
-}
-
-static void dmamux_init(void)
-{
-	/*Example DMA CHANNEL MUXING FOR SAC58R. This function is not called */
-	static const dmamux_cfg_t dma_channels [] = {
-		DMAMUX_CHANNEL(DMAMUX_0, 0, SAC58R_DMAREQSRC_UART0_RX, 0, 1), /* DMAMUX 0, Channel 0 => UART0_RX, no trigger, channel enable */
-		DMAMUX_CHANNEL(DMAMUX_1, 8, SAC58R_DMAREQSRC_PORTA, 0, 1), /* DMAMUX 1, Channel 8 => PORT_A, no trigger, channel enable */
-		DMAMUX_CHANNEL(DMAMUX_2, 4, SAC58R_DMAREQSRC_SAI6_TX, 0, 1), /* DMAMUX 2, Channel 4  => SAI6_TX, no trigger, channel enable */
-		DMAMUX_CHANNEL(DMAMUX_3, 12, SAC58R_DMAREQSRC_QSPIO_RX, 0, 1), /* DMAMUX 3, Channel 12 => QSPI0_TX, no trigger, channel enable */
-	};
-	imx_dmamux_setup_multiple_channels(dma_channels, ARRAY_SIZE(dma_channels));
-}
-
-int board_phy_config(struct phy_device *phydev)
-{
-	if (phydev->drv->config)
-		phydev->drv->config(phydev);
-
-	return 0;
-}
-
-int board_early_init_f(void)
-{
-	clock_init();
-	mscm_init();
-
-	setup_iomux_uart();
-	setup_iomux_enet();
-	setup_iomux_i2c();
-#ifdef CONFIG_SYS_USE_NAND
-	setup_iomux_nfc();
-#endif
-	return 0;
-}
-
-int board_init(void)
-{
-	/* address of boot parameters */
-	gd->bd->bi_boot_params = PHYS_SDRAM + 0x100;
-
-	return 0;
-}
-
-int checkboard(void)
-{
-	puts("Board: Rayleigh:sac58r\n");
-
-	return 0;
-}
diff --git a/board/freescale/sac58r/sac58r.cfg b/board/freescale/sac58r/sac58r.cfg
deleted file mode 100644
index 169ad194f2..0000000000
--- a/board/freescale/sac58r/sac58r.cfg
+++ /dev/null
@@ -1,30 +0,0 @@
-/*
- * (C) Copyright 2013 Freescale Semiconductor, Inc.
- *
- * SPDX-License-Identifier:	GPL-2.0+
- */
-
-/*
- * Refer docs/README.imxmage for more details about how-to configure
- * and create imximage boot image
- *
- * The syntax is taken as close as possible with the kwbimage
- */
-#include <asm/imx-common/imximage.cfg>
-
-/* image version */
-IMAGE_VERSION	2
-
-/*
- * Boot Device : one of spi, sd, eimnor, nand:
- * spinor: flash_offset: 0x0400
- * nand:   flash_offset: 0x0400
- * sd/mmc: flash_offset: 0x0400
- * eimnor: flash_offset: 0x1000
- */
-
- BOOT_FROM	sd
-
-#ifdef CONFIG_SECURE_BOOT
-SECURE_BOOT
-#endif
diff --git a/board/freescale/sac58r/sac58r_int_routing.h b/board/freescale/sac58r/sac58r_int_routing.h
deleted file mode 100644
index bdb5ae9708..0000000000
--- a/board/freescale/sac58r/sac58r_int_routing.h
+++ /dev/null
@@ -1,121 +0,0 @@
-/*
- * (C) Copyright 2014 Freescale Semiconductor, Inc.
- *
- * SPDX-License-Identifier:	GPL-2.0+
- */
-
-static const u8 int_routing_conf[] = {
-	MSCM_IRSPRC_ROUTE_TO_CA7,	/* DMA0 Transfer Complete CH0-31 */
-	MSCM_IRSPRC_ROUTE_TO_CA7,	/* DMA0 Error Interrupt CH0-31 */
-	MSCM_IRSPRC_ROUTE_TO_CA7,	/* DMA1 Transfer Complete CH0-31 */
-	MSCM_IRSPRC_ROUTE_TO_CA7,	/* DMA1 Transfer Complete CH0-31 */
-	MSCM_IRSPRC_ROUTE_TO_CA7,	/* SWT 0 */
-	MSCM_IRSPRC_ROUTE_TO_CA7,	/* SWT 1 */
-	MSCM_IRSPRC_ROUTE_TO_CA7,	/* SWT 2 */
-	MSCM_IRSPRC_ROUTE_TO_CA7,	/* MSCM-ECC0 */
-	MSCM_IRSPRC_ROUTE_TO_CA7,	/* MSCM-ECC1 */
-	MSCM_IRSPRC_ROUTE_TO_CA7,	/* xRDC */
-	MSCM_IRSPRC_ROUTE_TO_CA7,	/* MSCM-ACTZS */
-	MSCM_IRSPRC_ROUTE_TO_CA7,	/* STM 0 */
-	MSCM_IRSPRC_ROUTE_TO_CA7,
-	MSCM_IRSPRC_ROUTE_TO_CA7,	/* WDOG-SNVS */
-	MSCM_IRSPRC_ROUTE_TO_CA7,	/* SNVS - Non TZ*/
-	MSCM_IRSPRC_ROUTE_TO_CA7,	/* SNVS - TZ */
-	MSCM_IRSPRC_ROUTE_TO_CA7,	/* QuadSPI0 */
-	MSCM_IRSPRC_ROUTE_TO_CA7,	/* MMDC */
-	MSCM_IRSPRC_ROUTE_TO_CA7,	/* NFC */
-	MSCM_IRSPRC_ROUTE_TO_CA7,	/* USDHC0 */
-	MSCM_IRSPRC_ROUTE_TO_CA7,	/* USDHC1 */
-	MSCM_IRSPRC_ROUTE_TO_CA7,	/* USDHC 2 */
-	MSCM_IRSPRC_ROUTE_TO_CA7,	/* MIPI-CSI2 */
-	MSCM_IRSPRC_ROUTE_TO_CA7,	/* DCU0 */
-	MSCM_IRSPRC_ROUTE_TO_CA7,	/* VIU */
-	MSCM_IRSPRC_ROUTE_TO_CA7,	/* VPU */
-	MSCM_IRSPRC_ROUTE_TO_CA7,	/* GC400T */
-	MSCM_IRSPRC_ROUTE_TO_CA7,	/* RLE */
-	MSCM_IRSPRC_ROUTE_TO_CA7,	/* USBC 0*/
-	MSCM_IRSPRC_ROUTE_TO_CA7,	/* USBC 1 */
-	MSCM_IRSPRC_ROUTE_TO_CA7,	/* USBC 2 */
-	MSCM_IRSPRC_ROUTE_TO_CA7,	/* PIT */
-	MSCM_IRSPRC_ROUTE_TO_CA7,	/* LPTimer */
-	MSCM_IRSPRC_ROUTE_TO_CA7,	/* SPDIF1 */
-	MSCM_IRSPRC_ROUTE_TO_CA7,	/*FlexTimer  */
-	MSCM_IRSPRC_ROUTE_TO_CA7,	/* ENET 0 */
-	MSCM_IRSPRC_ROUTE_TO_CA7,	/* 1588 Timer 0 */
-	MSCM_IRSPRC_ROUTE_TO_CA7,	/* VSPA */
-	MSCM_IRSPRC_ROUTE_TO_CA7,	/* FECA */
-	MSCM_IRSPRC_ROUTE_TO_CA7,	/* AXIQ */
-	MSCM_IRSPRC_ROUTE_TO_CA7,	/* JESD204B 0/1 */
-	MSCM_IRSPRC_ROUTE_TO_CA7,	/* JESD204B 2/3 */
-	MSCM_IRSPRC_ROUTE_TO_CA7,	/* ANADIG - USB PHY 0 */
-	MSCM_IRSPRC_ROUTE_TO_CA7,	/* ANADIG - USB PHY 1 */
-	MSCM_IRSPRC_ROUTE_TO_CA7,	/* ENET 0 errors */
-	MSCM_IRSPRC_ROUTE_TO_CA7,	/* ADC 0 */
-	MSCM_IRSPRC_ROUTE_TO_CA7,	/* AUD_ADC_DAC */
-	MSCM_IRSPRC_ROUTE_TO_CA7,	/* ENET Queue 0 */
-	MSCM_IRSPRC_ROUTE_TO_CA7,	/* ENET Queues  */
-	MSCM_IRSPRC_ROUTE_TO_CA7,	/* FlexCAN 0 */
-	MSCM_IRSPRC_ROUTE_TO_CA7,	/* FlexCAN 1 */
-	MSCM_IRSPRC_ROUTE_TO_CA7,	/* FlexCAN 2 */
-	MSCM_IRSPRC_ROUTE_TO_CA7,	/* MLB */
-	MSCM_IRSPRC_ROUTE_TO_CA7,	/* UART 0 */
-	MSCM_IRSPRC_ROUTE_TO_CA7,	/* UART 1 */
-	MSCM_IRSPRC_ROUTE_TO_CA7,	/* UART 2 */
-	MSCM_IRSPRC_ROUTE_TO_CA7,	/* UART 3 */
-	MSCM_IRSPRC_ROUTE_TO_CA7,	/* UART 4 */
-	MSCM_IRSPRC_ROUTE_TO_CA7,	/* UART 5 */
-	MSCM_IRSPRC_ROUTE_TO_CA7,	/* SPI 0 */
-	MSCM_IRSPRC_ROUTE_TO_CA7,	/* SPI 1 */
-	MSCM_IRSPRC_ROUTE_TO_CA7,	/* VSPA-GPO11[24] */
-	MSCM_IRSPRC_ROUTE_TO_CA7,	/* VSPA-GPO11[25] */
-	MSCM_IRSPRC_ROUTE_TO_CA7,	/* I2C 0 */
-	MSCM_IRSPRC_ROUTE_TO_CA7,	/* I2C 1 */
-	MSCM_IRSPRC_ROUTE_TO_CA7,	/* I2C 2 */
-	MSCM_IRSPRC_ROUTE_TO_CA7,	/* I2C 3 */
-	MSCM_IRSPRC_ROUTE_TO_CA7,	/* SAI 0 */
-	MSCM_IRSPRC_ROUTE_TO_CA7,	/* SAI 1 */
-	MSCM_IRSPRC_ROUTE_TO_CA7,	/* SAI 2 */
-	MSCM_IRSPRC_ROUTE_TO_CA7,	/* SAI 3 */
-	MSCM_IRSPRC_ROUTE_TO_CA7,	/* SAI 4 */
-	MSCM_IRSPRC_ROUTE_TO_CA7,	/* SAI 5 */
-	MSCM_IRSPRC_ROUTE_TO_CA7,	/* SAI 6 */
-	MSCM_IRSPRC_ROUTE_TO_CA7,	/* SAI 7 */
-	MSCM_IRSPRC_ROUTE_TO_CA7,	/* SAI 8 */
-	MSCM_IRSPRC_ROUTE_TO_CA7,	/* SAI 9 */
-	MSCM_IRSPRC_ROUTE_TO_CA7,	/* SAI 10 */
-	MSCM_IRSPRC_ROUTE_TO_CA7,	/* SAI 11 */
-	MSCM_IRSPRC_ROUTE_TO_CA7,	/* ESAI0 BIFIFO */
-	MSCM_IRSPRC_ROUTE_TO_CA7,	/* ESAI1 BIFIFO */
-	MSCM_IRSPRC_ROUTE_TO_CA7,	/* SPDIF0 */
-	MSCM_IRSPRC_ROUTE_TO_CA7,	/* ASRC0 */
-	MSCM_IRSPRC_ROUTE_TO_CA7,	/* ASRC1 */
-	MSCM_IRSPRC_ROUTE_TO_CA7,	/* SRC */
-	MSCM_IRSPRC_ROUTE_TO_CA7,	/* WKUP 0 */
-	MSCM_IRSPRC_ROUTE_TO_CA7,	/* GPC */
-	MSCM_IRSPRC_ROUTE_TO_CA7,	/* Temp Sensor */
-	MSCM_IRSPRC_ROUTE_TO_CA7,
-	MSCM_IRSPRC_ROUTE_TO_CA7,	/* PDB */
-	MSCM_IRSPRC_ROUTE_TO_CA7,	/* CMU */
-	MSCM_IRSPRC_ROUTE_TO_CA7,	/* CAAM */
-	MSCM_IRSPRC_ROUTE_TO_CA7,	/* GPIO 0 */
-	MSCM_IRSPRC_ROUTE_TO_CA7,	/* GPIO 1 */
-	MSCM_IRSPRC_ROUTE_TO_CA7,	/* GPIO 2 */
-	MSCM_IRSPRC_ROUTE_TO_CA7,	/* GPIO 3 */
-	MSCM_IRSPRC_ROUTE_TO_CA7,	/* GPIO 4 */
-	MSCM_IRSPRC_ROUTE_TO_CA7,	/* GPIO 5 */
-	MSCM_IRSPRC_ROUTE_TO_CA7,	/* GPIO 6 */
-	MSCM_IRSPRC_ROUTE_TO_CA7,	/* GPIO 7 */
-	MSCM_IRSPRC_ROUTE_TO_CA7,	/* GPIO 8 */
-	MSCM_IRSPRC_ROUTE_TO_CA7,	/* GPIO 9 */
-	MSCM_IRSPRC_ROUTE_TO_CA7,	/* GPIO 10 */
-	MSCM_IRSPRC_ROUTE_TO_CA7,
-	MSCM_IRSPRC_ROUTE_TO_CA7,	/* JESD204B_0 */
-	MSCM_IRSPRC_ROUTE_TO_CA7,	/* JESD204B_1 */
-	MSCM_IRSPRC_ROUTE_TO_CA7,	/* JESD204B_2 */
-	MSCM_IRSPRC_ROUTE_TO_CA7,	/* JESD204B_3 */
-	MSCM_IRSPRC_ROUTE_TO_CA7,	/* ENET Queue 1 */
-	MSCM_IRSPRC_ROUTE_TO_CA7,	/* ENET Queue 2 */
-	MSCM_IRSPRC_ROUTE_TO_CA7,
-	MSCM_IRSPRC_ROUTE_TO_CA7,
-};
-
diff --git a/board/freescale/sac58revb/Makefile b/board/freescale/sac58revb/Makefile
deleted file mode 100644
index 6a2ef99010..0000000000
--- a/board/freescale/sac58revb/Makefile
+++ /dev/null
@@ -1,7 +0,0 @@
-#
-# (C) Copyright 2013 Freescale Semiconductor, Inc.
-#
-# SPDX-License-Identifier:	GPL-2.0+
-#
-
-obj-y	:= sac58revb.o
diff --git a/board/freescale/sac58revb/sac58r_mt41j64.cfg b/board/freescale/sac58revb/sac58r_mt41j64.cfg
deleted file mode 100644
index b859c8bc98..0000000000
--- a/board/freescale/sac58revb/sac58r_mt41j64.cfg
+++ /dev/null
@@ -1,48 +0,0 @@
-/*
- * (C) Copyright 2013 Freescale Semiconductor, Inc.
- *
- * SPDX-License-Identifier:	GPL-2.0+
- */
-
-/*
- * Refer docs/README.imxmage for more details about how-to configure
- * and create imximage boot image
- *
- * The syntax is taken as close as possible with the kwbimage
- */
-#include <asm/imx-common/imximage.cfg>
-
-/* image version */
-IMAGE_VERSION	2
-
-/*
- * Boot Device : one of spi, sd, eimnor, nand:
- * spinor: flash_offset: 0x0400
- * nand:   flash_offset: 0x0400
- * sd/mmc: flash_offset: 0x0400
- * eimnor: flash_offset: 0x1000
- */
-
- BOOT_FROM	sd
-
-#ifdef CONFIG_SECURE_BOOT
-SECURE_BOOT
-#endif
-
-/*
- * Device Configuration Data (DCD)
- *
- * Each entry must have the format:
- * Addr-type           Address        Value
- *
- * where:
- *      Addr-type register length (1,2 or 4 bytes)
- *      Address   absolute address of the register
- *      value     value to be stored in the register
- */
-
-/* GPC: enable all modules on GPC_AIPS2_OFFPF_PCTL4 */
-DATA  4, 0x40020198,  0xFFFFFFFF
-
-/* GPC: enable all modules on GPC_AIPS1_OFFPF_PCTL1 */
-DATA  4, 0x4002010C,  0xFFFFFFFF
diff --git a/board/freescale/sac58revb/sac58revb.c b/board/freescale/sac58revb/sac58revb.c
deleted file mode 100644
index 15be8e114b..0000000000
--- a/board/freescale/sac58revb/sac58revb.c
+++ /dev/null
@@ -1,887 +0,0 @@
-/*
- * (C) Copyright 2014 Freescale Semiconductor, Inc.
- *
- * SPDX-License-Identifier:	GPL-2.0+
- */
-
-/*
- * U-Boot Implementation for the Freescale SAC58R EVB
- */
-
-#include <common.h>
-#include <asm/io.h>
-#include <asm/arch/imx-regs.h>
-#include <asm/arch/iomux-sac58r.h>
-#include <asm/arch/crm_regs.h>
-#include <asm/arch/clock.h>
-#include <mmc.h>
-#include <fsl_esdhc.h>
-#include <miiphy.h>
-#include <netdev.h>
-#include <i2c.h>
-#include <asm/imx-common/mxc_i2c.h>
-#include <asm/arch/dmachmux-sac58r.h>
-#include <asm/gpio.h>
-
-#include "sac58revb_int_routing.h"
-
-DECLARE_GLOBAL_DATA_PTR;
-
-
-#ifdef CONFIG_SYS_I2C_MXC
-/* I2C0, backlight, MIPI-CSI, CS4288 */
-struct i2c_pads_info i2c_pad_info0 = {
-	.scl = {
-		.i2c_mode = SAC58R_PAD_PA1_I2C0_SCL,
-		.gpio_mode = SAC58R_PAD_PA1_GPIO_1,
-		.gp = 1
-	},
-	.sda = {
-		.i2c_mode = SAC58R_PAD_PA0_I2C0_SDA,
-		.gpio_mode = SAC58R_PAD_PA0_GPIO_0,
-		.gp = 0
-	}
-};
-
-/* I2C1 Tuner I2S */
-struct i2c_pads_info i2c_pad_info1 = {
-	.scl = {
-		.i2c_mode = SAC58R_PAD_PE19_I2C1_SCL,
-		.gpio_mode = SAC58R_PAD_PE19_GPIO_148,
-		.gp = 148
-	},
-	.sda = {
-		.i2c_mode = SAC58R_PAD_PE10_I2C1_SDA,
-		.gpio_mode = SAC58R_PAD_PE10_GPIO_147,
-		.gp = 147
-	}
-};
-
-/* I2C3: iPod header */
-struct i2c_pads_info i2c_pad_info3 = {
-	.scl = {
-		.i2c_mode = SAC58R_PAD_PH2_I2C3_SCL,
-		.gpio_mode = SAC58R_PAD_PH2_GPIO_226,
-		.gp = 226
-	},
-	.sda = {
-		.i2c_mode = SAC58R_PAD_PH4_I2C3_SDA,
-		.gpio_mode = SAC58R_PAD_PH4_GPIO_228,
-		.gp = 228
-	}
-};
-#endif
-
-
-#ifdef CONFIG_REVB
-/* Micron 1GB */
-#define MDCTL_CONFIG 		0x04190000
-#define MDCFG0_CONFIG		0x6C7175D3
-#define MDOR_CONFIG		0x00711023
-#define MDASP_CONFIG		0x0000007F
-#define MPRDDLCTL_CONFIG 	0x48484A46
-#define MPWRDLCTL_CONFIG	0x33353533
-#define MPDGCTRL0_CONFIG	0x414F0149
-#define MPDGCTRL1_CONFIG	0x0156015D
-#else
-/* Micron MT41J64M16 @ 416 MHz*/
-/* 13 row addr, 10 col addr, burst length 8, data size 32 */
-#define MDCTL_CONFIG 		0x02190000
-#define MDCFG0_CONFIG		0x303475D3
-#define MDOR_CONFIG		0x00341023
-#define MDASP_CONFIG		0x0000004F
-#define MPRDDLCTL_CONFIG 	0x4B494F4E
-#define MPWRDLCTL_CONFIG	0x38353635
-#define MPDGCTRL0_CONFIG	0x41520142
-#define MPDGCTRL1_CONFIG	0x01560152
-#endif
-
-void setup_iomux_ddr(void)
-{
-	int i;
-	int ddr_iomuxc_reg = 0x400B1000;
-
-	/* 0x001701E0 For all control signals (not DQS) and address pins.
-	This means:
-		- DDR_ODT = 0b010 (60 Ohm ODT, change)
-		- DDR_SEL = 0b11 (DDR 3 Mode, default)
-		- DDR_INPUT = 0b1 (Differential, default)
-		- DDR_TRIM = 0b (No delay, default)
-		- HYS = 0b1 (CMOS input, default)
-		- DSE = 0b111 (34 Ohm DDR, change)
-		- PUS = 0b10 (100K Pullup, default)
-		- PKE = 0b0 (Pull/Keeper disabled, default).
-		- PUE = 0b0 (Keeper select, default).
-
-		No change has been made to the DDR_ZQ pin,
-		which keeps its default value of 0x00060000 (DDR3 Mode).
-	*/
-	for (i=0;i<32;i++) {
-		writel( 0x1701E0, ddr_iomuxc_reg);
-		ddr_iomuxc_reg += 4;
-	}
-
-
-	/* 0x000701E0 For D0-D31 (Data) and DQS signals.
-		This means:
-		- DDR_SEL = 0b11 (DDR 3 Mode, default)
-		- DDR_INPUT = 0b1 (Differential, default)
-		- DDR_TRIM = 0b (No delay, default)
-		- HYS = 0b1 (CMOS input, default)
-		- DSE = 0b111 (34 Ohm DDR, change)
-		- PUS = 0b10 (100K Pullup, default)
-		- PKE = 0b0 (Pull/Keeper disabled, default).
-		- PUE = 0b0 (Keeper select, default).
-	*/
-	ddr_iomuxc_reg = 0x400B1000 + 0x80;
-	for (i=0;i<36;i++) {
-		/* DQS[0..3] and DATA[0..31] */
-		writel( 0x0701E0, ddr_iomuxc_reg);
-		ddr_iomuxc_reg += 4;
-	}
-
-	writel( 0x1701E0, 0x400B1110); /* ODT-1 */
-	writel( 0x1701E0, 0x400B1114); /* ODT-2 */
-}
-
-void ddr_ctrl_init(void)
-{
-	int con_ack = 0;
-
-	/* Soft reset */
-	writel(2, 0x40169018); //MDMISC
-
-	/* Set MDSCR[CON_REQ] (configuration request) */
-	writel(0x00008000, 0x4016901C); //MDSCR
-
-	/* Wait for configuration acknowledgement */
-	while (con_ack == 0) {
-		con_ack = readl(0x4016901C) & (1<<14);
-	}
-
-	/* MDCFG0: tRFC=48,tXS=52,tXP=3,tXPDLL=10,tFAW=30,tCL=6 */
-	writel(MDCFG0_CONFIG, 0x4016900C); //MDCFG0
-
-	/* MDCFG1:  tRCD=6,tRP=6,tRC=20,tRAS=15,tRPA=1,tWR=6,tMRD=4,tCWL=5 */
-	writel(0xB66E8A83, 0x40169010); //MDCFG1
-
-	/* MDCFG2: tDLLK=512,tRTP=4,tWTR=4,tRRD=4 */
-	writel(0x01FF00DB, 0x40169014); //MDCFG2
-
-	/*MDOTC:  tAOFPD=1,tAONPD=1,tANPD=4,tAXPD=4,tODTLon=5,tODT_idle_off=0 */
-	writel(0x11335030, 0x40169008); //MDOTC (timing param)
-
-	/* MDMISC: WALAT=1, BI bank interleave off, MIF3=3, RALAT=1, 8 banks, DDR3 */
-	writel(0x00010640, 0x40169018); //MDMISC 
-
-	/* MDOR: WALAT=1, BI bank interleave on, MIF3=3, RALAT=1, 8 banks, DDR3 */
-	writel(MDOR_CONFIG, 0x40169030); //MDOR
-	writel(MDCTL_CONFIG, 0x40169000); //MDCTL
-
-	/* Perform ZQ calibration */
-	writel(0xA1390003, 0x40169800); //MPZQHWCTRL: Force h/w calibration
-	writel(0x33333333, 0x4016981C);
-	writel(0x33333333, 0x40169820);
-	writel(0x33333333, 0x40169824);
-	writel(0x33333333, 0x40169828);
-	writel(0x33333333, 0x4016982C);
-	writel(0x33333333, 0x40169830);
-	writel(0x33333333, 0x40169834);
-	writel(0x33333333, 0x40169838);
-
-	/* Enable MMDC with CS0 */
-	writel(MDCTL_CONFIG + 0x80000000, 0x40169000); //MDCTL
-
-	/*** Complete the initialization sequence as defined by JEDEC */
-	/* Configure MR2: CWL=5, self-refresh=off, self-refresh temp=normal */
-	writel(0x00008032, 0x4016901C);
-	/* Configure MR3: normal operation */
-	writel(0x00008033, 0x4016901C);
-	/* Configure MR1: enable DLL, drive strength=40R, AL off, ODT=40R, write levelling off, TDQS=0, Qoff=on */
-	writel(0x00068031, 0x4016901C);
-	/* Configure MR0: BL=8, CL=6, DLL reset, write recovery=6, precharge PD off */
-	writel(0x05208030, 0x4016901C);
-	/* DDR ZQ calibration */
-	writel(0x04008040, 0x4016901C);
-
-	writel(MDASP_CONFIG, 0x40169040);
-
-	/* Configure the power down and self-refresh entry and exit parameters */
-	/* Read delay line offsets */
-	writel(MPRDDLCTL_CONFIG, 0x40169848); //MPRDDLCTL,
-	/* Write delay line offsets */
-	writel(MPWRDLCTL_CONFIG, 0x40169850); //MPWRDLCTL0
-	/* Read DQS gating control 0 */
-	writel(MPDGCTRL0_CONFIG, 0x4016983C); //MPDGCTRL0
-	/* Read DQS gating control 1 */
-	writel(MPDGCTRL1_CONFIG, 0x40169840); //MPDGCTRL1
-	/* Read/write command delay - default */
-	writel(0x000026D2, 0x4016902C); //MDRWD
-	/* ODT timing control */
-	writel(0x22334010, 0x40169008); //MDOTC (timing param)
-
-	/* Power down control */
-	writel(0x00020024, 0x40169004); //MDPDC
-	/* Refresh control */
-	writel(0x30B01800, 0x40169020); //MDREF
-	/* 60R nominal */
-	writel(0x0002222F, 0x40169818); //MPODTCTRL
-	/* Deassert the configuration request */
-	writel(0x00000000, 0x4016901C); //MDSCR 1
-}
-
-
-
-
-int dram_init(void)
-{
-	gd->ram_size = ((ulong)CONFIG_DDR_MB * SZ_1M);
-
-	return 0;
-}
-
-#ifdef	CONFIG_LVDS
-static void setup_iomux_lvds(void)
-{
-	static const iomux_v3_cfg_t lvds_pads[] = {
-			SAC58R_PAD_PD12__LVDS0_CLKP,
-			SAC58R_PAD_PD13__LVDS0_CLKN,
-			SAC58R_PAD_PD11__LVDS0_TX0P,
-			SAC58R_PAD_PD14__LVDS0_TX0N,
-			SAC58R_PAD_PD15__LVDS0_TX1P,
-			SAC58R_PAD_PD16__LVDS0_TX1N,
-			SAC58R_PAD_PD17__LVDS0_TX2P,
-			SAC58R_PAD_PD18__LVDS0_TX2N,
-			SAC58R_PAD_PD19__LVDS0_TX3P,
-			SAC58R_PAD_PD20__LVDS0_TX3N,
-			SAC58R_PAD_PK7__GPIO327,
-			SAC58R_PAD_PK9__GPIO329
-	};
-	
-	imx_iomux_v3_setup_multiple_pads(lvds_pads, ARRAY_SIZE(lvds_pads));
-}
-#endif
-
-static void setup_iomux_uart(void)
-{
-	static const iomux_v3_cfg_t uart_pads[] = {
-		SAC58R_PAD_PH14__UART0_TX,
-		SAC58R_PAD_PH15__UART0_RX,
-		SAC58R_PAD_PF11__UART1_TX,
-		SAC58R_PAD_PF12__UART1_RX,
-		SAC58R_PAD_PL5__UART2_TX,
-		SAC58R_PAD_PL4__UART2_RX,
-		SAC58R_PAD_PE28__UART3_TX,
-		SAC58R_PAD_PE27__UART3_RX,
-		SAC58R_PAD_PH0__UART4_TX,
-		SAC58R_PAD_PH1__UART4_RX,
-		SAC58R_PAD_PH9__UART5_TX,
-		SAC58R_PAD_PH10__UART5_RX,
-	};
-
-	imx_iomux_v3_setup_multiple_pads(uart_pads, ARRAY_SIZE(uart_pads));
-}
-
-static void setup_iomux_dspi(void)
-{
-	static const iomux_v3_cfg_t dspi0_pads[] = {
-		SAC58R_PAD_PH8_SPIO_PCS2,
-		SAC58R_PAD_PH3_SPIO_PCS3,
-		SAC58R_PAD_PK14_SPIO_SOUT,
-		SAC58R_PAD_PK15_SPIO_PCS0,
-		SAC58R_PAD_PK16_SPIO_SCK,
-		SAC58R_PAD_PK17_SPIO_SIN,
-	};
-
-	imx_iomux_v3_setup_multiple_pads(dspi0_pads, ARRAY_SIZE(dspi0_pads));
-}
-
-#ifdef	CONFIG_FEC_MXC
-static void setup_iomux_enet(void)
-{
-	static const iomux_v3_cfg_t enet_pads[] = {
-		SAC58R_PAD_PA10_ENET_RMII_CLKOUT,
-		SAC58R_PAD_PB0_ENET_RMII_RXD1,
-		SAC58R_PAD_PB2_ENET_RMII_CRS_DV,
-		SAC58R_PAD_PB3_ENET_RMII_TXDEN,
-		SAC58R_PAD_PB4_ENET_RMII_RXD0,
-		SAC58R_PAD_PB7_ENET_RMII_MDIO,
-		SAC58R_PAD_PB8_ENET_RMII_TXD0,
-		SAC58R_PAD_PB9_ENET_RMII_TXD1,
-		SAC58R_PAD_PB10_ENET_RMII_MDC,
-		SAC58R_PAD_PB12_ENET_REF_MII_CLK,
-		SAC58R_PAD_PL13_GPIO365, /* PHY_RESET */
-	};
-
-	imx_iomux_v3_setup_multiple_pads(enet_pads, ARRAY_SIZE(enet_pads));
-
-	/* Reset LAN8720 PHY */
-	gpio_direction_output(PHY_RESET_GPIO , 0);
-	udelay(1000);
-	gpio_set_value(PHY_RESET_GPIO, 1);
-}
-#endif
-
-#ifdef CONFIG_SYS_I2C_MXC
-static void setup_board_i2c(void)
-{
-	setup_i2c(0, CONFIG_SYS_I2C_SPEED, 0x7f, &i2c_pad_info0);
-	setup_i2c(1, CONFIG_SYS_I2C_SPEED, 0x7f, &i2c_pad_info1);
-	setup_i2c(3, CONFIG_SYS_I2C_SPEED, 0x7f, &i2c_pad_info3);
-}
-#endif
-
-#ifdef CONFIG_SYS_USE_NAND
-void setup_iomux_nfc(void)
-{
-	static const iomux_v3_cfg_t nfc_pads[] = {
-		SAC58R_PAD_PF29__NFC_IO15,
-		SAC58R_PAD_PF28__NFC_IO14,
-		SAC58R_PAD_PF27__NFC_IO13,
-		SAC58R_PAD_PF26__NFC_IO12,
-		SAC58R_PAD_PF23__NFC_IO11,
-		SAC58R_PAD_PF22__NFC_IO10,
-		SAC58R_PAD_PF20__NFC_IO9,
-		SAC58R_PAD_PF19__NFC_IO8,
-		SAC58R_PAD_PC13__NFC_IO7,
-		SAC58R_PAD_PC12__NFC_IO6,
-		SAC58R_PAD_PC11__NFC_IO5,
-		SAC58R_PAD_PC10__NFC_IO4,
-		SAC58R_PAD_PC9__NFC_IO3,
-		SAC58R_PAD_PC6__NFC_IO2,
-		SAC58R_PAD_PC8__NFC_IO1,
-		SAC58R_PAD_PC7__NFC_IO0,
-		SAC58R_PAD_PC5__NFC_WEB,
-		SAC58R_PAD_PC2__NFC_CE0B,
-		SAC58R_PAD_PA16__NFC_CE1B,
-		SAC58R_PAD_PC1__NFC_REB,
-		SAC58R_PAD_PC0__NFC_RB0B,
-		SAC58R_PAD_PC4__NFC_ALE,
-		SAC58R_PAD_PC3__NFC_CLE,
-	};
-	imx_iomux_v3_setup_multiple_pads(nfc_pads, ARRAY_SIZE(nfc_pads));
-
-}
-#endif
-
-#ifdef CONFIG_FSL_ESDHC
-struct fsl_esdhc_cfg esdhc_cfg[CONFIG_SYS_FSL_ESDHC_NUM] = {
-	{USDHC0_BASE_ADDR},
-#ifndef CONFIG_SYS_USE_NAND
-	{USDHC1_BASE_ADDR},
-	{USDHC2_BASE_ADDR},
-#endif
-};
-
-int board_mmc_getcd(struct mmc *mmc)
-{
-	/* eSDHC0 is always present */
-	return 1;
-}
-
-int board_mmc_init(bd_t *bis)
-{
-	int i;
-	int ret;
-
-	static const iomux_v3_cfg_t sdhc_pads[] = {
-		SAC58R_PAD_PF0__SDHC0_CLK,
-		SAC58R_PAD_PF1__SDHC0_CMD,
-		SAC58R_PAD_PF2__SDHC0_DAT0,
-		SAC58R_PAD_PF3__SDHC0_DAT1,
-		SAC58R_PAD_PF4__SDHC0_DAT2,
-		SAC58R_PAD_PF5__SDHC0_DAT3,
-		SAC58R_PAD_PF0__SDHC0_CLK,
-		SAC58R_PAD_PF1__SDHC0_CMD,
-		SAC58R_PAD_PF2__SDHC0_DAT0,
-		SAC58R_PAD_PF3__SDHC0_DAT1,
-		SAC58R_PAD_PF4__SDHC0_DAT2,
-		SAC58R_PAD_PF5__SDHC0_DAT3,
-
-#ifndef CONFIG_SYS_USE_NAND
-		SAC58R_PAD_PF26__SDHC1_CLK,
-		SAC58R_PAD_PF27__SDHC1_CMD,
-		SAC58R_PAD_PF22__SDHC1_DAT0,
-		SAC58R_PAD_PF23__SDHC1_DAT1,
-		SAC58R_PAD_PF19__SDHC1_DAT2,
-		SAC58R_PAD_PF20__SDHC1_DAT3,
-		SAC58R_PAD_PC12__SDHC2_CLK,
-		SAC58R_PAD_PC13__SDHC2_CMD,
-		SAC58R_PAD_PC9__SDHC2_DAT0,
-		SAC58R_PAD_PC6__SDHC2_DAT1,
-		SAC58R_PAD_PC5__SDHC2_DAT2,
-		SAC58R_PAD_PC2__SDHC2_DAT3,
-		SAC58R_PAD_PC10__SDHC2_DAT4,
-		SAC58R_PAD_PC11__SDHC2_DAT5,
-		SAC58R_PAD_PC7__SDHC2_DAT6,
-		SAC58R_PAD_PC8__SDHC2_DAT7,
-#endif
-
-	};
-
-	imx_iomux_v3_setup_multiple_pads(
-		sdhc_pads, ARRAY_SIZE(sdhc_pads));
-
-	/* Enable SDHCs modules in GPC */
-	enable_periph_clk(AIPS2,AIPS2_OFF_SDHC0);
-	enable_periph_clk(AIPS2,AIPS2_OFF_SDHC1);
-	enable_periph_clk(AIPS2,AIPS2_OFF_SDHC2);
-
-	for (i = 0; i < CONFIG_SYS_FSL_ESDHC_NUM; i++) {
-		esdhc_cfg[i].sdhc_clk = mxc_get_clock(MXC_USDHC0_CLK + i);
-		ret = fsl_esdhc_initialize(bis, &esdhc_cfg[i]);
-		if (ret < 0) {
-			printf("Warning: failed to initialize mmc dev %d\n", i);
-		}
-	}
-
-	return 0;
-}
-#endif
-
-
-#ifdef CONFIG_MVF_GPIO
-static void setup_iomux_gpio(void)
-{
-	iomux_v3_cfg_t sdcard0_cd;
-	iomux_v3_cfg_t sdcard1_cd;
-	u32 sdcard_cd_padconf;
-
-	static const iomux_v3_cfg_t gpio_pads[] = {
-		SAC58R_PAD_PF16_USB0_ID,  /* USB OTG pin id */
-		SAC58R_PAD_PF25_GPIO_185, /* USB OTG VBUS ENABLE */
-		SAC58R_PAD_PA4__GPIO_4,   /* CS42888 reset line */
-		SAC58R_PAD_PF14__GPIO_174, /* USR-SW3 button */
-		SAC58R_PAD_PL8__GPIO_360, /* USR-SW1 button */
-		SAC58R_PAD_PL9__GPIO_361, /* USR-SW2 button */
-		SAC58R_PAD_PK12__GPIO_332, /* USB HOST VBUS ENABLE */
-		SAC58R_PAD_PL0_GPIO352,  /* GPIO352 TUNER_PIN7 */
-		SAC58R_PAD_PF18_GPIO178, /* GPIO178 BT_RESET */
-	};
-
-	imx_iomux_v3_setup_multiple_pads(
-		gpio_pads, ARRAY_SIZE(gpio_pads));
-
-	gpio_direction_input(174);
-	gpio_direction_input(360);
-	gpio_direction_input(361);
-
-	/* On some boards, CS42888 holds I2C0 bus lines low. Resetting audio codec
-		puts things back to normal */
-	gpio_direction_output(4, 1);
-
-	/*
-	 * SD cards Card Detect GPIOs for slot 0 (GPIO_153) and slot 1 (GPIO154):
-	 * set specific IOMUX configuration:
-	 * - keep IO in input only so that IRQ gets triggered
-	 */
-	sdcard_cd_padconf = PAD_CTL_PUS_100K_UP |
-			PAD_CTL_SPEED_MED |
-			PAD_CTL_DSE_25ohm |
-			PAD_CTL_IBE_ENABLE;
-
-	sdcard0_cd = IOMUX_PAD(0x264, 0x264, 0,  __NA_, 0, sdcard_cd_padconf);
-	sdcard1_cd = IOMUX_PAD(0x268, 0x268, 0,  __NA_, 0, sdcard_cd_padconf);
-
-	imx_iomux_v3_setup_pad(sdcard0_cd);
-	imx_iomux_v3_setup_pad(sdcard1_cd);
-}
-#endif
-
-void setup_iomux_audio(void)
-{
-	static const iomux_v3_cfg_t audio_pads[] = {
-		/* SAI0 */
-		SAC58R_PAD_PG5_SAI0_TX_BCLK,
-		SAC58R_PAD_PG6_SAI0_TX_SYNC,
-		SAC58R_PAD_PF10_SAI0_RX_DATA,
-		SAC58R_PAD_PF9_SAI0_TX_DATA,
-
-		/* SAI1 */
-		SAC58R_PAD_PH11_SAI1_TX_BCLK,
-		SAC58R_PAD_PH12_SAI1_TX_SYNC,
-		SAC58R_PAD_PH16_SAI1_RX_BCLK,
-		SAC58R_PAD_PH17_SAI1_RX_SYNC,
-		SAC58R_PAD_PH18_SAI1_RX_DATA,
-		SAC58R_PAD_PH19_SAI1_TX_DATA,
-
-		/* ESAI0 */
-		SAC58R_PAD_PA5_ESAI0_FSR,
-		SAC58R_PAD_PA6_ESAI0_SCKR,
-		SAC58R_PAD_PA12_ESAI0_SDO5_SDI0,
-		SAC58R_PAD_PA14_ESAI0_SDO2_SDI3,
-		SAC58R_PAD_PA15_ESAI0_SDO4_SDI3,
-		SAC58R_PAD_PA16_ESAI0_SDO3_SDI2,
-		SAC58R_PAD_PA17_ESAI0_SDO1,
-		SAC58R_PAD_PA18_ESAI0_SD00,
-		SAC58R_PAD_PA19_ESAI0_SCKT,
-		SAC58R_PAD_PA20_ESAI0_FST,
-	};
-
-	imx_iomux_v3_setup_multiple_pads(
-		audio_pads, ARRAY_SIZE(audio_pads));
-}
-
-#define VPU_HD_SUPPORT	0x8
-static void vpu_init(void)
-{
-	/* Enable HD-support on VPU */
-
-	u32 gpcr03 = readl(REG_BANK_PD2_BASE_ADDR + 0x0C);
-	gpcr03 |= VPU_HD_SUPPORT;
-	writel(gpcr03, REG_BANK_PD2_BASE_ADDR + 0x0C);
-
-	printf("Enabled HD-support in VPU\n");
-}
-
-
-static void audiocodec_clock_init(void)
-{
-	struct ccm_reg *ccm = (struct ccm_reg *)CCM_BASE_ADDR;
-
-	/* Audio codec subsystem will use AUDIO1_PLL_DIV input
-		as defined below:
-		PLL8_FREQ = 1179 MHz
-		CCM_AUDIO1_CLK_CTL = PLL8/2
-		TDM_SRC0 input = AUDIO1_PLL_DIV/2/24 = 24.576 MHz
-		TDM_SRC1 input = AUDIO1_PLL_DIV/2/24 = 24.576 MHz
-		CODEC MCLK = FSOXC
-	*/
-
-	/* CCM_AUDIO1_CLK_CTL = AUDIO1_PLL/2 = 1179/2 MHz */
-	writel(CCM_MODULE_ENABLE_CTL_EN |(0x1 << CCM_MUX_CTL_OFFSET),
-			&ccm->AUDIO1_pll_div_clk);
-
-	/* CODEC_MCLK INPUT SEL = FSOXC */
-	writel( (0x1 << CCM_MUX_CTL_OFFSET), &ccm->codec_mclk);
-
-	/* SAI0 MCLK selection = AUDIO1_PLL_DIV */
-	writel(0x4 << CCM_MUX_CTL_OFFSET, &ccm->sai0_mclk);
-
-	/* SAI1 MCLK selection = AUDIO1_PLL_DIV */
-	writel(0x4 << CCM_MUX_CTL_OFFSET, &ccm->sai1_mclk);
-
-	/* CODEC SAI_BCLK0 input clock sel = AUDIO1_PLL_DIV/2
-		SAI BCLK0 clock frequency = 589/(23+1) = 24,576MHz */
-	writel(CCM_MODULE_ENABLE_CTL_EN | (23 << CCM_PREDIV_CTRL_OFFSET)
-		| (0x5 << CCM_MUX_CTL_OFFSET), &ccm->codec_sai_bclk0);
-
-	/* CODEC SAI_BCLK1 input clock sel = AUDIO1_PLL_DIV/2
-		SAI BCLK1 clock frequency = 589/(23+1) = 24,576MHz */
-	writel(CCM_MODULE_ENABLE_CTL_EN | (23 << CCM_PREDIV_CTRL_OFFSET)
-		| (0x5 << CCM_MUX_CTL_OFFSET), &ccm->codec_sai_bclk1);
-
-	/* TDM_SRC0 input clock sel = AUDIO1_PLL_DIV/2
-		TDM SRC0 clock frequency = 589/(23+1) = 24,576MHz */
-	writel(CCM_MODULE_ENABLE_CTL_EN | (23 << CCM_PREDIV_CTRL_OFFSET)
-		| (0x5 << CCM_MUX_CTL_OFFSET), &ccm->codec_dac_tdm_src0);
-
-	/* TDM_SRC1 input clock sel = AUDIO1_PLL_DIV/2
-		TDM SRC1 clock frequency = 589/(23+1) = 24,576MHz */
-	writel(CCM_MODULE_ENABLE_CTL_EN | (23 << CCM_PREDIV_CTRL_OFFSET)
-			| (0x5 << CCM_MUX_CTL_OFFSET), &ccm->codec_dac_tdm_src1);
-
-	/* Enable AUDIO1 PLL */
-	enable_pll(PLL_AUDIO1);
-
-	/* Enable Audio Codec IPG clock divider */
-	writel( CCM_MODULE_ENABLE_CTL_EN | (0x3 << CCM_PREDIV_CTRL_OFFSET),
-			&ccm->audio_codec_ipg_clk);
-}
-
-static void esai_clock_init(void)
-{
-	struct ccm_reg *ccm = (struct ccm_reg *)CCM_BASE_ADDR;
-
-	/* ESAI will use AUDIO0_PLL_DIV input
-		as defined below:
-		PLL8_FREQ = 1179 MHz
-		CCM_AUDIO0_CLK_CTL = PLL4/48
-	*/
-
-	/* CCM_AUDIO0_CLK_CTL = AUDIO0_PLL/48 = 1179/48 MHz */
-	writel(CCM_MODULE_ENABLE_CTL_EN | (23 << CCM_PREDIV_CTRL_OFFSET) |
-		   (0x1 << CCM_MUX_CTL_OFFSET),
-			&ccm->AUDIO0_pll_div_clk);
-
-	/* ESAI0 MCLK selection = AUDIO0_PLL_DIV */
-	writel(0x3 << CCM_MUX_CTL_OFFSET, &ccm->esai0_mclk);
-
-	/* Enable AUDIO0 PLL */
-	enable_pll(PLL_AUDIO0);
-}
-
-static void spdif_clock_init(void)
-{
-	struct ccm_reg *ccm = (struct ccm_reg *)CCM_BASE_ADDR;
-
-	/* SPDIF will use AUDIO0_PLL_DIV as defined for ESAI
-		as defined below:
-		PLL8_FREQ = 1179 MHz
-		CCM_AUDIO0_CLK_CTL = PLL4/48 (24,576MHz)
-	*/
-
-	/* SPDIF0 input clock selection = AUDIO0_PLL_DIV */
-	writel(0x3 << CCM_MUX_CTL_OFFSET, &ccm->spdif_tx_clk);
-
-	/* SPDIF1 input clock selection = AUDIO0_PLL_DIV */
-	writel(0x3 << CCM_MUX_CTL_OFFSET, &ccm->spdif1_tx_clk);
-}
-
-/* This function configures the VIU subsystem, i.e. :
-	- VIU core clocks
-	- CSI2 clocks
-	- VAFE and VDEC clocks
-*/
-static void viu_subsystem_clocks_init(void)
-{
-	struct ccm_reg *ccm = (struct ccm_reg *)CCM_BASE_ADDR;
-
-	/* VIU core input clock source is USB0_PLL_PFD1:
-		- Set USB0_PLL_PFD1 to 270 MHz (480*18)/32
-		- Select input clock source to VIU as USB0_PLL_PFD1 */
-	config_pll_pfd_frac(PLL_USBOTG0, PLL_PFD1, 32);
-	enable_pll_pfd(PLL_USBOTG0, PLL_PFD1, 1);
-
-	/* VIU input clock selection = USB0_PLL_PFD1 */
-	writel(0x7 << CCM_MUX_CTL_OFFSET, &ccm->viu_clk);
-
-	/* CSI2:
-		- Set MIPI interface clock divider to 3
-		- Set MIPI ref clock as FXOSC
-	*/
-	writel(0x2 << CCM_PREDIV_CTRL_OFFSET, &ccm->mipi_viu_intf_clk);
-	writel(0x1 << CCM_MUX_CTL_OFFSET, &ccm->mipi_24M_ref_clk);
-
-	/* VAFE:
-		- Select VAFE proc input clock source as BUS_CLK
-		- Set VAFE proc clk = 133 MHz */
-	writel(CCM_MODULE_ENABLE_CTL_EN | (0 << CCM_PREDIV_CTRL_OFFSET) |
-		0x4 << CCM_MUX_CTL_OFFSET, &ccm->vidadc_proc_clk);
-}
-
-static void clock_init(void)
-{
-	struct ccm_reg *ccm = (struct ccm_reg *)CCM_BASE_ADDR;
-
-	/* Enable some modules in GPC */
-	enable_periph_clk(AIPS0, AIPS0_OFF_GPC);
-	enable_periph_clk(AIPS0, AIPS0_OFF_SRC);
-	enable_periph_clk(AIPS0, AIPS0_OFF_CCM);
-	enable_periph_clk(AIPS0, AIPS0_OFF_SCSC);
-	enable_periph_clk(AIPS0, AIPS0_OFF_CMU);
-	enable_periph_clk(AIPS0, AIPS0_OFF_ANADIG);
-	enable_periph_clk(AIPS0, AIPS0_OFF_IOMUXC);
-	enable_periph_clk(AIPS1, AIPS1_OFF_MISC_PIN_CONTROL);
-	enable_periph_clk(AIPS0, AIPS0_OFF_WKUP);
-	enable_periph_clk(AIPS0, AIPS0_OFF_PIT);
-	enable_periph_clk(AIPS2, AIPS2_OFF_SDHC0);
-	enable_periph_clk(AIPS1, AIPS1_OFF_UART0);
-	enable_periph_clk(AIPS2, AIPS2_OFF_UART4);
-	enable_periph_clk(AIPS0, AIPS0_OFF_PORTA);
-	enable_periph_clk(AIPS0, AIPS0_OFF_PORTB);
-	enable_periph_clk(AIPS0, AIPS0_OFF_PORTC);
-	enable_periph_clk(AIPS0, AIPS0_OFF_PORTD);
-	enable_periph_clk(AIPS0, AIPS0_OFF_PORTE);
-	enable_periph_clk(AIPS0, AIPS0_OFF_PORTF);
-	enable_periph_clk(AIPS0, AIPS0_OFF_PORTG);
-	enable_periph_clk(AIPS0, AIPS0_OFF_PORTH);
-	enable_periph_clk(AIPS0, AIPS0_OFF_PORTJ);
-	enable_periph_clk(AIPS0, AIPS0_OFF_PORTK);
-	enable_periph_clk(AIPS0, AIPS0_OFF_PORTL);
-	enable_periph_clk(AIPS0, AIPS0_OFF_GPIOC);
-	enable_periph_clk(AIPS2, AIPS2_OFF_ENET);
-	enable_periph_clk(AIPS2, AIPS2_OFF_MMDC);
-
-	enable_periph_clk(AIPS1, AIPS1_OFF_AUD_ADC_DAC0);
-	enable_periph_clk(AIPS1, AIPS1_OFF_AUD_ADC_DAC1);
-	enable_periph_clk(AIPS1, AIPS1_OFF_AUD_ADC_DAC2);
-	enable_periph_clk(AIPS1, AIPS1_OFF_AUD_ADC_DAC3);
-
-#ifdef CONFIG_I2C_MXC
-	enable_periph_clk(AIPS1, AIPS1_OFF_I2C0);
-#endif
-
-	enable_periph_clk(AIPS1, AIPS2_OFF_SAI0);
-	enable_periph_clk(AIPS1, AIPS2_OFF_SAI1);
-	enable_periph_clk(AIPS1, AIPS1_OFF_SAI4);
-	enable_periph_clk(AIPS1, AIPS1_OFF_SAI5);
-	enable_periph_clk(AIPS1, AIPS1_OFF_SAI6);
-	enable_periph_clk(AIPS1, AIPS1_OFF_SAI7);
-
-	enable_periph_clk(AIPS2, AIPS2_OFF_NFC0);
-	enable_periph_clk(AIPS2, AIPS2_OFF_NFC1);
-	enable_periph_clk(AIPS2, AIPS2_OFF_NFC2);
-	enable_periph_clk(AIPS2, AIPS2_OFF_NFC3);
-
-	enable_periph_clk(AIPS2, AIPS2_OFF_ASRC0);
-
-	/* Set PLL ARM = 1200 MHz and enable it */
-	config_pll(PLL_ARM, 50, 0, 1);
-	enable_pll(PLL_ARM);
-
-	/* configure ARM A7 clock => From PLL1 (PLL_CORE) = 1200/2 = 600MHz */
-	writel( (0x1 << CCM_PREDIV_CTRL_OFFSET) | (0x3 << CCM_MUX_CTL_OFFSET), &ccm->a7_clk);
-
-	/* SDHC0,1,2 clocks => from PLL_SS_PFD2/2 = 396/2 = 198 MHz */
-	writel(CCM_MODULE_ENABLE_CTL_EN | (0x1 << CCM_PREDIV_CTRL_OFFSET)
-		| (0x2 << CCM_MUX_CTL_OFFSET), &ccm->uSDHC0_perclk);
-#ifndef CONFIG_SYS_USE_NAND
-	writel(CCM_MODULE_ENABLE_CTL_EN | (0x1 << CCM_PREDIV_CTRL_OFFSET)
-		| (0x2 << CCM_MUX_CTL_OFFSET), &ccm->uSDHC1_perclk);
-	writel(CCM_MODULE_ENABLE_CTL_EN | (0x1 << CCM_PREDIV_CTRL_OFFSET)
-		| (0x2 << CCM_MUX_CTL_OFFSET), &ccm->uSDHC2_perclk);
-#endif
-
-	/*  NFC clock => from SYS_PLL_PFD2 = 396/8 (0x7 +1)= 49.5 MHz */
-	writel(CCM_MODULE_ENABLE_CTL_EN | (0x7 << CCM_PREDIV_CTRL_OFFSET)
-		| (0x1 << CCM_MUX_CTL_OFFSET), &ccm->nfc_flash_clk_div);
-
-	/* Refine AUDIO0 and AUDIO1 PLLs MFN and MFD parameters:
-		By default, they are way too big, kernel is unable to compute
-		the right values of the PLLs and end up with a erroneous
-		1176MHz instead of the correct 1179MHz value.
-		(see arch/arm/mach-imx/clk-pllv3.c, clk_pllv3_av_recalc_rate()).
-		These values make it easy for the kernel to compute the right
-		value of these PLLs (1179648000 Hz)
-		This value divided by 48 allows providing a 24,576MHz
-		input clock to the different audio IPs */
-
-	/* Setting PLL4_MAIN and PLL8_MAIN to 1179MHz:
-			- (24 MHz * 49) + ((24 MHz/1000)*152)
-		=> DIV_SELECT = 49
-		=> PLLx_NUM   =  152
-		=> PLLx_DENOM = 1000
-	*/
-	config_pll(PLL_AUDIO0, 49, 152, 1000);
-	config_pll(PLL_AUDIO1, 49, 152, 1000);
-}
-
-static void gpu_clk_init(void)
-{
-	struct ccm_reg *ccm = (struct ccm_reg *)CCM_BASE_ADDR;
-	/* Setting PLL6_MAIN to 640MHz = 24MHz * (26 + 2/3)
-	   => DIV_SELECT = 26 = 0x1A
-	   => PLL6_NUM   =  2 = 0x02
-	   => PLL6_DENOM =  3 = 0x03
-	*/
-	config_pll(PLL_VIDEO, 26, 2, 3);
-	enable_pll(PLL_VIDEO);
-
-	/* Setting GPU input clock to VIDEO_PLL (PLL6_MAIN) */
-	writel(0x00000005, &ccm->GCC_clk2x);
-}
-
-static void mscm_init(void)
-{
-	struct mscm_ir *mscmir = (struct mscm_ir *)MSCM_IR_BASE_ADDR;
-	int i;
-
-	/* Interrupt Routing Configuration */
-	for (i = 0; i < MSCM_IRSPRC_NUM; i++)
-		writew(int_routing_conf[i], &mscmir->irsprc[i]);
-}
-
-static void dmamux_init(void)
-{
-	/* Example DMA CHANNEL MUXING FOR SAC58R. This function is not called */
-	static const dmamux_cfg_t dma_channels [] = {
-		DMAMUX_CHANNEL(DMAMUX_0, 0, SAC58R_DMAREQSRC_UART0_RX, 0, 1), /* DMAMUX 0, Channel 0 => UART0_RX, no trigger, channel enable */
-		DMAMUX_CHANNEL(DMAMUX_1, 8, SAC58R_DMAREQSRC_PORTA, 0, 1), /* DMAMUX 1, Channel 8 => PORT_A, no trigger, channel enable */
-		DMAMUX_CHANNEL(DMAMUX_2, 4, SAC58R_DMAREQSRC_SAI6_TX, 0, 1), /* DMAMUX 2, Channel 4  => SAI6_TX, no trigger, channel enable */
-		DMAMUX_CHANNEL(DMAMUX_3, 12, SAC58R_DMAREQSRC_QSPIO_RX, 0, 1), /* DMAMUX 3, Channel 12 => QSPI0_TX, no trigger, channel enable */
-	};
-	imx_dmamux_setup_multiple_channels(dma_channels, ARRAY_SIZE(dma_channels));
-}
-
-#ifdef	CONFIG_FEC_MXC
-int board_phy_config(struct phy_device *phydev)
-{
-	if (phydev->drv->config) {
-		phydev->drv->config(phydev);
-	}
-
-	return 0;
-}
-
-
-int board_eth_init(bd_t *bis)
-{
-	int ret;
-
-	setup_iomux_enet();
-
-	ret = cpu_eth_init(bis);
-	if (ret)
-		printf("FEC MXC: %s:failed\n", __func__);
-
-	return 0;
-}
-#endif
-
-int board_early_init_f(void)
-{
-	clock_init();
-	mscm_init();
-
-	setup_iomux_ddr();
-	ddr_ctrl_init();
-
-	setup_iomux_uart();
-	setup_iomux_dspi();
-
-#ifdef CONFIG_SYS_USE_NAND
-	setup_iomux_nfc();
-#endif
-
-#ifdef CONFIG_MVF_GPIO
-	setup_iomux_gpio();
-#endif
-
-	setup_iomux_audio();
-
-	return 0;
-}
-
-int board_init(void)
-{
-	/* address of boot parameters */
-	gd->bd->bi_boot_params = PHYS_SDRAM + 0x100;
-
-#ifdef CONFIG_SYS_I2C_MXC
-	setup_board_i2c();
-#endif
-
-#ifdef	CONFIG_FEC_MXC
-	enable_fec_clock();
-#endif
-
-#ifdef CONFIG_LVDS
-	setup_iomux_lvds();
-#endif
-
-	audiocodec_clock_init();
-
-	esai_clock_init();
-
-	vpu_init();
-
-	gpu_clk_init();
-
-	spdif_clock_init();
-
-	viu_subsystem_clocks_init();
-
-	return 0;
-}
-
-int checkboard(void)
-{
-#ifdef CONFIG_REVB
-	puts("Board: SAC58R EVB RevB\n");
-#else
-	puts("Board: SAC58R EVB\n");
-#endif
-
-	return 0;
-}
diff --git a/board/freescale/sac58revb/sac58revb_int_routing.h b/board/freescale/sac58revb/sac58revb_int_routing.h
deleted file mode 100644
index bdb5ae9708..0000000000
--- a/board/freescale/sac58revb/sac58revb_int_routing.h
+++ /dev/null
@@ -1,121 +0,0 @@
-/*
- * (C) Copyright 2014 Freescale Semiconductor, Inc.
- *
- * SPDX-License-Identifier:	GPL-2.0+
- */
-
-static const u8 int_routing_conf[] = {
-	MSCM_IRSPRC_ROUTE_TO_CA7,	/* DMA0 Transfer Complete CH0-31 */
-	MSCM_IRSPRC_ROUTE_TO_CA7,	/* DMA0 Error Interrupt CH0-31 */
-	MSCM_IRSPRC_ROUTE_TO_CA7,	/* DMA1 Transfer Complete CH0-31 */
-	MSCM_IRSPRC_ROUTE_TO_CA7,	/* DMA1 Transfer Complete CH0-31 */
-	MSCM_IRSPRC_ROUTE_TO_CA7,	/* SWT 0 */
-	MSCM_IRSPRC_ROUTE_TO_CA7,	/* SWT 1 */
-	MSCM_IRSPRC_ROUTE_TO_CA7,	/* SWT 2 */
-	MSCM_IRSPRC_ROUTE_TO_CA7,	/* MSCM-ECC0 */
-	MSCM_IRSPRC_ROUTE_TO_CA7,	/* MSCM-ECC1 */
-	MSCM_IRSPRC_ROUTE_TO_CA7,	/* xRDC */
-	MSCM_IRSPRC_ROUTE_TO_CA7,	/* MSCM-ACTZS */
-	MSCM_IRSPRC_ROUTE_TO_CA7,	/* STM 0 */
-	MSCM_IRSPRC_ROUTE_TO_CA7,
-	MSCM_IRSPRC_ROUTE_TO_CA7,	/* WDOG-SNVS */
-	MSCM_IRSPRC_ROUTE_TO_CA7,	/* SNVS - Non TZ*/
-	MSCM_IRSPRC_ROUTE_TO_CA7,	/* SNVS - TZ */
-	MSCM_IRSPRC_ROUTE_TO_CA7,	/* QuadSPI0 */
-	MSCM_IRSPRC_ROUTE_TO_CA7,	/* MMDC */
-	MSCM_IRSPRC_ROUTE_TO_CA7,	/* NFC */
-	MSCM_IRSPRC_ROUTE_TO_CA7,	/* USDHC0 */
-	MSCM_IRSPRC_ROUTE_TO_CA7,	/* USDHC1 */
-	MSCM_IRSPRC_ROUTE_TO_CA7,	/* USDHC 2 */
-	MSCM_IRSPRC_ROUTE_TO_CA7,	/* MIPI-CSI2 */
-	MSCM_IRSPRC_ROUTE_TO_CA7,	/* DCU0 */
-	MSCM_IRSPRC_ROUTE_TO_CA7,	/* VIU */
-	MSCM_IRSPRC_ROUTE_TO_CA7,	/* VPU */
-	MSCM_IRSPRC_ROUTE_TO_CA7,	/* GC400T */
-	MSCM_IRSPRC_ROUTE_TO_CA7,	/* RLE */
-	MSCM_IRSPRC_ROUTE_TO_CA7,	/* USBC 0*/
-	MSCM_IRSPRC_ROUTE_TO_CA7,	/* USBC 1 */
-	MSCM_IRSPRC_ROUTE_TO_CA7,	/* USBC 2 */
-	MSCM_IRSPRC_ROUTE_TO_CA7,	/* PIT */
-	MSCM_IRSPRC_ROUTE_TO_CA7,	/* LPTimer */
-	MSCM_IRSPRC_ROUTE_TO_CA7,	/* SPDIF1 */
-	MSCM_IRSPRC_ROUTE_TO_CA7,	/*FlexTimer  */
-	MSCM_IRSPRC_ROUTE_TO_CA7,	/* ENET 0 */
-	MSCM_IRSPRC_ROUTE_TO_CA7,	/* 1588 Timer 0 */
-	MSCM_IRSPRC_ROUTE_TO_CA7,	/* VSPA */
-	MSCM_IRSPRC_ROUTE_TO_CA7,	/* FECA */
-	MSCM_IRSPRC_ROUTE_TO_CA7,	/* AXIQ */
-	MSCM_IRSPRC_ROUTE_TO_CA7,	/* JESD204B 0/1 */
-	MSCM_IRSPRC_ROUTE_TO_CA7,	/* JESD204B 2/3 */
-	MSCM_IRSPRC_ROUTE_TO_CA7,	/* ANADIG - USB PHY 0 */
-	MSCM_IRSPRC_ROUTE_TO_CA7,	/* ANADIG - USB PHY 1 */
-	MSCM_IRSPRC_ROUTE_TO_CA7,	/* ENET 0 errors */
-	MSCM_IRSPRC_ROUTE_TO_CA7,	/* ADC 0 */
-	MSCM_IRSPRC_ROUTE_TO_CA7,	/* AUD_ADC_DAC */
-	MSCM_IRSPRC_ROUTE_TO_CA7,	/* ENET Queue 0 */
-	MSCM_IRSPRC_ROUTE_TO_CA7,	/* ENET Queues  */
-	MSCM_IRSPRC_ROUTE_TO_CA7,	/* FlexCAN 0 */
-	MSCM_IRSPRC_ROUTE_TO_CA7,	/* FlexCAN 1 */
-	MSCM_IRSPRC_ROUTE_TO_CA7,	/* FlexCAN 2 */
-	MSCM_IRSPRC_ROUTE_TO_CA7,	/* MLB */
-	MSCM_IRSPRC_ROUTE_TO_CA7,	/* UART 0 */
-	MSCM_IRSPRC_ROUTE_TO_CA7,	/* UART 1 */
-	MSCM_IRSPRC_ROUTE_TO_CA7,	/* UART 2 */
-	MSCM_IRSPRC_ROUTE_TO_CA7,	/* UART 3 */
-	MSCM_IRSPRC_ROUTE_TO_CA7,	/* UART 4 */
-	MSCM_IRSPRC_ROUTE_TO_CA7,	/* UART 5 */
-	MSCM_IRSPRC_ROUTE_TO_CA7,	/* SPI 0 */
-	MSCM_IRSPRC_ROUTE_TO_CA7,	/* SPI 1 */
-	MSCM_IRSPRC_ROUTE_TO_CA7,	/* VSPA-GPO11[24] */
-	MSCM_IRSPRC_ROUTE_TO_CA7,	/* VSPA-GPO11[25] */
-	MSCM_IRSPRC_ROUTE_TO_CA7,	/* I2C 0 */
-	MSCM_IRSPRC_ROUTE_TO_CA7,	/* I2C 1 */
-	MSCM_IRSPRC_ROUTE_TO_CA7,	/* I2C 2 */
-	MSCM_IRSPRC_ROUTE_TO_CA7,	/* I2C 3 */
-	MSCM_IRSPRC_ROUTE_TO_CA7,	/* SAI 0 */
-	MSCM_IRSPRC_ROUTE_TO_CA7,	/* SAI 1 */
-	MSCM_IRSPRC_ROUTE_TO_CA7,	/* SAI 2 */
-	MSCM_IRSPRC_ROUTE_TO_CA7,	/* SAI 3 */
-	MSCM_IRSPRC_ROUTE_TO_CA7,	/* SAI 4 */
-	MSCM_IRSPRC_ROUTE_TO_CA7,	/* SAI 5 */
-	MSCM_IRSPRC_ROUTE_TO_CA7,	/* SAI 6 */
-	MSCM_IRSPRC_ROUTE_TO_CA7,	/* SAI 7 */
-	MSCM_IRSPRC_ROUTE_TO_CA7,	/* SAI 8 */
-	MSCM_IRSPRC_ROUTE_TO_CA7,	/* SAI 9 */
-	MSCM_IRSPRC_ROUTE_TO_CA7,	/* SAI 10 */
-	MSCM_IRSPRC_ROUTE_TO_CA7,	/* SAI 11 */
-	MSCM_IRSPRC_ROUTE_TO_CA7,	/* ESAI0 BIFIFO */
-	MSCM_IRSPRC_ROUTE_TO_CA7,	/* ESAI1 BIFIFO */
-	MSCM_IRSPRC_ROUTE_TO_CA7,	/* SPDIF0 */
-	MSCM_IRSPRC_ROUTE_TO_CA7,	/* ASRC0 */
-	MSCM_IRSPRC_ROUTE_TO_CA7,	/* ASRC1 */
-	MSCM_IRSPRC_ROUTE_TO_CA7,	/* SRC */
-	MSCM_IRSPRC_ROUTE_TO_CA7,	/* WKUP 0 */
-	MSCM_IRSPRC_ROUTE_TO_CA7,	/* GPC */
-	MSCM_IRSPRC_ROUTE_TO_CA7,	/* Temp Sensor */
-	MSCM_IRSPRC_ROUTE_TO_CA7,
-	MSCM_IRSPRC_ROUTE_TO_CA7,	/* PDB */
-	MSCM_IRSPRC_ROUTE_TO_CA7,	/* CMU */
-	MSCM_IRSPRC_ROUTE_TO_CA7,	/* CAAM */
-	MSCM_IRSPRC_ROUTE_TO_CA7,	/* GPIO 0 */
-	MSCM_IRSPRC_ROUTE_TO_CA7,	/* GPIO 1 */
-	MSCM_IRSPRC_ROUTE_TO_CA7,	/* GPIO 2 */
-	MSCM_IRSPRC_ROUTE_TO_CA7,	/* GPIO 3 */
-	MSCM_IRSPRC_ROUTE_TO_CA7,	/* GPIO 4 */
-	MSCM_IRSPRC_ROUTE_TO_CA7,	/* GPIO 5 */
-	MSCM_IRSPRC_ROUTE_TO_CA7,	/* GPIO 6 */
-	MSCM_IRSPRC_ROUTE_TO_CA7,	/* GPIO 7 */
-	MSCM_IRSPRC_ROUTE_TO_CA7,	/* GPIO 8 */
-	MSCM_IRSPRC_ROUTE_TO_CA7,	/* GPIO 9 */
-	MSCM_IRSPRC_ROUTE_TO_CA7,	/* GPIO 10 */
-	MSCM_IRSPRC_ROUTE_TO_CA7,
-	MSCM_IRSPRC_ROUTE_TO_CA7,	/* JESD204B_0 */
-	MSCM_IRSPRC_ROUTE_TO_CA7,	/* JESD204B_1 */
-	MSCM_IRSPRC_ROUTE_TO_CA7,	/* JESD204B_2 */
-	MSCM_IRSPRC_ROUTE_TO_CA7,	/* JESD204B_3 */
-	MSCM_IRSPRC_ROUTE_TO_CA7,	/* ENET Queue 1 */
-	MSCM_IRSPRC_ROUTE_TO_CA7,	/* ENET Queue 2 */
-	MSCM_IRSPRC_ROUTE_TO_CA7,
-	MSCM_IRSPRC_ROUTE_TO_CA7,
-};
-
diff --git a/board/freescale/sac58rfvb/Kconfig b/board/freescale/sac58rfvb/Kconfig
deleted file mode 100644
index af9371553e..0000000000
--- a/board/freescale/sac58rfvb/Kconfig
+++ /dev/null
@@ -1,23 +0,0 @@
-if TARGET_SAC58RFVB
-
-config SYS_CPU
-	string
-	default "armv7"
-
-config SYS_BOARD
-	string
-	default "sac58rfvb"
-
-config SYS_VENDOR
-	string
-	default "freescale"
-
-config SYS_SOC
-	string
-	default "sac58r"
-
-config SYS_CONFIG_NAME
-	string
-	default "sac58rfvb"
-
-endif
diff --git a/board/freescale/sac58rfvb/MAINTAINERS b/board/freescale/sac58rfvb/MAINTAINERS
deleted file mode 100644
index 68e147de85..0000000000
--- a/board/freescale/sac58rfvb/MAINTAINERS
+++ /dev/null
@@ -1,6 +0,0 @@
-SAC58R Functional Validation BOARD
-M:	-
-S:	Orphaned
-F:	board/freescale/sac58rfvb/
-F:	include/configs/sac58rfvb.h
-F:	configs/sac58rfvb_defconfig
diff --git a/board/freescale/sac58rfvb/Makefile b/board/freescale/sac58rfvb/Makefile
deleted file mode 100644
index 72b971bed1..0000000000
--- a/board/freescale/sac58rfvb/Makefile
+++ /dev/null
@@ -1,7 +0,0 @@
-#
-# (C) Copyright 2013 Freescale Semiconductor, Inc.
-#
-# SPDX-License-Identifier:	GPL-2.0+
-#
-
-obj-y	:= sac58rfvb.o
diff --git a/board/freescale/sac58rfvb/sac58r_mt41j64.cfg b/board/freescale/sac58rfvb/sac58r_mt41j64.cfg
deleted file mode 100644
index 31a0ca0268..0000000000
--- a/board/freescale/sac58rfvb/sac58r_mt41j64.cfg
+++ /dev/null
@@ -1,71 +0,0 @@
-/*
- * (C) Copyright 2013 Freescale Semiconductor, Inc.
- *
- * SPDX-License-Identifier:	GPL-2.0+
- */
-
-/*
- * Refer docs/README.imxmage for more details about how-to configure
- * and create imximage boot image
- *
- * The syntax is taken as close as possible with the kwbimage
- */
-#include <asm/imx-common/imximage.cfg>
-
-/* image version */
-IMAGE_VERSION	2
-
-/*
- * Boot Device : one of spi, sd, eimnor, nand:
- * spinor: flash_offset: 0x0400
- * nand:   flash_offset: 0x0400
- * sd/mmc: flash_offset: 0x0400
- * eimnor: flash_offset: 0x1000
- */
-
- BOOT_FROM	sd
-
-#ifdef CONFIG_SECURE_BOOT
-SECURE_BOOT
-#endif
-
-/*
- * Device Configuration Data (DCD)
- *
- * Each entry must have the format:
- * Addr-type           Address        Value
- *
- * where:
- *      Addr-type register length (1,2 or 4 bytes)
- *      Address   absolute address of the register
- *      value     value to be stored in the register
- */
-
-/* GPC: enable all modules on GPC_AIPS2_OFFPF_PCTL4 */
-DATA  4, 0x40020198,  0xFFFFFFFF
-DATA  4, 0x4016901C,  0x00008000
-DATA  4, 0x4016900C,  0x303475D3
-DATA  4, 0x40169010,  0xB66E8A83
-DATA  4, 0x40169014,  0x01FF00DB
-DATA  4, 0x40169008,  0x11335030
-DATA  4, 0x40169018,  0x00011640
-DATA  4, 0x40169030,  0x00341023
-DATA  4, 0x40169000,  0x02190000
-DATA  4, 0x40169800,  0xA1390003
-DATA  4, 0x40169000,  0x82190000
-DATA  4, 0x4016901C,  0x00008032
-DATA  4, 0x4016901C,  0x00008033
-DATA  4, 0x4016901C,  0x00448031
-DATA  4, 0x4016901C,  0x05208030
-DATA  4, 0x4016901C,  0x04008040
-DATA  4, 0x40169040,  0x0000004F
-DATA  4, 0x40169848,  0x453E4942
-DATA  4, 0x40169850,  0x30353033
-DATA  4, 0x4016983C,  0x41720154
-DATA  4, 0x40169840,  0x016A014F
-DATA  4, 0x4016902C,  0x000026D2
-DATA  4, 0x40169008,  0x22334010
-DATA  4, 0x40169004,  0x00020024
-DATA  4, 0x40169020,  0x30B01800
-DATA  4, 0x40169818,  0x0003333F
-DATA  4, 0x4016901C,  0x00000000
diff --git a/board/freescale/sac58rfvb/sac58rfvb.c b/board/freescale/sac58rfvb/sac58rfvb.c
deleted file mode 100644
index 48ebdb2b50..0000000000
--- a/board/freescale/sac58rfvb/sac58rfvb.c
+++ /dev/null
@@ -1,567 +0,0 @@
-/*
- * (C) Copyright 2014 Freescale Semiconductor, Inc.
- *
- * SPDX-License-Identifier:	GPL-2.0+
- */
-
-/*
- * U-Boot Implementation for the Freescale SAC58R Functional Validation Board
- */
-
-#include <common.h>
-#include <asm/io.h>
-#include <asm/arch/imx-regs.h>
-#include <asm/arch/iomux-sac58r.h>
-#include <asm/arch/crm_regs.h>
-#include <asm/arch/clock.h>
-#include <mmc.h>
-#include <fsl_esdhc.h>
-#include <miiphy.h>
-#include <netdev.h>
-#include <i2c.h>
-#include <asm/imx-common/mxc_i2c.h>
-#include <asm/arch/dmachmux-sac58r.h>
-
-#include "sac58rfvb_int_routing.h"
-
-DECLARE_GLOBAL_DATA_PTR;
-
-#ifdef CONFIG_I2C_MXC
-/* I2C0 */
-struct i2c_pads_info i2c_pad_info0 = {
-	.scl = {
-		.i2c_mode = SAC58R_PAD_PA1_I2C0_SCL,
-		.gpio_mode = SAC58R_PAD_PA1_GPIO_1,
-		.gp = 1
-	},
-	.sda = {
-		.i2c_mode = SAC58R_PAD_PA0_I2C0_SDA,
-		.gpio_mode = SAC58R_PAD_PA0_GPIO_0,
-		.gp = 0
-	}
-};
-
-/* I2C1 */
-struct i2c_pads_info i2c_pad_info1 = {
-	.scl = {
-		.i2c_mode = SAC58R_PAD_PE19_I2C1_SCL,
-		.gpio_mode = SAC58R_PAD_PE19_GPIO_148,
-		.gp = 148
-	},
-	.sda = {
-		.i2c_mode = SAC58R_PAD_PE10_I2C1_SDA,
-		.gpio_mode = SAC58R_PAD_PE10_GPIO_147,
-		.gp = 147
-	}
-};
-
-
-/* I2C2 */
-struct i2c_pads_info i2c_pad_info2 = {
-	.scl = {
-		.i2c_mode = SAC58R_PAD_PA9_I2C2_SCL,
-		.gpio_mode = SAC58R_PAD_PA9_GPIO_9,
-		.gp = 9
-	},
-	.sda = {
-		.i2c_mode = SAC58R_PAD_PA8_I2C2_SDA,
-		.gpio_mode = SAC58R_PAD_PA8_GPIO_8,
-		.gp = 8
-	}
-};
-
-/* I2C3 */
-struct i2c_pads_info i2c_pad_info3 = {
-	.scl = {
-		.i2c_mode = SAC58R_PAD_PH2_I2C3_SCL,
-		.gpio_mode = SAC58R_PAD_PH2_GPIO_226,
-		.gp = 226
-	},
-	.sda = {
-		.i2c_mode = SAC58R_PAD_PH4_I2C3_SDA,
-		.gpio_mode = SAC58R_PAD_PH4_GPIO_228,
-		.gp = 228
-	}
-};
-#endif
-
-
-#ifdef CONFIG_RUN_FROM_IRAM_ONLY
-/* Run DDR configuration if we run from IRAM only */
-
-/* Micron MT41J64M16 @ 416 MHz*/
-/* 13 row addr, 10 col addr, burst length 8, data size 32 */
-#define MDCTL_CONFIG 	0x02190000
-
-void ddr_ctrl_init(void)
-{
-	writel(0x00008000, 0x4016901C); //MDSCR
-
-	/* MDCFG0: tRFC=48,tXS=52,tXP=3,tXPDLL=10,tFAW=30,tCL=6 */
-	writel(0x303475D3, 0x4016900C); //MDCFG0
-
-	/* MDCFG1:  tRCD=6,tRP=6,tRC=20,tRAS=15,tRPA=1,tWR=6,tMRD=4,tCWL=5 */
-	writel(0xB66E8A83, 0x40169010); //MDCFG1
-
-	/* MDCFG2: tDLLK=512,tRTP=4,tWTR=4,tRRD=4 */
-	writel(0x01FF00DB, 0x40169014); //MDCFG2
-
-	/*MDOTC:  tAOFPD=1,tAONPD=1,tANPD=4,tAXPD=4,tODTLon=5,tODT_idle_off=0 */
-	writel(0x11335030, 0x40169008); //MDOTC (timing param)
-
-	/* MDMISC: WALAT=1, BI bank interleave on, MIF3=3, RALAT=1, 8 banks, DDR3 */
-	writel(0x00011640, 0x40169018); //MDMISC 
-
-	/* MDOR: WALAT=1, BI bank interleave on, MIF3=3, RALAT=1, 8 banks, DDR3 */
-	writel(0x00341023, 0x40169030); //MDOR
-	writel(MDCTL_CONFIG, 0x40169000); //MDCTL
-
-	/* Perform ZQ calibration */
-	writel(0xA1390003, 0x40169800); //MPZQHWCTRL
-
-	/* Enable MMDC with CS0 */
-	writel(MDCTL_CONFIG + 0x80000000, 0x40169000); //MDCTL
-
-	/*** Complete the initialization sequence as defined by JEDEC */
-	/* Configure MR2: CWL=5, self-refresh=off, self-refresh temp=normal */
-	writel(0x00008032, 0x4016901C);
-	/* Configure MR3: normal operation */
-	writel(0x00008033, 0x4016901C);
-	/* Configure MR1: enable DLL, drive strength=40R, AL off, ODT=40R, write levelling off, TDQS=0, Qoff=on */
-	writel(0x00448031, 0x4016901C);
-	/* Configure MR0: BL=8, CL=6, DLL reset, write recovery=6, precharge PD off */
-	writel(0x05208030, 0x4016901C);
-	/* DDR ZQ calibration */
-	writel(0x04008040, 0x4016901C);
-
-	writel(0x0000004F, 0x40169040); //MDASP: 256 MB memory
-
-	/* Configure the power down and self-refresh entry and exit parameters */
-	writel(0x453E4942, 0x40169848); //MPRDDLCTL, 
-	writel(0x30353033, 0x40169850); //MPWRDLCTL0
-	
-	writel(0x41720154, 0x4016983C); //MPDGCTRL0
-	writel(0x016A014F, 0x40169840); //MPDGCTRL1
-	writel(0x000026D2, 0x4016902C); //MDRWD
-
-	writel(0x22334010, 0x40169008); //MDOTC (timing param)
-
-	writel(0x00020024, 0x40169004); //MDPDC
-	writel(0x30B01800, 0x40169020); //MDREF
-	writel(0x0003333F, 0x40169818); //MPODTCTRL
-
-	writel(0x00000000, 0x4016901C); //MDSCR 1
-}
-#endif
-
-
-int dram_init(void)
-{
-#ifdef CONFIG_RUN_FROM_IRAM_ONLY
-	/* When booting from IRAM, we need to enable the MMDC controller */
-	ddr_ctrl_init();
-#endif
-
-	gd->ram_size = ((ulong)CONFIG_DDR_MB * SZ_1M);
-
-	return 0;
-}
-
-static void setup_iomux_uart(void)
-{
-	static const iomux_v3_cfg_t uart_pads[] = {
-		SAC58R_PAD_PH14__UART0_TX,
-		SAC58R_PAD_PH15__UART0_RX,
-		SAC58R_PAD_PF11__UART1_TX,
-		SAC58R_PAD_PF12__UART1_RX,
-		SAC58R_PAD_PL5__UART2_TX,
-		SAC58R_PAD_PL4__UART2_RX,
-		SAC58R_PAD_PE28__UART3_TX,
-		SAC58R_PAD_PE27__UART3_RX,
-		SAC58R_PAD_PH0__UART4_TX,
-		SAC58R_PAD_PH1__UART4_RX,
-		SAC58R_PAD_PH9__UART5_TX,
-		SAC58R_PAD_PH10__UART5_RX,
-	};
-
-	imx_iomux_v3_setup_multiple_pads(uart_pads, ARRAY_SIZE(uart_pads));
-}
-
-static void setup_iomux_enet(void)
-{
-}
-
-#ifdef CONFIG_I2C_MXC
-static void setup_board_i2c(void)
-{
-	setup_i2c(0, CONFIG_SYS_I2C_SPEED, 0x7f, &i2c_pad_info0);
-	setup_i2c(1, CONFIG_SYS_I2C_SPEED, 0x7f, &i2c_pad_info1);
-	setup_i2c(2, CONFIG_SYS_I2C_SPEED, 0x7f, &i2c_pad_info2);
-	setup_i2c(3, CONFIG_SYS_I2C_SPEED, 0x7f, &i2c_pad_info3);
-}
-#endif
-
-void setup_iomux_qspi(void)
-{
-	static const iomux_v3_cfg_t qspi_pads[] = {
-		SAC58R_PAD_PC24__QSPI_A_DATA0,
-		SAC58R_PAD_PC21__QSPI_A_DATA1,
-		SAC58R_PAD_PC25__QSPI_A_DATA2,
-		SAC58R_PAD_PC16__QSPI_A_DATA3,
-		SAC58R_PAD_PC19__QSPI_B_DATA0,
-		SAC58R_PAD_PC15__QSPI_B_DATA1,
-		SAC58R_PAD_PC23__QSPI_B_DATA2,
-		SAC58R_PAD_PC14__QSPI_B_DATA3,
-		SAC58R_PAD_PC17__QSPI_A_CS0,
-		SAC58R_PAD_PC18__QSPI_B_CS0,
-		SAC58R_PAD_PD2__QSPI_A_CS1,
-		SAC58R_PAD_PD9__QSPI_B_CS1,
-		SAC58R_PAD_PC20__QSPI_A_SCK,
-		SAC58R_PAD_PC22__QSPI_B_SCK,
-	};
-	imx_iomux_v3_setup_multiple_pads(qspi_pads, ARRAY_SIZE(qspi_pads));
-}
-
-#ifdef CONFIG_SYS_USE_NAND
-void setup_iomux_nfc(void)
-{
-}
-#endif
-
-#ifdef CONFIG_FSL_ESDHC
-struct fsl_esdhc_cfg esdhc_cfg[CONFIG_SYS_FSL_ESDHC_NUM] = {
-	{USDHC0_BASE_ADDR},
-	{USDHC1_BASE_ADDR},
-	{USDHC2_BASE_ADDR},
-};
-
-int board_mmc_getcd(struct mmc *mmc)
-{
-	/* eSDHC0 is always present */
-	return 1;
-}
-
-int board_mmc_init(bd_t *bis)
-{
-	int i;
-	int ret;
-
-	static const iomux_v3_cfg_t sdhc_pads[] = {
-		SAC58R_PAD_PF0__SDHC0_CLK,
-		SAC58R_PAD_PF1__SDHC0_CMD,
-		SAC58R_PAD_PF2__SDHC0_DAT0,
-		SAC58R_PAD_PF3__SDHC0_DAT1,
-		SAC58R_PAD_PF4__SDHC0_DAT2,
-		SAC58R_PAD_PF5__SDHC0_DAT3,
-		SAC58R_PAD_PF0__SDHC0_CLK,
-		SAC58R_PAD_PF1__SDHC0_CMD,
-		SAC58R_PAD_PF2__SDHC0_DAT0,
-		SAC58R_PAD_PF3__SDHC0_DAT1,
-		SAC58R_PAD_PF4__SDHC0_DAT2,
-		SAC58R_PAD_PF5__SDHC0_DAT3,
-		SAC58R_PAD_PF26__SDHC1_CLK,
-		SAC58R_PAD_PF27__SDHC1_CMD,
-		SAC58R_PAD_PF22__SDHC1_DAT0,
-		SAC58R_PAD_PF23__SDHC1_DAT1,
-		SAC58R_PAD_PF19__SDHC1_DAT2,
-		SAC58R_PAD_PF20__SDHC1_DAT3,
-		SAC58R_PAD_PC12__SDHC2_CLK,
-		SAC58R_PAD_PC13__SDHC2_CMD,
-		SAC58R_PAD_PC9__SDHC2_DAT0,
-		SAC58R_PAD_PC6__SDHC2_DAT1,
-		SAC58R_PAD_PC5__SDHC2_DAT2,
-		SAC58R_PAD_PC2__SDHC2_DAT3,
-		SAC58R_PAD_PC10__SDHC2_DAT4,
-		SAC58R_PAD_PC11__SDHC2_DAT5,
-		SAC58R_PAD_PC7__SDHC2_DAT6,
-		SAC58R_PAD_PC8__SDHC2_DAT7,
-	};
-
-	imx_iomux_v3_setup_multiple_pads(
-		sdhc_pads, ARRAY_SIZE(sdhc_pads));
-
-	/* Enable SDHCs modules in GPC */
-	enable_periph_clk(AIPS2,AIPS2_OFF_SDHC0);
-	enable_periph_clk(AIPS2,AIPS2_OFF_SDHC1);
-	enable_periph_clk(AIPS2,AIPS2_OFF_SDHC2);
-
-	for (i = 0; i < CONFIG_SYS_FSL_ESDHC_NUM; i++) {
-		esdhc_cfg[i].sdhc_clk = mxc_get_clock(MXC_USDHC0_CLK + i);
-		ret = fsl_esdhc_initialize(bis, &esdhc_cfg[i]);
-		if (ret < 0) {
-			printf("Warning: failed to initialize mmc dev %d\n", i);
-		}
-	}
-
-	return 0;
-}
-#endif
-
-static void setup_iomux_gpio(void)
-{
-	static const iomux_v3_cfg_t gpio_pads[] = {
-
-		SAC58R_PAD_PF17_GPIO_177, /* USB OTG VBUS ENABLE */
-		SAC58R_PAD_PF16_USB0_ID, /* USB OTG ID muxing*/
-		SAC58R_PAD_PH21_GPIO_245, /* USB HOST VBUS Enable*/
-	};
-
-	imx_iomux_v3_setup_multiple_pads(
-		gpio_pads, ARRAY_SIZE(gpio_pads));
-}
-
-void setup_iomux_audio(void)
-{
-	static const iomux_v3_cfg_t audio_pads[] = {
-		/*SPDIF0 */
-		SAC58R_PAD_PG4__SPDIF0_IN1,
-		SAC58R_PAD_PG5__SPDIF0_OUT1,
-
-		/*SPDIF1 */
-		SAC58R_PAD_PG1__SPDIF1_IN1,
-		SAC58R_PAD_PG2__SPDIF1_OUT1,
-	};
-
-	imx_iomux_v3_setup_multiple_pads(
-		audio_pads, ARRAY_SIZE(audio_pads));
-}
-
-
-static void audiocodec_clock_init(void)
-{
-	struct ccm_reg *ccm = (struct ccm_reg *)CCM_BASE_ADDR;
-
-	/* Audio codec subsystem will use AUDIO1_PLL_DIV input
-		as defined below:
-		PLL8_FREQ = 1179 MHz
-		CCM_AUDIO1_CLK_CTL = PLL8/2
-		TDM_SRC0 input = AUDIO1_PLL_DIV/2/24 = 24.576 MHz
-		TDM_SRC1 input = AUDIO1_PLL_DIV/2/24 = 24.576 MHz
-		CODEC MCLK = FSOXC
-	*/
-
-	/* CCM_AUDIO1_CLK_CTL = AUDIO1_PLL/2 = 1179/2 MHz */
-	writel(CCM_MODULE_ENABLE_CTL_EN |(0x1 << CCM_MUX_CTL_OFFSET),
-			&ccm->AUDIO1_pll_div_clk);
-
-	/* CODEC_MCLK INPUT SEL = FSOXC */
-	writel( (0x1 << CCM_MUX_CTL_OFFSET), &ccm->codec_mclk);
-
-	/* SAI0 MCLK selection = AUDIO1_PLL_DIV */
-	writel(0x4 << CCM_MUX_CTL_OFFSET, &ccm->sai0_mclk);
-
-	/* SAI1 MCLK selection = AUDIO1_PLL_DIV */
-	writel(0x4 << CCM_MUX_CTL_OFFSET, &ccm->sai1_mclk);
-
-	/* CODEC SAI_BCLK0 input clock sel = AUDIO1_PLL_DIV/2
-		SAI BCLK0 clock frequency = 589/(23+1) = 24,576MHz */
-	writel(CCM_MODULE_ENABLE_CTL_EN | (23 << CCM_PREDIV_CTRL_OFFSET)
-		| (0x5 << CCM_MUX_CTL_OFFSET), &ccm->codec_sai_bclk0);
-
-	/* CODEC SAI_BCLK1 input clock sel = AUDIO1_PLL_DIV/2
-		SAI BCLK1 clock frequency = 589/(23+1) = 24,576MHz */
-	writel(CCM_MODULE_ENABLE_CTL_EN | (23 << CCM_PREDIV_CTRL_OFFSET)
-		| (0x5 << CCM_MUX_CTL_OFFSET), &ccm->codec_sai_bclk1);
-
-	/* TDM_SRC0 input clock sel = AUDIO1_PLL_DIV/2
-		TDM SRC0 clock frequency = 589/(23+1) = 24,576MHz */
-	writel(CCM_MODULE_ENABLE_CTL_EN | (23 << CCM_PREDIV_CTRL_OFFSET)
-		| (0x5 << CCM_MUX_CTL_OFFSET), &ccm->codec_dac_tdm_src0);
-
-	/* TDM_SRC1 input clock sel = AUDIO1_PLL_DIV/2
-		TDM SRC1 clock frequency = 589/(23+1) = 24,576MHz */
-	writel(CCM_MODULE_ENABLE_CTL_EN | (23 << CCM_PREDIV_CTRL_OFFSET)
-			| (0x5 << CCM_MUX_CTL_OFFSET), &ccm->codec_dac_tdm_src1);
-
-	/* Enable AUDIO1 PLL */
-	enable_pll(PLL_AUDIO1);
-
-	/* Enable Audio Codec IPG clock divider */
-	writel( CCM_MODULE_ENABLE_CTL_EN | (0x3 << CCM_PREDIV_CTRL_OFFSET),
-			&ccm->audio_codec_ipg_clk);
-}
-
-static void spdif_clock_init(void)
-{
-	struct ccm_reg *ccm = (struct ccm_reg *)CCM_BASE_ADDR;
-
-	/* SPDIFs will use AUDIO0_PLL_DIV input
-		as defined below:
-		PLL8_FREQ = 1179 MHz
-		CCM_AUDIO0_CLK_CTL = PLL4/48
-
-		AUDIO0_PLL_DIV = 24,576 MHz
-	*/
-
-	/* CCM_AUDIO0_CLK_CTL = AUDIO0_PLL/48 = 1179/48 MHz */
-	writel(CCM_MODULE_ENABLE_CTL_EN | (23 << CCM_PREDIV_CTRL_OFFSET) |
-		   (0x1 << CCM_MUX_CTL_OFFSET),
-			&ccm->AUDIO0_pll_div_clk);
-
-
-	/* SPDIF0 input clock selection = AUDIO0_PLL_DIV */
-	writel(0x3 << CCM_MUX_CTL_OFFSET, &ccm->spdif_tx_clk);
-
-	/* SPDIF1 input clock selection = AUDIO0_PLL_DIV */
-	writel(0x3 << CCM_MUX_CTL_OFFSET, &ccm->spdif1_tx_clk);
-
-	/* Enable AUDIO0 PLL */
-	enable_pll(PLL_AUDIO0);
-}
-
-static void clock_init(void)
-{
-	struct ccm_reg *ccm = (struct ccm_reg *)CCM_BASE_ADDR;
-	struct anadig_reg *anadig = (struct anadig_reg *)ANADIG_BASE_ADDR;
-
-	/* Enable some modules in GPC */
-	enable_periph_clk(AIPS0, AIPS0_OFF_GPC);
-	enable_periph_clk(AIPS0, AIPS0_OFF_SRC);
-	enable_periph_clk(AIPS0, AIPS0_OFF_CCM);
-	enable_periph_clk(AIPS0, AIPS0_OFF_SCSC);
-	enable_periph_clk(AIPS0, AIPS0_OFF_CMU);
-	enable_periph_clk(AIPS0, AIPS0_OFF_ANADIG);
-	enable_periph_clk(AIPS0, AIPS0_OFF_IOMUXC);
-	enable_periph_clk(AIPS0, AIPS0_OFF_WKUP);
-	enable_periph_clk(AIPS0, AIPS0_OFF_PIT);
-	enable_periph_clk(AIPS2, AIPS2_OFF_SDHC0);
-	enable_periph_clk(AIPS1, AIPS1_OFF_UART0);
-	enable_periph_clk(AIPS0, AIPS0_OFF_PORTA);
-	enable_periph_clk(AIPS0, AIPS0_OFF_PORTB);
-	enable_periph_clk(AIPS0, AIPS0_OFF_PORTC);
-	enable_periph_clk(AIPS0, AIPS0_OFF_PORTD);
-	enable_periph_clk(AIPS0, AIPS0_OFF_PORTE);
-	enable_periph_clk(AIPS0, AIPS0_OFF_PORTF);
-	enable_periph_clk(AIPS0, AIPS0_OFF_PORTG);
-	enable_periph_clk(AIPS0, AIPS0_OFF_PORTH);
-	enable_periph_clk(AIPS0, AIPS0_OFF_PORTJ);
-	enable_periph_clk(AIPS0, AIPS0_OFF_PORTK);
-	enable_periph_clk(AIPS0, AIPS0_OFF_PORTL);
-	enable_periph_clk(AIPS0, AIPS0_OFF_GPIOC);
-	enable_periph_clk(AIPS2, AIPS2_OFF_ENET);
-	enable_periph_clk(AIPS2, AIPS2_OFF_MMDC);
-	enable_periph_clk(AIPS2, AIPS2_OFF_QSPI);
-
-#ifdef CONFIG_I2C_MXC
-	enable_periph_clk(AIPS1, AIPS1_OFF_I2C0);
-#endif
-
-	/* Set PLL ARM = 1200 MHz and enable it */
-	config_pll(PLL_ARM, 50, 0, 1);
-	enable_pll(PLL_ARM);
-
-	/* configure ARM A7 clock => From PLL1 (PLL_CORE) = 1200/2 = 600MHz */
-	writel( (0x1 << CCM_PREDIV_CTRL_OFFSET) | (0x3 << CCM_MUX_CTL_OFFSET), &ccm->a7_clk);
-
-	/* SDHC0,1,2 clocks => from PLL_SYS/5 = 480/5 = 96 MHz */
-	writel(CCM_MODULE_ENABLE_CTL_EN | (0x4<< CCM_PREDIV_CTRL_OFFSET)
-		| (0x3 << CCM_MUX_CTL_OFFSET), &ccm->uSDHC0_perclk);
-	writel(CCM_MODULE_ENABLE_CTL_EN | (0x4<< CCM_PREDIV_CTRL_OFFSET)
-		| (0x3 << CCM_MUX_CTL_OFFSET), &ccm->uSDHC1_perclk);
-	writel(CCM_MODULE_ENABLE_CTL_EN | (0x4<< CCM_PREDIV_CTRL_OFFSET)
-		| (0x3 << CCM_MUX_CTL_OFFSET), &ccm->uSDHC2_perclk);
-
-	/* Refine AUDIO0 and AUDIO1 PLLs MFN and MFD parameters:
-		By default, they are way too big, kernel is unable to compute
-		the right values of the PLLs and end up with a erroneous
-		1176MHz instead of the correct 1179MHz value.
-		(see arch/arm/mach-imx/clk-pllv3.c, clk_pllv3_av_recalc_rate()).
-		These values make it easy for the kernel to compute the right
-		value of these PLLs (1179648000 Hz)
-		This value divided by 48 allows providing a 24,576MHz
-		input clock to the different audio IPs */
-
-	/* Setting PLL4_MAIN and PLL8_MAIN to 1179MHz:
-			- (24 MHz * 49) + ((24 MHz/1000)*152)
-		=> DIV_SELECT = 49
-		=> PLLx_NUM   =  152
-		=> PLLx_DENOM = 1000
-	*/
-
-	config_pll(PLL_AUDIO0, 49, 152, 1000);
-	config_pll(PLL_AUDIO1, 49, 152, 1000);
-
-
-	/* QSPI_4x clock => from SYS_PLL_PFD1/2 = 500/2 = 250 MHz */
-	writel(CCM_MODULE_ENABLE_CTL_EN | (0x1<< CCM_PREDIV_CTRL_OFFSET)
-		| (0x0 << CCM_MUX_CTL_OFFSET), &ccm->qspi_4x_clk);
-}
-
-static void mscm_init(void)
-{
-	struct mscm_ir *mscmir = (struct mscm_ir *)MSCM_IR_BASE_ADDR;
-	int i;
-
-	/* Interrupt Routing Configuration */
-	for (i = 0; i < MSCM_IRSPRC_NUM; i++)
-		writew(int_routing_conf[i], &mscmir->irsprc[i]);
-}
-
-static void dmamux_init(void)
-{
-	/* Example DMA CHANNEL MUXING FOR SAC58R. This function is not called */
-	static const dmamux_cfg_t dma_channels [] = {
-		DMAMUX_CHANNEL(DMAMUX_0, 0, SAC58R_DMAREQSRC_UART0_RX, 0, 1), /* DMAMUX 0, Channel 0 => UART0_RX, no trigger, channel enable */
-		DMAMUX_CHANNEL(DMAMUX_1, 8, SAC58R_DMAREQSRC_PORTA, 0, 1), /* DMAMUX 1, Channel 8 => PORT_A, no trigger, channel enable */
-		DMAMUX_CHANNEL(DMAMUX_2, 4, SAC58R_DMAREQSRC_SAI6_TX, 0, 1), /* DMAMUX 2, Channel 4  => SAI6_TX, no trigger, channel enable */
-		DMAMUX_CHANNEL(DMAMUX_3, 12, SAC58R_DMAREQSRC_QSPIO_RX, 0, 1), /* DMAMUX 3, Channel 12 => QSPI0_TX, no trigger, channel enable */
-	};
-	imx_dmamux_setup_multiple_channels(dma_channels, ARRAY_SIZE(dma_channels));
-}
-
-int board_eth_init(bd_t *bis)
-{
-	setup_iomux_enet();
-
-	return 0;
-}
-
-int board_phy_config(struct phy_device *phydev)
-{
-	if (phydev->drv->config)
-		phydev->drv->config(phydev);
-
-	return 0;
-}
-
-int board_early_init_f(void)
-{
-	clock_init();
-	mscm_init();
-
-	setup_iomux_gpio();
-
-	setup_iomux_uart();
-
-	setup_iomux_qspi();
-
-#ifdef CONFIG_SYS_USE_NAND
-	setup_iomux_nfc();
-#endif
-
-	setup_iomux_audio();
-
-	return 0;
-}
-
-int board_init(void)
-{
-	/* address of boot parameters */
-	gd->bd->bi_boot_params = PHYS_SDRAM + 0x100;
-
-#ifdef CONFIG_I2C_MXC
-	setup_board_i2c();
-#endif
-
-	audiocodec_clock_init();
-	spdif_clock_init();
-
-	return 0;
-}
-
-int checkboard(void)
-{
-	puts("Board: SAC58R Functional Validation Board\n");
-
-	return 0;
-}
diff --git a/board/freescale/sac58rfvb/sac58rfvb_int_routing.h b/board/freescale/sac58rfvb/sac58rfvb_int_routing.h
deleted file mode 100644
index bdb5ae9708..0000000000
--- a/board/freescale/sac58rfvb/sac58rfvb_int_routing.h
+++ /dev/null
@@ -1,121 +0,0 @@
-/*
- * (C) Copyright 2014 Freescale Semiconductor, Inc.
- *
- * SPDX-License-Identifier:	GPL-2.0+
- */
-
-static const u8 int_routing_conf[] = {
-	MSCM_IRSPRC_ROUTE_TO_CA7,	/* DMA0 Transfer Complete CH0-31 */
-	MSCM_IRSPRC_ROUTE_TO_CA7,	/* DMA0 Error Interrupt CH0-31 */
-	MSCM_IRSPRC_ROUTE_TO_CA7,	/* DMA1 Transfer Complete CH0-31 */
-	MSCM_IRSPRC_ROUTE_TO_CA7,	/* DMA1 Transfer Complete CH0-31 */
-	MSCM_IRSPRC_ROUTE_TO_CA7,	/* SWT 0 */
-	MSCM_IRSPRC_ROUTE_TO_CA7,	/* SWT 1 */
-	MSCM_IRSPRC_ROUTE_TO_CA7,	/* SWT 2 */
-	MSCM_IRSPRC_ROUTE_TO_CA7,	/* MSCM-ECC0 */
-	MSCM_IRSPRC_ROUTE_TO_CA7,	/* MSCM-ECC1 */
-	MSCM_IRSPRC_ROUTE_TO_CA7,	/* xRDC */
-	MSCM_IRSPRC_ROUTE_TO_CA7,	/* MSCM-ACTZS */
-	MSCM_IRSPRC_ROUTE_TO_CA7,	/* STM 0 */
-	MSCM_IRSPRC_ROUTE_TO_CA7,
-	MSCM_IRSPRC_ROUTE_TO_CA7,	/* WDOG-SNVS */
-	MSCM_IRSPRC_ROUTE_TO_CA7,	/* SNVS - Non TZ*/
-	MSCM_IRSPRC_ROUTE_TO_CA7,	/* SNVS - TZ */
-	MSCM_IRSPRC_ROUTE_TO_CA7,	/* QuadSPI0 */
-	MSCM_IRSPRC_ROUTE_TO_CA7,	/* MMDC */
-	MSCM_IRSPRC_ROUTE_TO_CA7,	/* NFC */
-	MSCM_IRSPRC_ROUTE_TO_CA7,	/* USDHC0 */
-	MSCM_IRSPRC_ROUTE_TO_CA7,	/* USDHC1 */
-	MSCM_IRSPRC_ROUTE_TO_CA7,	/* USDHC 2 */
-	MSCM_IRSPRC_ROUTE_TO_CA7,	/* MIPI-CSI2 */
-	MSCM_IRSPRC_ROUTE_TO_CA7,	/* DCU0 */
-	MSCM_IRSPRC_ROUTE_TO_CA7,	/* VIU */
-	MSCM_IRSPRC_ROUTE_TO_CA7,	/* VPU */
-	MSCM_IRSPRC_ROUTE_TO_CA7,	/* GC400T */
-	MSCM_IRSPRC_ROUTE_TO_CA7,	/* RLE */
-	MSCM_IRSPRC_ROUTE_TO_CA7,	/* USBC 0*/
-	MSCM_IRSPRC_ROUTE_TO_CA7,	/* USBC 1 */
-	MSCM_IRSPRC_ROUTE_TO_CA7,	/* USBC 2 */
-	MSCM_IRSPRC_ROUTE_TO_CA7,	/* PIT */
-	MSCM_IRSPRC_ROUTE_TO_CA7,	/* LPTimer */
-	MSCM_IRSPRC_ROUTE_TO_CA7,	/* SPDIF1 */
-	MSCM_IRSPRC_ROUTE_TO_CA7,	/*FlexTimer  */
-	MSCM_IRSPRC_ROUTE_TO_CA7,	/* ENET 0 */
-	MSCM_IRSPRC_ROUTE_TO_CA7,	/* 1588 Timer 0 */
-	MSCM_IRSPRC_ROUTE_TO_CA7,	/* VSPA */
-	MSCM_IRSPRC_ROUTE_TO_CA7,	/* FECA */
-	MSCM_IRSPRC_ROUTE_TO_CA7,	/* AXIQ */
-	MSCM_IRSPRC_ROUTE_TO_CA7,	/* JESD204B 0/1 */
-	MSCM_IRSPRC_ROUTE_TO_CA7,	/* JESD204B 2/3 */
-	MSCM_IRSPRC_ROUTE_TO_CA7,	/* ANADIG - USB PHY 0 */
-	MSCM_IRSPRC_ROUTE_TO_CA7,	/* ANADIG - USB PHY 1 */
-	MSCM_IRSPRC_ROUTE_TO_CA7,	/* ENET 0 errors */
-	MSCM_IRSPRC_ROUTE_TO_CA7,	/* ADC 0 */
-	MSCM_IRSPRC_ROUTE_TO_CA7,	/* AUD_ADC_DAC */
-	MSCM_IRSPRC_ROUTE_TO_CA7,	/* ENET Queue 0 */
-	MSCM_IRSPRC_ROUTE_TO_CA7,	/* ENET Queues  */
-	MSCM_IRSPRC_ROUTE_TO_CA7,	/* FlexCAN 0 */
-	MSCM_IRSPRC_ROUTE_TO_CA7,	/* FlexCAN 1 */
-	MSCM_IRSPRC_ROUTE_TO_CA7,	/* FlexCAN 2 */
-	MSCM_IRSPRC_ROUTE_TO_CA7,	/* MLB */
-	MSCM_IRSPRC_ROUTE_TO_CA7,	/* UART 0 */
-	MSCM_IRSPRC_ROUTE_TO_CA7,	/* UART 1 */
-	MSCM_IRSPRC_ROUTE_TO_CA7,	/* UART 2 */
-	MSCM_IRSPRC_ROUTE_TO_CA7,	/* UART 3 */
-	MSCM_IRSPRC_ROUTE_TO_CA7,	/* UART 4 */
-	MSCM_IRSPRC_ROUTE_TO_CA7,	/* UART 5 */
-	MSCM_IRSPRC_ROUTE_TO_CA7,	/* SPI 0 */
-	MSCM_IRSPRC_ROUTE_TO_CA7,	/* SPI 1 */
-	MSCM_IRSPRC_ROUTE_TO_CA7,	/* VSPA-GPO11[24] */
-	MSCM_IRSPRC_ROUTE_TO_CA7,	/* VSPA-GPO11[25] */
-	MSCM_IRSPRC_ROUTE_TO_CA7,	/* I2C 0 */
-	MSCM_IRSPRC_ROUTE_TO_CA7,	/* I2C 1 */
-	MSCM_IRSPRC_ROUTE_TO_CA7,	/* I2C 2 */
-	MSCM_IRSPRC_ROUTE_TO_CA7,	/* I2C 3 */
-	MSCM_IRSPRC_ROUTE_TO_CA7,	/* SAI 0 */
-	MSCM_IRSPRC_ROUTE_TO_CA7,	/* SAI 1 */
-	MSCM_IRSPRC_ROUTE_TO_CA7,	/* SAI 2 */
-	MSCM_IRSPRC_ROUTE_TO_CA7,	/* SAI 3 */
-	MSCM_IRSPRC_ROUTE_TO_CA7,	/* SAI 4 */
-	MSCM_IRSPRC_ROUTE_TO_CA7,	/* SAI 5 */
-	MSCM_IRSPRC_ROUTE_TO_CA7,	/* SAI 6 */
-	MSCM_IRSPRC_ROUTE_TO_CA7,	/* SAI 7 */
-	MSCM_IRSPRC_ROUTE_TO_CA7,	/* SAI 8 */
-	MSCM_IRSPRC_ROUTE_TO_CA7,	/* SAI 9 */
-	MSCM_IRSPRC_ROUTE_TO_CA7,	/* SAI 10 */
-	MSCM_IRSPRC_ROUTE_TO_CA7,	/* SAI 11 */
-	MSCM_IRSPRC_ROUTE_TO_CA7,	/* ESAI0 BIFIFO */
-	MSCM_IRSPRC_ROUTE_TO_CA7,	/* ESAI1 BIFIFO */
-	MSCM_IRSPRC_ROUTE_TO_CA7,	/* SPDIF0 */
-	MSCM_IRSPRC_ROUTE_TO_CA7,	/* ASRC0 */
-	MSCM_IRSPRC_ROUTE_TO_CA7,	/* ASRC1 */
-	MSCM_IRSPRC_ROUTE_TO_CA7,	/* SRC */
-	MSCM_IRSPRC_ROUTE_TO_CA7,	/* WKUP 0 */
-	MSCM_IRSPRC_ROUTE_TO_CA7,	/* GPC */
-	MSCM_IRSPRC_ROUTE_TO_CA7,	/* Temp Sensor */
-	MSCM_IRSPRC_ROUTE_TO_CA7,
-	MSCM_IRSPRC_ROUTE_TO_CA7,	/* PDB */
-	MSCM_IRSPRC_ROUTE_TO_CA7,	/* CMU */
-	MSCM_IRSPRC_ROUTE_TO_CA7,	/* CAAM */
-	MSCM_IRSPRC_ROUTE_TO_CA7,	/* GPIO 0 */
-	MSCM_IRSPRC_ROUTE_TO_CA7,	/* GPIO 1 */
-	MSCM_IRSPRC_ROUTE_TO_CA7,	/* GPIO 2 */
-	MSCM_IRSPRC_ROUTE_TO_CA7,	/* GPIO 3 */
-	MSCM_IRSPRC_ROUTE_TO_CA7,	/* GPIO 4 */
-	MSCM_IRSPRC_ROUTE_TO_CA7,	/* GPIO 5 */
-	MSCM_IRSPRC_ROUTE_TO_CA7,	/* GPIO 6 */
-	MSCM_IRSPRC_ROUTE_TO_CA7,	/* GPIO 7 */
-	MSCM_IRSPRC_ROUTE_TO_CA7,	/* GPIO 8 */
-	MSCM_IRSPRC_ROUTE_TO_CA7,	/* GPIO 9 */
-	MSCM_IRSPRC_ROUTE_TO_CA7,	/* GPIO 10 */
-	MSCM_IRSPRC_ROUTE_TO_CA7,
-	MSCM_IRSPRC_ROUTE_TO_CA7,	/* JESD204B_0 */
-	MSCM_IRSPRC_ROUTE_TO_CA7,	/* JESD204B_1 */
-	MSCM_IRSPRC_ROUTE_TO_CA7,	/* JESD204B_2 */
-	MSCM_IRSPRC_ROUTE_TO_CA7,	/* JESD204B_3 */
-	MSCM_IRSPRC_ROUTE_TO_CA7,	/* ENET Queue 1 */
-	MSCM_IRSPRC_ROUTE_TO_CA7,	/* ENET Queue 2 */
-	MSCM_IRSPRC_ROUTE_TO_CA7,
-	MSCM_IRSPRC_ROUTE_TO_CA7,
-};
-
diff --git a/configs/sac58revb_defconfig b/configs/sac58revb_defconfig
deleted file mode 100644
index 915f519141..0000000000
--- a/configs/sac58revb_defconfig
+++ /dev/null
@@ -1,3 +0,0 @@
-CONFIG_SYS_EXTRA_OPTIONS="IMX_CONFIG=board/freescale/sac58r/sac58r.cfg,DDR_MB=128"
-CONFIG_ARM=y
-CONFIG_TARGET_SAC58R=y
diff --git a/configs/sac58rfvb_defconfig b/configs/sac58rfvb_defconfig
deleted file mode 100644
index ea80b3c11a..0000000000
--- a/configs/sac58rfvb_defconfig
+++ /dev/null
@@ -1,3 +0,0 @@
-CONFIG_SYS_EXTRA_OPTIONS="IMX_CONFIG=board/freescale/sac58rfvb/sac58r_mt41j64.cfg,DDR_MB=1024"
-CONFIG_ARM=y
-CONFIG_TARGET_SAC58RFVB=y
diff --git a/drivers/gpio/Makefile b/drivers/gpio/Makefile
index ce8b0e3406..043a7dcb67 100644
--- a/drivers/gpio/Makefile
+++ b/drivers/gpio/Makefile
@@ -25,7 +25,6 @@ obj-$(CONFIG_MARVELL_GPIO)	+= mvgpio.o
 obj-$(CONFIG_MARVELL_MFP)	+= mvmfp.o
 obj-$(CONFIG_MXC_GPIO)	+= mxc_gpio.o
 obj-$(CONFIG_MXS_GPIO)	+= mxs_gpio.o
-obj-$(CONFIG_MVF_GPIO)	+= mvf_gpio.o
 obj-$(CONFIG_PCA953X)		+= pca953x.o
 obj-$(CONFIG_PCA9698)		+= pca9698.o
 obj-$(CONFIG_ROCKCHIP_GPIO)	+= rk_gpio.o
diff --git a/drivers/gpio/mvf_gpio.c b/drivers/gpio/mvf_gpio.c
deleted file mode 100644
index 8531d64705..0000000000
--- a/drivers/gpio/mvf_gpio.c
+++ /dev/null
@@ -1,161 +0,0 @@
-/*
- * Freescale VF610/SAC58R GPIO control code
- *
- * Copyright 2014 Freescale Semiconductor, Inc.
- * Gilles Talis, Freescale Semiconductors, Inc <gilles.talis@freescale.com>
- *
- * See file CREDITS for list of people who contributed to this
- * project.
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License as
- * published by the Free Software Foundation; either version 2 of
- * the License, or (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
- * MA 02111-1307 USA
- */
-#include <common.h>
-#include <asm/arch/imx-regs.h>
-#include <asm/gpio.h>
-#include <asm/io.h>
-#include <errno.h>
-
-enum mvf_gpio_direction {
-	MVF_GPIO_DIRECTION_IN,
-	MVF_GPIO_DIRECTION_OUT,
-};
-
-#define GPIO_TO_PORT(n)		(n / 32)
-
-#define GPIO_BANK_OFFSET			0x40
-
-#define PORT_PCR					0x00
-#define	PORT_PCR_IRQC_BOTH_EDGES	(11<<16)
-#define	PORT_PCR_IRQC_DISABLED		0
-
-#define GPIO_PDOR					0x00
-#define GPIO_PSOR					0x04
-#define GPIO_PCOR					0x08
-#define GPIO_PDIR					0x10
-
-
-static unsigned long gpio_ports[] = {
-	[0] = PORTA_BASE_ADDR,
-	[1] = PORTB_BASE_ADDR,
-	[2] = PORTC_BASE_ADDR,
-	[3] = PORTD_BASE_ADDR,
-	[4] = PORTE_BASE_ADDR,
-	[5] = PORTF_BASE_ADDR,
-	[6] = PORTG_BASE_ADDR,
-	[7] = PORTH_BASE_ADDR,
-	[8] = 0,
-	[9] = PORTJ_BASE_ADDR,
-	[10] = PORTK_BASE_ADDR,
-	[11] = PORTL_BASE_ADDR,
-};
-
-static int mvf_gpio_direction(unsigned int gpio,
-	enum mvf_gpio_direction direction)
-{
-	unsigned int port = GPIO_TO_PORT(gpio);
-
-	if (port >= ARRAY_SIZE(gpio_ports))
-		return -1;
-	
-	gpio &= 0x1f;
-
-	if (direction == MVF_GPIO_DIRECTION_IN) {		
-		writel( PORT_PCR_IRQC_BOTH_EDGES,
-			gpio_ports[port] + (gpio * 4));
-	}
-	else {		
-		writel( PORT_PCR_IRQC_DISABLED,
-			gpio_ports[port] + (gpio * 4));
-	}
-	
-	return 0;
-}
-
-int gpio_set_value(unsigned gpio, int value)
-{
-	unsigned int port = GPIO_TO_PORT(gpio);
-	unsigned int bank;
-
-	if (port >= ARRAY_SIZE(gpio_ports))
-		return -1;
-
-	bank = GPIO_BASE_ADDR + (port * GPIO_BANK_OFFSET);
-
-	gpio &= 0x1f;
-
-	if (value)
-		writel( 1<<gpio, bank + GPIO_PSOR);
-	else
-		writel( 1<<gpio, bank + GPIO_PCOR);
-
-	return 0;
-}
-
-int gpio_get_value(unsigned gpio)
-{
-	unsigned int port = GPIO_TO_PORT(gpio);
-	unsigned int bank;
-	
-	u32 val;
-
-	if (port >= ARRAY_SIZE(gpio_ports))
-		return -1;
-
-	bank = GPIO_BASE_ADDR + (port * GPIO_BANK_OFFSET);
-
-	gpio &= 0x1f;
-
-	val = readl(gpio_ports[port] + (gpio * 4));
-
-	if (val & PORT_PCR_IRQC_BOTH_EDGES) {
-		/* GPIO configured as input */
-		val =(readl(bank + GPIO_PDIR) >> gpio) & 0x01;
-	}
-	else {
-		/* GPIO configured as output */
-		val =(readl(bank + GPIO_PDOR) >> gpio) & 0x01;		
-	}
-	
-	return val;
-}
-
-int gpio_request(unsigned gpio, const char *label)
-{
-	unsigned int port = GPIO_TO_PORT(gpio);
-	if (port >= ARRAY_SIZE(gpio_ports))
-		return -1;
-	return 0;
-}
-
-int gpio_free(unsigned gpio)
-{
-	return 0;
-}
-
-int gpio_direction_input(unsigned gpio)
-{
-	return mvf_gpio_direction(gpio, MVF_GPIO_DIRECTION_IN);
-}
-
-int gpio_direction_output(unsigned gpio, int value)
-{
-	int ret = mvf_gpio_direction(gpio, MVF_GPIO_DIRECTION_OUT);
-
-	if (ret < 0)
-		return ret;
-
-	return gpio_set_value(gpio, value);
-}
diff --git a/drivers/i2c/mxc_i2c.c b/drivers/i2c/mxc_i2c.c
index 860efc89fa..4f67d66233 100644
--- a/drivers/i2c/mxc_i2c.c
+++ b/drivers/i2c/mxc_i2c.c
@@ -699,7 +699,7 @@ static int bus_i2c_write(struct mxc_i2c_bus *i2c_bus, u8 chip, u32 addr,
 static struct mxc_i2c_bus mxc_i2c_buses[] = {
 #if defined(CONFIG_LS1021A) || defined(CONFIG_VF610) || \
 	defined(CONFIG_FSL_LAYERSCAPE) || \
-	defined(CONFIG_SAC58R) || defined(CONFIG_MAC57D5XH) || \
+	defined(CONFIG_MAC57D5XH) || \
 	defined(CONFIG_S32_GEN1)
 	{ 0, I2C1_BASE_ADDR, I2C_QUIRK_FLAG },
 	{ 1, I2C2_BASE_ADDR, I2C_QUIRK_FLAG },
diff --git a/drivers/mmc/fsl_esdhc_imx.c b/drivers/mmc/fsl_esdhc_imx.c
index ac68ac87f7..f1ce633b09 100644
--- a/drivers/mmc/fsl_esdhc_imx.c
+++ b/drivers/mmc/fsl_esdhc_imx.c
@@ -575,13 +575,6 @@ static int esdhc_send_cmd_common(struct fsl_esdhc_priv *priv, struct mmc *mmc,
 
 		do {
 			irqstat = esdhc_read32(&regs->irqstat);
-#ifdef CONFIG_SAC58R
-			/* HACK: For some reason, we need a delay here in
-			 * sac58r, otherwise, we get stuck in this loop.
-			 * To be further investigated and REMOVED
-			 */
-			udelay(100);
-#endif
 
 			if (irqstat & IRQSTAT_DTOE) {
 				err = -ETIMEDOUT;
diff --git a/include/configs/sac58r.h b/include/configs/sac58r.h
deleted file mode 100644
index 9f63d10fc9..0000000000
--- a/include/configs/sac58r.h
+++ /dev/null
@@ -1,250 +0,0 @@
-/*
- * (C) Copyright 2013 Freescale Semiconductor, Inc.
- *
- * SPDX-License-Identifier:	GPL-2.0+
- */
-
-#ifndef __CONFIG_H
-#define __CONFIG_H
-
-#include <asm/arch/imx-regs.h>
-#include <config_cmd_default.h>
-
-#define CONFIG_SAC58R
-#define CONFIG_PALLADIUM
-
-#define CONFIG_DISPLAY_CPUINFO
-#define CONFIG_DISPLAY_BOARDINFO
-
-#define CONFIG_MACH_TYPE		4146 /* MATT: to change later */
-
-#define CONFIG_SKIP_LOWLEVEL_INIT
-
-/* Enable passing of ATAGs */
-#define CONFIG_CMDLINE_TAG
-
-#define CONFIG_CMD_FUSE
-#ifdef CONFIG_CMD_FUSE
-#define CONFIG_MXC_OCOTP
-#endif
-
-/* Size of malloc() pool */
-#define CONFIG_SYS_MALLOC_LEN		(CONFIG_ENV_SIZE + 2 * 1024 * 1024)
-
-#define CONFIG_BOARD_EARLY_INIT_F
-
-#define CONFIG_FSL_LPUART
-#define LPUART_BASE			UART1_BASE_ADDR /* MATT: to check wich UART to use */
-
-/* Allow to overwrite serial and ethaddr */
-#define CONFIG_ENV_OVERWRITE
-#define CONFIG_SYS_UART_PORT		(1)
-#define CONFIG_BAUDRATE			115200
-
-#undef CONFIG_CMD_IMLS
-
-#define CONFIG_MMC
-#define CONFIG_FSL_ESDHC
-#define CONFIG_FSL_USDHC
-#define CONFIG_SYS_FSL_ESDHC_ADDR	0
-#define CONFIG_SYS_FSL_ESDHC_NUM	1
-
-#define CONFIG_SYS_FSL_ERRATUM_ESDHC111
-
-#define CONFIG_CMD_MMC
-#define CONFIG_GENERIC_MMC
-#define CONFIG_CMD_EXT2		/* EXT2 Support			*/
-#define CONFIG_CMD_FAT		/* FAT support			*/
-#define CONFIG_DOS_PARTITION
-
-#if 0 /* MATT: enable Ethernet in a second step */
-/* Ethernet config */
-#define CONFIG_CMD_PING
-#define CONFIG_CMD_DHCP
-#define CONFIG_CMD_MII
-#define CONFIG_CMD_NET
-#define CONFIG_FEC_MXC
-#define CONFIG_MII
-#define IMX_FEC_BASE			ENET_BASE_ADDR
-#define CONFIG_FEC_XCV_TYPE		RMII
-#define CONFIG_FEC_MXC_PHYADDR          0
-#define CONFIG_PHYLIB
-#define CONFIG_PHY_MICREL
-#endif
-
-#if 0 /* MATT: enable I2C in a second step */
-/* I2C Configs */
-#define CONFIG_CMD_I2C
-#define CONFIG_HARD_I2C
-#define CONFIG_SYS_I2C
-#define CONFIG_SYS_I2C_MXC
-#define CONFIG_SYS_I2C_BASE		I2C0_BASE_ADDR
-#define CONFIG_SYS_I2C_SPEED		100000
-#endif
-
-#if 0 /* MATT: enable NAND in a second step */
-#define CONFIG_SYS_USE_NAND */
-
-#ifdef CONFIG_SYS_USE_NAND
-/* Nand Flash Configs */
-#define	CONFIG_CMD_NAND
-#define CONFIG_JFFS2_NAND
-#define MTD_NAND_FSL_NFC_SWECC 1
-#define CONFIG_NAND_FSL_NFC
-#define CONFIG_SYS_NAND_BASE		0x400E0000
-#define CONFIG_SYS_MAX_NAND_DEVICE	1
-#define NAND_MAX_CHIPS			CONFIG_SYS_MAX_NAND_DEVICE
-#define CONFIG_SYS_NAND_SELECT_DEVICE
-#define CONFIG_SYS_64BIT_VSPRINTF  /* needed for nand_util.c */
-#endif
-#endif
-
-#define CONFIG_BOOTDELAY		3
-
-#define CONFIG_LOADADDR			0x82000000
-#define CONFIG_SYS_TEXT_BASE		0x3f408000 // OCRAM - need to check on final RM version
-
-
-#if 0 /* MATT: no need to have env settings now, will enable later when booting Linux */
-#define CONFIG_EXTRA_ENV_SETTINGS \
-	"script=boot.scr\0" \
-	"uimage=uImage\0" \
-	"console=ttyLP1\0" \
-	"fdt_high=0xffffffff\0" \
-	"initrd_high=0xffffffff\0" \
-	"fdt_file=vf610-twr.dtb\0" \
-	"fdt_addr=0x81000000\0" \
-	"boot_fdt=try\0" \
-	"ip_dyn=yes\0" \
-	"mmcdev=" __stringify(CONFIG_SYS_MMC_ENV_DEV) "\0" \
-	"mmcpart=1\0" \
-	"mmcroot=/dev/mmcblk0p2 rootwait rw\0" \
-	"update_sd_firmware_filename=u-boot.imx\0" \
-	"update_sd_firmware=" \
-		"if test ${ip_dyn} = yes; then " \
-			"setenv get_cmd dhcp; " \
-		"else " \
-			"setenv get_cmd tftp; " \
-		"fi; " \
-		"if mmc dev ${mmcdev}; then "	\
-			"if ${get_cmd} ${update_sd_firmware_filename}; then " \
-				"setexpr fw_sz ${filesize} / 0x200; " \
-				"setexpr fw_sz ${fw_sz} + 1; "	\
-				"mmc write ${loadaddr} 0x2 ${fw_sz}; " \
-			"fi; "	\
-		"fi\0" \
-	"mmcargs=setenv bootargs console=${console},${baudrate} " \
-		"root=${mmcroot}\0" \
-	"loadbootscript=" \
-		"fatload mmc ${mmcdev}:${mmcpart} ${loadaddr} ${script};\0" \
-	"bootscript=echo Running bootscript from mmc ...; " \
-		"source\0" \
-	"loaduimage=fatload mmc ${mmcdev}:${mmcpart} ${loadaddr} ${uimage}\0" \
-	"loadfdt=fatload mmc ${mmcdev}:${mmcpart} ${fdt_addr} ${fdt_file}\0" \
-	"mmcboot=echo Booting from mmc ...; " \
-		"run mmcargs; " \
-		"if test ${boot_fdt} = yes || test ${boot_fdt} = try; then " \
-			"if run loadfdt; then " \
-				"bootm ${loadaddr} - ${fdt_addr}; " \
-			"else " \
-				"if test ${boot_fdt} = try; then " \
-					"bootm; " \
-				"else " \
-					"echo WARN: Cannot load the DT; " \
-				"fi; " \
-			"fi; " \
-		"else " \
-			"bootm; " \
-		"fi;\0" \
-	"netargs=setenv bootargs console=${console},${baudrate} " \
-		"root=/dev/nfs " \
-	"ip=dhcp nfsroot=${serverip}:${nfsroot},v3,tcp\0" \
-		"netboot=echo Booting from net ...; " \
-		"run netargs; " \
-		"if test ${ip_dyn} = yes; then " \
-			"setenv get_cmd dhcp; " \
-		"else " \
-			"setenv get_cmd tftp; " \
-		"fi; " \
-		"${get_cmd} ${uimage}; " \
-		"if test ${boot_fdt} = yes || test ${boot_fdt} = try; then " \
-			"if ${get_cmd} ${fdt_addr} ${fdt_file}; then " \
-				"bootm ${loadaddr} - ${fdt_addr}; " \
-			"else " \
-				"if test ${boot_fdt} = try; then " \
-					"bootm; " \
-				"else " \
-					"echo WARN: Cannot load the DT; " \
-				"fi; " \
-			"fi; " \
-		"else " \
-			"bootm; " \
-		"fi;\0"
-
-#define CONFIG_BOOTCOMMAND \
-	   "mmc dev ${mmcdev}; if mmc rescan; then " \
-		   "if run loadbootscript; then " \
-			   "run bootscript; " \
-		   "else " \
-			   "if run loaduimage; then " \
-				   "run mmcboot; " \
-			   "else run netboot; " \
-			   "fi; " \
-		   "fi; " \
-	   "else run netboot; fi"
-
-#endif //#if 0
-
-/* Miscellaneous configurable options */
-#define CONFIG_SYS_LONGHELP		/* undef to save memory */
-#define CONFIG_SYS_HUSH_PARSER		/* use "hush" command parser */
-#define CONFIG_SYS_PROMPT_HUSH_PS2	"> "
-#define CONFIG_SYS_PROMPT		"=> "
-#undef CONFIG_AUTO_COMPLETE
-#define CONFIG_SYS_CBSIZE		256	/* Console I/O Buffer Size */
-#define CONFIG_SYS_PBSIZE		\
-			(CONFIG_SYS_CBSIZE + sizeof(CONFIG_SYS_PROMPT) + 16)
-#define CONFIG_SYS_MAXARGS		16	/* max number of command args */
-#define CONFIG_SYS_BARGSIZE		CONFIG_SYS_CBSIZE
-#define CONFIG_CMDLINE_EDITING
-
-#define CONFIG_CMD_MEMTEST
-#define CONFIG_SYS_MEMTEST_START	0x80010000
-#define CONFIG_SYS_MEMTEST_END		0x87C00000
-
-#define CONFIG_SYS_LOAD_ADDR		CONFIG_LOADADDR
-#define CONFIG_SYS_HZ			1000
-
-/*
- * Stack sizes
- * The stack sizes are set up in start.S using the settings below
- */
-#define CONFIG_STACKSIZE		(128 * 1024)	/* regular stack */
-
-/* Physical memory map */
-#define CONFIG_NR_DRAM_BANKS		1
-#define PHYS_SDRAM			(0x80000000)
-#define PHYS_SDRAM_SIZE			(128 * 1024 * 1024)
-
-#define CONFIG_SYS_SDRAM_BASE		PHYS_SDRAM
-#define CONFIG_SYS_INIT_RAM_ADDR	IRAM_BASE_ADDR
-#define CONFIG_SYS_INIT_RAM_SIZE	IRAM_SIZE
-
-#define CONFIG_SYS_INIT_SP_OFFSET \
-	(CONFIG_SYS_INIT_RAM_SIZE - GENERATED_GBL_DATA_SIZE)
-#define CONFIG_SYS_INIT_SP_ADDR \
-	(CONFIG_SYS_INIT_RAM_ADDR + CONFIG_SYS_INIT_SP_OFFSET)
-
-/* FLASH and environment organization */
-#define CONFIG_SYS_NO_FLASH
-
-#define CONFIG_ENV_SIZE			(8 * 1024)
-#define CONFIG_ENV_IS_IN_MMC
-
-#define CONFIG_ENV_OFFSET		(12 * 64 * 1024)
-#define CONFIG_SYS_MMC_ENV_DEV		0
-
-#define CONFIG_OF_LIBFDT
-#define CONFIG_CMD_BOOTZ
-
-#endif
diff --git a/include/configs/sac58revb.h b/include/configs/sac58revb.h
deleted file mode 100644
index e51193b911..0000000000
--- a/include/configs/sac58revb.h
+++ /dev/null
@@ -1,283 +0,0 @@
-/*
- * (C) Copyright 2014 Freescale Semiconductor, Inc.
- *
- * SPDX-License-Identifier:	GPL-2.0+
- */
-
-#ifndef __CONFIG_H
-#define __CONFIG_H
-
-#include <asm/arch/imx-regs.h>
-//#include <config_cmd_default.h>
-#include <linux/sizes.h>
-
-
-#define CONFIG_SAC58R
-//#define CONFIG_RUN_FROM_IRAM_ONLY
-
-#define CONFIG_DISPLAY_CPUINFO
-#define CONFIG_DISPLAY_BOARDINFO
-
-#define CONFIG_CMD_BOOTD			/* bootd			*/
-#define CONFIG_CMD_RUN				/* run command in env variable	*/
-
-#define CONFIG_SKIP_LOWLEVEL_INIT
-
-#define CONFIG_CMD_MEMORY	/* md mm nm mw cp cmp crc base loop */
-
-#define CONFIG_ARCH_MISC_INIT
-
-/*#define CONFIG_SYS_USE_NAND*/
-
-/* uncomment for SECURE mode support */
-/* #define CONFIG_SECURE_BOOT */
-
-/* Enable passing of ATAGs */
-#define CONFIG_CMDLINE_TAG
-
-#define CONFIG_CMD_FUSE
-#ifdef CONFIG_CMD_FUSE
-#define CONFIG_MXC_OCOTP
-#endif
-
-/* Size of malloc() pool */
-#define CONFIG_SYS_MALLOC_LEN		(1 * SZ_1M)
-
-#define CONFIG_BOARD_EARLY_INIT_F
-
-#define CONFIG_FSL_LPUART
-#define LPUART_BASE			UART4_BASE_ADDR
-/* Only UART0 and UART1 have hardware flow control */
-#define LPUART_WO_HW_FLOW_CTRL
-
-/* Allow to overwrite serial and ethaddr */
-#define CONFIG_ENV_OVERWRITE
-#define CONFIG_SYS_UART_PORT		(1)
-#define CONFIG_BAUDRATE			115200
-
-#undef CONFIG_CMD_IMLS
-
-#define CONFIG_MMC
-#define CONFIG_FSL_ESDHC
-#define CONFIG_FSL_USDHC
-#define CONFIG_SYS_FSL_ESDHC_ADDR	USDHC0_BASE_ADDR
-#define CONFIG_SYS_FSL_ESDHC_NUM	3
-#ifdef CONFIG_SYS_USE_NAND
-/* Boot from SDHC0 if NAND support is selected */
-#define CONFIG_SYS_MMC_ENV_DEV		0
-#else
-/* Otherwise boot from SDHC1 */
-#define CONFIG_SYS_MMC_ENV_DEV		1
-#endif
-
-
-#define CONFIG_MVF_GPIO
-
-#define CONFIG_SYS_FSL_ERRATUM_ESDHC111
-
-#define CONFIG_CMD_MMC
-#define CONFIG_GENERIC_MMC
-//#define CONFIG_CMD_EXT2		/* EXT2 Support			*/
-#define CONFIG_CMD_FAT		/* FAT support			*/
-#define CONFIG_DOS_PARTITION
-
-/* Ethernet config */
-#define CONFIG_CMD_PING
-#define CONFIG_CMD_DHCP
-#define CONFIG_CMD_MII
-#define CONFIG_CMD_NET
-#define CONFIG_FEC_MXC
-#define CONFIG_MII
-#define IMX_FEC_BASE					ENET_BASE_ADDR
-#define CONFIG_FEC_XCV_TYPE             RMII
-#define CONFIG_FEC_MXC_PHYADDR          0
-#define CONFIG_ETHADDR			00:e0:0c:bc:e5:60
-#define CONFIG_ETH1ADDR			00:e0:0c:bc:e5:61
-
-
-#define CONFIG_PHYLIB
-#define CONFIG_PHY_SMSC
-#define PHY_RESET_GPIO			365
-
-/* DCU configs */
-#define CONFIG_LVDS
-
-/* I2C configs */
-#define CONFIG_CMD_I2C
-#define CONFIG_I2C_MULTI_BUS
-#define I2C_QUIRK_REG
-#define CONFIG_HARD_I2C         		1
-#define CONFIG_SYS_I2C
-#define CONFIG_SYS_I2C_MXC          		1
-#define CONFIG_SYS_I2C_BASE             I2C0_BASE_ADDR
-#define CONFIG_SYS_I2C_SPEED            100000
-#define CONFIG_SYS_I2C_SLAVE            0x8
-
-#if 0
-#ifdef CONFIG_SYS_USE_NAND
-/* Nand Flash Configs */
-#define CONFIG_CMD_NAND
-#define CONFIG_JFFS2_NAND
-#define MTD_NAND_FSL_NFC_SWECC 1
-#define CONFIG_NAND_FSL_NFC
-#define CONFIG_SYS_NAND_BASE		0x40178000
-#define CONFIG_SYS_MAX_NAND_DEVICE	1
-#define NAND_MAX_CHIPS			CONFIG_SYS_MAX_NAND_DEVICE
-#define CONFIG_SYS_NAND_SELECT_DEVICE
-#define CONFIG_SYS_64BIT_VSPRINTF  /* needed for nand_util.c */
-#endif
-#endif
-
-#define CONFIG_BOOTDELAY		3
-
-#define CONFIG_LOADADDR				0x82000000
-#ifdef CONFIG_RUN_FROM_IRAM_ONLY
-#define CONFIG_SYS_DCACHE_OFF
-#define CONFIG_SYS_MALLOC_BASE		0x3f004000 // HACK
-#endif
-
-#define CONFIG_SYS_TEXT_BASE		0x3F008000
-#define CONFIG_EXTRA_ENV_SETTINGS \
-	"script=boot.scr\0" \
-	"uimage=uImage\0" \
-	"console=ttyLP4\0" \
-	"fdt_high=0xffffffff\0" \
-	"initrd_high=0xffffffff\0" \
-	"fdt_file=sac58r-evb.dtb\0" \
-	"fdt_addr=0x81000000\0" \
-	"boot_fdt=try\0" \
-	"ip_dyn=yes\0" \
-	"mmcdev=" __stringify(CONFIG_SYS_MMC_ENV_DEV) "\0" \
-	"mmcpart=1\0" \
-	"mmcroot=/dev/mmcblk0p2 rootwait rw\0" \
-	"update_sd_firmware_filename=u-boot.imx\0" \
-	"update_sd_firmware=" \
-		"if test ${ip_dyn} = yes; then " \
-			"setenv get_cmd dhcp; " \
-		"else " \
-			"setenv get_cmd tftp; " \
-		"fi; " \
-		"if mmc dev ${mmcdev}; then "	\
-			"if ${get_cmd} ${update_sd_firmware_filename}; then " \
-				"setexpr fw_sz ${filesize} / 0x200; " \
-				"setexpr fw_sz ${fw_sz} + 1; "	\
-				"mmc write ${loadaddr} 0x2 ${fw_sz}; " \
-			"fi; "	\
-		"fi\0" \
-	"mmcargs=setenv bootargs console=${console},${baudrate} " \
-		"root=${mmcroot}\0" \
-	"loadbootscript=" \
-		"fatload mmc ${mmcdev}:${mmcpart} ${loadaddr} ${script};\0" \
-	"bootscript=echo Running bootscript from mmc ...; " \
-		"source\0" \
-	"loaduimage=fatload mmc ${mmcdev}:${mmcpart} ${loadaddr} ${uimage}\0" \
-	"loadfdt=fatload mmc ${mmcdev}:${mmcpart} ${fdt_addr} ${fdt_file}\0" \
-	"mmcboot=echo Booting from mmc ...; " \
-		"run mmcargs; " \
-		"if test ${boot_fdt} = yes || test ${boot_fdt} = try; then " \
-			"if run loadfdt; then " \
-				"bootm ${loadaddr} - ${fdt_addr}; " \
-			"else " \
-				"if test ${boot_fdt} = try; then " \
-					"bootm; " \
-				"else " \
-					"echo WARN: Cannot load the DT; " \
-				"fi; " \
-			"fi; " \
-		"else " \
-			"bootm; " \
-		"fi;\0" \
-	"netargs=setenv bootargs console=${console},${baudrate} " \
-		"root=/dev/nfs " \
-	"ip=dhcp nfsroot=${serverip}:${nfsroot},v3,tcp\0" \
-		"netboot=echo Booting from net ...; " \
-		"run netargs; " \
-		"if test ${ip_dyn} = yes; then " \
-			"setenv get_cmd dhcp; " \
-		"else " \
-			"setenv get_cmd tftp; " \
-		"fi; " \
-		"${get_cmd} ${uimage}; " \
-		"if test ${boot_fdt} = yes || test ${boot_fdt} = try; then " \
-			"if ${get_cmd} ${fdt_addr} ${fdt_file}; then " \
-				"bootm ${loadaddr} - ${fdt_addr}; " \
-			"else " \
-				"if test ${boot_fdt} = try; then " \
-					"bootm; " \
-				"else " \
-					"echo WARN: Cannot load the DT; " \
-				"fi; " \
-			"fi; " \
-		"else " \
-			"bootm; " \
-		"fi;\0"
-
-#define CONFIG_BOOTCOMMAND \
-	   "mmc dev ${mmcdev}; if mmc rescan; then " \
-		   "if run loadbootscript; then " \
-			   "run bootscript; " \
-		   "else " \
-			   "if run loaduimage; then " \
-				   "run mmcboot; " \
-			   "else run netboot; " \
-			   "fi; " \
-		   "fi; " \
-	   "else run netboot; fi"
-
-
-/* Miscellaneous configurable options */
-#define CONFIG_SYS_LONGHELP		/* undef to save memory */
-#define CONFIG_SYS_HUSH_PARSER		/* use "hush" command parser */
-#define CONFIG_SYS_PROMPT_HUSH_PS2	"> "
-#define CONFIG_SYS_PROMPT		"=> "
-#undef CONFIG_AUTO_COMPLETE
-#define CONFIG_SYS_CBSIZE		256	/* Console I/O Buffer Size */
-#define CONFIG_SYS_PBSIZE		\
-			(CONFIG_SYS_CBSIZE + sizeof(CONFIG_SYS_PROMPT) + 16)
-#define CONFIG_SYS_MAXARGS		16	/* max number of command args */
-#define CONFIG_SYS_BARGSIZE		CONFIG_SYS_CBSIZE
-#define CONFIG_CMDLINE_EDITING
-
-#define CONFIG_CMD_MEMTEST
-#define CONFIG_SYS_MEMTEST_START	0x80010000
-#define CONFIG_SYS_MEMTEST_END		0x87C00000
-
-#define CONFIG_SYS_LOAD_ADDR		CONFIG_LOADADDR
-#define CONFIG_SYS_HZ				1000
-
-/*
- * Stack sizes
- * The stack sizes are set up in start.S using the settings below
- */
-#define CONFIG_STACKSIZE			(128 * 1024)	/* regular stack */
-
-/* Physical memory map */
-#define CONFIG_NR_DRAM_BANKS		1
-#define PHYS_SDRAM					(0x80000000)
-#define PHYS_SDRAM_SIZE				(256 * 1024 * 1024)
-
-#define CONFIG_SYS_SDRAM_BASE		PHYS_SDRAM
-#define CONFIG_SYS_INIT_RAM_ADDR	IRAM_BASE_ADDR
-#define CONFIG_SYS_INIT_RAM_SIZE	IRAM_SIZE
-
-#define CONFIG_SYS_INIT_SP_OFFSET \
-	(CONFIG_SYS_INIT_RAM_SIZE - GENERATED_GBL_DATA_SIZE)
-#define CONFIG_SYS_INIT_SP_ADDR \
-	(CONFIG_SYS_INIT_RAM_ADDR + CONFIG_SYS_INIT_SP_OFFSET)
-
-/* FLASH and environment organization */
-#define CONFIG_SYS_NO_FLASH
-
-#define CONFIG_ENV_SIZE			(8 * 1024)
-//#ifdef CONFIG_GENERIC_MMC
-//#define CONFIG_ENV_IS_IN_MMC
-//#else
-#define CONFIG_ENV_IS_NOWHERE
-//#endif
-
-#define CONFIG_ENV_OFFSET		(12 * 64 * 1024)
-
-#define CONFIG_OF_LIBFDT
-#define CONFIG_CMD_BOOTZ
-
-#endif
diff --git a/include/configs/sac58rfvb.h b/include/configs/sac58rfvb.h
deleted file mode 100644
index 56e53c59d9..0000000000
--- a/include/configs/sac58rfvb.h
+++ /dev/null
@@ -1,264 +0,0 @@
-/*
- * (C) Copyright 2014 Freescale Semiconductor, Inc.
- *
- * SPDX-License-Identifier:	GPL-2.0+
- */
-
-#ifndef __CONFIG_H
-#define __CONFIG_H
-
-#include <asm/arch/imx-regs.h>
-#include <config_cmd_default.h>
-#include <linux/sizes.h>
-
-
-#define CONFIG_SAC58R
-//#define CONFIG_RUN_FROM_IRAM_ONLY
-
-#define CONFIG_DISPLAY_CPUINFO
-#define CONFIG_DISPLAY_BOARDINFO
-
-#define CONFIG_SKIP_LOWLEVEL_INIT
-
-#define CONFIG_ARCH_MISC_INIT
-
-/* uncomment for SECURE mode support */
-/* #define CONFIG_SECURE_BOOT */
-
-/* Enable passing of ATAGs */
-#define CONFIG_CMDLINE_TAG
-
-#define CONFIG_CMD_FUSE
-#ifdef CONFIG_CMD_FUSE
-#define CONFIG_MXC_OCOTP
-#endif
-
-/* Size of malloc() pool */
-#define CONFIG_SYS_MALLOC_LEN		(1 * SZ_1M)
-
-#define CONFIG_BOARD_EARLY_INIT_F
-
-#define CONFIG_FSL_LPUART
-#define LPUART_BASE			UART0_BASE_ADDR
-
-/* Allow to overwrite serial and ethaddr */
-#define CONFIG_ENV_OVERWRITE
-#define CONFIG_SYS_UART_PORT		(1)
-#define CONFIG_BAUDRATE			115200
-
-#undef CONFIG_CMD_IMLS
-
-#define CONFIG_MMC
-#define CONFIG_FSL_ESDHC
-#define CONFIG_FSL_USDHC
-#define CONFIG_SYS_FSL_ESDHC_ADDR	USDHC0_BASE_ADDR
-#define CONFIG_SYS_FSL_ESDHC_NUM	3
-#define CONFIG_SYS_MMC_ENV_DEV		2
-
-#define CONFIG_MVF_GPIO
-
-#define CONFIG_SYS_FSL_ERRATUM_ESDHC111
-
-#define CONFIG_CMD_MMC
-#define CONFIG_GENERIC_MMC
-#define CONFIG_CMD_EXT2		/* EXT2 Support			*/
-#define CONFIG_CMD_FAT		/* FAT support			*/
-#define CONFIG_DOS_PARTITION
-
-#if 0
-/* Ethernet config */
-#define CONFIG_CMD_PING
-#define CONFIG_CMD_DHCP
-#define CONFIG_CMD_MII
-#define CONFIG_CMD_NET
-#define CONFIG_FEC_MXC
-#define CONFIG_MII
-#define IMX_FEC_BASE			ENET_BASE_ADDR
-#define CONFIG_FEC_XCV_TYPE		RMII
-#define CONFIG_FEC_MXC_PHYADDR          0
-#define CONFIG_PHYLIB
-#define CONFIG_PHY_MICREL
-#endif
-
-
-/* I2C configs */
-#define CONFIG_CMD_I2C
-#define CONFIG_HARD_I2C			1
-#define CONFIG_I2C_MULTI_BUS
-#define I2C_QUIRK_REG
-#define CONFIG_SYS_I2C
-#define CONFIG_SYS_I2C_MXC		1
-#define CONFIG_SYS_I2C_BASE		I2C0_BASE_ADDR
-#define CONFIG_SYS_I2C_SPEED		100000
-#define CONFIG_SYS_I2C_SLAVE            0x8
-
-#if 0
-#define CONFIG_SYS_USE_NAND */
-
-#ifdef CONFIG_SYS_USE_NAND
-/* Nand Flash Configs */
-#define	CONFIG_CMD_NAND
-#define CONFIG_JFFS2_NAND
-#define MTD_NAND_FSL_NFC_SWECC 1
-#define CONFIG_NAND_FSL_NFC
-#define CONFIG_SYS_NAND_BASE		0x400E0000
-#define CONFIG_SYS_MAX_NAND_DEVICE	1
-#define NAND_MAX_CHIPS			CONFIG_SYS_MAX_NAND_DEVICE
-#define CONFIG_SYS_NAND_SELECT_DEVICE
-#define CONFIG_SYS_64BIT_VSPRINTF  /* needed for nand_util.c */
-#endif
-#endif
-
-#define CONFIG_BOOTDELAY		3
-
-#define CONFIG_LOADADDR				0x82000000
-#ifdef CONFIG_RUN_FROM_IRAM_ONLY
-#define CONFIG_SYS_DCACHE_OFF
-#define CONFIG_SYS_MALLOC_BASE		0x3f004000 // HACK
-#endif
-#define CONFIG_SYS_TEXT_BASE		0x87800000
-
-#define CONFIG_EXTRA_ENV_SETTINGS \
-	"script=boot.scr\0" \
-	"uimage=uImage\0" \
-	"console=ttyLP0\0" \
-	"fdt_high=0xffffffff\0" \
-	"initrd_high=0xffffffff\0" \
-	"fdt_file=sac58r-fvb.dtb\0" \
-	"fdt_addr=0x81000000\0" \
-	"boot_fdt=try\0" \
-	"ip_dyn=yes\0" \
-	"mmcdev=" __stringify(CONFIG_SYS_MMC_ENV_DEV) "\0" \
-	"mmcpart=1\0" \
-	"mmcroot=/dev/mmcblk0p2 rootwait rw\0" \
-	"update_sd_firmware_filename=u-boot.imx\0" \
-	"update_sd_firmware=" \
-		"if test ${ip_dyn} = yes; then " \
-			"setenv get_cmd dhcp; " \
-		"else " \
-			"setenv get_cmd tftp; " \
-		"fi; " \
-		"if mmc dev ${mmcdev}; then "	\
-			"if ${get_cmd} ${update_sd_firmware_filename}; then " \
-				"setexpr fw_sz ${filesize} / 0x200; " \
-				"setexpr fw_sz ${fw_sz} + 1; "	\
-				"mmc write ${loadaddr} 0x2 ${fw_sz}; " \
-			"fi; "	\
-		"fi\0" \
-	"mmcargs=setenv bootargs console=${console},${baudrate} " \
-		"root=${mmcroot}\0" \
-	"loadbootscript=" \
-		"fatload mmc ${mmcdev}:${mmcpart} ${loadaddr} ${script};\0" \
-	"bootscript=echo Running bootscript from mmc ...; " \
-		"source\0" \
-	"loaduimage=fatload mmc ${mmcdev}:${mmcpart} ${loadaddr} ${uimage}\0" \
-	"loadfdt=fatload mmc ${mmcdev}:${mmcpart} ${fdt_addr} ${fdt_file}\0" \
-	"mmcboot=echo Booting from mmc ...; " \
-		"run mmcargs; " \
-		"if test ${boot_fdt} = yes || test ${boot_fdt} = try; then " \
-			"if run loadfdt; then " \
-				"bootm ${loadaddr} - ${fdt_addr}; " \
-			"else " \
-				"if test ${boot_fdt} = try; then " \
-					"bootm; " \
-				"else " \
-					"echo WARN: Cannot load the DT; " \
-				"fi; " \
-			"fi; " \
-		"else " \
-			"bootm; " \
-		"fi;\0" \
-	"netargs=setenv bootargs console=${console},${baudrate} " \
-		"root=/dev/nfs " \
-	"ip=dhcp nfsroot=${serverip}:${nfsroot},v3,tcp\0" \
-		"netboot=echo Booting from net ...; " \
-		"run netargs; " \
-		"if test ${ip_dyn} = yes; then " \
-			"setenv get_cmd dhcp; " \
-		"else " \
-			"setenv get_cmd tftp; " \
-		"fi; " \
-		"${get_cmd} ${uimage}; " \
-		"if test ${boot_fdt} = yes || test ${boot_fdt} = try; then " \
-			"if ${get_cmd} ${fdt_addr} ${fdt_file}; then " \
-				"bootm ${loadaddr} - ${fdt_addr}; " \
-			"else " \
-				"if test ${boot_fdt} = try; then " \
-					"bootm; " \
-				"else " \
-					"echo WARN: Cannot load the DT; " \
-				"fi; " \
-			"fi; " \
-		"else " \
-			"bootm; " \
-		"fi;\0"
-
-#define CONFIG_BOOTCOMMAND \
-	   "mmc dev ${mmcdev}; if mmc rescan; then " \
-		   "if run loadbootscript; then " \
-			   "run bootscript; " \
-		   "else " \
-			   "if run loaduimage; then " \
-				   "run mmcboot; " \
-			   "else run netboot; " \
-			   "fi; " \
-		   "fi; " \
-	   "else run netboot; fi"
-
-
-/* Miscellaneous configurable options */
-#define CONFIG_SYS_LONGHELP		/* undef to save memory */
-#define CONFIG_SYS_HUSH_PARSER		/* use "hush" command parser */
-#define CONFIG_SYS_PROMPT_HUSH_PS2	"> "
-#define CONFIG_SYS_PROMPT		"=> "
-#undef CONFIG_AUTO_COMPLETE
-#define CONFIG_SYS_CBSIZE		256	/* Console I/O Buffer Size */
-#define CONFIG_SYS_PBSIZE		\
-			(CONFIG_SYS_CBSIZE + sizeof(CONFIG_SYS_PROMPT) + 16)
-#define CONFIG_SYS_MAXARGS		16	/* max number of command args */
-#define CONFIG_SYS_BARGSIZE		CONFIG_SYS_CBSIZE
-#define CONFIG_CMDLINE_EDITING
-
-#define CONFIG_CMD_MEMTEST
-#define CONFIG_SYS_MEMTEST_START	0x80010000
-#define CONFIG_SYS_MEMTEST_END		0x87C00000
-
-#define CONFIG_SYS_LOAD_ADDR		CONFIG_LOADADDR
-#define CONFIG_SYS_HZ				1000
-
-/*
- * Stack sizes
- * The stack sizes are set up in start.S using the settings below
- */
-#define CONFIG_STACKSIZE			(128 * 1024)	/* regular stack */
-
-/* Physical memory map */
-#define CONFIG_NR_DRAM_BANKS		1
-#define PHYS_SDRAM					(0x80000000)
-#define PHYS_SDRAM_SIZE				(256 * 1024 * 1024)
-
-#define CONFIG_SYS_SDRAM_BASE		PHYS_SDRAM
-#define CONFIG_SYS_INIT_RAM_ADDR	IRAM_BASE_ADDR
-#define CONFIG_SYS_INIT_RAM_SIZE	IRAM_SIZE
-
-#define CONFIG_SYS_INIT_SP_OFFSET \
-	(CONFIG_SYS_INIT_RAM_SIZE - GENERATED_GBL_DATA_SIZE)
-#define CONFIG_SYS_INIT_SP_ADDR \
-	(CONFIG_SYS_INIT_RAM_ADDR + CONFIG_SYS_INIT_SP_OFFSET)
-
-/* FLASH and environment organization */
-#define CONFIG_SYS_NO_FLASH
-
-#define CONFIG_ENV_SIZE			(8 * 1024)
-//#ifdef CONFIG_GENERIC_MMC
-//#define CONFIG_ENV_IS_IN_MMC
-//#else
-#define CONFIG_ENV_IS_NOWHERE
-//#endif
-
-#define CONFIG_ENV_OFFSET		(12 * 64 * 1024)
-
-#define CONFIG_OF_LIBFDT
-#define CONFIG_CMD_BOOTZ
-
-#endif
-- 
2.17.1

