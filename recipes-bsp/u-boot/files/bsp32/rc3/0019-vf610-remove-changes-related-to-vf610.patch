From dab45fad6d90dfe595d1aacf3671dba138526db5 Mon Sep 17 00:00:00 2001
From: Andrei Botila <andrei.botila@nxp.com>
Date: Sat, 15 Jan 2022 00:35:39 +0200
Subject: [PATCH 19/25] vf610: remove changes related to vf610

These changes include modification in nand support and
dma channel muxing.

Issue: ALB-8332
Upstream-Status: Pending 

Signed-off-by: Andrei Botila <andrei.botila@nxp.com>
Signed-off-by: Zhantao Tang <zhantao.tang@windriver.com>
---
 arch/arm/include/asm/arch-vf610/crm_regs.h    |  10 -
 .../include/asm/arch-vf610/dmachmux-vf610.h   | 114 ---
 arch/arm/include/asm/arch-vf610/imx-regs.h    |   7 -
 board/freescale/vf610twr/vf610twr.c           |  25 +-
 .../freescale/vf610twr/vf610twr_int_routing.h | 133 ---
 drivers/mtd/nand/mpc5125_nfc.c                | 894 ------------------
 include/configs/vf610twr.h                    |  28 -
 include/mtd/fsl_nfc.h                         | 288 ------
 8 files changed, 2 insertions(+), 1497 deletions(-)
 delete mode 100644 arch/arm/include/asm/arch-vf610/dmachmux-vf610.h
 delete mode 100644 board/freescale/vf610twr/vf610twr_int_routing.h
 delete mode 100644 drivers/mtd/nand/mpc5125_nfc.c
 delete mode 100644 include/mtd/fsl_nfc.h

diff --git a/arch/arm/include/asm/arch-vf610/crm_regs.h b/arch/arm/include/asm/arch-vf610/crm_regs.h
index 51f4968e52..0c9ed52933 100644
--- a/arch/arm/include/asm/arch-vf610/crm_regs.h
+++ b/arch/arm/include/asm/arch-vf610/crm_regs.h
@@ -177,16 +177,6 @@ struct anadig_reg {
 #define CCM_CSCDR2_ESDHC1_CLK_DIV_OFFSET	20
 #define CCM_CSCDR2_ESDHC1_CLK_DIV_MASK		(0xf << 20)
 #define CCM_CSCDR2_ESDHC1_CLK_DIV(v)		(((v) & 0xf) << 20)
-#define CCM_CSCDR2_NFC_CLK_INV					(1 << 14)
-#define CCM_CSCDR2_NFC_CLK_FRAC_DIV_EN			(1 << 13)
-#define CCM_CSCDR2_NFC_EN						(1 << 9)
-#define CCM_CSCDR2_NFC_CLK_FRAC_DIV_OFFSET		4
-#define CCM_CSCDR2_NFC_CLK_FRAC_DIV_MASK		(0xf << 4)
-#define CCM_CSCDR2_NFC_CLK_FRAC_DIV(v)			(((v) & 0xf) << 4)
-
-#define CCM_CSCDR3_NFC_PRE_DIV_OFFSET			13
-#define CCM_CSCDR3_NFC_PRE_DIV_MASK				(0x7 << 13)
-#define CCM_CSCDR3_NFC_PRE_DIV(v)				(((v) & 0x7) << 13)
 
 #define CCM_CSCDR3_DCU1_EN			(1 << 23)
 #define CCM_CSCDR3_DCU1_DIV_MASK		(0x7 << 20)
diff --git a/arch/arm/include/asm/arch-vf610/dmachmux-vf610.h b/arch/arm/include/asm/arch-vf610/dmachmux-vf610.h
deleted file mode 100644
index f54ca69390..0000000000
--- a/arch/arm/include/asm/arch-vf610/dmachmux-vf610.h
+++ /dev/null
@@ -1,114 +0,0 @@
-/*
- * Copyright 2014 Freescale Semiconductor, Inc.
- *
- * Author: Gilles Talis <gilles.talis@freescale.com>
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License as
- * published by the Free Software Foundation; either version 2 of
- * the License, or (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
- * MA 02111-1307 USA
- */
-
-#ifndef __DMACHMUX_VF610_H__
-#define __DMACHMUX_VF610_H__
-
-#include <asm/imx-common/dmachmux.h>
-
-/* DMA Channel sources */
-enum {
-	/* DMA request sources - DMA0(MUX0)/DMA1(MUX3) */
-	VF610_DMAREQSRC_UART0_RX = 2,
-	VF610_DMAREQSRC_UART0_TX = 3,
-	VF610_DMAREQSRC_UART1_RX = 4,
-	VF610_DMAREQSRC_UART1_TX = 5,
-	VF610_DMAREQSRC_UART2_RX = 6,
-	VF610_DMAREQSRC_UART2_TX = 7,
-	VF610_DMAREQSRC_UART3_RX = 8,
-	VF610_DMAREQSRC_UART3_TX = 9,
-	VF610_DMAREQSRC_SPI0_RX = 12,
-	VF610_DMAREQSRC_SPI0_TX = 13,
-	VF610_DMAREQSRC_SPI1_RX = 14,
-	VF610_DMAREQSRC_SPI1_TX = 15,
-	VF610_DMAREQSRC_SAI0_RX = 16,
-	VF610_DMAREQSRC_SAI0_TX = 17,
-	VF610_DMAREQSRC_SAI1_RX = 18,
-	VF610_DMAREQSRC_SAI1_TX = 19,
-	VF610_DMAREQSRC_SAI2_RX = 20,
-	VF610_DMAREQSRC_SAI2_TX = 21,
-	VF610_DMAREQSRC_PDB 	= 22,
-	VF610_DMAREQSRC_FTM0_CH0 = 24,
-	VF610_DMAREQSRC_FTM0_CH1 = 25,
-	VF610_DMAREQSRC_FTM0_CH2 = 26,
-	VF610_DMAREQSRC_FTM0_CH3 = 27,
-	VF610_DMAREQSRC_FTM0_CH4 = 28,
-	VF610_DMAREQSRC_FTM0_CH5 = 29,
-	VF610_DMAREQSRC_FTM0_CH6 = 30,
-	VF610_DMAREQSRC_FTM0_CH7 = 31,
-	VF610_DMAREQSRC_FTM1_CH0 = 32,
-	VF610_DMAREQSRC_FTM1_CH1 = 33,
-	VF610_DMAREQSRC_ADC0 	= 34,
-	VF610_DMAREQSRC_QSPI0 	= 36,
-	VF610_DMAREQSRC_PORTA 	= 38,
-	VF610_DMAREQSRC_PORTB 	= 39,
-	VF610_DMAREQSRC_PORTC 	= 40,
-	VF610_DMAREQSRC_PORTD 	= 41,
-	VF610_DMAREQSRC_PORTE 	= 42,
-	VF610_DMAREQSRC_RLE_RX	= 45,
-	VF610_DMAREQSRC_RLE_TX	= 46,
-	VF610_DMAREQSRC_SPDIF_RX = 47,
-	VF610_DMAREQSRC_SPDIF_TX = 48,
-	VF610_DMAREQSRC_I2C0_RX = 50,
-	VF610_DMAREQSRC_I2C0_TX = 51,
-	VF610_DMAREQSRC_I2C1_RX = 52,
-	VF610_DMAREQSRC_I2C1_TX = 53,
-	/* DMA request sources - DMA1(MUX2)/DMA0(MUX1) */
-	VF610_DMAREQSRC_UART4_RX = 2,
-	VF610_DMAREQSRC_UART4_TX = 3,
-	VF610_DMAREQSRC_UART5_RX = 4,
-	VF610_DMAREQSRC_UART5_TX = 5,
-	VF610_DMAREQSRC_SAI3_RX = 8,
-	VF610_DMAREQSRC_SAI3_TX = 9,
-	VF610_DMAREQSRC_SPI2_RX = 10,
-	VF610_DMAREQSRC_SPI2_TX = 11,
-	VF610_DMAREQSRC_SPI3_RX = 12,
-	VF610_DMAREQSRC_SPI3_TX = 13,
-	VF610_DMAREQSRC_FTM2_CH0 = 16,
-	VF610_DMAREQSRC_FTM2_CH1 = 17,
-	VF610_DMAREQSRC_FTM3_CH0 = 18,
-	VF610_DMAREQSRC_FTM3_CH1 = 19,
-	VF610_DMAREQSRC_FTM3_CH2 = 20,
-	VF610_DMAREQSRC_FTM3_CH3 = 21,
-	VF610_DMAREQSRC_FTM3_CH4 = 22,
-	VF610_DMAREQSRC_FTM3_CH5 = 23,
-	VF610_DMAREQSRC_FTM3_CH6 = 24,
-	VF610_DMAREQSRC_FTM3_CH7 = 25,
-	VF610_DMAREQSRC_ADC1 	= 26,
-	VF610_DMAREQSRC_QSPI1 	= 27,
-	VF610_DMAREQSRC_DAC0 	= 32,
-	VF610_DMAREQSRC_DAC1 	= 33,
-	VF610_DMAREQSRC_ESAI_BFIFO_TX 	= 34,
-	VF610_DMAREQSRC_ESAI_BFIFO_RX 	= 35,
-	VF610_DMAREQSRC_I2C2_RX = 36,
-	VF610_DMAREQSRC_I2C2_TX = 37,
-	VF610_DMAREQSRC_I2C3_RX = 38,
-	VF610_DMAREQSRC_I2C4_TX = 39,
-	VF610_DMAREQSRC_ASRC1 	= 40,
-	VF610_DMAREQSRC_ASRC4 	= 41,
-	VF610_DMAREQSRC_ASRC2 	= 42,
-	VF610_DMAREQSRC_ASRC5 	= 43,
-	VF610_DMAREQSRC_ASRC3 	= 52,
-	VF610_DMAREQSRC_ASRC6 	= 53,
-};
-
-
-#endif	/* __IOMUX_VF610_H__ */
diff --git a/arch/arm/include/asm/arch-vf610/imx-regs.h b/arch/arm/include/asm/arch-vf610/imx-regs.h
index efda87fe02..ae0a187c4d 100644
--- a/arch/arm/include/asm/arch-vf610/imx-regs.h
+++ b/arch/arm/include/asm/arch-vf610/imx-regs.h
@@ -40,7 +40,6 @@
 #define SEMA4_BASE_ADDR		(AIPS0_BASE_ADDR + 0x0001D000)
 #define FB_BASE_ADDR		(AIPS0_BASE_ADDR + 0x0001E000)
 #define DMA_MUX0_BASE_ADDR	(AIPS0_BASE_ADDR + 0x00024000)
-#define DMA_MUX1_BASE_ADDR	(AIPS0_BASE_ADDR + 0x00025000)
 #define UART0_BASE		(AIPS0_BASE_ADDR + 0x00027000)
 #define UART1_BASE		(AIPS0_BASE_ADDR + 0x00028000)
 #define UART2_BASE		(AIPS0_BASE_ADDR + 0x00029000)
@@ -92,8 +91,6 @@
 #define GPIO4_BASE_ADDR		(AIPS0_BASE_ADDR + 0x000FF100)
 
 /* AIPS 1 */
-#define DMA_MUX2_BASE_ADDR	(AIPS1_BASE_ADDR + 0x00021000)
-#define DMA_MUX3_BASE_ADDR	(AIPS1_BASE_ADDR + 0x00022000)
 #define OCOTP_BASE_ADDR		(AIPS1_BASE_ADDR + 0x00025000)
 #define DDR_BASE_ADDR		(AIPS1_BASE_ADDR + 0x0002E000)
 #define ESDHC0_BASE_ADDR	(AIPS1_BASE_ADDR + 0x00031000)
@@ -114,10 +111,6 @@
 
 /* MSCM interrupt rounter */
 #define MSCM_IRSPRC_CP0_EN				1
-#define MSCM_IRSPRC_CP1_EN				2
-#define MSCM_IRSPRC_ROUTE_TO_CA5		MSCM_IRSPRC_CP0_EN
-#define MSCM_IRSPRC_ROUTE_TO_CM4		MSCM_IRSPRC_CP1_EN
-#define MSCM_IRSPRC_ROUTE_TO_CA5_CM4	MSCM_IRSPRC_CP1_EN | MSCM_IRSPRC_CP0_EN
 #define MSCM_IRSPRC_NUM					112
 
 /* DDRMC */
diff --git a/board/freescale/vf610twr/vf610twr.c b/board/freescale/vf610twr/vf610twr.c
index 931c3dd557..17427f23d8 100644
--- a/board/freescale/vf610twr/vf610twr.c
+++ b/board/freescale/vf610twr/vf610twr.c
@@ -16,9 +16,6 @@
 #include <miiphy.h>
 #include <netdev.h>
 #include <i2c.h>
-#include <asm/arch/dmachmux-vf610.h>
-
-#include "vf610twr_int_routing.h"
 
 DECLARE_GLOBAL_DATA_PTR;
 
@@ -321,9 +318,7 @@ static void clock_init(void)
 		CCM_CSCDR1_RMII_CLK_EN);
 	clrsetbits_le32(&ccm->cscdr2, CCM_REG_CTRL_MASK,
 		CCM_CSCDR2_ESDHC1_EN | CCM_CSCDR2_ESDHC1_CLK_DIV(0) |
-		CCM_CSCDR2_NFC_CLK_INV | CCM_CSCDR2_NFC_EN | CCM_CSCDR2_NFC_CLK_FRAC_DIV(4));
-	clrsetbits_le32(&ccm->cscdr3,CCM_CSCDR3_NFC_PRE_DIV_MASK,
-		CCM_CSCDR3_NFC_PRE_DIV(1));
+		CCM_CSCDR2_NFC_EN);
 	clrsetbits_le32(&ccm->cscdr3, CCM_REG_CTRL_MASK,
 		CCM_CSCDR3_QSPI0_EN | CCM_CSCDR3_QSPI0_DIV(1) |
 		CCM_CSCDR3_QSPI0_X2_DIV(1) | CCM_CSCDR3_QSPI0_X4_DIV(3) |
@@ -337,26 +332,10 @@ static void mscm_init(void)
 	struct mscm_ir *mscmir = (struct mscm_ir *)MSCM_IR_BASE_ADDR;
 	int i;
 
-	/* Interrupt routing configuration */
 	for (i = 0; i < MSCM_IRSPRC_NUM; i++)
-			writew(int_routing_conf[i], &mscmir->irsprc[i]);
-
-}
-
-
-static void dmamux_init(void)
-{
-	/*Example DMA CHANNEL MUXING FOR VF610. This function is not called */
-	static const dmamux_cfg_t dma_channels [] = {
-		DMAMUX_CHANNEL(DMAMUX_0, 0, VF610_DMAREQSRC_UART0_RX, 0, 1), /* DMAMUX 0, Channel 0 => UART0_RX, no trigger, channel enable */
-		DMAMUX_CHANNEL(DMAMUX_1, 8, VF610_DMAREQSRC_UART4_RX, 0, 1), /* DMAMUX 1, Channel 8 => UART0_RX, no trigger, channel enable */
-		DMAMUX_CHANNEL(DMAMUX_2, 4, VF610_DMAREQSRC_SPI2_RX, 0, 1), /* DMAMUX 2, Channel 4  => SPI2_RX, no trigger, channel enable */
-		DMAMUX_CHANNEL(DMAMUX_3, 12, VF610_DMAREQSRC_I2C1_TX, 0, 1), /* DMAMUX 3, Channel 12 => I2C1_TX, no trigger, channel enable */
-	};
-	imx_dmamux_setup_multiple_channels(dma_channels, ARRAY_SIZE(dma_channels));
+		writew(MSCM_IRSPRC_CP0_EN, &mscmir->irsprc[i]);
 }
 
-
 int board_phy_config(struct phy_device *phydev)
 {
 	if (phydev->drv->config)
diff --git a/board/freescale/vf610twr/vf610twr_int_routing.h b/board/freescale/vf610twr/vf610twr_int_routing.h
deleted file mode 100644
index 6eb37319d1..0000000000
--- a/board/freescale/vf610twr/vf610twr_int_routing.h
+++ /dev/null
@@ -1,133 +0,0 @@
-/*
- * Copyright 2014 Freescale Semiconductor, Inc.
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License as
- * published by the Free Software Foundation; either version 2 of
- * the License, or (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
- * MA 02111-1307 USA
- */
-
-static const u8 int_routing_conf[] = {
-	MSCM_IRSPRC_ROUTE_TO_CA5,	/* DMA0 Transfer Complete CH0-31 */
-	MSCM_IRSPRC_ROUTE_TO_CA5,	/* DMA0 Error Interrupt CH0-31 */
-	MSCM_IRSPRC_ROUTE_TO_CA5,	/* DMA1 Transfer Complete CH0-31 */
-	MSCM_IRSPRC_ROUTE_TO_CA5,	/* DMA1 Transfer Complete CH0-31 */
-	MSCM_IRSPRC_ROUTE_TO_CA5,
-	MSCM_IRSPRC_ROUTE_TO_CA5,
-	MSCM_IRSPRC_ROUTE_TO_CA5,	/* MSCM-ECC0 */
-	MSCM_IRSPRC_ROUTE_TO_CA5,	/* MSCM-ECC1 */
-	MSCM_IRSPRC_ROUTE_TO_CA5,	/* CSU Alarm */
-	MSCM_IRSPRC_ROUTE_TO_CA5,
-	MSCM_IRSPRC_ROUTE_TO_CA5,	/* MSCM-ACTZS */
-	MSCM_IRSPRC_ROUTE_TO_CA5,
-	MSCM_IRSPRC_ROUTE_TO_CA5,	/* WDOG-A5 */
-	MSCM_IRSPRC_ROUTE_TO_CA5,	/* WDOG-M4 */
-	MSCM_IRSPRC_ROUTE_TO_CA5,	/* WDOG-SNVS */
-	MSCM_IRSPRC_ROUTE_TO_CA5,	/* CP1 Boot Fail */
-	MSCM_IRSPRC_ROUTE_TO_CA5,	/* QSPI0 */
-	MSCM_IRSPRC_ROUTE_TO_CA5,	/* QSPI1 */
-	MSCM_IRSPRC_ROUTE_TO_CA5,	/*DDRMC */
-	MSCM_IRSPRC_ROUTE_TO_CA5,	/*SDHC0 */
-	MSCM_IRSPRC_ROUTE_TO_CA5,	/*SDHC1 */
-	MSCM_IRSPRC_ROUTE_TO_CA5,
-	MSCM_IRSPRC_ROUTE_TO_CA5,	/*DCU0 */
-	MSCM_IRSPRC_ROUTE_TO_CA5,	/*DCU1 */
-	MSCM_IRSPRC_ROUTE_TO_CA5,	/*VIU */
-	MSCM_IRSPRC_ROUTE_TO_CA5,
-	MSCM_IRSPRC_ROUTE_TO_CA5,
-	MSCM_IRSPRC_ROUTE_TO_CA5,	/*RLE */
-	MSCM_IRSPRC_ROUTE_TO_CA5,	/*SEG LCD*/
-	MSCM_IRSPRC_ROUTE_TO_CA5,
-	MSCM_IRSPRC_ROUTE_TO_CA5,
-	MSCM_IRSPRC_ROUTE_TO_CA5,	/*PIT */
-	MSCM_IRSPRC_ROUTE_TO_CA5,	/*LPTimer 0*/
-	MSCM_IRSPRC_ROUTE_TO_CA5,
-	MSCM_IRSPRC_ROUTE_TO_CA5,	/*FlexTimer 0 */
-	MSCM_IRSPRC_ROUTE_TO_CA5,	/*FlexTimer 1 */
-	MSCM_IRSPRC_ROUTE_TO_CA5,	/*FlexTimer 2 */
-	MSCM_IRSPRC_ROUTE_TO_CA5,	/*FlexTimer 3 */
-	MSCM_IRSPRC_ROUTE_TO_CA5,
-	MSCM_IRSPRC_ROUTE_TO_CA5,
-	MSCM_IRSPRC_ROUTE_TO_CA5,
-	MSCM_IRSPRC_ROUTE_TO_CA5,
-	MSCM_IRSPRC_ROUTE_TO_CA5,	/*ANADIG - USB PHY 0 */
-	MSCM_IRSPRC_ROUTE_TO_CA5,	/*ANADIG - USB PHY 1 */
-	MSCM_IRSPRC_ROUTE_TO_CA5,
-	MSCM_IRSPRC_ROUTE_TO_CA5,	/*ADC 0 */
-	MSCM_IRSPRC_ROUTE_TO_CA5,	/*ADC 1 */
-	MSCM_IRSPRC_ROUTE_TO_CA5,	/*DAC 0 */
-	MSCM_IRSPRC_ROUTE_TO_CA5,	/*DAC 1 */
-	MSCM_IRSPRC_ROUTE_TO_CA5,
-	MSCM_IRSPRC_ROUTE_TO_CA5,	/*FlexCAN 0 */
-	MSCM_IRSPRC_ROUTE_TO_CA5,	/*FlexCAN 1 */
-	MSCM_IRSPRC_ROUTE_TO_CA5,
-	MSCM_IRSPRC_ROUTE_TO_CA5,	/*UART 0 */
-	MSCM_IRSPRC_ROUTE_TO_CA5,	/*UART 1 */
-	MSCM_IRSPRC_ROUTE_TO_CA5,	/*UART 2 */
-	MSCM_IRSPRC_ROUTE_TO_CA5,	/*UART 3 */
-	MSCM_IRSPRC_ROUTE_TO_CA5,	/*UART 4 */
-	MSCM_IRSPRC_ROUTE_TO_CA5,	/*UART 5 */
-	MSCM_IRSPRC_ROUTE_TO_CA5,	/*SPI 0 */
-	MSCM_IRSPRC_ROUTE_TO_CA5,	/*SPI 1 */
-	MSCM_IRSPRC_ROUTE_TO_CA5,	/*SPI 2 */
-	MSCM_IRSPRC_ROUTE_TO_CA5,	/*SPI 3 */
-	MSCM_IRSPRC_ROUTE_TO_CA5,	/*I2C 0 */
-	MSCM_IRSPRC_ROUTE_TO_CA5,	/*I2C 1 */
-	MSCM_IRSPRC_ROUTE_TO_CA5,	/*I2C 2 */
-	MSCM_IRSPRC_ROUTE_TO_CA5,	/*I2C 3 */
-	MSCM_IRSPRC_ROUTE_TO_CA5,	/*USBC 0 */
-	MSCM_IRSPRC_ROUTE_TO_CA5,	/*USBC 1 */
-	MSCM_IRSPRC_ROUTE_TO_CA5,
-	MSCM_IRSPRC_ROUTE_TO_CA5,	/*ENET 0 */
-	MSCM_IRSPRC_ROUTE_TO_CA5,	/*ENET 1 */
-	MSCM_IRSPRC_ROUTE_TO_CA5,	/*1588 Timer 0 */
-	MSCM_IRSPRC_ROUTE_TO_CA5,	/*1588 Timer 1 */
-	MSCM_IRSPRC_ROUTE_TO_CA5,	/*ENET Switch */
-	MSCM_IRSPRC_ROUTE_TO_CA5,	/*NFC */
-	MSCM_IRSPRC_ROUTE_TO_CA5,	/* SAI 0 */
-	MSCM_IRSPRC_ROUTE_TO_CA5,	/* SAI 1 */
-	MSCM_IRSPRC_ROUTE_TO_CA5,	/* SAI 2 */
-	MSCM_IRSPRC_ROUTE_TO_CA5,	/* SAI 3 */
-	MSCM_IRSPRC_ROUTE_TO_CA5,	/* ESAI BIFIFO */
-	MSCM_IRSPRC_ROUTE_TO_CA5,	/* SPDIF */
-	MSCM_IRSPRC_ROUTE_TO_CA5,	/* ASRC */
-	MSCM_IRSPRC_ROUTE_TO_CA5,	/* VREG - HVD Interrupt */
-	MSCM_IRSPRC_ROUTE_TO_CA5,	/* WKUP 0 */
-	MSCM_IRSPRC_ROUTE_TO_CA5,
-	MSCM_IRSPRC_ROUTE_TO_CA5,	/* CCM - FXOSC Ready */
-	MSCM_IRSPRC_ROUTE_TO_CA5,	/* CCM - PLLs */
-	MSCM_IRSPRC_ROUTE_TO_CA5,	/* SRC */
-	MSCM_IRSPRC_ROUTE_TO_CA5,	/* PDB */
-	MSCM_IRSPRC_ROUTE_TO_CA5,	/* EWM */
-	MSCM_IRSPRC_ROUTE_TO_CA5,
-	MSCM_IRSPRC_ROUTE_TO_CA5,
-	MSCM_IRSPRC_ROUTE_TO_CA5,
-	MSCM_IRSPRC_ROUTE_TO_CA5,
-	MSCM_IRSPRC_ROUTE_TO_CA5,
-	MSCM_IRSPRC_ROUTE_TO_CA5,
-	MSCM_IRSPRC_ROUTE_TO_CA5,
-	MSCM_IRSPRC_ROUTE_TO_CA5,
-	MSCM_IRSPRC_ROUTE_TO_CA5,	/* GPIO 0 */
-	MSCM_IRSPRC_ROUTE_TO_CA5,	/* GPIO 1 */
-	MSCM_IRSPRC_ROUTE_TO_CA5,	/* GPIO 2 */
-	MSCM_IRSPRC_ROUTE_TO_CA5,	/* GPIO 3 */
-	MSCM_IRSPRC_ROUTE_TO_CA5,	/* GPIO 4 */
-	MSCM_IRSPRC_ROUTE_TO_CA5,
-	MSCM_IRSPRC_ROUTE_TO_CA5,
-	MSCM_IRSPRC_ROUTE_TO_CA5,
-	MSCM_IRSPRC_ROUTE_TO_CA5,
-	MSCM_IRSPRC_ROUTE_TO_CA5,
-	MSCM_IRSPRC_ROUTE_TO_CA5,
-	MSCM_IRSPRC_ROUTE_TO_CA5,
-	MSCM_IRSPRC_ROUTE_TO_CA5,
-};
diff --git a/drivers/mtd/nand/mpc5125_nfc.c b/drivers/mtd/nand/mpc5125_nfc.c
deleted file mode 100644
index 1e789bd057..0000000000
--- a/drivers/mtd/nand/mpc5125_nfc.c
+++ /dev/null
@@ -1,894 +0,0 @@
-/*
- * Copyright 2009-2012 Freescale Semiconductor, Inc.
- *
- *
- * Description:
- * MPC5125 Nand driver.
- * Port to m54418twr/Vybrid board.
- *
- * Based on original driver mpc5121_nfc.c.
- *
- * This is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- */
-
-#include <common.h>
-#include <malloc.h>
-
-#include <linux/mtd/mtd.h>
-#include <linux/mtd/nand.h>
-#include <linux/mtd/nand_ecc.h>
-#include <linux/compat.h>
-
-#include <mtd/fsl_nfc.h>
-
-#include <nand.h>
-#include <errno.h>
-#include <asm/io.h>
-#include <asm/processor.h>
-
-#ifdef CONFIG_COLDFIRE
-#include <asm/immap.h>
-#endif
-
-#define	DRV_NAME		"fsl_nfc"
-#define	DRV_VERSION		"0.5"
-
-/* Timeouts */
-#define NFC_RESET_TIMEOUT	1000	/* 1 ms */
-#define NFC_TIMEOUT		5000	/* 1/10 s */
-#define ECC_SRAM_ADDR		(0x840 >> 3)
-#define ECC_STATUS_MASK	0x80
-#define ECC_ERR_COUNT	0x3F
-
-/*#define CONFIG_MTD_NAND_FSL_NFC_SWECC*/
-
-#ifdef CONFIG_MTD_NAND_FSL_NFC_SWECC
-static int hardware_ecc;
-#else
-static int hardware_ecc = 1;
-#endif
-
-struct fsl_nfc_prv {
-	struct mtd_info		mtd;
-	struct nand_chip	chip;
-	int			irq;
-	void __iomem		*regs;
-	struct clk		*clk;
-	uint			column;
-	int			spareonly;
-	u8			*testbuf;
-	int			pg_boot;
-	int			page;
-};
-
-int fsl_nfc_chip;
-
-static int get_status;
-static int get_id;
-
-static u8 bbt_pattern[] = {'B', 'b', 't', '0' };
-static u8 mirror_pattern[] = {'1', 't', 'b', 'B' };
-
-static struct nand_bbt_descr bbt_main_descr = {
-	.options = NAND_BBT_LASTBLOCK | NAND_BBT_CREATE | NAND_BBT_WRITE |
-		   NAND_BBT_2BIT | NAND_BBT_VERSION,
-	.offs =	11,
-	.len = 4,
-	.veroffs = 15,
-	.maxblocks = 4,
-	.pattern = bbt_pattern,
-};
-
-static struct nand_bbt_descr bbt_mirror_descr = {
-	.options = NAND_BBT_LASTBLOCK | NAND_BBT_CREATE | NAND_BBT_WRITE |
-		   NAND_BBT_2BIT | NAND_BBT_VERSION,
-	.offs =	11,
-	.len = 4,
-	.veroffs = 15,
-	.maxblocks = 4,
-	.pattern = mirror_pattern,
-};
-
-static struct nand_ecclayout fsl_nfc_ecc45 = {
-	.eccbytes = 45,
-	.eccpos = {19, 20, 21, 22, 23,
-		   24, 25, 26, 27, 28, 29, 30, 31,
-		   32, 33, 34, 35, 36, 37, 38, 39,
-		   40, 41, 42, 43, 44, 45, 46, 47,
-		   48, 49, 50, 51, 52, 53, 54, 55,
-		   56, 57, 58, 59, 60, 61, 62, 63},
-	.oobfree = {
-		{.offset = 8,
-		.length = 11} }
-};
-
-static inline u32 nfc_read(struct mtd_info *mtd, uint reg)
-{
-	struct nand_chip *chip = mtd->priv;
-	struct fsl_nfc_prv *prv = chip->priv;
-#ifdef CONFIG_COLDFIRE
-	return in_be32(prv->regs + reg);
-#else
-	return in_le32(prv->regs + reg);
-#endif
-}
-
-/* Write NFC register */
-static inline void nfc_write(struct mtd_info *mtd, uint reg, u32 val)
-{
-	struct nand_chip *chip = mtd->priv;
-	struct fsl_nfc_prv *prv = chip->priv;
-#ifdef CONFIG_COLDFIRE
-	out_be32(prv->regs + reg, val);
-#else
-	out_le32(prv->regs + reg, val);
-#endif
-}
-
-/* Set bits in NFC register */
-static inline void nfc_set(struct mtd_info *mtd, uint reg, u32 bits)
-{
-	nfc_write(mtd, reg, nfc_read(mtd, reg) | bits);
-}
-
-/* Clear bits in NFC register */
-static inline void nfc_clear(struct mtd_info *mtd, uint reg, u32 bits)
-{
-	nfc_write(mtd, reg, nfc_read(mtd, reg) & ~bits);
-}
-
-static inline void
-nfc_set_field(struct mtd_info *mtd, u32 reg, u32 mask, u32 shift, u32 val)
-{
-	struct nand_chip *chip = mtd->priv;
-	struct fsl_nfc_prv *prv = chip->priv;
-#ifdef CONFIG_COLDFIRE
-	out_be32(prv->regs + reg,
-			(in_be32(prv->regs + reg) & (~mask))
-			| val << shift);
-#else
-	out_le32(prv->regs + reg,
-			(in_le32(prv->regs + reg) & (~mask))
-			| val << shift);
-#endif
-}
-
-static inline int
-nfc_get_field(struct mtd_info *mtd, u32 reg, u32 field_mask)
-{
-	struct nand_chip *chip = mtd->priv;
-	struct fsl_nfc_prv *prv = chip->priv;
-#ifdef CONFIG_COLDFIRE
-	return in_be32(prv->regs + reg) & field_mask;
-#else
-	return in_le32(prv->regs + reg) & field_mask;
-#endif
-}
-
-static inline u8 nfc_check_status(struct mtd_info *mtd)
-{
-	u8 fls_status = 0;
-	fls_status = nfc_get_field(mtd, NFC_FLASH_STATUS2, STATUS_BYTE1_MASK);
-	return fls_status;
-}
-
-/* clear cmd_done and cmd_idle falg for the coming command */
-static void fsl_nfc_clear(struct mtd_info *mtd)
-{
-	nfc_write(mtd, NFC_IRQ_STATUS, 1 << CMD_DONE_CLEAR_SHIFT);
-	nfc_write(mtd, NFC_IRQ_STATUS, 1 << IDLE_CLEAR_SHIFT);
-}
-
-/* Wait for operation complete */
-static void fsl_nfc_done(struct mtd_info *mtd)
-{
-	uint start = 0;
-
-	nfc_set_field(mtd, NFC_FLASH_CMD2, START_MASK,
-			START_SHIFT, 1);
-
-	start = get_timer(0);
-
-	while (!nfc_get_field(mtd, NFC_IRQ_STATUS, IDLE_IRQ_MASK)) {
-		if (get_timer(start) > NFC_TIMEOUT)
-			printf("Timeout while waiting for BUSY.\n");
-	}
-	fsl_nfc_clear(mtd);
-}
-
-static u8 fsl_nfc_get_id(struct mtd_info *mtd, int col)
-{
-	u32 flash_id1 = 0;
-	u8 *pid;
-
-	flash_id1 = nfc_read(mtd, NFC_FLASH_STATUS1);
-	pid = (u8 *)&flash_id1;
-#ifdef CONFIG_COLDFIRE
-	return *(pid + col);
-#else
-	return *(pid + 3 - col);
-#endif
-}
-
-static inline u8 fsl_nfc_get_status(struct mtd_info *mtd)
-{
-	u32 flash_status = 0;
-	u8 *pstatus;
-
-	flash_status = nfc_read(mtd, NFC_FLASH_STATUS2);
-	pstatus = (u8 *)&flash_status;
-#ifdef CONFIG_COLDFIRE
-	return *(pstatus + 3);
-#else
-	return *(pstatus);
-#endif
-}
-
-/* Invoke command cycle */
-static inline void
-fsl_nfc_send_cmd(struct mtd_info *mtd, u32 cmd_byte1,
-		u32 cmd_byte2, u32 cmd_code)
-{
-	fsl_nfc_clear(mtd);
-	nfc_set_field(mtd, NFC_FLASH_CMD2, CMD_BYTE1_MASK,
-			CMD_BYTE1_SHIFT, cmd_byte1);
-
-	nfc_set_field(mtd, NFC_FLASH_CMD1, CMD_BYTE2_MASK,
-			CMD_BYTE2_SHIFT, cmd_byte2);
-
-	nfc_set_field(mtd, NFC_FLASH_CMD2, BUFNO_MASK,
-			BUFNO_SHIFT, 0);
-
-	nfc_set_field(mtd, NFC_FLASH_CMD2, CMD_CODE_MASK,
-			CMD_CODE_SHIFT, cmd_code);
-
-	if (cmd_code == RANDOM_OUT_CMD_CODE)
-		nfc_set_field(mtd, NFC_FLASH_CMD2, BUFNO_MASK,
-			BUFNO_SHIFT, 1);
-}
-
-/* Receive ID and status from NAND flash */
-static inline void
-fsl_nfc_send_one_byte(struct mtd_info *mtd, u32 cmd_byte1, u32 cmd_code)
-{
-	fsl_nfc_clear(mtd);
-
-	nfc_set_field(mtd, NFC_FLASH_CMD2, CMD_BYTE1_MASK,
-			CMD_BYTE1_SHIFT, cmd_byte1);
-
-	nfc_set_field(mtd, NFC_FLASH_CMD2, BUFNO_MASK,
-			BUFNO_SHIFT, 0);
-
-	nfc_set_field(mtd, NFC_FLASH_CMD2, CMD_CODE_MASK,
-			CMD_CODE_SHIFT, cmd_code);
-}
-
-
-/* Do address cycle(s) */
-static void
-fsl_nfc_addr_cycle(struct mtd_info *mtd, int column, int page)
-{
-
-	if (column != -1) {
-		nfc_set_field(mtd, NFC_COL_ADDR,
-				COL_ADDR_MASK,
-				COL_ADDR_SHIFT, column);
-	}
-
-	if (page != -1) {
-		nfc_set_field(mtd, NFC_ROW_ADDR,
-				ROW_ADDR_MASK,
-				ROW_ADDR_SHIFT, page);
-	}
-
-	/* DMA Disable */
-	nfc_clear(mtd, NFC_FLASH_CONFIG, CONFIG_DMA_REQ_MASK);
-
-	/* PAGE_CNT = 1 */
-	nfc_set_field(mtd, NFC_FLASH_CONFIG, CONFIG_PAGE_CNT_MASK,
-			CONFIG_PAGE_CNT_SHIFT, 0x1);
-}
-
-
-/* Control chips select signal on the board */
-static void
-nfc_select_chip(struct mtd_info *mtd, int chip)
-{
-#ifdef CONFIG_COLDFIRE
-	volatile gpio_t *gpio = (gpio_t *) MMAP_GPIO;
-
-	if (chip < 0) {
-		gpio->par_fbctl &= (GPIO_PAR_FBCTL_ALE_MASK &
-				   GPIO_PAR_FBCTL_TA_MASK);
-		gpio->par_fbctl |= GPIO_PAR_FBCTL_ALE_FB_TS |
-				   GPIO_PAR_FBCTL_TA_TA;
-		gpio->par_be =
-		    GPIO_PAR_BE_BE3_BE3 | GPIO_PAR_BE_BE2_BE2 |
-		    GPIO_PAR_BE_BE1_BE1 | GPIO_PAR_BE_BE0_BE0;
-		gpio->par_cs &= ~GPIO_PAR_CS_CS1_NFC_CE;
-		gpio->par_cs = GPIO_PAR_CS_CS0_CS0;
-		return;
-	}
-
-	gpio->par_fbctl &= (GPIO_PAR_FBCTL_ALE_MASK & GPIO_PAR_FBCTL_TA_MASK);
-	gpio->par_fbctl |= GPIO_PAR_FBCTL_ALE_FB_ALE |
-			   GPIO_PAR_FBCTL_TA_NFC_RB;
-	gpio->par_be =
-	    GPIO_PAR_BE_BE3_FB_A1 | GPIO_PAR_BE_BE2_FB_A0 |
-	    GPIO_PAR_BE_BE1_BE1 | GPIO_PAR_BE_BE0_BE0;
-	gpio->par_cs &= (GPIO_PAR_BE_BE3_MASK & GPIO_PAR_BE_BE2_MASK);
-	gpio->par_cs = GPIO_PAR_CS_CS1_NFC_CE;
-#endif
-}
-
-void board_nand_select_device(struct nand_chip *nand, int chip)
-{
-	fsl_nfc_chip = chip;
-}
-
-/* Read NAND Ready/Busy signal */
-static int
-fsl_nfc_dev_ready(struct mtd_info *mtd)
-{
-	/*
-	 * NFC handles ready/busy signal internally. Therefore, this function
-	 * always returns status as ready.
-	 */
-	return 1;
-}
-
-/* Write command to NAND flash */
-static void
-fsl_nfc_command(struct mtd_info *mtd, unsigned command,
-					int column, int page)
-{
-	struct nand_chip *chip = mtd->priv;
-	struct fsl_nfc_prv *prv = chip->priv;
-
-	prv->column = (column >= 0) ? column : 0;
-	prv->spareonly = 0;
-	get_id = 0;
-	get_status = 0;
-
-	if (page != -1)
-		prv->page = page;
-
-	if (!prv->pg_boot) {
-
-		if (hardware_ecc)
-			nfc_set_field(mtd, NFC_FLASH_CONFIG,
-				CONFIG_ECC_MODE_MASK,
-				CONFIG_ECC_MODE_SHIFT, ECC_45_BYTE);
-		else
-			/* set ECC BY_PASS */
-			nfc_set_field(mtd, NFC_FLASH_CONFIG,
-				CONFIG_ECC_MODE_MASK,
-				CONFIG_ECC_MODE_SHIFT, ECC_BYPASS);
-
-		if (!(page%0x40))
-			nfc_set_field(mtd, NFC_FLASH_CONFIG,
-				CONFIG_ECC_MODE_MASK,
-				CONFIG_ECC_MODE_SHIFT, ECC_BYPASS);
-	}
-
-	switch (command) {
-	case NAND_CMD_PAGEPROG:
-		if (!(prv->page%0x40) && !prv->pg_boot)
-			nfc_set_field(mtd, NFC_FLASH_CONFIG,
-				CONFIG_ECC_MODE_MASK,
-				CONFIG_ECC_MODE_SHIFT, ECC_BYPASS);
-
-		fsl_nfc_send_cmd(mtd,
-				PROGRAM_PAGE_CMD_BYTE1,
-				PROGRAM_PAGE_CMD_BYTE2,
-				PROGRAM_PAGE_CMD_CODE);
-		break;
-	/*
-	 * NFC does not support sub-page reads and writes,
-	 * so emulate them using full page transfers.
-	 */
-	case NAND_CMD_READ0:
-		column = 0;
-		goto read0;
-		break;
-
-	case NAND_CMD_READ1:
-		prv->column += 256;
-		command = NAND_CMD_READ0;
-		column = 0;
-		goto read0;
-		break;
-
-	case NAND_CMD_READOOB:
-		prv->spareonly = 1;
-		command = NAND_CMD_READ0;
-		column = 0;
-read0:
-		fsl_nfc_send_cmd(mtd,
-				PAGE_READ_CMD_BYTE1,
-				PAGE_READ_CMD_BYTE2,
-				READ_PAGE_CMD_CODE);
-		break;
-
-	case NAND_CMD_SEQIN:
-		fsl_nfc_command(mtd, NAND_CMD_READ0, column, page);
-		column = 0;
-		break;
-
-	case NAND_CMD_ERASE1:
-		fsl_nfc_send_cmd(mtd,
-				ERASE_CMD_BYTE1,
-				ERASE_CMD_BYTE2,
-				ERASE_CMD_CODE);
-		break;
-	case NAND_CMD_ERASE2:
-		return;
-	case NAND_CMD_READID:
-		get_id = 1;
-		fsl_nfc_send_one_byte(mtd, command, READ_ID_CMD_CODE);
-		break;
-	case NAND_CMD_STATUS:
-		get_status = 1;
-		fsl_nfc_send_one_byte(mtd, command, STATUS_READ_CMD_CODE);
-		break;
-	case NAND_CMD_RNDOUT:
-		fsl_nfc_send_cmd(mtd,
-				RANDOM_OUT_CMD_BYTE1,
-				RANDOM_OUT_CMD_BYTE2,
-				RANDOM_OUT_CMD_CODE);
-		break;
-	case NAND_CMD_RESET:
-		fsl_nfc_send_one_byte(mtd, command, RESET_CMD_CODE);
-		break;
-	default:
-		return;
-	}
-
-	fsl_nfc_addr_cycle(mtd, column, page);
-
-	fsl_nfc_done(mtd);
-}
-
-/* Copy data from/to NFC spare buffers. */
-static void
-fsl_nfc_copy_spare(struct mtd_info *mtd, uint offset,
-			u8 *buffer, uint size, int wr)
-{
-	struct nand_chip *nand = mtd->priv;
-	struct fsl_nfc_prv *prv = nand->priv;
-	uint o, s, sbsize, blksize;
-
-	/*
-	 * NAND spare area is available through NFC spare buffers.
-	 * The NFC divides spare area into (page_size / 512) chunks.
-	 * Each chunk is placed into separate spare memory area, using
-	 * first (spare_size / num_of_chunks) bytes of the buffer.
-	 *
-	 * For NAND device in which the spare area is not divided fully
-	 * by the number of chunks, number of used bytes in each spare
-	 * buffer is rounded down to the nearest even number of bytes,
-	 * and all remaining bytes are added to the last used spare area.
-	 *
-	 * For more information read section 26.6.10 of MPC5121e
-	 * Microcontroller Reference Manual, Rev. 3.
-	 */
-
-	/* Calculate number of valid bytes in each spare buffer */
-/*	sbsize = (mtd->oobsize / (mtd->writesize / 512)) & ~1;*/
-	sbsize = (mtd->oobsize / (mtd->writesize / 2048)) & ~1;
-
-
-	while (size) {
-		/* Calculate spare buffer number */
-		s = offset / sbsize;
-		if (s > NFC_SPARE_BUFFERS - 1)
-			s = NFC_SPARE_BUFFERS - 1;
-
-		/*
-		 * Calculate offset to requested data block in selected spare
-		 * buffer and its size.
-		 */
-		o = offset - (s * sbsize);
-		blksize = min(sbsize - o, size);
-
-		if (wr)
-			memcpy(prv->regs + NFC_SPARE_AREA(s) + o,
-							buffer, blksize);
-		else {
-			memcpy(buffer,
-				prv->regs + NFC_SPARE_AREA(s) + o, blksize);
-		}
-
-		buffer += blksize;
-		offset += blksize;
-		size -= blksize;
-	};
-}
-
-/* Copy data from/to NFC main and spare buffers */
-static void
-fsl_nfc_buf_copy(struct mtd_info *mtd, u_char *buf, int len, int wr)
-{
-	struct nand_chip *chip = mtd->priv;
-	struct fsl_nfc_prv *prv = chip->priv;
-	uint c = prv->column;
-	uint l;
-
-	/* Handle spare area access */
-	if (prv->spareonly || c >= mtd->writesize) {
-		/* Calculate offset from beginning of spare area */
-		if (c >= mtd->writesize)
-			c -= mtd->writesize;
-
-		prv->column += len;
-		fsl_nfc_copy_spare(mtd, c, buf, len, wr);
-		return;
-	}
-
-	/*
-	 * Handle main area access - limit copy length to prevent
-	 * crossing main/spare boundary.
-	 */
-	l = min((uint)len, mtd->writesize - c);
-	prv->column += l;
-
-	if (wr)
-		memcpy(prv->regs + NFC_MAIN_AREA(0) + c, buf, l);
-	else {
-		if (get_status) {
-			get_status = 0;
-			*buf = fsl_nfc_get_status(mtd);
-		} else if (l == 1 && c <= 3 && get_id) {
-			*buf = fsl_nfc_get_id(mtd, c);
-		} else
-			memcpy(buf, prv->regs + NFC_MAIN_AREA(0) + c, l);
-	}
-
-	/* Handle crossing main/spare boundary */
-	if (l != len) {
-		buf += l;
-		len -= l;
-		fsl_nfc_buf_copy(mtd, buf, len, wr);
-	}
-}
-
-/* Read data from NFC buffers */
-static void
-fsl_nfc_read_buf(struct mtd_info *mtd, u_char *buf, int len)
-{
-	fsl_nfc_buf_copy(mtd, buf, len, 0);
-}
-
-/* Write data to NFC buffers */
-static void
-fsl_nfc_write_buf(struct mtd_info *mtd, const u_char *buf, int len)
-{
-	fsl_nfc_buf_copy(mtd, (u_char *)buf, len, 1);
-}
-
-/* Compare buffer with NAND flash */
-static int
-fsl_nfc_verify_buf(struct mtd_info *mtd, const u_char *buf, int len)
-{
-	u_char tmp[256];
-	uint bsize;
-
-	while (len) {
-		bsize = min(len, 256);
-		fsl_nfc_read_buf(mtd, tmp, bsize);
-
-		if (memcmp(buf, tmp, bsize))
-			return 1;
-
-		buf += bsize;
-		len -= bsize;
-	}
-
-	return 0;
-}
-
-/* Read byte from NFC buffers */
-static u8
-fsl_nfc_read_byte(struct mtd_info *mtd)
-{
-	u8 tmp;
-	fsl_nfc_read_buf(mtd, &tmp, sizeof(tmp));
-	return tmp;
-}
-
-/* Read word from NFC buffers */
-static u16
-fsl_nfc_read_word(struct mtd_info *mtd)
-{
-	u16 tmp;
-	fsl_nfc_read_buf(mtd, (u_char *)&tmp, sizeof(tmp));
-	return tmp;
-}
-
-static void
-copy_from_to_spare(struct mtd_info *mtd, void *pbuf, int len, int wr)
-{
-	struct nand_chip *chip = mtd->priv;
-	struct fsl_nfc_prv *prv = chip->priv;
-	int i = 0, copy_count, copy_size;
-
-	copy_count = mtd->writesize / 2048;
-	/*
-	 * Each spare area has 16 bytes for 512, 2K and normal 4K nand.
-	 * For 4K nand with large 218 byte spare size, the size is 26 bytes for
-	 * the first 7 buffers and 36 for the last.
-	 */
-	copy_size = 64;
-	/*
-	 * Each spare area has 16 bytes for 512, 2K and normal 4K nand.
-	 * For 4K nand with large 218 byte spare size, the size is 26
-	 * bytes for the first 7 buffers and 36 for the last.
-	 */
-	for (i = 0; i < copy_count - 1 && len > 0; i++) {
-		if (wr)
-			memcpy(prv->regs + NFC_SPARE_AREA(i),
-					pbuf, MIN(len, copy_size));
-		else
-			memcpy(pbuf, prv->regs + NFC_SPARE_AREA(i),
-					MIN(len, copy_size));
-		pbuf += copy_size;
-		len -= copy_size;
-	}
-	if (len > 0) {
-		if (wr)
-			memcpy(prv->regs + NFC_SPARE_AREA(i),
-				pbuf, len);
-		else
-			memcpy(pbuf,
-				prv->regs + NFC_SPARE_AREA(i), len);
-	}
-}
-
-
-static int fsl_nfc_read_oob(struct mtd_info *mtd, struct nand_chip *chip,
-				int page)
-{
-	fsl_nfc_command(mtd, NAND_CMD_READ0, 0, page);
-	copy_from_to_spare(mtd, chip->oob_poi, mtd->oobsize, 0);
-	return 0;
-}
-
-static int fsl_nfc_write_oob(struct mtd_info *mtd, struct nand_chip *chip,
-					int page)
-{
-	fsl_nfc_command(mtd, NAND_CMD_READ0, 0, page);
-
-	fsl_nfc_command(mtd, NAND_CMD_SEQIN, 0, page);
-
-	/* copy the oob data */
-	copy_from_to_spare(mtd, chip->oob_poi, mtd->oobsize, 1);
-
-	fsl_nfc_command(mtd, NAND_CMD_PAGEPROG, 0, page);
-
-	return 0;
-}
-
-static int fsl_nfc_read_page(struct mtd_info *mtd, struct nand_chip *chip,
-					uint8_t *buf, int oob_required, int page)
-{
-	struct fsl_nfc_prv *prv = chip->priv;
-	/*fsl_nfc_check_ecc_status(mtd);*/
-
-	memcpy((void *)buf, prv->regs + NFC_MAIN_AREA(0),
-			mtd->writesize);
-	copy_from_to_spare(mtd, chip->oob_poi, mtd->oobsize, 0);
-	return 0;
-}
-
-static int fsl_nfc_write_page(struct mtd_info *mtd,
-		struct nand_chip *chip, const uint8_t *buf, int oob_required)
-{
-	struct fsl_nfc_prv *prv = chip->priv;
-
-	memcpy(prv->regs + NFC_MAIN_AREA(0), buf, mtd->writesize);
-	copy_from_to_spare(mtd, chip->oob_poi, mtd->oobsize, 1);
-	return 0;
-}
-
-static void fsl_nfc_enable_hwecc(struct mtd_info *mtd, int mode)
-{
-	return;
-}
-
-int board_nand_init(struct nand_chip *chip)
-{
-	struct fsl_nfc_prv *prv;
-	struct mtd_info *mtd;
-	uint chips_no = 0;
-	u8 *testbuf = NULL;
-
-	if (chip->IO_ADDR_R == NULL)
-		return -1;
-
-	prv = malloc(sizeof(*prv));
-	if (!prv) {
-		printf(KERN_ERR DRV_NAME ": Memory exhausted!\n");
-		return -ENOMEM;
-	}
-
-	mtd = &nand_info[chips_no++];
-	mtd->priv = chip;
-	chip->priv = prv;
-
-	prv->regs = (void __iomem *)chip->IO_ADDR_R;
-	prv->testbuf = testbuf;
-	prv->pg_boot = 0;
-
-	mtd->writesize = 2048;
-	mtd->oobsize = 64;
-	chip->dev_ready = fsl_nfc_dev_ready;
-	chip->cmdfunc = fsl_nfc_command;
-	chip->read_byte = fsl_nfc_read_byte;
-	chip->read_word = fsl_nfc_read_word;
-	chip->read_buf = fsl_nfc_read_buf;
-	chip->write_buf = fsl_nfc_write_buf;
-	chip->verify_buf = fsl_nfc_verify_buf;
-	chip->options = NAND_BUSWIDTH_16 | NAND_CACHEPRG;
-        chip->bbt_options = NAND_BBT_USE_FLASH;
-	chip->select_chip = nfc_select_chip;
-
-	if (hardware_ecc) {
-		chip->ecc.read_page = fsl_nfc_read_page;
-		chip->ecc.write_page = fsl_nfc_write_page;
-		chip->ecc.read_oob = fsl_nfc_read_oob;
-		chip->ecc.write_oob = fsl_nfc_write_oob;
-		chip->ecc.layout = &fsl_nfc_ecc45;
-
-		/* propagate ecc.layout to mtd_info */
-		mtd->ecclayout = chip->ecc.layout;
-		chip->ecc.calculate = NULL;
-		chip->ecc.hwctl = fsl_nfc_enable_hwecc;
-		chip->ecc.correct = NULL;
-		chip->ecc.mode = NAND_ECC_HW;
-		/* RS-ECC is applied for both MAIN+SPARE not MAIN alone */
-		chip->ecc.steps = 1;
-		chip->ecc.bytes = 45;
-		chip->ecc.size = 0x800;
-		chip->ecc.strength = 4;
-
-		nfc_set_field(mtd, NFC_FLASH_CONFIG,
-				CONFIG_ECC_MODE_MASK,
-				CONFIG_ECC_MODE_SHIFT, ECC_45_BYTE);
-		/* set ECC_STATUS write position */
-		nfc_set_field(mtd, NFC_FLASH_CONFIG,
-				CONFIG_ECC_SRAM_ADDR_MASK,
-				CONFIG_ECC_SRAM_ADDR_SHIFT, ECC_SRAM_ADDR);
-		/* enable ECC_STATUS results write */
-		nfc_set_field(mtd, NFC_FLASH_CONFIG,
-				CONFIG_ECC_SRAM_REQ_MASK,
-				CONFIG_ECC_SRAM_REQ_SHIFT, 1);
-	} else {
-		chip->ecc.mode = NAND_ECC_SOFT;
-		/* set ECC BY_PASS */
-
-		nfc_set_field(mtd, NFC_FLASH_CONFIG,
-				CONFIG_ECC_MODE_MASK,
-				CONFIG_ECC_MODE_SHIFT, ECC_BYPASS);
-	}
-	chip->bbt_td = &bbt_main_descr;
-	chip->bbt_md = &bbt_mirror_descr;
-	bbt_main_descr.pattern = bbt_pattern;
-	bbt_mirror_descr.pattern = mirror_pattern;
-
-	/* SET SECTOR SIZE */
-	nfc_write(mtd, NFC_SECTOR_SIZE, (PAGE_2K | PAGE_64) + 1);
-
-	nfc_set_field(mtd, NFC_FLASH_CONFIG,
-			CONFIG_ADDR_AUTO_INCR_MASK,
-			CONFIG_ADDR_AUTO_INCR_SHIFT, 0);
-
-	nfc_set_field(mtd, NFC_FLASH_CONFIG,
-			CONFIG_BUFNO_AUTO_INCR_MASK,
-			CONFIG_BUFNO_AUTO_INCR_SHIFT, 0);
-
-	nfc_set_field(mtd, NFC_FLASH_CONFIG,
-			CONFIG_16BIT_MASK,
-			CONFIG_16BIT_SHIFT, 1);
-
-	/* SET FAST_FLASH = 1 */
-	nfc_set_field(mtd, NFC_FLASH_CONFIG,
-			CONFIG_BOOT_MODE_MASK,
-			CONFIG_BOOT_MODE_SHIFT, 0);
-
-	return 0;
-}
-
-int do_nand_boot_update(cmd_tbl_t *cmdtp, int flag,
-		int argc, char * const argv[])
-{
-	ulong mem_addr;
-	size_t data_size;
-	int j;
-	struct mtd_info *mtd;
-	u_char *addr;
-	u32 saved_cfg;
-	struct nand_chip *chip;
-	struct fsl_nfc_prv *prv;
-	nand_info_t *nand;
-
-	if (nand_curr_device < 0 ||
-		nand_curr_device >= CONFIG_SYS_MAX_NAND_DEVICE ||
-		!nand_info[nand_curr_device].name) {
-		puts("\nno devices available\n");
-		return 1;
-	}
-
-
-	mtd =  &nand_info[nand_curr_device];
-	nand = &nand_info[nand_curr_device];
-	chip = mtd->priv;
-	prv = chip->priv;
-
-	prv->pg_boot = 1;
-
-	if (argc < 3) {
-		cmd_usage(cmdtp);
-		return -1;
-	}
-
-	strict_strtoul(argv[1], 16, &mem_addr);
-	strict_strtoul(argv[2], 16, &data_size);
-
-	saved_cfg = nfc_read(mtd, NFC_FLASH_CONFIG);
-
-	nfc_write(mtd, NFC_FLASH_CONFIG, 0x000ea671);
-	memcpy((void *)CONFIG_SYS_NAND_BASE, (unsigned char *)mem_addr, 0xf80);
-
-	nfc_write(mtd, NFC_FLASH_CMD1, 0x10000000);
-	nfc_write(mtd, NFC_FLASH_CONFIG, 0x000ea631);
-	nfc_write(mtd, NFC_SECTOR_SIZE, 0x0000420);
-	nfc_write(mtd, NFC_FLASH_COMMAND_REPEAT, 0x0);
-
-	/*program the first 4 pages.*/
-	nfc_select_chip(mtd, 0);
-	for (j = 0; j < 4; j++) {
-		nfc_write(mtd, NFC_ROW_ADDR, 0x11000000 + j);
-		nfc_write(mtd, NFC_COL_ADDR, 0x00);
-
-		nfc_write(mtd, NFC_FLASH_CMD2, 0x807e0000);
-		fsl_nfc_done(mtd);
-		nfc_write(mtd, NFC_FLASH_CMD2, 0x8001c000 + j*2);
-		fsl_nfc_done(mtd);
-
-	}
-	nfc_select_chip(mtd, -1);
-
-	/*program the other part*/
-
-	fsl_nfc_clear(mtd);
-
-	nfc_write(mtd, NFC_FLASH_CONFIG, 0x000e0681);
-
-	nfc_write(mtd, NFC_SECTOR_SIZE, (PAGE_2K | PAGE_64) + 1);
-
-	nfc_write(mtd, NFC_FLASH_CMD2, 0x007ee000);
-	nfc_write(mtd, NFC_ROW_ADDR, 0x11000000);
-
-	addr = (u_char *)mem_addr + 0xf80;
-
-	data_size = ((data_size - 0xf80) + 0x800) & ~(0x800 - 1) ;
-
-
-	if (nand_write_skip_bad(nand, 0x2000, &data_size, NULL, nand->size, addr, 0)) {
-		printf("write nand boot error!\n");
-		return -1;
-	}
-
-	prv->pg_boot = 0;
-
-	nfc_write(mtd, NFC_FLASH_CONFIG, saved_cfg);
-
-	return 0;
-}
-
-U_BOOT_CMD(nb_update, 4, 1, do_nand_boot_update,
-	   "Nand boot update  program",
-	   "mem_addr size");
diff --git a/include/configs/vf610twr.h b/include/configs/vf610twr.h
index 0ec3b1b144..3ab3231943 100644
--- a/include/configs/vf610twr.h
+++ b/include/configs/vf610twr.h
@@ -38,18 +38,6 @@
 #define CONFIG_SYS_FSL_ESDHC_ADDR	0
 #define CONFIG_SYS_FSL_ESDHC_NUM	1
 
-#define CONFIG_SYS_FSL_ERRATUM_ESDHC111
-
-#define CONFIG_CMD_MMC
-#define CONFIG_GENERIC_MMC
-#define CONFIG_CMD_EXT2		/* EXT2 Support			*/
-#define CONFIG_CMD_FAT		/* FAT support			*/
-#define CONFIG_DOS_PARTITION
-
-/* Ethernet config */
-#define CONFIG_CMD_PING
-#define CONFIG_CMD_DHCP
-#define CONFIG_CMD_MII
 #define CONFIG_FEC_MXC
 #define IMX_FEC_BASE			ENET_BASE_ADDR
 #define CONFIG_FEC_XCV_TYPE		RMII
@@ -71,10 +59,6 @@
 #define CONFIG_SYS_SPD_BUS_NUM		0
 
 
-/* Nand Flash Configs */
-
-#define CONFIG_BOOTDELAY		3
-
 #define CONFIG_SYS_LOAD_ADDR		0x82000000
 
 /* We boot from the gfxRAM area of the OCRAM. */
@@ -185,18 +169,6 @@
 	   "else run netboot; fi"
 
 /* Miscellaneous configurable options */
-#define CONFIG_SYS_LONGHELP		/* undef to save memory */
-#define CONFIG_SYS_HUSH_PARSER		/* use "hush" command parser */
-#define CONFIG_SYS_PROMPT_HUSH_PS2	"> "
-#undef CONFIG_AUTO_COMPLETE
-#define CONFIG_SYS_CBSIZE		256	/* Console I/O Buffer Size */
-#define CONFIG_SYS_PBSIZE		\
-			(CONFIG_SYS_CBSIZE + sizeof(CONFIG_SYS_PROMPT) + 16)
-#define CONFIG_SYS_MAXARGS		16	/* max number of command args */
-#define CONFIG_SYS_BARGSIZE		CONFIG_SYS_CBSIZE
-#define CONFIG_CMDLINE_EDITING
-
-#define CONFIG_CMD_MEMTEST
 
 #define CONFIG_SYS_MEMTEST_START	0x80010000
 #define CONFIG_SYS_MEMTEST_END		0x87C00000
diff --git a/include/mtd/fsl_nfc.h b/include/mtd/fsl_nfc.h
deleted file mode 100644
index 2af024a949..0000000000
--- a/include/mtd/fsl_nfc.h
+++ /dev/null
@@ -1,288 +0,0 @@
-/*
- * Copyright 2009-2012 Freescale Semiconductor, Inc.
- *
- * Description:
- * MPC5125/M54418TWR/Vybrid Nand driver.
- *
- * This is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- */
-
-#ifndef MPC5125_NFC_H
-#define MPC5125_NFC_H
-
-/* Addresses for NFC MAIN RAM BUFFER areas */
-#define NFC_MAIN_AREA(n)		((n) *  0x1000)
-
-/* Addresses for NFC SPARE BUFFER areas */
-#define NFC_SPARE_BUFFERS		8
-#define NFC_SPARE_LEN			0x10
-#define NFC_SPARE_AREA(n)		(0x800 + ((n) * NFC_SPARE_LEN))
-
-#define PAGE_2K				0x0800
-#define PAGE_64				0x0040
-
-/* MPC5125 NFC registers */
-/* Typical Flash Commands */
-#define READ_PAGE_CMD_CODE		0x7EE0
-#define PROGRAM_PAGE_CMD_CODE		0x7FC0
-#define ERASE_CMD_CODE			0x4EC0
-#define READ_ID_CMD_CODE		0x4804
-#define RESET_CMD_CODE			0x4040
-#define DMA_PROGRAM_PAGE_CMD_CODE	0xFFC8
-#define RANDOM_IN_CMD_CODE		0x7140
-#define RANDOM_OUT_CMD_CODE		0x70E0
-#define STATUS_READ_CMD_CODE		0x4068
-
-#define PAGE_READ_CMD_BYTE1		0x00
-#define PAGE_READ_CMD_BYTE2		0x30
-#define PROGRAM_PAGE_CMD_BYTE1		0x80
-#define PROGRAM_PAGE_CMD_BYTE2		0x10
-#define READ_STATUS_CMD_BYTE		0x70
-#define ERASE_CMD_BYTE1			0x60
-#define ERASE_CMD_BYTE2			0xD0
-#define READ_ID_CMD_BYTE		0x90
-#define RESET_CMD_BYTE			0xFF
-#define RANDOM_OUT_CMD_BYTE1		0x05
-#define RANDOM_OUT_CMD_BYTE2		0xE0
-
-/* NFC ECC mode define */
-#define ECC_BYPASS			0x0
-#define ECC_8_BYTE			0x1
-#define ECC_12_BYTE			0x2
-#define ECC_15_BYTE			0x3
-#define ECC_23_BYTE			0x4
-#define ECC_30_BYTE			0x5
-#define ECC_45_BYTE			0x6
-#define ECC_60_BYTE			0x7
-#define ECC_ERROR			1
-#define ECC_RIGHT			0
-
-/***************** Module-Relative Register Offsets *************************/
-#define NFC_SRAM_BUFFER			0x0000
-#define NFC_FLASH_CMD1			0x3F00
-#define NFC_FLASH_CMD2			0x3F04
-#define NFC_COL_ADDR			0x3F08
-#define NFC_ROW_ADDR			0x3F0c
-#define NFC_FLASH_COMMAND_REPEAT	0x3F10
-#define NFC_ROW_ADDR_INC		0x3F14
-#define NFC_FLASH_STATUS1		0x3F18
-#define NFC_FLASH_STATUS2		0x3F1c
-#define NFC_DMA1_ADDR			0x3F20
-#define NFC_DMA2_ADDR			0x3F34
-#define NFC_DMA_CONFIG			0x3F24
-#define NFC_CACHE_SWAP			0x3F28
-#define NFC_SECTOR_SIZE			0x3F2c
-#define NFC_FLASH_CONFIG		0x3F30
-#define NFC_IRQ_STATUS			0x3F38
-
-/***************** Module-Relative Register Reset Value *********************/
-#define NFC_SRAM_BUFFER_RSTVAL			0x00000000
-#define NFC_FLASH_CMD1_RSTVAL			0x30FF0000
-#define NFC_FLASH_CMD2_RSTVAL			0x007EE000
-#define NFC_COL_ADDR_RSTVAL			0x00000000
-#define NFC_ROW_ADDR_RSTVAL			0x11000000
-#define NFC_FLASH_COMMAND_REPEAT_RSTVAL		0x00000000
-#define NFC_ROW_ADDR_INC_RSTVAL			0x00000001
-#define NFC_FLASH_STATUS1_RSTVAL		0x00000000
-#define NFC_FLASH_STATUS2_RSTVAL		0x00000000
-#define NFC_DMA1_ADDR_RSTVAL			0x00000000
-#define NFC_DMA2_ADDR_RSTVAL			0x00000000
-#define NFC_DMA_CONFIG_RSTVAL			0x00000000
-#define NFC_CACHE_SWAP_RSTVAL			0x0FFE0FFE
-#define NFC_SECTOR_SIZE_RSTVAL			0x00000420
-#define NFC_FLASH_CONFIG_RSTVAL			0x000EA631
-#define NFC_IRQ_STATUS_RSTVAL			0x04000000
-
-/***************** Module-Relative Register Mask *************************/
-
-/* NFC_FLASH_CMD1 Field */
-#define CMD1_MASK			0xFFFF0000
-#define CMD1_SHIFT			0
-#define CMD_BYTE2_MASK			0xFF000000
-#define CMD_BYTE2_SHIFT			24
-#define CMD_BYTE3_MASK			0x00FF0000
-#define CMD_BYTE3_SHIFT			16
-
-/* NFC_FLASH_CM2 Field */
-#define CMD2_MASK			0xFFFFFF07
-#define CMD2_SHIFT			0
-#define CMD_BYTE1_MASK			0xFF000000
-#define CMD_BYTE1_SHIFT			24
-#define CMD_CODE_MASK			0x00FFFF00
-#define CMD_CODE_SHIFT			8
-#define BUFNO_MASK			0x00000006
-#define BUFNO_SHIFT			1
-#define BUSY_MASK			0x00000001
-#define BUSY_SHIFT			0
-#define START_MASK			0x00000001
-#define START_SHIFT			0
-
-/* NFC_COL_ADDR Field */
-#define COL_ADDR_MASK			0x0000FFFF
-#define COL_ADDR_SHIFT			0
-#define COL_ADDR_COL_ADDR2_MASK		0x0000FF00
-#define COL_ADDR_COL_ADDR2_SHIFT	8
-#define COL_ADDR_COL_ADDR1_MASK		0x000000FF
-#define COL_ADDR_COL_ADDR1_SHIFT	0
-
-/* NFC_ROW_ADDR Field */
-#define ROW_ADDR_MASK			0x00FFFFFF
-#define ROW_ADDR_SHIFT			0
-#define ROW_ADDR_CHIP_SEL_RB_MASK	0xF0000000
-#define ROW_ADDR_CHIP_SEL_RB_SHIFT	28
-#define ROW_ADDR_CHIP_SEL_MASK		0x0F000000
-#define ROW_ADDR_CHIP_SEL_SHIFT		24
-#define ROW_ADDR_ROW_ADDR3_MASK		0x00FF0000
-#define ROW_ADDR_ROW_ADDR3_SHIFT	16
-#define ROW_ADDR_ROW_ADDR2_MASK		0x0000FF00
-#define ROW_ADDR_ROW_ADDR2_SHIFT	8
-#define ROW_ADDR_ROW_ADDR1_MASK		0x000000FF
-#define ROW_ADDR_ROW_ADDR1_SHIFT	0
-
-/* NFC_FLASH_COMMAND_REPEAT Field */
-#define COMMAND_REPEAT_MASK			0x0000FFFF
-#define COMMAND_REPEAT_SHIFT			0
-#define COMMAND_REPEAT_REPEAT_COUNT_MASK	0x0000FFFF
-#define COMMAND_REPEAT_REPEAT_COUNT_SHIFT	0
-
-/* NFC_ROW_ADDR_INC Field */
-#define ROW_ADDR_INC_MASK			0x00FFFFFF
-#define ROW_ADDR_INC_SHIFT			0
-#define ROW_ADDR_INC_ROW_ADDR3_INC_MASK		0x00FF0000
-#define ROW_ADDR_INC_ROW_ADDR3_INC_SHIFT	16
-#define ROW_ADDR_INC_ROW_ADDR2_INC_MASK		0x0000FF00
-#define ROW_ADDR_INC_ROW_ADDR2_INC_SHIFT	8
-#define ROW_ADDR_INC_ROW_ADDR1_INC_MASK		0x000000FF
-#define ROW_ADDR_INC_ROW_ADDR1_INC_SHIFT	0
-
-/* NFC_FLASH_STATUS1 Field */
-#define STATUS1_MASK				0xFFFFFFFF
-#define STATUS1_SHIFT				0
-#define STATUS1_ID_BYTE1_MASK			0xFF000000
-#define STATUS1_ID_BYTE1_SHIFT			24
-#define STATUS1_ID_BYTE2_MASK			0x00FF0000
-#define STATUS1_ID_BYTE2_SHIFT			16
-#define STATUS1_ID_BYTE3_MASK			0x0000FF00
-#define STATUS1_ID_BYTE3_SHIFT			8
-#define STATUS1_ID_BYTE4_MASK			0x000000FF
-#define STATUS1_ID_BYTE4_SHIFT			0
-
-/* NFC_FLASH_STATUS2 Field */
-#define STATUS2_MASK				0xFF0000FF
-#define STATUS2_SHIFT				0
-#define STATUS2_ID_BYTE5_MASK			0xFF000000
-#define STATUS2_ID_BYTE5_SHIFT			24
-#define STATUS_BYTE1_MASK			0x000000FF
-#define STATUS2_STATUS_BYTE1_SHIFT		0
-
-/* NFC_DMA1_ADDR Field */
-#define DMA1_ADDR_MASK				0xFFFFFFFF
-#define DMA1_ADDR_SHIFT				0
-#define DMA1_ADDR_DMA1_ADDR_MASK		0xFFFFFFFF
-#define DMA1_ADDR_DMA1_ADDR_SHIFT		0
-
-/* DMA2_ADDR Field */
-#define DMA2_ADDR_MASK				0xFFFFFFFF
-#define DMA2_ADDR_SHIFT				0
-#define DMA2_ADDR_DMA2_ADDR_MASK		0xFFFFFFFF
-#define DMA2_ADDR_DMA2_ADDR_SHIFT		0
-
-/* DMA_CONFIG Field */
-#define DMA_CONFIG_MASK				0xFFFFFFFF
-#define DMA_CONFIG_SHIFT			0
-#define DMA_CONFIG_DMA1_CNT_MASK		0xFFF00000
-#define DMA_CONFIG_DMA1_CNT_SHIFT		20
-#define DMA_CONFIG_DMA2_CNT_MASK		0x000FE000
-#define DMA_CONFIG_DMA2_CNT_SHIFT		13
-#define DMA_CONFIG_DMA2_OFFSET_MASK		0x00001FC0
-#define DMA_CONFIG_DMA2_OFFSET_SHIFT		2
-#define DMA_CONFIG_DMA1_ACT_MASK		0x00000002
-#define DMA_CONFIG_DMA1_ACT_SHIFT		1
-#define DMA_CONFIG_DMA2_ACT_MASK		0x00000001
-#define DMA_CONFIG_DMA2_ACT_SHIFT		0
-
-/* NFC_CACHE_SWAP Field */
-#define CACHE_SWAP_MASK				0x0FFE0FFE
-#define CACHE_SWAP_SHIFT			1
-#define CACHE_SWAP_CACHE_SWAP_ADDR2_MASK	0x0FFE0000
-#define CACHE_SWAP_CACHE_SWAP_ADDR2_SHIFT	17
-#define CACHE_SWAP_CACHE_SWAP_ADDR1_MASK	0x00000FFE
-#define CACHE_SWAP_CACHE_SWAP_ADDR1_SHIFT	1
-
-/* NFC_SECTOR_SIZE Field */
-#define SECTOR_SIZE_MASK			0x00001FFF
-#define SECTOR_SIZE_SHIFT			0
-#define SECTOR_SIZE_SECTOR_SIZE_MASK		0x00001FFF
-#define SECTOR_SIZE_SECTOR_SIZE_SHIFT		0
-
-/* NFC_FLASH_CONFIG Field */
-#define CONFIG_MASK				0xFFFFFFFF
-#define CONFIG_SHIFT				0
-#define CONFIG_STOP_ON_WERR_MASK		0x80000000
-#define CONFIG_STOP_ON_WERR_SHIFT		31
-#define CONFIG_ECC_SRAM_ADDR_MASK		0x7FC00000
-#define CONFIG_ECC_SRAM_ADDR_SHIFT		22
-#define CONFIG_ECC_SRAM_REQ_MASK		0x00200000
-#define CONFIG_ECC_SRAM_REQ_SHIFT		21
-#define CONFIG_DMA_REQ_MASK			0x00100000
-#define CONFIG_DMA_REQ_SHIFT			20
-#define CONFIG_ECC_MODE_MASK			0x000E0000
-#define CONFIG_ECC_MODE_SHIFT			17
-#define CONFIG_FAST_FLASH_MASK			0x00010000
-#define CONFIG_FAST_FLASH_SHIFT			16
-#define CONFIG_ID_COUNT_MASK			0x0000E000
-#define CONFIG_ID_COUNT_SHIFT			13
-#define CONFIG_CMD_TIMEOUT_MASK			0x00001F00
-#define CONFIG_CMD_TIMEOUT_SHIFT		8
-#define CONFIG_16BIT_MASK			0x00000080
-#define CONFIG_16BIT_SHIFT			7
-#define CONFIG_BOOT_MODE_MASK			0x00000040
-#define CONFIG_BOOT_MODE_SHIFT			6
-#define CONFIG_ADDR_AUTO_INCR_MASK		0x00000020
-#define CONFIG_ADDR_AUTO_INCR_SHIFT		5
-#define CONFIG_BUFNO_AUTO_INCR_MASK		0x00000010
-#define CONFIG_BUFNO_AUTO_INCR_SHIFT		4
-#define CONFIG_PAGE_CNT_MASK			0x0000000F
-#define CONFIG_PAGE_CNT_SHIFT			0
-
-/* NFC_IRQ_STATUS Field */
-#define MASK				0xEFFC003F
-#define SHIFT				0
-#define WERR_IRQ_MASK			0x80000000
-#define WERR_IRQ_SHIFT			31
-#define CMD_DONE_IRQ_MASK		0x40000000
-#define CMD_DONE_IRQ_SHIFT		30
-#define IDLE_IRQ_MASK			0x20000000
-#define IDLE_IRQ_SHIFT			29
-#define WERR_STATUS_MASK		0x08000000
-#define WERR_STATUS_SHIFT		27
-#define FLASH_CMD_BUSY_MASK		0x04000000
-#define FLASH_CMD_BUSY_SHIFT		26
-#define RESIDUE_BUSY_MASK		0x02000000
-#define RESIDUE_BUSY_SHIFT		25
-#define ECC_BUSY_MASK			0x01000000
-#define ECC_BUSY_SHIFT			24
-#define DMA_BUSY_MASK			0x00800000
-#define DMA_BUSY_SHIFT			23
-#define WERR_EN_MASK			0x00400000
-#define WERR_EN_SHIFT			22
-#define CMD_DONE_EN_MASK		0x00200000
-#define CMD_DONE_EN_SHIFT		21
-#define IDLE_EN_MASK			0x00100000
-#define IDLE_EN_SHIFT			20
-#define WERR_CLEAR_MASK			0x00080000
-#define WERR_CLEAR_SHIFT		19
-#define CMD_DONE_CLEAR_MASK		0x00040000
-#define CMD_DONE_CLEAR_SHIFT		18
-#define IDLE_CLEAR_MASK			0x00020000
-#define IDLE_CLEAR_SHIFT		17
-#define RESIDUE_BUFF_NO_MASK		0x00000030
-#define RESIDUE_BUFF_NO_SHIFT		4
-#define ECC_BUFF_NO_MASK		0x000000C0
-#define ECC_BUFF_NO_SHIFT		2
-#define DMA_BUFF_NO_MASK		0x00000003
-
-#endif /* MPC5125_NFC_H */
-- 
2.17.1

