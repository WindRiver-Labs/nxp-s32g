From 15285c19bcad1435a352327466c6478c1b50a79f Mon Sep 17 00:00:00 2001
From: Andrei Botila <andrei.botila@nxp.com>
Date: Fri, 14 Jan 2022 21:16:27 +0200
Subject: [PATCH 13/25] arch: fsl-lsch2: Remove unmaintained fsl-lsch2

This revert is part of removing legacy code.

Revert "armv8/fsl-lsch2: Release secondary cores from boot hold off
with Boot Page"

This reverts commit 31f84d375a3450569fdee7eceb685480bb5f38ae.

Issue: ALB-8332
Upstream-Status: Pending 

Signed-off-by: Andrei Botila <andrei.botila@nxp.com>
Signed-off-by: Zhantao Tang <zhantao.tang@windriver.com>
---
 arch/arm/cpu/armv8/fsl-lsch2/Makefile        |  11 -
 arch/arm/cpu/armv8/fsl-lsch2/cpu.c           | 417 -------------------
 arch/arm/cpu/armv8/fsl-lsch2/cpu.h           |   8 -
 arch/arm/cpu/armv8/fsl-lsch2/fdt.c           |  56 ---
 arch/arm/cpu/armv8/fsl-lsch2/lowlevel.S      | 200 ---------
 arch/arm/cpu/armv8/fsl-lsch2/mp.c            | 168 --------
 arch/arm/cpu/armv8/fsl-lsch2/mp.h            |  36 --
 arch/arm/include/asm/arch-fsl-lsch2/config.h | 139 -------
 8 files changed, 1035 deletions(-)
 delete mode 100644 arch/arm/cpu/armv8/fsl-lsch2/Makefile
 delete mode 100644 arch/arm/cpu/armv8/fsl-lsch2/cpu.c
 delete mode 100644 arch/arm/cpu/armv8/fsl-lsch2/cpu.h
 delete mode 100644 arch/arm/cpu/armv8/fsl-lsch2/fdt.c
 delete mode 100644 arch/arm/cpu/armv8/fsl-lsch2/lowlevel.S
 delete mode 100644 arch/arm/cpu/armv8/fsl-lsch2/mp.c
 delete mode 100644 arch/arm/cpu/armv8/fsl-lsch2/mp.h
 delete mode 100644 arch/arm/include/asm/arch-fsl-lsch2/config.h

diff --git a/arch/arm/cpu/armv8/fsl-lsch2/Makefile b/arch/arm/cpu/armv8/fsl-lsch2/Makefile
deleted file mode 100644
index f920eebc56..0000000000
--- a/arch/arm/cpu/armv8/fsl-lsch2/Makefile
+++ /dev/null
@@ -1,11 +0,0 @@
-#
-# Copyright 2014, Freescale Semiconductor
-#
-# SPDX-License-Identifier:	GPL-2.0+
-#
-
-obj-y += cpu.o
-obj-y += lowlevel.o
-obj-y += speed.o
-obj-$(CONFIG_MP) += mp.o
-obj-$(CONFIG_OF_LIBFDT) += fdt.o
diff --git a/arch/arm/cpu/armv8/fsl-lsch2/cpu.c b/arch/arm/cpu/armv8/fsl-lsch2/cpu.c
deleted file mode 100644
index ba5ee1f618..0000000000
--- a/arch/arm/cpu/armv8/fsl-lsch2/cpu.c
+++ /dev/null
@@ -1,417 +0,0 @@
-/*
- * Copyright 2014 Freescale Semiconductor, Inc.
- *
- * SPDX-License-Identifier:	GPL-2.0+
- */
-
-#include <common.h>
-#include <asm/io.h>
-#include <asm/system.h>
-#include <asm/armv8/mmu.h>
-#include <asm/io.h>
-#include <asm/arch-fsl-lsch2/immap_lsch2.h>
-#include "cpu.h"
-#include "mp.h"
-#include "speed.h"
-
-DECLARE_GLOBAL_DATA_PTR;
-
-#ifndef CONFIG_SYS_DCACHE_OFF
-/*
- * To start MMU before DDR is available, we create MMU table in SRAM.
- * The base address of SRAM is CONFIG_SYS_FSL_OCRAM_BASE. We use three
- * levels of translation tables here to cover 40-bit address space.
- * We use 4KB granule size, with 40 bits physical address, T0SZ=24
- * Level 0 IA[39], table address @0
- * Level 1 IA[31:30], table address @01000, 0x2000
- * Level 2 IA[29:21], table address @0x3000
- */
-
-#define SECTION_SHIFT_L0	39UL
-#define SECTION_SHIFT_L1	30UL
-#define SECTION_SHIFT_L2	21UL
-#define BLOCK_SIZE_L0	0x8000000000UL
-#define BLOCK_SIZE_L1	(1 << SECTION_SHIFT_L1)
-#define BLOCK_SIZE_L2	(1 << SECTION_SHIFT_L2)
-#define CONFIG_SYS_IFC_BASE	0x60000000UL
-#define CONFIG_SYS_IFC_SIZE	0x20000000UL
-#define CONFIG_SYS_IFC_BASE2	0x620000000UL
-#define CONFIG_SYS_IFC_SIZE2	0x0e0000000UL
-#define TCR_EL2_PS_40BIT	(2 << 16)
-#define LSCH2_VA_BITS		(40)
-#define LSCH2_TCR	(TCR_TG0_4K		| \
-			TCR_EL2_PS_40BIT	| \
-			TCR_SHARED_NON		| \
-			TCR_ORGN_NC		| \
-			TCR_IRGN_NC		| \
-			TCR_T0SZ(LSCH2_VA_BITS))
-
-/*
- * Final MMU
- * Let's start from the same layout as early MMU and modify as needed.
- * IFC regions will be cache-inhibit.
- */
-#define FINAL_QBMAN_CACHED_MEM	0x818000000UL
-#define FINAL_QBMAN_CACHED_SIZE	0x4000000
-
-static inline void early_mmu_setup(void)
-{
-	int el;
-	u64 i;
-	u64 section_l1t0, section_l1t1, section_l2;
-	u64 *level0_table = (u64 *)CONFIG_SYS_FSL_OCRAM_BASE;
-	u64 *level1_table_0 = (u64 *)(CONFIG_SYS_FSL_OCRAM_BASE + 0x1000);
-	u64 *level1_table_1 = (u64 *)(CONFIG_SYS_FSL_OCRAM_BASE + 0x2000);
-	u64 *level2_table = (u64 *)(CONFIG_SYS_FSL_OCRAM_BASE + 0x3000);
-
-
-	level0_table[0] =
-		(u64)level1_table_0 | PMD_TYPE_TABLE;
-	level0_table[1] =
-		(u64)level1_table_1 | PMD_TYPE_TABLE;
-
-	/*
-	 * set level 1 table 0 to cache_inhibit, covering 0 to 512GB
-	 * set level 1 table 1 to cache enabled, covering 512GB to 1TB
-	 * set level 2 table to cache-inhibit, covering 0 to 1GB
-	 */
-	section_l1t0 = 0;
-	section_l1t1 = BLOCK_SIZE_L0;
-	section_l2 = 0;
-	for (i = 0; i < 512; i++) {
-		set_pgtable_section(level1_table_0, i, section_l1t0,
-				    MT_DEVICE_NGNRNE);
-		set_pgtable_section(level1_table_1, i, section_l1t1,
-				    MT_NORMAL);
-		set_pgtable_section(level2_table, i, section_l2,
-				    MT_DEVICE_NGNRNE);
-		section_l1t0 += BLOCK_SIZE_L1;
-		section_l1t1 += BLOCK_SIZE_L1;
-		section_l2 += BLOCK_SIZE_L2;
-	}
-
-	level1_table_0[0] =
-		(u64)level2_table | PMD_TYPE_TABLE;
-	level1_table_0[1] =
-		0x40000000 | PMD_SECT_AF | PMD_TYPE_SECT |
-		PMD_ATTRINDX(MT_DEVICE_NGNRNE);
-	level1_table_0[2] =
-		0x80000000 | PMD_SECT_AF | PMD_TYPE_SECT |
-		PMD_ATTRINDX(MT_NORMAL);
-	level1_table_0[3] =
-		0xc0000000 | PMD_SECT_AF | PMD_TYPE_SECT |
-		PMD_ATTRINDX(MT_NORMAL);
-
-	/* Rewrite table to enable cache */
-	set_pgtable_section(level2_table,
-			    CONFIG_SYS_FSL_OCRAM_BASE >> SECTION_SHIFT_L2,
-			    CONFIG_SYS_FSL_OCRAM_BASE,
-			    MT_NORMAL);
-	for (i = CONFIG_SYS_IFC_BASE >> SECTION_SHIFT_L2;
-	     i < (CONFIG_SYS_IFC_BASE + CONFIG_SYS_IFC_SIZE)
-	     >> SECTION_SHIFT_L2; i++) {
-		section_l2 = i << SECTION_SHIFT_L2;
-		set_pgtable_section(level2_table, i,
-				    section_l2, MT_NORMAL);
-	}
-
-	el = current_el();
-	set_ttbr_tcr_mair(el, (u64)level0_table, LSCH2_TCR, MEMORY_ATTRIBUTES);
-	set_sctlr(get_sctlr() | CR_M);
-}
-
-static inline void final_mmu_setup(void)
-{
-	int el;
-	u64 i, tbl_base, tbl_limit, section_base;
-	u64 section_l1t0, section_l1t1, section_l2;
-	u64 *level0_table = (u64 *)gd->arch.tlb_addr;
-	u64 *level1_table_0 = (u64 *)(gd->arch.tlb_addr + 0x1000);
-	u64 *level1_table_1 = (u64 *)(gd->arch.tlb_addr + 0x2000);
-	u64 *level2_table_0 = (u64 *)(gd->arch.tlb_addr + 0x3000);
-	u64 *level2_table_1 = (u64 *)(gd->arch.tlb_addr + 0x4000);
-
-
-	level0_table[0] =
-		(u64)level1_table_0 | PMD_TYPE_TABLE;
-	level0_table[1] =
-		(u64)level1_table_1 | PMD_TYPE_TABLE;
-
-	/*
-	 * set level 1 table 0 to cache_inhibit, covering 0 to 512GB
-	 * set level 1 table 1 to cache enabled, covering 512GB to 1TB
-	 * set level 2 table 0 to cache-inhibit, covering 0 to 1GB
-	 */
-	section_l1t0 = 0;
-	section_l1t1 = BLOCK_SIZE_L0;
-	section_l2 = 0;
-	for (i = 0; i < 512; i++) {
-		set_pgtable_section(level1_table_0, i, section_l1t0,
-				    MT_DEVICE_NGNRNE);
-		set_pgtable_section(level1_table_1, i, section_l1t1,
-				    MT_NORMAL);
-		set_pgtable_section(level2_table_0, i, section_l2,
-				    MT_DEVICE_NGNRNE);
-		section_l1t0 += BLOCK_SIZE_L1;
-		section_l1t1 += BLOCK_SIZE_L1;
-		section_l2 += BLOCK_SIZE_L2;
-	}
-
-	level1_table_0[0] =
-		(u64)level2_table_0 | PMD_TYPE_TABLE;
-	level1_table_0[2] =
-		0x80000000 | PMD_SECT_AF | PMD_TYPE_SECT |
-		PMD_ATTRINDX(MT_NORMAL);
-	level1_table_0[3] =
-		0xc0000000 | PMD_SECT_AF | PMD_TYPE_SECT |
-		PMD_ATTRINDX(MT_NORMAL);
-
-	/* Rewrite table to enable cache */
-	set_pgtable_section(level2_table_0,
-			    CONFIG_SYS_FSL_OCRAM_BASE >> SECTION_SHIFT_L2,
-			    CONFIG_SYS_FSL_OCRAM_BASE,
-			    MT_NORMAL);
-
-	/*
-	 * Fill in other part of tables if cache is needed
-	 * If finer granularity than 1GB is needed, sub table
-	 * should be created.
-	 */
-	section_base = FINAL_QBMAN_CACHED_MEM & ~(BLOCK_SIZE_L1 - 1);
-	i = section_base >> SECTION_SHIFT_L1;
-	level1_table_0[i] = (u64)level2_table_1 | PMD_TYPE_TABLE;
-	section_l2 = section_base;
-	for (i = 0; i < 512; i++) {
-		set_pgtable_section(level2_table_1, i, section_l2,
-				    MT_DEVICE_NGNRNE);
-		section_l2 += BLOCK_SIZE_L2;
-	}
-	tbl_base = FINAL_QBMAN_CACHED_MEM & (BLOCK_SIZE_L1 - 1);
-	tbl_limit = (FINAL_QBMAN_CACHED_MEM + FINAL_QBMAN_CACHED_SIZE) &
-		    (BLOCK_SIZE_L1 - 1);
-	for (i = tbl_base >> SECTION_SHIFT_L2;
-	     i < tbl_limit >> SECTION_SHIFT_L2; i++) {
-		section_l2 = section_base + (i << SECTION_SHIFT_L2);
-		set_pgtable_section(level2_table_1, i,
-				    section_l2, MT_NORMAL);
-	}
-
-	/* flush new MMU table */
-	flush_dcache_range(gd->arch.tlb_addr,
-			   gd->arch.tlb_addr +  gd->arch.tlb_size);
-
-	el = current_el();
-	asm volatile("dsb sy");
-	if (el == 1) {
-		asm volatile("msr ttbr0_el1, %0"
-			     : : "r" ((u64)level0_table) : "memory");
-	} else if (el == 2) {
-		asm volatile("msr ttbr0_el2, %0"
-			     : : "r" ((u64)level0_table) : "memory");
-	} else if (el == 3) {
-		asm volatile("msr ttbr0_el3, %0"
-			     : : "r" ((u64)level0_table) : "memory");
-	} else {
-		hang();
-	}
-	asm volatile("isb");
-
-	/*
-	 * MMU is already enabled, just need to invalidate TLB to load the
-	 * new table. The new table is compatible with the current table, if
-	 * MMU somehow walks through the new table before invalidation TLB,
-	 * it still works. So we don't need to turn off MMU here.
-	 */
-}
-
-int arch_cpu_init(void)
-{
-	icache_enable();
-	__asm_invalidate_dcache_all();
-	__asm_invalidate_tlb_all();
-	early_mmu_setup();
-	set_sctlr(get_sctlr() | CR_C);
-	return 0;
-}
-
-/*
- * This function is called from lib/board.c.
- * It recreates MMU table in main memory. MMU and d-cache are enabled earlier.
- * There is no need to disable d-cache for this operation.
- */
-void enable_caches(void)
-{
-	final_mmu_setup();
-	__asm_invalidate_tlb_all();
-}
-#endif
-
-
-static inline u32 initiator_type(u32 cluster, int init_id)
-{
-	struct ccsr_gur *gur = (void *)(CONFIG_SYS_FSL_GUTS_ADDR);
-	u32 idx = (cluster >> (init_id * 8)) & TP_CLUSTER_INIT_MASK;
-	u32 type = in_be32(&gur->tp_ityp[idx]);
-
-	if (type & TP_ITYP_AV)
-		return type;
-
-	return 0;
-}
-
-u32 cpu_mask(void)
-{
-	struct ccsr_gur __iomem *gur = (void *)(CONFIG_SYS_FSL_GUTS_ADDR);
-	int i = 0, count = 0;
-	u32 cluster, type, mask = 0;
-
-	do {
-		int j;
-		cluster = in_be32(&gur->tp_cluster[i].lower);
-		for (j = 0; j < TP_INIT_PER_CLUSTER; j++) {
-			type = initiator_type(cluster, j);
-			if (type) {
-				if (TP_ITYP_TYPE(type) == TP_ITYP_TYPE_ARM)
-					mask |= 1 << count;
-				count++;
-			}
-		}
-		i++;
-	} while ((cluster & TP_CLUSTER_EOC_MASK) == 0x0);
-
-	return mask;
-}
-
-/*
- * Return the number of cores on this SOC.
- */
-int cpu_numcores(void)
-{
-	return hweight32(cpu_mask());
-}
-
-int fsl_qoriq_core_to_cluster(unsigned int core)
-{
-	struct ccsr_gur __iomem *gur =
-		(void __iomem *)(CONFIG_SYS_FSL_GUTS_ADDR);
-	int i = 0, count = 0;
-	u32 cluster;
-
-	do {
-		int j;
-		cluster = in_be32(&gur->tp_cluster[i].lower);
-		for (j = 0; j < TP_INIT_PER_CLUSTER; j++) {
-			if (initiator_type(cluster, j)) {
-				if (count == core)
-					return i;
-				count++;
-			}
-		}
-		i++;
-	} while ((cluster & TP_CLUSTER_EOC_MASK) == 0x0);
-
-	return -1;      /* cannot identify the cluster */
-}
-
-u32 fsl_qoriq_core_to_type(unsigned int core)
-{
-	struct ccsr_gur __iomem *gur =
-		(void __iomem *)(CONFIG_SYS_FSL_GUTS_ADDR);
-	int i = 0, count = 0;
-	u32 cluster, type;
-
-	do {
-		int j;
-		cluster = in_be32(&gur->tp_cluster[i].lower);
-		for (j = 0; j < TP_INIT_PER_CLUSTER; j++) {
-			type = initiator_type(cluster, j);
-			if (type) {
-				if (count == core)
-					return type;
-				count++;
-			}
-		}
-		i++;
-	} while ((cluster & TP_CLUSTER_EOC_MASK) == 0x0);
-
-	return -1;      /* cannot identify the cluster */
-}
-
-#ifdef CONFIG_DISPLAY_CPUINFO
-int print_cpuinfo(void)
-{
-	struct sys_info sysinfo;
-	struct ccsr_gur __iomem *gur = (void *)(CONFIG_SYS_FSL_GUTS_ADDR);
-	char buf[32];
-	unsigned int i, core;
-	u32 type;
-
-	get_sys_info(&sysinfo);
-	puts("Clock Configuration:");
-	for_each_cpu(i, core, cpu_numcores(), cpu_mask()) {
-		if (!(i % 3))
-			puts("\n       ");
-		type = TP_ITYP_VER(fsl_qoriq_core_to_type(core));
-		printf("CPU%d(%s):%-4s MHz  ", core,
-		       type == TY_ITYP_VER_A7 ? "A7 " :
-		       (type == TY_ITYP_VER_A53 ? "A53" :
-			(type == TY_ITYP_VER_A57 ? "A57" : "   ")),
-		       strmhz(buf, sysinfo.freq_processor[core]));
-	}
-	printf("\n       Bus:      %-4s MHz  ",
-	       strmhz(buf, sysinfo.freq_systembus));
-	printf("DDR:      %-4s MHz", strmhz(buf, sysinfo.freq_ddrbus));
-	puts("\n");
-
-	/*
-	 * Display the RCW, so that no one gets confused as to what RCW
-	 * we're actually using for this boot.
-	 */
-	puts("Reset Configuration Word (RCW):");
-	for (i = 0; i < ARRAY_SIZE(gur->rcwsr); i++) {
-		u32 rcw = in_be32(&gur->rcwsr[i]);
-
-		if ((i % 4) == 0)
-			printf("\n       %08x:", i * 4);
-		printf(" %08x", rcw);
-	}
-	puts("\n");
-
-	return 0;
-}
-#endif
-
-/*
- * Initializes on-chip ethernet controllers.
- * to override, implement board_eth_init()
- */
-int cpu_eth_init(bd_t *bis)
-{
-#if defined(CONFIG_ETHER_ON_FCC)
-	fec_initialize(bis);
-#endif
-
-#if defined(CONFIG_UEC_ETH)
-	uec_standard_init(bis);
-#endif
-
-#if defined(CONFIG_TSEC_ENET) || defined(CONFIG_MPC85XX_FEC)
-	tsec_standard_init(bis);
-#endif
-
-#ifdef CONFIG_FMAN_ENET
-	fm_standard_init(bis);
-#endif
-	return 0;
-}
-
-int arch_early_init_r(void)
-{
-	int rv;
-	rv = fsl_lsch2_wake_seconday_cores();
-
-	if (rv)
-		printf("Did not wake secondary cores\n");
-
-	return 0;
-}
diff --git a/arch/arm/cpu/armv8/fsl-lsch2/cpu.h b/arch/arm/cpu/armv8/fsl-lsch2/cpu.h
deleted file mode 100644
index 2e3312b99b..0000000000
--- a/arch/arm/cpu/armv8/fsl-lsch2/cpu.h
+++ /dev/null
@@ -1,8 +0,0 @@
-/*
- * Copyright 2014, Freescale Semiconductor
- *
- * SPDX-License-Identifier:	GPL-2.0+
- */
-
-int fsl_qoriq_core_to_cluster(unsigned int core);
-u32 cpu_mask(void);
diff --git a/arch/arm/cpu/armv8/fsl-lsch2/fdt.c b/arch/arm/cpu/armv8/fsl-lsch2/fdt.c
deleted file mode 100644
index b5a768852b..0000000000
--- a/arch/arm/cpu/armv8/fsl-lsch2/fdt.c
+++ /dev/null
@@ -1,56 +0,0 @@
-/*
- * Copyright 2014 Freescale Semiconductor, Inc.
- *
- * SPDX-License-Identifier:	GPL-2.0+
- */
-
-#include <common.h>
-#include <linux/libfdt.h>
-#include <fdt_support.h>
-#include "mp.h"
-
-#ifdef CONFIG_MP
-void ft_fixup_cpu(void *blob)
-{
-	int off;
-	__maybe_unused u64 spin_tbl_addr = (u64)get_spin_tbl_addr();
-	u64 *reg;
-	u64 val;
-
-	off = fdt_node_offset_by_prop_value(blob, -1, "device_type", "cpu", 4);
-	while (off != -FDT_ERR_NOTFOUND) {
-		reg = (u64 *)fdt_getprop(blob, off, "reg", 0);
-		if (reg) {
-			val = spin_tbl_addr;
-#ifndef CONFIG_FSL_SMP_RELEASE_ALL
-			val += id_to_core(fdt64_to_cpu(*reg)) * SIZE_BOOT_ENTRY;
-#endif
-			val = cpu_to_fdt64(val);
-			fdt_setprop_string(blob, off, "enable-method",
-					   "spin-table");
-			fdt_setprop(blob, off, "cpu-release-addr",
-				    &val, sizeof(val));
-		} else {
-			puts("cpu NULL\n");
-		}
-		off = fdt_node_offset_by_prop_value(blob, off, "device_type",
-						    "cpu", 4);
-	}
-	/*
-	 * Boot page and spin table can be reserved here if not done staticlly
-	 * in device tree.
-	 *
-	 * fdt_add_mem_rsv(blob, bootpg,
-	 *		   *((u64 *)&(__secondary_boot_page_size)));
-	 * If defined CONFIG_FSL_SMP_RELEASE_ALL, the release address should
-	 * also be reserved.
-	 */
-}
-#endif
-
-void ft_cpu_setup(void *blob, bd_t *bd)
-{
-#ifdef CONFIG_MP
-	ft_fixup_cpu(blob);
-#endif
-}
diff --git a/arch/arm/cpu/armv8/fsl-lsch2/lowlevel.S b/arch/arm/cpu/armv8/fsl-lsch2/lowlevel.S
deleted file mode 100644
index 162d3d6f09..0000000000
--- a/arch/arm/cpu/armv8/fsl-lsch2/lowlevel.S
+++ /dev/null
@@ -1,200 +0,0 @@
-/*
- * (C) Copyright 2014 Freescale Semiconductor
- *
- * SPDX-License-Identifier:	GPL-2.0+
- *
- * Extracted from armv8/start.S
- */
-
-#include <config.h>
-#include <linux/linkage.h>
-#include <asm/gic.h>
-#include <asm/macro.h>
-#include "mp.h"
-
-ENTRY(lowlevel_init)
-	mov	x29, lr			/* Save LR */
-
-	/* Set the SMMU page size in the sACR register */
-	ldr	x1, =SMMU_BASE
-	ldr	w0, [x1, #0x10]
-	orr	w0, w0, #1 << 16  /* set sACR.pagesize to indicate 64K page */
-	str	w0, [x1, #0x10]
-
-	/* Initialize GIC Secure Bank Status */
-#if defined(CONFIG_GICV2) || defined(CONFIG_GICV3)
-	branch_if_slave x0, 1f
-	ldr	x0, =GICD_BASE
-	bl	gic_init_secure
-1:
-#ifdef CONFIG_GICV3
-	ldr	x0, =GICR_BASE
-	bl	gic_init_secure_percpu
-#elif defined(CONFIG_GICV2)
-	ldr	x0, =GICD_BASE
-	ldr	x1, =GICC_BASE
-	bl	gic_init_secure_percpu
-#endif
-#endif
-
-	branch_if_master x0, x1, 1f
-
-	ldr	x0, =(SECONDARY_CPU_BOOT_PAGE)
-	ldr	x1, =secondary_boot_func
-	ldr	x2, =secondary_boot_page
-	sub	x1, x1, x2
-	add	x0, x0, x1
-	blr	x0
-
-1:
-	/* Set Non Secure access for all devices protected via TZPC */
-	ldr	x1, =TZPCDECPROT_0_SET_BASE /* Decode Protection-0 Set Reg */
-	mov	w0, #0xFF		/* Set decode region to NS, Bits[7:0] */
-	str	w0, [x1]
-
-	ldr	x1, =TZPCDECPROT_1_SET_BASE /* Decode Protection-1 Set Reg */
-	mov	w0, #0xFF		/* Set decode region to NS, Bits[7:0] */
-	str	w0, [x1]
-
-	ldr	x1, =TZPCDECPROT_2_SET_BASE /* Decode Protection-2 Set Reg */
-	mov	w0, #0xFF		/* Set decode region to NS, Bits[7:0] */
-	str	w0, [x1]
-
-	/* Entire SRAM as NS */
-	ldr	x1, =TZPCR0SIZE_BASE	/* Secure RAM region size Reg */
-	mov	w0, #0x00000000		/* 0x00000000 = no secure region */
-	str	w0, [x1]
-
-	/* Set TZASC so that:
-	 * a. We use only Region0 whose global secure write/read is EN
-	 * b. We use only Region0 whose NSAID write/read is EN
-	 *
-	 * NOTE: As per the CCSR map doc, TZASC 3 and TZASC 4 are just
-	 * 	 placeholders.
-	 */
-	ldr	x1, =TZASC_GATE_KEEPER(0)
-	ldr	x0, [x1]		/* Filter 0 Gate Keeper Register */
-	orr	x0, x0, #1 << 0		/* Set open_request for Filter 0 */
-	str	x0, [x1]
-
-	ldr	x1, =TZASC_GATE_KEEPER(1)
-	ldr	x0, [x1]		/* Filter 0 Gate Keeper Register */
-	orr	x0, x0, #1 << 0		/* Set open_request for Filter 0 */
-	str	x0, [x1]
-
-	ldr	x1, =TZASC_REGION_ATTRIBUTES_0(0)
-	ldr	x0, [x1]		/* Region-0 Attributes Register */
-	orr	x0, x0, #1 << 31	/* Set Sec global write en, Bit[31] */
-	orr	x0, x0, #1 << 30	/* Set Sec global read en, Bit[30] */
-	str	x0, [x1]
-
-	ldr	x1, =TZASC_REGION_ATTRIBUTES_0(1)
-	ldr	x0, [x1]		/* Region-1 Attributes Register */
-	orr	x0, x0, #1 << 31	/* Set Sec global write en, Bit[31] */
-	orr	x0, x0, #1 << 30	/* Set Sec global read en, Bit[30] */
-	str	x0, [x1]
-
-	ldr	x1, =TZASC_REGION_ID_ACCESS_0(0)
-	ldr	w0, [x1]		/* Region-0 Access Register */
-	mov	w0, #0xFFFFFFFF		/* Set nsaid_wr_en and nsaid_rd_en */
-	str	w0, [x1]
-
-	ldr	x1, =TZASC_REGION_ID_ACCESS_0(1)
-	ldr	w0, [x1]		/* Region-1 Attributes Register */
-	mov	w0, #0xFFFFFFFF		/* Set nsaid_wr_en and nsaid_rd_en */
-	str	w0, [x1]
-2:
-	mov	lr, x29			/* Restore LR */
-	ret
-ENDPROC(lowlevel_init)
-
-	/* Keep literals not used by the secondary boot page outside it */
-	.ltorg
-
-	.align 4
-	.global secondary_boot_page
-secondary_boot_page:
-	.global __spin_table
-__spin_table:
-	.space CONFIG_MAX_CPUS*ENTRY_SIZE
-
-	.align 4
-	/* Secondary Boot Page starts here */
-ENTRY(secondary_boot_func)
-	/*
-	 * PIR calculation from MPIDR_EL1
-	 * MPIDR[1:0] = AFF0_CPUID <- Core ID (0,1)
-	 * MPIDR[7:2] = AFF0_RES
-	 * MPIDR[15:8] = AFF1_CLUSTERID <- Cluster ID (0,1,2,3)
-	 * MPIDR[23:16] = AFF2_CLUSTERID
-	 * MPIDR[24] = MT
-	 * MPIDR[29:25] =RES
-	 * MPIDR[30] = U
-	 * MPIDR[31] = ME
-	 * MPIDR[39:32] = AFF3
-	 * We only use AFF0_CPUID and AFF1_CLUSTERID for now
-	 * until AFF2_CLUSTERID and AFF3 have non-zero values.
-	 */
-	mrs	x0, mpidr_el1
-	ubfm	x1, x0, #8, #15
-	ubfm	x2, x0, #0, #1
-	orr	x10, x2, x1, lsl #2	/* x10 has PIR */
-	ubfm	x9, x0, #0, #15		/* w9 has 16-bit original PIR */
-	lsl	x1, x10, #6	/* spin table is padded to 64 byte each core */
-	ldr	x0, =(SECONDARY_CPU_BOOT_PAGE)
-	ldr	x3, =__spin_table
-	ldr	x4, =secondary_boot_page
-	sub	x3, x3, x4
-	add	x0, x0, x3
-	add	x11, x1, x0
-
-	str	x9, [x11, #16]	/* ENTRY_PIR */
-	mov	x4, #1
-	str	x4, [x11]	/* ENTRY_ADDR */
-	dsb	sy
-	isb
-#if defined(CONFIG_GICV3)
-	gic_wait_for_interrupt_m x0
-#endif
-
-	bl secondary_switch_to_el2
-#ifdef CONFIG_ARMV8_SWITCH_TO_EL1
-	secondary_switch_to_el1
-#endif
-
-slave_cpu:
-	wfe
-#ifdef CONFIG_FSL_SMP_RELEASE_ALL
-	ldr	x1, =CPU_RELEASE_ADDR
-	ldr	x0, [x1]
-#else
-	ldr	x0, [x11]
-	tbnz	x0, #0, slave_cpu
-#endif
-	cbz	x0, slave_cpu
-	br	x0			/* branch to the given address */
-ENDPROC(secondary_boot_func)
-
-ENTRY(secondary_switch_to_el2)
-	switch_el x0, 1f, 0f, 0f
-0:	ret
-1:	armv8_switch_to_el2_m x0
-ENDPROC(secondary_switch_to_el2)
-
-ENTRY(secondary_switch_to_el1)
-	switch_el x0, 0f, 1f, 0f
-0:	ret
-1:	armv8_switch_to_el1_m x0, x1
-ENDPROC(secondary_switch_to_el1)
-
-	/* Ensure that the literals used by the secondary boot page are
-	 * assembled within it
-	 */
-	.ltorg
-
-	.align 4
-	.globl __secondary_boot_page_size
-	.type __secondary_boot_page_size, %object
-	/* Secondary Boot Page ends here */
-__secondary_boot_page_size:
-	.quad .-secondary_boot_page
diff --git a/arch/arm/cpu/armv8/fsl-lsch2/mp.c b/arch/arm/cpu/armv8/fsl-lsch2/mp.c
deleted file mode 100644
index 1ddff58134..0000000000
--- a/arch/arm/cpu/armv8/fsl-lsch2/mp.c
+++ /dev/null
@@ -1,168 +0,0 @@
-/*
- * Copyright 2014 Freescale Semiconductor, Inc.
- *
- * SPDX-License-Identifier:	GPL-2.0+
- */
-
-#include <common.h>
-#include <asm/io.h>
-#include <asm/system.h>
-#include <asm/io.h>
-#include <asm/arch-fsl-lsch2/immap_lsch2.h>
-#include "mp.h"
-
-DECLARE_GLOBAL_DATA_PTR;
-
-void *get_spin_tbl_addr(void)
-{
-	void *ptr = (void *)SECONDARY_CPU_BOOT_PAGE;
-
-	/*
-	 * Spin table is at the beginning of secondary boot page. It is
-	 * copied to SECONDARY_CPU_BOOT_PAGE.
-	 */
-	ptr += (u64)&__spin_table - (u64)&secondary_boot_page;
-
-	return ptr;
-}
-
-phys_addr_t determine_mp_bootpg(void)
-{
-	return (phys_addr_t)SECONDARY_CPU_BOOT_PAGE;
-}
-
-int fsl_lsch2_wake_seconday_cores(void)
-{
-	struct ccsr_gur __iomem *gur = (void *)(CONFIG_SYS_FSL_GUTS_ADDR);
-	struct ccsr_scfg __iomem *scfg = (void *)(CONFIG_SYS_FSL_SCFG_ADDR);
-	void *boot_loc = (void *)SECONDARY_CPU_BOOT_PAGE;
-	size_t *boot_page_size = &(__secondary_boot_page_size);
-	u32 cores;
-	u32 corebcr;
-	int timeout = 10;
-	u64 *table = get_spin_tbl_addr();
-
-	cores = cpu_mask();
-	memcpy(boot_loc, &secondary_boot_page, *boot_page_size);
-	/* Clear spin table so that secondary processors
-	 * observe the correct value after waking up from wfe.
-	 */
-	memset(table, 0, CONFIG_MAX_CPUS * ENTRY_SIZE);
-	flush_dcache_range((unsigned long)boot_loc,
-			   (unsigned long)boot_loc + *boot_page_size);
-
-	printf("Waking secondary cores to start from %lx\n", gd->relocaddr);
-	out_be32(&scfg->scratchrw[0], (u32)(gd->relocaddr >> 32));
-	out_be32(&scfg->scratchrw[1], (u32)gd->relocaddr);
-
-	asm volatile("dsb st" : : : "memory");
-	out_be32(&gur->brrl, cores);
-	asm volatile("dsb st" : : : "memory");
-
-	/* Bootup online cores */
-	out_be32(&scfg->corebcr, cores);
-
-	do {
-		asm volatile("sev");
-		udelay(10);
-		corebcr = in_be32(&scfg->corebcr);
-		if (hweight32(~corebcr) == hweight32(cores))
-			break;
-	} while (timeout--);
-	if (timeout <= 0) {
-		printf("Not all cores (0x%x) are up (0x%x)\n",
-		       cores, corebcr);
-		return 1;
-	}
-
-	printf("All (%d) cores are up.\n", hweight32(cores));
-
-	return 0;
-}
-
-int is_core_valid(unsigned int core)
-{
-	return !!((1 << core) & cpu_mask());
-}
-
-int cpu_reset(int nr)
-{
-	puts("Feature is not implemented.\n");
-
-	return 0;
-}
-
-int cpu_disable(int nr)
-{
-	puts("Feature is not implemented.\n");
-
-	return 0;
-}
-
-int core_to_pos(int nr)
-{
-	u32 cores = cpu_mask();
-	int i, count = 0;
-
-	if (nr == 0) {
-		return 0;
-	} else if (nr >= hweight32(cores)) {
-		puts("Not a valid core number.\n");
-		return -1;
-	}
-
-	for (i = 1; i < 32; i++) {
-		if (is_core_valid(i)) {
-			count++;
-			if (count == nr)
-				break;
-		}
-	}
-
-	return count;
-}
-
-int cpu_status(int nr)
-{
-	u64 *table;
-	int pos;
-
-	if (nr == 0) {
-		table = (u64 *)get_spin_tbl_addr();
-		printf("table base @ 0x%p\n", table);
-	} else {
-		pos = core_to_pos(nr);
-		if (pos < 0)
-			return -1;
-		table = (u64 *)get_spin_tbl_addr() + pos * NUM_BOOT_ENTRY;
-		printf("table @ 0x%p\n", table);
-		printf("   addr - 0x%016llx\n", table[BOOT_ENTRY_ADDR]);
-		printf("   r3   - 0x%016llx\n", table[BOOT_ENTRY_R3]);
-		printf("   pir  - 0x%016llx\n", table[BOOT_ENTRY_PIR]);
-	}
-
-	return 0;
-}
-
-int cpu_release(int nr, int argc, char * const argv[])
-{
-	u64 boot_addr;
-	u64 *table = (u64 *)get_spin_tbl_addr();
-#ifndef CONFIG_FSL_SMP_RELEASE_ALL
-	int pos;
-
-	pos = core_to_pos(nr);
-	if (pos <= 0)
-		return -1;
-
-	table += pos * NUM_BOOT_ENTRY;
-#endif
-	boot_addr = simple_strtoull(argv[0], NULL, 16);
-	table[BOOT_ENTRY_ADDR] = boot_addr;
-	flush_dcache_range((unsigned long)table,
-			   (unsigned long)table + SIZE_BOOT_ENTRY);
-	asm volatile("dsb st");
-	smp_kick_all_cpus();	/* only those with entry addr set will run */
-
-	return 0;
-}
diff --git a/arch/arm/cpu/armv8/fsl-lsch2/mp.h b/arch/arm/cpu/armv8/fsl-lsch2/mp.h
deleted file mode 100644
index 87b6c79001..0000000000
--- a/arch/arm/cpu/armv8/fsl-lsch2/mp.h
+++ /dev/null
@@ -1,36 +0,0 @@
-/*
- * Copyright 2014, Freescale Semiconductor
- *
- * SPDX-License-Identifier:	GPL-2.0+
- */
-
-#ifndef _FSL_CH2_MP_H
-#define _FSL_CH2_MP_H
-
-/*
-* spin table is defined as
-* struct {
-*      uint64_t entry_addr;
-*      uint64_t r3;
-*      uint64_t pir;
-* };
-* we pad this struct to 64 bytes so each entry is in its own cacheline
-*/
-#define ENTRY_SIZE	64
-#define BOOT_ENTRY_ADDR	0
-#define BOOT_ENTRY_R3	1
-#define BOOT_ENTRY_PIR	2
-#define NUM_BOOT_ENTRY	8	/* pad to 64 bytes */
-#define SIZE_BOOT_ENTRY		(NUM_BOOT_ENTRY * sizeof(u64))
-
-#define id_to_core(x)	((x & 3) | (x >> 8))
-#ifndef __ASSEMBLY__
-extern u64 __spin_table[];
-extern u64 *secondary_boot_page;
-extern size_t __secondary_boot_page_size;
-int fsl_lsch2_wake_seconday_cores(void);
-void *get_spin_tbl_addr(void);
-phys_addr_t determine_mp_bootpg(void);
-void secondary_boot_func(void);
-#endif
-#endif /* _FSL_CH2_MP_H */
diff --git a/arch/arm/include/asm/arch-fsl-lsch2/config.h b/arch/arm/include/asm/arch-fsl-lsch2/config.h
deleted file mode 100644
index b4967e099c..0000000000
--- a/arch/arm/include/asm/arch-fsl-lsch2/config.h
+++ /dev/null
@@ -1,139 +0,0 @@
-/*
- * Copyright 2014, Freescale Semiconductor
- *
- * SPDX-License-Identifier:	GPL-2.0+
- */
-
-#ifndef _ASM_ARMV8_FSL_LSCH2_CONFIG_
-#define _ASM_ARMV8_FSL_LSCH2_CONFIG_
-
-#define CONFIG_MP
-#define CONFIG_SYS_FSL_OCRAM_BASE	0x10000000	/* initial RAM */
-
-/* Link Definitions */
-#define CONFIG_SYS_INIT_SP_ADDR		(CONFIG_SYS_FSL_OCRAM_BASE + 0xfff0)
-
-#define CONFIG_SYS_IMMR				0x01000000
-
-#define CONFIG_SYS_FSL_DDR_ADDR			(CONFIG_SYS_IMMR + 0x00080000)
-#define CONFIG_SYS_CCI400_ADDR			(CONFIG_SYS_IMMR + 0x00180000)
-#define CONFIG_SYS_IFC_ADDR			(CONFIG_SYS_IMMR + 0x00530000)
-#define CONFIG_SYS_FSL_GUTS_ADDR		(CONFIG_SYS_IMMR + 0x00ee0000)
-#define CONFIG_SYS_FSL_SCFG_ADDR		(CONFIG_SYS_IMMR + 0x00570000)
-#define CONFIG_SYS_FSL_SERDES_ADDR		(CONFIG_SYS_IMMR + 0x00ea0000)
-#define CONFIG_SYS_FSL_LS1_CLK_ADDR		(CONFIG_SYS_IMMR + 0x00ee1000)
-#define CONFIG_SYS_NS16550_COM1			(CONFIG_SYS_IMMR + 0x011c0500)
-#define CONFIG_SYS_NS16550_COM2			(CONFIG_SYS_IMMR + 0x011c0600)
-#define CONFIG_SYS_NS16550_COM3			(CONFIG_SYS_IMMR + 0x011d0500)
-#define CONFIG_SYS_NS16550_COM4			(CONFIG_SYS_IMMR + 0x011d0600)
-#define CONFIG_SYS_PCIE1_ADDR			(CONFIG_SYS_IMMR + 0x2400000)
-#define CONFIG_SYS_PCIE2_ADDR			(CONFIG_SYS_IMMR + 0x2500000)
-#define CONFIG_SYS_FSL_SEC_ADDR			(CONFIG_SYS_IMMR + 0x700000)
-#define CONFIG_SYS_FSL_JR0_ADDR			(CONFIG_SYS_IMMR + 0x710000)
-#define CONFIG_SYS_SNVS_ADDR			(CONFIG_SYS_IMMR + 0xe90000)
-#define CONFIG_SYS_SFP_ADDR			(CONFIG_SYS_IMMR + 0xe80200)
-
-#define CONFIG_SYS_FSL_TIMER_ADDR		0x02b00000
-
-#define CONFIG_SYS_TSEC1_OFFSET			0x01d10000
-#define CONFIG_SYS_TSEC2_OFFSET			0x01d50000
-#define CONFIG_SYS_TSEC3_OFFSET			0x01d90000
-#define CONFIG_SYS_MDIO1_OFFSET			0x01d24000
-
-#define ESDHC1_BASE_ADDR			(CONFIG_SYS_IMMR + 0x00560000)
-#define SCTR_BASE_ADDR				(CONFIG_SYS_IMMR + 0x01b00000)
-
-#define I2C1_BASE_ADDR				(CONFIG_SYS_IMMR + 0x01180000)
-#define I2C2_BASE_ADDR				(CONFIG_SYS_IMMR + 0x01190000)
-#define I2C3_BASE_ADDR				(CONFIG_SYS_IMMR + 0x011a0000)
-#define I2C4_BASE_ADDR				(CONFIG_SYS_IMMR + 0x011b0000)
-
-#define WDOG1_BASE_ADDR				(CONFIG_SYS_IMMR + 0x01ad0000)
-
-#define QSPI0_BASE_ADDR				(CONFIG_SYS_IMMR + 0x00550000)
-#define DSPI1_BASE_ADDR				(CONFIG_SYS_IMMR + 0x01100000)
-
-#define LPUART_BASE				(CONFIG_SYS_IMMR + 0x01950000)
-
-#define AHCI_BASE_ADDR				(CONFIG_SYS_IMMR + 0x02200000)
-
-/* SMMU Defintions */
-#define SMMU_BASE				0x09000000
-
-/* Generic Interrupt Controller Definitions */
-#define GICD_BASE              0x01401000
-#define GICC_BASE              0x01402000
-
-/* TZ Protection Controller Definitions */
-#define TZPC_BASE				0x02200000
-#define TZPCR0SIZE_BASE				(TZPC_BASE)
-#define TZPCDECPROT_0_STAT_BASE			(TZPC_BASE + 0x800)
-#define TZPCDECPROT_0_SET_BASE			(TZPC_BASE + 0x804)
-#define TZPCDECPROT_0_CLR_BASE			(TZPC_BASE + 0x808)
-#define TZPCDECPROT_1_STAT_BASE			(TZPC_BASE + 0x80C)
-#define TZPCDECPROT_1_SET_BASE			(TZPC_BASE + 0x810)
-#define TZPCDECPROT_1_CLR_BASE			(TZPC_BASE + 0x814)
-#define TZPCDECPROT_2_STAT_BASE			(TZPC_BASE + 0x818)
-#define TZPCDECPROT_2_SET_BASE			(TZPC_BASE + 0x81C)
-#define TZPCDECPROT_2_CLR_BASE			(TZPC_BASE + 0x820)
-
-/* TZ Address Space Controller Definitions */
-#define TZASC1_BASE			0x01100000	/* as per CCSR map. */
-#define TZASC2_BASE			0x01110000	/* as per CCSR map. */
-#define TZASC3_BASE			0x01120000	/* as per CCSR map. */
-#define TZASC4_BASE			0x01130000	/* as per CCSR map. */
-#define TZASC_BUILD_CONFIG_REG(x)	((TZASC1_BASE + (x * 0x10000)))
-#define TZASC_ACTION_REG(x)		((TZASC1_BASE + (x * 0x10000)) + 0x004)
-#define TZASC_GATE_KEEPER(x)		((TZASC1_BASE + (x * 0x10000)) + 0x008)
-#define TZASC_REGION_BASE_LOW_0(x)	((TZASC1_BASE + (x * 0x10000)) + 0x100)
-#define TZASC_REGION_BASE_HIGH_0(x)	((TZASC1_BASE + (x * 0x10000)) + 0x104)
-#define TZASC_REGION_TOP_LOW_0(x)	((TZASC1_BASE + (x * 0x10000)) + 0x108)
-#define TZASC_REGION_TOP_HIGH_0(x)	((TZASC1_BASE + (x * 0x10000)) + 0x10C)
-#define TZASC_REGION_ATTRIBUTES_0(x)	((TZASC1_BASE + (x * 0x10000)) + 0x110)
-#define TZASC_REGION_ID_ACCESS_0(x)	((TZASC1_BASE + (x * 0x10000)) + 0x114)
-
-#define CONFIG_SYS_FSL_DDR_BE
-#define CONFIG_VERY_BIG_RAM
-#define CONFIG_SYS_FSL_DDRC_ARM_GEN3    /* Enable Freescale ARM DDR3 driver */
-#define CONFIG_SYS_FSL_DDR              /* Freescale DDR driver */
-#define CONFIG_SYS_LS1_DDR_BLOCK1_SIZE  ((phys_size_t)2 << 30)
-#define CONFIG_MAX_MEM_MAPPED           CONFIG_SYS_LS1_DDR_BLOCK1_SIZE
-
-#define CONFIG_SYS_FSL_IFC_BE
-#define CONFIG_SYS_FSL_ESDHC_BE
-#define CONFIG_SYS_FSL_WDOG_BE
-#define CONFIG_SYS_FSL_DSPI_BE
-#define CONFIG_SYS_FSL_QSPI_BE
-
-#define QE_MURAM_SIZE          0x6000UL
-#define MAX_QE_RISC            1
-#define QE_NUM_OF_SNUM         28
-
-#define CONFIG_SYS_FSL_SRDS_1
-#define CONFIG_SYS_FSL_PCIE_COMPAT		"fsl,qoriq-pcie-v2.4"
-
-#ifdef CONFIG_LS102xA
-#define CONFIG_MAX_CPUS				2
-#define CONFIG_SYS_FSL_IFC_BANK_COUNT		4
-#define CONFIG_NUM_DDR_CONTROLLERS		1
-#define CONFIG_SYS_CCSRBAR_DEFAULT		0x01000000
-#define CONFIG_SYS_FSL_SEC_COMPAT		5
-#elif defined(CONFIG_LS1043A)
-#define CONFIG_MAX_CPUS				4
-#define CONFIG_SYS_FSL_IFC_BANK_COUNT		4
-#define CONFIG_NUM_DDR_CONTROLLERS		1
-#define CONFIG_SYS_CCSRBAR_DEFAULT		0x01000000
-#define CONFIG_SYS_FSL_SEC_COMPAT		5
-#else
-#error SoC not defined
-#endif
-
-
-#define CONFIG_SYS_FSL_SFP_VER_3_2
-#define CONFIG_SYS_FSL_SNVS_LE
-#define CONFIG_SYS_FSL_SEC_LE
-#define CONFIG_SYS_FSL_SFP_BE
-#define CONFIG_SYS_FSL_SRK_LE
-#define CONFIG_KEY_REVOCATION
-
-#endif /* _ASM_ARMV8_FSL_LSCH2_CONFIG_ */
-- 
2.17.1

