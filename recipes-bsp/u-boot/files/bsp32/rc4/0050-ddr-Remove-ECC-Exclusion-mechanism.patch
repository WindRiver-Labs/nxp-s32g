From 4a0b4c3d7bddf13cf5d35aab128e3c831614806d Mon Sep 17 00:00:00 2001
From: Andrei Cherechesu <andrei.cherechesu@nxp.com>
Date: Thu, 20 Jan 2022 16:05:54 +0200
Subject: [PATCH 50/64] ddr: Remove ECC Exclusion mechanism

Removed the ECC Exclusion mechanism, which is now part
of the ATF DDR driver.

The RAM banks start/size parameters will now be taken from
U-Boot's DT 'memory' nodes, as modified by ATF beforehand.

Modified the get_effective_memsize() function to also read
the size of the first DRAM bank from its corresponding
DT node.

Issue: ALB-8325
Upstream-Status: Pending 

Signed-off-by: Andrei Cherechesu <andrei.cherechesu@nxp.com>
Signed-off-by: Zhantao Tang <zhantao.tang@windriver.com>
---
 arch/arm/cpu/armv8/s32/cpu.c           | 130 +++----------------
 board/freescale/s32-gen1/Makefile      |   9 +-
 board/freescale/s32-gen1/ddr_density.c | 170 -------------------------
 board/freescale/s32-gen1/ddr_density.h |  56 --------
 4 files changed, 20 insertions(+), 345 deletions(-)
 delete mode 100644 board/freescale/s32-gen1/ddr_density.c
 delete mode 100644 board/freescale/s32-gen1/ddr_density.h

diff --git a/arch/arm/cpu/armv8/s32/cpu.c b/arch/arm/cpu/armv8/s32/cpu.c
index 6029f8c00f..07d43fc26c 100644
--- a/arch/arm/cpu/armv8/s32/cpu.c
+++ b/arch/arm/cpu/armv8/s32/cpu.c
@@ -422,109 +422,6 @@ static int s32_gentimer_init(void)
 }
 #endif /* CONFIG_S32_STANDALONE_BOOT_FLOW */
 
-#if defined(CONFIG_SYS_FSL_DDRSS) && \
-	!defined(CONFIG_TARGET_TYPE_S32GEN1_EMULATOR)
-#include "ddr_density.h"
-
-static inline bool get_intersection(unsigned long s1, unsigned long e1,
-				    unsigned long s2, unsigned long e2,
-				    unsigned long *s3, unsigned long *e3)
-{
-	if (s2 > e1 || s1 > e2)
-		return false;
-
-	*s3 = max(s1, s2);
-	*e3 = min(e1, e2);
-
-	return true;
-}
-
-static bool is_ext_addr(unsigned long addr)
-{
-	return addr >= S32GEN1_DRAM_EXT_ADDR;
-}
-
-static unsigned long to_ext_addr(unsigned long addr)
-{
-	return addr - S32GEN1_DRAM_STD_ADDR + S32GEN1_DRAM_EXT_ADDR;
-}
-
-static unsigned long to_std_addr(unsigned long addr)
-{
-	return addr + S32GEN1_DRAM_STD_ADDR - S32GEN1_DRAM_EXT_ADDR;
-}
-
-static void s32_exclude_ecc(unsigned long *start, unsigned long *size)
-{
-	static struct s32_ddr_region pages[S32GEN1_DDR_MAX_NO_PAGES];
-	static int active_pages;
-	static bool init_pages;
-	unsigned long pg_start, pg_end;
-	unsigned long r_start, r_end;
-	bool std_map;
-	u32 j;
-
-	if (!init_pages) {
-		s32gen1_get_ddr_regions(pages, &active_pages);
-		init_pages = true;
-	}
-
-	/* Skip SRAM */
-	if (*start == S32_SRAM_BASE)
-		return;
-
-	/* Use extended addresses */
-	if (!is_ext_addr(*start)) {
-		*start = to_ext_addr(*start);
-		std_map = true;
-	} else {
-		std_map = false;
-	}
-
-	for (j = 0; j < active_pages; j++) {
-		pg_start = pages[j].address;
-		pg_end = pg_start + pages[j].size;
-
-		if (!get_intersection(*start, *start + *size,
-				      pg_start, pg_end,
-				      &r_start, &r_end))
-			continue;
-
-		*start = r_start;
-		*size = r_end - r_start;
-	}
-
-	if (std_map)
-		*start = to_std_addr(*start);
-}
-
-static void s32_exclude_ecc_range(unsigned long start, unsigned long *size)
-{
-	s32_exclude_ecc(&start, size);
-}
-
-static void s32_exclude_ecc_from_dram(void)
-{
-	unsigned long start, size;
-	u32 i;
-
-	if (!gd->bd) {
-		pr_err("gd->bd isn't initialized\n");
-		return;
-	}
-
-	for (i = 0; i < CONFIG_NR_DRAM_BANKS; i++) {
-		start = gd->bd->bi_dram[i].start;
-		size = gd->bd->bi_dram[i].size;
-
-		s32_exclude_ecc(&start, &size);
-
-		gd->bd->bi_dram[i].start = start;
-		gd->bd->bi_dram[i].size = size;
-	}
-}
-#endif
-
 static void s32_init_ram_size(void)
 {
 	int i;
@@ -571,17 +468,14 @@ int dram_init_banksize(void)
 #endif
 	s32_init_ram_size();
 
-#if defined(CONFIG_SYS_FSL_DDRSS) && \
-	!defined(CONFIG_TARGET_TYPE_S32GEN1_EMULATOR)
-	s32_exclude_ecc_from_dram();
-#endif
-
 	return 0;
 }
 
 phys_size_t __weak get_effective_memsize(void)
 {
 	unsigned long size;
+	int nodeoff = -1, ret;
+	struct fdt_resource res = {.start = 0, .end = 0};
 
 	/*
 	 * Restrict U-Boot area to the first bank of the DDR memory.
@@ -591,13 +485,23 @@ phys_size_t __weak get_effective_memsize(void)
 	size = get_sram_size();
 #else
 	size = CONFIG_SYS_FSL_DRAM_SIZE1;
-
-#if defined(CONFIG_SYS_FSL_DDRSS) && \
-	!defined(CONFIG_TARGET_TYPE_S32GEN1_EMULATOR)
-	s32_exclude_ecc_range(CONFIG_SYS_FSL_DRAM_BASE1, &size);
 #endif
 
-#endif
+	/* Get first DDR bank size from DT 'memory' node */
+	while ((nodeoff = fdt_node_offset_by_prop_value(gd->fdt_blob, nodeoff,
+							"device_type",
+							"memory", 7)) >= 0) {
+		ret = fdt_get_resource(gd->fdt_blob, nodeoff, "reg", 0, &res);
+		if (ret) {
+			pr_err("Unable to get 'reg' values of memory node\n");
+			return ret;
+		}
+		if (res.start == CONFIG_SYS_FSL_DRAM_BASE1) {
+			size = res.end - res.start + 1;
+			break;
+		}
+	}
+
 	return size;
 }
 
diff --git a/board/freescale/s32-gen1/Makefile b/board/freescale/s32-gen1/Makefile
index 77d49cccb0..ec52802600 100644
--- a/board/freescale/s32-gen1/Makefile
+++ b/board/freescale/s32-gen1/Makefile
@@ -30,8 +30,7 @@ obj-$(CONFIG_SYS_FSL_DDRSS) += ddrss_regconf_emu.o ddrss_firmware_emu.o
 else
 
 ifneq ($(filter y,$(CONFIG_NXP_S32G2XX)),)
-obj-$(CONFIG_SYS_FSL_DDRSS) +=	ddr_density.o \
-				ddr_init.o \
+obj-$(CONFIG_SYS_FSL_DDRSS) +=	ddr_init.o \
 				ddr_utils.o \
 				ddrss_cfg.o \
 				imem_cfg.o \
@@ -44,8 +43,7 @@ obj-$(CONFIG_SYS_FSL_DDRSS) +=	ddr_density.o \
 endif
 
 ifneq ($(filter y,$(CONFIG_NXP_S32G3XX)),)
-obj-$(CONFIG_SYS_FSL_DDRSS) +=	ddr_density.o \
-				ddr_init.o \
+obj-$(CONFIG_SYS_FSL_DDRSS) +=	ddr_init.o \
 				ddr_utils.o \
 				ddrss_cfg.o \
 				imem_cfg.o \
@@ -58,8 +56,7 @@ obj-$(CONFIG_SYS_FSL_DDRSS) +=	ddr_density.o \
 endif
 
 ifneq ($(filter y,$(CONFIG_TARGET_S32R45EVB)),)
-obj-$(CONFIG_SYS_FSL_DDRSS) +=	ddr_density.o \
-				ddr_init.o \
+obj-$(CONFIG_SYS_FSL_DDRSS) +=	ddr_init.o \
 				ddr_utils.o \
 				ddrss_cfg.o \
 				imem_cfg.o \
diff --git a/board/freescale/s32-gen1/ddr_density.c b/board/freescale/s32-gen1/ddr_density.c
deleted file mode 100644
index 1edc2dd1e5..0000000000
--- a/board/freescale/s32-gen1/ddr_density.c
+++ /dev/null
@@ -1,170 +0,0 @@
-// SPDX-License-Identifier:     GPL-2.0+
-/*
- * Copyright 2021 NXP
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are met:
- *
- * 1. Redistributions of source code must retain the above copyright notice,
- * this list of conditions and the following disclaimer.
- *
- * 2. Redistributions in binary form must reproduce the above copyright notice,
- * this list of conditions and the following disclaimer in the documentation
- * and/or other materials provided with the distribution.
- *
- * 3. Neither the name of the copyright holder nor the names of its
- * contributors may be used to endorse or promote products derived from this
- * software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
- * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
- * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
- * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
- * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
- * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
- * POSSIBILITY OF SUCH DAMAGE.
- */
-
-#include "ddr_density.h"
-#include "ddr_utils.h"
-
-#include <linux/bitops.h>
-#include <bitfield.h>
-#include <linux/kernel.h>
-
-#define OFFSET_DDRC_START_ADDRMAP	0x21C
-
-#define NO_ADDRMAP_REGS			8
-
-/* ECC */
-#define ECC_MODE_MASK	0x00000007
-#define ECC_MODE_SHIFT	0x00000000
-#define ECC_DISABLE	0x00000000
-#define ECC_FLAG_MASK	0x00000001
-
-enum addr_map_masks {
-	ADDRMAP7 = 0x00000f0f,
-	ADDRMAP6 = 0x0f0f0f0f,
-	ADDRMAP5 = 0x0f0f0f00,
-	ADDRMAP4 = 0x00001f1f,
-	ADDRMAP3 = 0x1f1f1f1f,
-	ADDRMAP2 = 0x0f0f1f0f,
-	ADDRMAP1 = 0x003f3f3f,
-	ADDRMAP0 = 0x0000001f,
-};
-
-enum addr_map_internal_base {
-	ADDRMAP7_BASE = 0x00001716,
-	ADDRMAP6_BASE = 0x15141312,
-	ADDRMAP5_BASE = 0x11060706,
-	ADDRMAP4_BASE = 0x00000b0a,
-	ADDRMAP3_BASE = 0x09080706,
-	ADDRMAP2_BASE = 0x05040302,
-	ADDRMAP1_BASE = 0x00040302,
-	ADDRMAP0_BASE = 0x00000006,
-};
-
-enum addr_map_shift {
-	ADDRMAP7_SHIFT = 0x00000800,
-	ADDRMAP6_SHIFT = 0x18100800,
-	ADDRMAP5_SHIFT = 0x18100800,
-	ADDRMAP4_SHIFT = 0x00000800,
-	ADDRMAP3_SHIFT = 0x18100800,
-	ADDRMAP2_SHIFT = 0x18100800,
-	ADDRMAP1_SHIFT = 0x00100800,
-	ADDRMAP0_SHIFT = 0x00000000,
-};
-
-static const enum addr_map_masks addr_map_masks_map[] = {
-	ADDRMAP7, ADDRMAP6, ADDRMAP5, ADDRMAP4,
-	ADDRMAP3, ADDRMAP2, ADDRMAP1, ADDRMAP0
-};
-
-static const enum addr_map_shift addr_map_shift_map[] = {
-	ADDRMAP7_SHIFT, ADDRMAP6_SHIFT, ADDRMAP5_SHIFT,
-	ADDRMAP4_SHIFT, ADDRMAP3_SHIFT, ADDRMAP2_SHIFT,
-	ADDRMAP1_SHIFT, ADDRMAP0_SHIFT
-};
-
-static const enum addr_map_internal_base addr_map_internal_base_map[] = {
-	ADDRMAP7_BASE, ADDRMAP6_BASE, ADDRMAP5_BASE, ADDRMAP4_BASE,
-	ADDRMAP3_BASE, ADDRMAP2_BASE, ADDRMAP1_BASE, ADDRMAP0_BASE
-};
-
-static inline u32 get_byte(u32 val, u32 nr)
-{
-	return bitfield_extract(val, 8 * nr, 8);
-}
-
-void s32gen1_get_ddr_regions(struct s32_ddr_region
-			     pages[S32GEN1_DDR_MAX_NO_PAGES],
-			     int *active_pages)
-{
-	u32 i, sh, mk;
-	u32 *reg = (u32 *)(DDRC_BASE_ADDR + OFFSET_DDRC_START_ADDRMAP);
-	u32 idx, tmp, reg_val, max_hif = 0;
-	struct s32_ddr_region curr_page = {
-		.address = 0x800000000,
-		/* Reset value */
-		.flags = 0x0,
-	};
-
-	reg_val = readl(DDRC_BASE_ADDR + OFFSET_DDRC_ECCCFG0);
-	reg_val = (reg_val & ECC_MODE_MASK) >> ECC_MODE_SHIFT;
-
-	if (reg_val != ECC_DISABLE)
-		curr_page.flags |= ECC_ON;
-
-	/**
-	 * Calculate the size.
-	 * Use HIF address bit number to determine total density
-	 */
-	for (idx = 0; idx < NO_ADDRMAP_REGS ; idx++, reg--) {
-		/* We start with highest reg */
-		reg_val = readl(reg);
-
-		if ((reg_val & addr_map_masks_map[idx]) ==
-		    addr_map_masks_map[idx])
-			continue;
-
-		for (i = 0; i < 4; i++) {
-			sh = get_byte(addr_map_shift_map[idx], i);
-			mk = get_byte(addr_map_masks_map[idx], i);
-			/**
-			 * If is equals to mask value it means it is disabled so
-			 * we don't need to process it
-			 */
-			tmp = ((reg_val >> sh) & mk);
-			if (tmp != mk) {
-				tmp += get_byte(addr_map_internal_base_map[idx],
-						i);
-				max_hif = max(tmp, max_hif);
-			}
-		}
-	}
-
-	max_hif++;
-	curr_page.size =  (1 << max_hif);
-
-	/**
-	 * Convert to AXI
-	 * See details in System Address to Physical Address Mapping
-	 */
-	curr_page.size <<= 2;
-
-	/**
-	 * If ECC is used we need to exclude the ECC region
-	 * ECC is always the last 1/8 of the memory
-	 */
-	if (curr_page.flags & ECC_FLAG_MASK)
-		curr_page.size = (curr_page.size * 7) / 8;
-
-	*active_pages = 1;
-
-	pages[0] =  curr_page;
-}
-
diff --git a/board/freescale/s32-gen1/ddr_density.h b/board/freescale/s32-gen1/ddr_density.h
deleted file mode 100644
index be4711f02c..0000000000
--- a/board/freescale/s32-gen1/ddr_density.h
+++ /dev/null
@@ -1,56 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0+ */
-/*
- * Copyright 2021 NXP
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are met:
- *
- * 1. Redistributions of source code must retain the above copyright notice,
- * this list of conditions and the following disclaimer.
- *
- * 2. Redistributions in binary form must reproduce the above copyright notice,
- * this list of conditions and the following disclaimer in the documentation
- * and/or other materials provided with the distribution.
- *
- * 3. Neither the name of the copyright holder nor the names of its
- * contributors may be used to endorse or promote products derived from this
- * software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
- * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
- * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
- * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
- * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
- * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
- * POSSIBILITY OF SUCH DAMAGE.
- */
-#ifndef DDR_DENSITY_H
-#define DDR_DENSITY_H
-
-#define ECC_FLAG_SHIFT	0
-#define ECC_ON		1
-#define ECC_OFF		0
-
-/* Hardware limitation */
-#define S32GEN1_DDR_MAX_NO_PAGES	5
-
-struct s32_ddr_region {
-	unsigned long flags; // e.g. ECC ON/OFF
-	unsigned long address; // start address
-	unsigned long size; // memory region size - total density
-};
-
-/**
- * Gets all DDR memory region based on Address Mapping registers
- * and ECC s32_ddr_regions
- */
-void s32gen1_get_ddr_regions(struct s32_ddr_region
-			     pages[S32GEN1_DDR_MAX_NO_PAGES],
-			     int *active_pages);
-
-#endif /* DDR_DENSITY_H */
-
-- 
2.17.1

