From 66852a294cdb5705c249853d2026e328dda37529 Mon Sep 17 00:00:00 2001
From: Ciprian Costea <ciprianmarian.costea@nxp.com>
Date: Tue, 15 Feb 2022 10:32:01 +0200
Subject: [PATCH 11/51] siul2: nvram: Add method to indentify max number of
 cores per cluster

Issue: ALB-8517
Upstream-Status: Pending 

Signed-off-by: Ciprian Costea <ciprianmarian.costea@nxp.com>
Signed-off-by: Zhantao Tang <zhantao.tang@windriver.com>
---
 arch/arm/dts/fsl-s32g.dtsi         |   2 +-
 arch/arm/dts/fsl-s32r45.dts        |   2 +-
 drivers/misc/s32gen1_siul2_nvram.c | 161 ++++++++++++++++++++++++++++-
 drivers/misc/s32gen1_siul2_nvram.h |   8 ++
 4 files changed, 169 insertions(+), 4 deletions(-)

diff --git a/arch/arm/dts/fsl-s32g.dtsi b/arch/arm/dts/fsl-s32g.dtsi
index f361414a60..45ff5a13a2 100644
--- a/arch/arm/dts/fsl-s32g.dtsi
+++ b/arch/arm/dts/fsl-s32g.dtsi
@@ -151,7 +151,7 @@
 		};
 
 		siul2_0_nvram {
-			compatible = "fsl,s32-gen1-siul2_0-nvram";
+			compatible = "fsl,s32g-siul2_0-nvram";
 			status = "okay";
 			u-boot,dm-pre-reloc;
 		};
diff --git a/arch/arm/dts/fsl-s32r45.dts b/arch/arm/dts/fsl-s32r45.dts
index b5366a8101..a7524333bf 100644
--- a/arch/arm/dts/fsl-s32r45.dts
+++ b/arch/arm/dts/fsl-s32r45.dts
@@ -65,7 +65,7 @@
 		};
 
 		siul2_0_nvram {
-			compatible = "fsl,s32-gen1-siul2_0-nvram";
+			compatible = "fsl,s32r-siul2_0-nvram";
 			status = "okay";
 			u-boot,dm-pre-reloc;
 		};
diff --git a/drivers/misc/s32gen1_siul2_nvram.c b/drivers/misc/s32gen1_siul2_nvram.c
index c671619e03..6d1bd210ea 100644
--- a/drivers/misc/s32gen1_siul2_nvram.c
+++ b/drivers/misc/s32gen1_siul2_nvram.c
@@ -43,6 +43,17 @@
 #define S32G2_SUBMINOR_SHIFT	26
 #define S32G2_SUBMINOR_MASK	GENMASK(27, 26)
 
+#define S32G_MIN_PART_NO	233
+#define S32G_MAX_PART_NO	399
+#define S32R_PART_NO_MIN	450
+
+#define CPUMASK_S32G2		((BIT(0) | BIT(1) | BIT(2) | BIT(3)))
+#define CPUMASK_S32G2_DERIVATIVE	(BIT(0) | BIT(2))
+#define CPUMASK_S32G3		(BIT(0) | BIT(1) | BIT(2) | BIT(3) | \
+				 BIT(4) | BIT(5) | BIT(6) | BIT(7))
+#define CPUMASK_S32G3_DERIVATIVE	(BIT(0) | BIT(1) | BIT(2) | BIT(3))
+#define CPUMASK_S32R		((BIT(0) | BIT(1) | BIT(2) | BIT(3)))
+
 struct siul2_nvram;
 
 struct siul_mapping {
@@ -64,6 +75,16 @@ struct siul2_nvram {
 	fdt_addr_t base;
 };
 
+static inline u32 get_second_digit(u32 val)
+{
+	return (val / 10) % 10;
+}
+
+static inline u32 get_third_digit(u32 val)
+{
+	return (val / 100) % 10;
+}
+
 static u32 adjust_letter(u32 value, struct siul2_nvram *nvram)
 {
 	return ('A' - 1 + value);
@@ -98,6 +119,92 @@ static u32 adjust_freq(u32 value, struct siul2_nvram *nvram)
 	return 0;
 }
 
+static u32 adjust_s32r_max_cores_per_cluster(u32 value,
+					     struct siul2_nvram *nvram)
+{
+	u32 vert_slot, plat_gen;
+
+	if (value < S32R_PART_NO_MIN)
+		return 0;
+
+	/* Get Platform Generation */
+	plat_gen = get_third_digit(value);
+
+	/* Get Number of Cores */
+	vert_slot = get_second_digit(value);
+
+	if (plat_gen == 4 && vert_slot == 5)
+		return 2;
+
+	return 0;
+}
+
+static u32 adjust_s32g_max_cores_per_cluster(u32 value,
+					     struct siul2_nvram *nvram)
+{
+	u32 series;
+
+	if (value < S32G_MIN_PART_NO || value > S32G_MAX_PART_NO)
+		return 0;
+
+	/* Get S32G platform flavour (S32G2/S32G3) */
+	series = get_third_digit(value);
+
+	if (series == 3)
+		return 4;
+
+	return 2;
+}
+
+static u32 adjust_s32r_derivative_cores(u32 value,
+					struct siul2_nvram *nvram)
+{
+	u32 vert_slot, plat_gen;
+
+	if (value < S32R_PART_NO_MIN)
+		return 0;
+
+	/* Get Platform Generation */
+	plat_gen = get_third_digit(value);
+
+	/* Get Number of Cores */
+	vert_slot = get_second_digit(value);
+
+	if (plat_gen == 4 && vert_slot == 5)
+		return CPUMASK_S32R;
+
+	return 0;
+}
+
+static u32 adjust_s32g_derivative_cores(u32 value,
+					struct siul2_nvram *nvram)
+{
+	u32 series;
+	u32 perf_id;
+
+	if (value < S32G_MIN_PART_NO || value > S32G_MAX_PART_NO)
+		return 0;
+
+	perf_id = get_second_digit(value);
+
+	/* Get S32G platform flavour (S32G2/S32G3) */
+	series = get_third_digit(value);
+
+	if (series == 3) {
+		if (perf_id == 9)
+			return CPUMASK_S32G3;
+		else if (perf_id == 7)
+			return CPUMASK_S32G3_DERIVATIVE;
+	} else if (series == 2) {
+		if (perf_id == 3 || perf_id == 5)
+			return CPUMASK_S32G2_DERIVATIVE;
+		else if (perf_id == 7)
+			return CPUMASK_S32G2;
+	}
+
+	return 0;
+}
+
 static const struct siul_mapping siul20_mappings[] = {
 	{
 		.nvram_off = S32GEN1_SOC_MAJOR,
@@ -149,6 +256,40 @@ static const struct siul_mapping siul21_mappings[] = {
 	},
 };
 
+static const struct siul_mapping s32g_siul20_mappings[] = {
+	{
+		.nvram_off = S32GEN1_MAX_A53_CORES_PER_CLUSTER,
+		.siul2_off = MIDR1_OFF,
+		.mask = PART_NO_MASK,
+		.shift = PART_NO_SHIFT,
+		.adjust_value = adjust_s32g_max_cores_per_cluster,
+	},
+	{
+		.nvram_off = S32GEN1_A53_CORES_MASK,
+		.siul2_off = MIDR1_OFF,
+		.mask = PART_NO_MASK,
+		.shift = PART_NO_SHIFT,
+		.adjust_value = adjust_s32g_derivative_cores,
+	},
+};
+
+static const struct siul_mapping s32r_siul20_mappings[] = {
+	{
+		.nvram_off = S32GEN1_MAX_A53_CORES_PER_CLUSTER,
+		.siul2_off = MIDR1_OFF,
+		.mask = PART_NO_MASK,
+		.shift = PART_NO_SHIFT,
+		.adjust_value = adjust_s32r_max_cores_per_cluster,
+	},
+	{
+		.nvram_off = S32GEN1_A53_CORES_MASK,
+		.siul2_off = MIDR1_OFF,
+		.mask = PART_NO_MASK,
+		.shift = PART_NO_SHIFT,
+		.adjust_value = adjust_s32r_derivative_cores,
+	},
+};
+
 static const struct siul_mapping s32g2_siul21_mappings[] = {
 	{
 		.nvram_off = S32GEN1_SOC_SUBMINOR,
@@ -168,6 +309,18 @@ static const struct siul_platdata siul21_platdata = {
 	.n_mappings = ARRAY_SIZE(siul21_mappings),
 };
 
+static const struct siul_platdata s32g_siul20_platdata = {
+	.mappings = &s32g_siul20_mappings[0],
+	.n_mappings = ARRAY_SIZE(s32g_siul20_mappings),
+	.next = &siul20_platdata,
+};
+
+static const struct siul_platdata s32r_siul20_platdata = {
+	.mappings = &s32r_siul20_mappings[0],
+	.n_mappings = ARRAY_SIZE(s32r_siul20_mappings),
+	.next = &siul20_platdata,
+};
+
 static const struct siul_platdata s32g2_siul21_platdata = {
 	.mappings = &s32g2_siul21_mappings[0],
 	.n_mappings = ARRAY_SIZE(s32g2_siul21_mappings),
@@ -220,8 +373,12 @@ static const struct misc_ops siul2_nvram_ops = {
 
 static const struct udevice_id siul2_nvram_ids[] = {
 	{
-		.compatible = "fsl,s32-gen1-siul2_0-nvram",
-		.data = (ulong)&siul20_platdata
+		.compatible = "fsl,s32g-siul2_0-nvram",
+		.data = (ulong)&s32g_siul20_platdata,
+	},
+	{
+		.compatible = "fsl,s32r-siul2_0-nvram",
+		.data = (ulong)&s32r_siul20_platdata,
 	},
 	{
 		.compatible = "fsl,s32g2-siul2_1-nvram",
diff --git a/drivers/misc/s32gen1_siul2_nvram.h b/drivers/misc/s32gen1_siul2_nvram.h
index 5bd865b19e..e93cd44148 100644
--- a/drivers/misc/s32gen1_siul2_nvram.h
+++ b/drivers/misc/s32gen1_siul2_nvram.h
@@ -11,6 +11,14 @@
 #define S32GEN1_SOC_MAJOR	0x8
 #define S32GEN1_SOC_MINOR	0xc
 #define S32GEN1_MAX_CORE_FREQ	0x10
+#define S32GEN1_MAX_A53_CORES_PER_CLUSTER	0x14
+
+/* Used for getting a mask where the state of a bit
+ * on position N corresponds to Core N,
+ * 0 = defeatured
+ * 1 = available
+ */
+#define S32GEN1_A53_CORES_MASK	0x18
 
 /* siul2_1 */
 #define S32GEN1_SERDES_PRESENCE	0x100
-- 
2.17.1

