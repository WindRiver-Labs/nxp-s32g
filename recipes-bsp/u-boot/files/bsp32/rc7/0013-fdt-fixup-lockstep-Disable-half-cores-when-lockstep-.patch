From df268f7b44d6b7e331b4009bf8000c9cfb178519 Mon Sep 17 00:00:00 2001
From: Ciprian Costea <ciprianmarian.costea@nxp.com>
Date: Tue, 15 Feb 2022 10:34:19 +0200
Subject: [PATCH 13/51] fdt: fixup: lockstep: Disable half cores when lockstep
 is enabled

Issue: ALB-8517
Upstream-Status: Pending 

Signed-off-by: Ciprian Costea <ciprianmarian.costea@nxp.com>
Signed-off-by: Zhantao Tang <zhantao.tang@windriver.com>
---
 arch/arm/cpu/armv8/s32/fdt.c | 125 +++++++++++++++++++++++++++++++++++
 1 file changed, 125 insertions(+)

diff --git a/arch/arm/cpu/armv8/s32/fdt.c b/arch/arm/cpu/armv8/s32/fdt.c
index bd6d1a302a..82c6589891 100644
--- a/arch/arm/cpu/armv8/s32/fdt.c
+++ b/arch/arm/cpu/armv8/s32/fdt.c
@@ -15,6 +15,10 @@
 #include <asm/arch-s32/s32-gen1/serdes_hwconfig.h>
 #include <dt-bindings/phy/phy.h>
 #include <linux/ctype.h>
+#include <dm/uclass.h>
+#include <misc.h>
+#include <s32gen1_a53_gpr.h>
+#include <s32gen1_siul2_nvram.h>
 
 DECLARE_GLOBAL_DATA_PTR;
 
@@ -37,6 +41,126 @@ DECLARE_GLOBAL_DATA_PTR;
 
 #define S32_DDR_LIMIT_VAR "ddr_limitX"
 
+static int get_core_id(u32 core_mpidr, u32 max_cores_per_cluster)
+{
+	u32 cluster_id = (core_mpidr >> 8) & 0xFF;
+
+	return (core_mpidr & 0xf) + cluster_id * max_cores_per_cluster;
+}
+
+static int get_cores_info(u32 *max_cores_per_cluster,
+			  u32 *cpu_mask)
+{
+	int ret;
+	const char *dev_name = "siul2_0_nvram";
+	struct udevice *siul2_nvmem = NULL;
+
+	ret = uclass_get_device_by_name(UCLASS_MISC, dev_name,
+					&siul2_nvmem);
+	if (ret) {
+		printf("%s: No SIUL21 NVMEM (err = %d)\n", __func__, ret);
+		return ret;
+	}
+
+	ret = misc_read(siul2_nvmem, S32GEN1_MAX_A53_CORES_PER_CLUSTER,
+			max_cores_per_cluster, sizeof(*max_cores_per_cluster));
+	if (ret != sizeof(*max_cores_per_cluster)) {
+		printf("%s: Failed to read SoC's Part Number (err = %d)\n",
+		       __func__, ret);
+		return ret;
+	}
+	if (!(*max_cores_per_cluster)) {
+		printf("%s: Number of max cores per cluster cannot be 0\n",
+		       __func__);
+		return -EINVAL;
+	}
+
+	ret = misc_read(siul2_nvmem, S32GEN1_A53_CORES_MASK,
+			cpu_mask, sizeof(*cpu_mask));
+	if (ret != sizeof(*cpu_mask)) {
+		printf("%s: Failed to read SoC's Part Number (err = %d)\n",
+		       __func__, ret);
+		return ret;
+	}
+
+	return 0;
+}
+
+static bool is_lockstep_enabled(void)
+{
+	int ret;
+	u32 lockstep_enabled = 0;
+	const char *dev_name = "a53_gpr";
+	struct udevice *s32gen1_a53_gpr = NULL;
+
+	ret = uclass_get_device_by_name(UCLASS_MISC, dev_name,
+					&s32gen1_a53_gpr);
+	if (ret) {
+		printf("%s: No A53 GPR (err = %d)\n", __func__, ret);
+		return false;
+	}
+
+	ret = misc_read(s32gen1_a53_gpr, S32GEN1_A53_GPR_LOCKSTEP_EN,
+			&lockstep_enabled, sizeof(lockstep_enabled));
+	if (ret != sizeof(lockstep_enabled)) {
+		printf("%s: Failed to read if Lockstep Enabled (err = %d)\n",
+		       __func__, ret);
+		return false;
+	}
+
+	return !!lockstep_enabled;
+}
+
+static void ft_fixup_cpu(void *blob)
+{
+	int off, addr_cells = 0;
+	int off_prev = -1;
+	u32 max_cores_per_cluster = 0;
+	u32 cpu_mask = 0;
+	u64 core_mpidr, core_id;
+	fdt32_t *reg;
+
+	if (get_cores_info(&max_cores_per_cluster, &cpu_mask))
+		return;
+
+	off = fdt_path_offset(blob, "/cpus");
+	if (off < 0) {
+		puts("couldn't find /cpus node\n");
+		return;
+	}
+
+	fdt_support_default_count_cells(blob, off, &addr_cells, NULL);
+	off = fdt_node_offset_by_prop_value(blob, off_prev, "device_type",
+					    "cpu", 4);
+
+	if (is_lockstep_enabled()) {
+		/* Disable secondary cluster */
+		cpu_mask &= ~GENMASK(max_cores_per_cluster * 2 - 1,
+							 max_cores_per_cluster);
+	}
+
+	while (off != -FDT_ERR_NOTFOUND) {
+		reg = (fdt32_t *)fdt_getprop(blob, off, "reg", 0);
+		if (!reg)
+			continue;
+
+		core_mpidr = fdt_read_number(reg, addr_cells);
+		core_id = get_core_id(core_mpidr, max_cores_per_cluster);
+
+		if (!test_bit(core_id, &cpu_mask)) {
+			/* Disable lockstep or defeatured
+			 * cores on derivatives
+			 */
+			fdt_del_node(blob, off);
+			off = off_prev;
+		}
+
+		off_prev = off;
+		off = fdt_node_offset_by_prop_value(blob, off_prev,
+						    "device_type", "cpu", 4);
+	}
+}
+
 static void ft_fixup_ddr_polling(const void *old_blob, void *new_blob)
 {
 	int off, ret;
@@ -582,6 +706,7 @@ static void ft_fixup_serdes(void *blob)
 
 void ft_cpu_setup(void *blob, bd_t *bd)
 {
+	ft_fixup_cpu(blob);
 	ft_fixup_memory(blob, bd);
 	ft_fixup_ddr_polling(gd->fdt_blob, blob);
 	ft_fixup_atf(gd->fdt_blob, blob);
-- 
2.17.1

