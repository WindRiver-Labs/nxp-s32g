From 2300e3bb4b0b6c539815cd8e701900f0a90795d7 Mon Sep 17 00:00:00 2001
From: Ghennadi Procopciuc <ghennadi.procopciuc@nxp.com>
Date: Tue, 16 Nov 2021 16:47:46 +0200
Subject: [PATCH 16/20] Remove S32V2 drivers

Issue: ALB-8201
Upstream-Status: Pending 

Signed-off-by: Ghennadi Procopciuc <ghennadi.procopciuc@nxp.com>
Signed-off-by: Zhantao Tang <zhantao.tang@windriver.com>
---
 Makefile                                      |    4 -
 arch/arm/cpu/armv8/s32/Kconfig                |   32 -
 arch/arm/cpu/armv8/s32/Makefile               |    6 -
 arch/arm/cpu/armv8/s32/cpu.c                  |   84 +-
 arch/arm/cpu/armv8/s32/cse.c                  |  251 ----
 arch/arm/cpu/armv8/s32/dcu.c                  |   65 -
 arch/arm/cpu/armv8/s32/ddr3.c                 |  149 ---
 arch/arm/cpu/armv8/s32/fdt.c                  |   41 -
 arch/arm/cpu/armv8/s32/lowlevel.S             |   24 +-
 arch/arm/cpu/armv8/s32/lpddr2.c               |  146 ---
 arch/arm/cpu/armv8/s32/lpddr4.c               |  131 --
 arch/arm/cpu/armv8/s32/mp.c                   |   43 -
 arch/arm/cpu/armv8/s32/s32v234/Makefile       |   10 -
 arch/arm/cpu/armv8/s32/s32v234/clock.c        |  524 --------
 arch/arm/cpu/armv8/s32/s32v234/memory_map.txt |  185 ---
 arch/arm/cpu/armv8/s32/s32v234/qspi_driver.c  |  619 ---------
 arch/arm/cpu/armv8/s32/s32v234/qspi_iomux.c   |  138 --
 arch/arm/cpu/armv8/s32/s32v234/soc.c          | 1162 -----------------
 arch/arm/cpu/armv8/s32/s32v234/sram.S         |  108 --
 arch/arm/include/asm/arch-s32/clock.h         |   35 +-
 arch/arm/include/asm/arch-s32/cpu.h           |    4 -
 arch/arm/include/asm/arch-s32/ddr.h           |  159 ---
 arch/arm/include/asm/arch-s32/ddr3.h          |  184 ---
 arch/arm/include/asm/arch-s32/imx-regs.h      |  124 +-
 arch/arm/include/asm/arch-s32/lpddr2.h        |  106 --
 arch/arm/include/asm/arch-s32/lpddr4.h        |   78 --
 arch/arm/include/asm/arch-s32/mc_cgm_regs.h   |    9 +-
 arch/arm/include/asm/arch-s32/mc_me_regs.h    |   11 +-
 arch/arm/include/asm/arch-s32/mc_rgm_regs.h   |   11 +-
 arch/arm/include/asm/arch-s32/mmdc.h          |    6 +-
 arch/arm/include/asm/arch-s32/qspi_s32v234.h  |   25 -
 .../include/asm/arch-s32/s32v234/dma_macros.h |   49 -
 .../asm/arch-s32/s32v234/mc_cgm_regs.h        |  369 ------
 .../include/asm/arch-s32/s32v234/mc_me_regs.h |  206 ---
 .../asm/arch-s32/s32v234/mc_rgm_regs.h        |   43 -
 .../asm/arch-s32/s32v234/s32v234-regs.h       |  180 ---
 arch/arm/include/asm/arch-s32/siul-s32v234.h  |  715 ----------
 arch/arm/include/asm/arch-s32/siul.h          |   13 +-
 arch/arm/include/asm/arch-s32/soc.h           |   19 +-
 arch/arm/include/asm/arch-s32/src.h           |  129 --
 arch/arm/include/asm/arch-s32/xrdc.h          |   32 -
 board/freescale/Kconfig                       |    2 -
 board/freescale/s32-gen1/Kconfig              |    2 +-
 board/freescale/s32-gen1/board_common.h       |    2 -
 board/freescale/s32-gen1/ddr_utils.h          |    5 -
 common/image.c                                |    1 -
 configs/s32g274a_emu_defconfig                |    1 -
 configs/s32g274a_sim_defconfig                |    1 -
 configs/s32g274abluebox3_defconfig            |    1 -
 configs/s32g274abluebox3_qspi_defconfig       |    1 -
 configs/s32g274ardb2_defconfig                |    1 -
 configs/s32g274ardb2_qspi_defconfig           |    1 -
 configs/s32g2xxaevb_defconfig                 |    1 -
 configs/s32g2xxaevb_qspi_defconfig            |    1 -
 configs/s32g399a_emu_defconfig                |    1 -
 configs/s32g3xxaevb_defconfig                 |    1 -
 configs/s32g3xxaevb_qspi_defconfig            |    1 -
 configs/s32r45_emu_defconfig                  |    1 -
 configs/s32r45_sim_defconfig                  |    1 -
 configs/s32r45evb_defconfig                   |    1 -
 configs/s32r45evb_qspi_defconfig              |    1 -
 drivers/i2c/mxc_i2c.c                         |    2 +-
 drivers/net/dwc_eth_qos_s32cc.c               |    2 +-
 drivers/net/fec_mxc.c                         |    4 +-
 drivers/net/fec_mxc.h                         |    5 -
 drivers/pci/Makefile                          |    1 -
 drivers/pci/pcie_s32v2xx.c                    |  819 ------------
 drivers/serial/serial_linflexuart.c           |    7 -
 drivers/spi/fsl_dspi.c                        |    3 +-
 include/configs/s32.h                         |   86 +-
 include/fsl_esdhc_imx.h                       |    3 +-
 include/image.h                               |    1 -
 scripts/config_whitelist.txt                  |    6 -
 tools/Makefile                                |    2 -
 tools/s32v234-cse/Makefile                    |   34 -
 tools/s32v234-cse/genCMAC.pl                  |   10 -
 tools/s32v234-cse/genCMAC.rb                  |    9 -
 tools/s32v234-cse/genHeader.pl                |   22 -
 tools/s32v234-cse/sec_call.c                  |   25 -
 tools/s32v234-cse/signmac.sh                  |   28 -
 tools/s32v234-smp/.gitignore                  |    2 -
 tools/s32v234-smp/makefile                    |   30 -
 tools/s32v234-smp/nop_generator.sh            |    9 -
 tools/s32v234-smp/readme.md                   |   22 -
 tools/s32v234image.c                          |  250 ----
 tools/s32v234image.h                          |  111 --
 86 files changed, 29 insertions(+), 7720 deletions(-)
 delete mode 100644 arch/arm/cpu/armv8/s32/cse.c
 delete mode 100644 arch/arm/cpu/armv8/s32/dcu.c
 delete mode 100644 arch/arm/cpu/armv8/s32/ddr3.c
 delete mode 100644 arch/arm/cpu/armv8/s32/lpddr2.c
 delete mode 100644 arch/arm/cpu/armv8/s32/lpddr4.c
 delete mode 100644 arch/arm/cpu/armv8/s32/s32v234/Makefile
 delete mode 100644 arch/arm/cpu/armv8/s32/s32v234/clock.c
 delete mode 100644 arch/arm/cpu/armv8/s32/s32v234/memory_map.txt
 delete mode 100644 arch/arm/cpu/armv8/s32/s32v234/qspi_driver.c
 delete mode 100644 arch/arm/cpu/armv8/s32/s32v234/qspi_iomux.c
 delete mode 100644 arch/arm/cpu/armv8/s32/s32v234/soc.c
 delete mode 100644 arch/arm/cpu/armv8/s32/s32v234/sram.S
 delete mode 100644 arch/arm/include/asm/arch-s32/ddr.h
 delete mode 100644 arch/arm/include/asm/arch-s32/ddr3.h
 delete mode 100644 arch/arm/include/asm/arch-s32/lpddr2.h
 delete mode 100644 arch/arm/include/asm/arch-s32/lpddr4.h
 delete mode 100644 arch/arm/include/asm/arch-s32/qspi_s32v234.h
 delete mode 100644 arch/arm/include/asm/arch-s32/s32v234/dma_macros.h
 delete mode 100644 arch/arm/include/asm/arch-s32/s32v234/mc_cgm_regs.h
 delete mode 100644 arch/arm/include/asm/arch-s32/s32v234/mc_me_regs.h
 delete mode 100644 arch/arm/include/asm/arch-s32/s32v234/mc_rgm_regs.h
 delete mode 100644 arch/arm/include/asm/arch-s32/s32v234/s32v234-regs.h
 delete mode 100644 arch/arm/include/asm/arch-s32/siul-s32v234.h
 delete mode 100644 arch/arm/include/asm/arch-s32/src.h
 delete mode 100644 arch/arm/include/asm/arch-s32/xrdc.h
 delete mode 100644 drivers/pci/pcie_s32v2xx.c
 delete mode 100644 tools/s32v234-cse/Makefile
 delete mode 100644 tools/s32v234-cse/genCMAC.pl
 delete mode 100644 tools/s32v234-cse/genCMAC.rb
 delete mode 100644 tools/s32v234-cse/genHeader.pl
 delete mode 100644 tools/s32v234-cse/sec_call.c
 delete mode 100755 tools/s32v234-cse/signmac.sh
 delete mode 100644 tools/s32v234-smp/.gitignore
 delete mode 100644 tools/s32v234-smp/makefile
 delete mode 100755 tools/s32v234-smp/nop_generator.sh
 delete mode 100644 tools/s32v234-smp/readme.md
 delete mode 100644 tools/s32v234image.c
 delete mode 100644 tools/s32v234image.h

diff --git a/Makefile b/Makefile
index b38e9c4b26..d97c2ae84e 100644
--- a/Makefile
+++ b/Makefile
@@ -988,7 +988,6 @@ ifneq ($(CONFIG_DM),y)
 	@echo >&2 "See doc/driver-model/migration.rst for more info."
 	@echo >&2 "===================================================="
 endif
-ifeq (,$(CONFIG_S32V234))
 ifeq ($(CONFIG_MMC),y)
 ifneq ($(CONFIG_DM_MMC)$(CONFIG_OF_CONTROL)$(CONFIG_BLK),yyy)
 	@echo >&2 "===================== WARNING ======================"
@@ -999,7 +998,6 @@ ifneq ($(CONFIG_DM_MMC)$(CONFIG_OF_CONTROL)$(CONFIG_BLK),yyy)
 	@echo >&2 "===================================================="
 endif
 endif
-endif
 ifeq ($(CONFIG_USB),y)
 ifneq ($(CONFIG_DM_USB)$(CONFIG_OF_CONTROL)$(CONFIG_BLK),yyy)
 	@echo >&2 "===================== WARNING ======================"
@@ -1031,7 +1029,6 @@ ifneq ($(CONFIG_AHCI),y)
 	@echo >&2 "===================================================="
 endif
 endif
-ifeq (,$(CONFIG_S32V234))
 ifeq ($(CONFIG_PCI),y)
 ifneq ($(CONFIG_DM_PCI),y)
 	@echo >&2 "===================== WARNING ======================"
@@ -1042,7 +1039,6 @@ ifneq ($(CONFIG_DM_PCI),y)
 	@echo >&2 "===================================================="
 endif
 endif
-endif
 ifneq ($(CONFIG_LCD)$(CONFIG_VIDEO),)
 ifneq ($(CONFIG_DM_VIDEO),y)
 	@echo >&2 "===================== WARNING ======================"
diff --git a/arch/arm/cpu/armv8/s32/Kconfig b/arch/arm/cpu/armv8/s32/Kconfig
index 624f5c4427..17afe93a31 100644
--- a/arch/arm/cpu/armv8/s32/Kconfig
+++ b/arch/arm/cpu/armv8/s32/Kconfig
@@ -101,38 +101,6 @@ endchoice
 
 endif
 
-choice
-	prompt "Select DDR type"
-	default S32_LPDDR2
-	help
-	  S32 DDR Configuration
-
-config S32_LPDDR2
-	bool "LPDDR2 Support"
-	help
-	  Enable the support for Micron LPDDR2,
-	  2*32-bit, up to 1066 MHz data rate, 2*1 GB addressable.
-
-config S32_LPDDR4
-	bool "LPDDR4 Support"
-	help
-	  Enable the support for Micron LPDDR4
-
-config S32_DDR3
-	bool "DDR3 Support"
-	help
-	  Enable the support for Micron DDR3,
-	  2*32-bit, up to 1066 MHz data rate, 2*1 GB addressable.
-
-endchoice
-
-config DDR_HANDSHAKE_AT_RESET
-	bool "Enable DDR handshake"
-	default y
-	help
-	  Enable DDR handshake after functional reset.
-	  Execute additional checks in case of a functional reset.
-
 config S32_CMU
 	bool "Enable Clock Monitoring Unit-Frequency Check"
 	default y
diff --git a/arch/arm/cpu/armv8/s32/Makefile b/arch/arm/cpu/armv8/s32/Makefile
index b7bdb6d49a..027dc05c45 100644
--- a/arch/arm/cpu/armv8/s32/Makefile
+++ b/arch/arm/cpu/armv8/s32/Makefile
@@ -6,20 +6,14 @@
 ccflags-y += -I./board/freescale/common/
 ccflags-y += -Iarch/arm/cpu/armv8/s32/
 
-obj-$(CONFIG_S32V234)		+= s32v234/
 obj-$(CONFIG_S32_GEN1)		+= s32-gen1/
 obj-$(CONFIG_S32_GEN1)		+= scmi_reset_agent.o
 obj-y				+= cpu.o
-obj-$(CONFIG_S32V234)		+= cse.o
 obj-y				+= lowlevel.o
 obj-$(CONFIG_SYS_PIT_TIMER)	+= timer.o
-obj-$(CONFIG_S32_LPDDR2)	+= lpddr2.o
-obj-$(CONFIG_S32_LPDDR4)	+= lpddr4.o
 obj-$(CONFIG_GICSUPPORT)	+= gicsupport.o
-obj-$(CONFIG_S32_DDR3)		+= ddr3.o
 obj-$(CONFIG_MP)		+= mp.o
 obj-$(CONFIG_OF_LIBFDT)		+= fdt.o
-obj-$(CONFIG_FSL_DCU_FB)	+= dcu.o
 obj-y				+= initsram.o
 ccflags-y			+= -Idrivers/clk/s32/include
 ccflags-y			+= -Idrivers/misc
diff --git a/arch/arm/cpu/armv8/s32/cpu.c b/arch/arm/cpu/armv8/s32/cpu.c
index a8127a3880..be258282f3 100644
--- a/arch/arm/cpu/armv8/s32/cpu.c
+++ b/arch/arm/cpu/armv8/s32/cpu.c
@@ -67,20 +67,12 @@ static struct mm_region early_map[] = {
 	  S32_SRAM_SIZE,
 	  PTE_BLOCK_MEMTYPE(MT_NORMAL) | PTE_BLOCK_OUTER_SHARE
 	},
-#ifdef CONFIG_S32_GEN1
 	{
 	  CONFIG_SYS_FSL_PERIPH_BASE, CONFIG_SYS_FSL_PERIPH_BASE,
 	  CONFIG_SYS_FSL_PERIPH_SIZE,
 	  PTE_BLOCK_MEMTYPE(MT_DEVICE_NGNRNE) | PTE_BLOCK_NON_SHARE |
 	  PTE_BLOCK_PXN | PTE_BLOCK_UXN
 	},
-#else	/* S32V234 */
-	{
-	  CONFIG_SYS_FSL_PERIPH_BASE, CONFIG_SYS_FSL_PERIPH_BASE,
-	  CONFIG_SYS_FSL_PERIPH_SIZE,
-	  PTE_BLOCK_MEMTYPE(MT_DEVICE_NGNRNE) | PTE_BLOCK_NON_SHARE
-	},
-#endif /* CONFIG_S32_GEN1 */
 #if defined(CONFIG_SYS_FSL_DRAM_BASE2)
 #if !defined(CONFIG_S32_SKIP_RELOC) || \
 	(defined(CONFIG_S32_SKIP_RELOC) && defined(CONFIG_S32_ATF_BOOT_FLOW))
@@ -129,20 +121,12 @@ static struct mm_region final_map[] = {
 	  S32_SRAM_SIZE,
 	  PTE_BLOCK_MEMTYPE(MT_NORMAL) | PTE_BLOCK_OUTER_SHARE
 	},
-#ifdef CONFIG_S32_GEN1
 	{
 	  CONFIG_SYS_FSL_PERIPH_BASE, CONFIG_SYS_FSL_PERIPH_BASE,
 	  CONFIG_SYS_FSL_PERIPH_SIZE,
 	  PTE_BLOCK_MEMTYPE(MT_DEVICE_NGNRNE) | PTE_BLOCK_NON_SHARE |
 	  PTE_BLOCK_PXN | PTE_BLOCK_UXN
 	},
-#else
-	{
-	  CONFIG_SYS_FSL_PERIPH_BASE, CONFIG_SYS_FSL_PERIPH_BASE,
-	  CONFIG_SYS_FSL_PERIPH_SIZE,
-	  PTE_BLOCK_MEMTYPE(MT_DEVICE_NGNRNE) | PTE_BLOCK_NON_SHARE
-	},
-#endif /* CONFIG_S32_GEN1 */
 #if defined(CONFIG_SYS_FSL_DRAM_BASE2)
 #if !defined(CONFIG_S32_SKIP_RELOC) || \
 	(defined(CONFIG_S32_SKIP_RELOC) && defined(CONFIG_S32_ATF_BOOT_FLOW))
@@ -188,25 +172,9 @@ static struct mm_region final_map[] = {
 
 struct mm_region *mem_map = early_map;
 
-#ifdef CONFIG_S32V234
-static void enable_snooping(void)
-{
-	struct ccsr_cci400 *cci = (struct ccsr_cci400 *)CCI400_BASE_ADDR;
-
-	out_le32(&cci->slave[3].snoop_ctrl,
-		 CCI400_DVM_MESSAGE_REQ_EN | CCI400_SNOOP_REQ_EN);
-	out_le32(&cci->slave[4].snoop_ctrl,
-		 CCI400_DVM_MESSAGE_REQ_EN | CCI400_SNOOP_REQ_EN);
-}
-#endif
-
 static unsigned long get_tlb_size(void)
 {
-#ifdef CONFIG_S32V234
-	return CONFIG_SYS_TEXT_BASE - S32_IRAM_MMU_TABLES_BASE;
-#else
 	return CONFIG_DTB_SRAM_ADDR - S32_IRAM_MMU_TABLES_BASE;
-#endif
 }
 
 static inline void early_mmu_setup(void)
@@ -219,9 +187,6 @@ static inline void early_mmu_setup(void)
 	sram_clr(gd->arch.tlb_addr, gd->arch.tlb_size);
 #endif
 
-#ifdef CONFIG_S32V234
-	enable_snooping();
-#endif
 	mmu_setup();
 	set_sctlr(get_sctlr() | CR_C);
 }
@@ -280,7 +245,7 @@ static inline void final_mmu_setup(void)
 	set_sctlr(get_sctlr() | CR_M);
 }
 
-#if defined(CONFIG_S32_GEN1) && !defined(CONFIG_S32_ATF_BOOT_FLOW)
+#if !defined(CONFIG_S32_ATF_BOOT_FLOW)
 /*
  * This function is a temporary fix for drivers without clock bindings.
  *
@@ -577,7 +542,7 @@ int arch_cpu_init(void)
 		return ret;
 #endif
 
-#if defined(CONFIG_S32_GEN1) && defined(CONFIG_S32_STANDALONE_BOOT_FLOW)
+#if defined(CONFIG_S32_STANDALONE_BOOT_FLOW)
 	/* Platforms with Concerto/Ncore have to explicitly initialize
 	 * the interconnect before any cache operations are performed.
 	 * Also, ensure that clocks are initialized before the interconnect.
@@ -612,9 +577,7 @@ void enable_caches(void)
 {
 	final_mmu_setup();
 	__asm_invalidate_tlb_all();
-#ifdef CONFIG_S32_GEN1
 	dcache_enable();
-#endif
 }
 
 #endif
@@ -637,17 +600,14 @@ int arch_early_init_r(void)
 	if (rv)
 		printf("Did not wake secondary cores\n");
 
-#ifdef CONFIG_S32_GEN1
 	/* Reconfigure Concerto before actually waking the cores */
 	ncore_init(cpu_pos_mask());
-#endif
 	asm volatile("sev");
 #endif
 
-#if defined(CONFIG_S32_GEN1) && !defined(CONFIG_S32_ATF_BOOT_FLOW)
+#if !defined(CONFIG_S32_ATF_BOOT_FLOW)
 	return enable_periph_clocks();
 #endif
-
 	return rv;
 }
 #endif /* CONFIG_ARCH_EARLY_INIT_R */
@@ -656,25 +616,6 @@ int arch_early_init_r(void)
  * the EL3 software (e.g. the TF-A) will initialize the generic timer.
  */
 #if defined(CONFIG_S32_STANDALONE_BOOT_FLOW)
-#ifdef CONFIG_S32V234
-static int s32_gentimer_init(void)
-{
-	if (get_siul2_midr1_major() >= 1)
-		return 0;
-
-	/* For CUT1 chip version, update with accurate clock frequency for all cores. */
-
-	/* update for secondary cores */
-	__real_cntfrq = COUNTER_FREQUENCY_CUT1;
-	flush_dcache_range((unsigned long)&__real_cntfrq,
-			   (unsigned long)&__real_cntfrq + 8);
-
-
-	/* Update made for main core. */
-	asm volatile("msr cntfrq_el0, %0" : : "r" (__real_cntfrq) : "memory");
-	return 0;
-}
-#elif defined(CONFIG_S32_GEN1) && defined(CONFIG_S32_STANDALONE_BOOT_FLOW)
 /* The base counter frequency (FXOSC on the S32G) is actually board-dependent.
  * Moreoever, only software running at the highest implemented Exception level
  * can write to CNTFRQ_EL0, so we won't even define this function if we are
@@ -697,9 +638,6 @@ static int s32_gentimer_init(void)
 
 	return 0;
 }
-#else
-#error "S32 platform should provide ARMv8 generic timer initialization"
-#endif
 #endif /* CONFIG_S32_STANDALONE_BOOT_FLOW */
 
 #if defined(CONFIG_SYS_FSL_DDRSS) && \
@@ -843,27 +781,11 @@ int dram_init_banksize(void)
 	gd->bd->bi_dram[2].start = 0x0;
 	gd->bd->bi_dram[2].size = 0x0;
 #else
-#ifdef CONFIG_S32_GEN1
 	int ret;
 
 	ret = fdtdec_setup_memory_banksize();
 	if (ret)
 		return ret;
-#else
-	gd->bd->bi_dram[0].start = CONFIG_SYS_FSL_DRAM_BASE1;
-	gd->bd->bi_dram[0].size = CONFIG_SYS_FSL_DRAM_SIZE1;
-
-#if defined(CONFIG_SYS_FSL_DRAM_BASE2)
-	gd->bd->bi_dram[1].start = CONFIG_SYS_FSL_DRAM_BASE2;
-	gd->bd->bi_dram[1].size = CONFIG_SYS_FSL_DRAM_SIZE2;
-#else
-	gd->bd->bi_dram[1].start = 0x0;
-	gd->bd->bi_dram[1].size = 0x0;
-#endif
-
-	gd->bd->bi_dram[2].start = S32_SRAM_BASE;
-	gd->bd->bi_dram[2].size = get_sram_size();
-#endif
 #endif
 	s32_init_ram_size();
 
diff --git a/arch/arm/cpu/armv8/s32/cse.c b/arch/arm/cpu/armv8/s32/cse.c
deleted file mode 100644
index 158781d879..0000000000
--- a/arch/arm/cpu/armv8/s32/cse.c
+++ /dev/null
@@ -1,251 +0,0 @@
-// SPDX-License-Identifier:     GPL-2.0+
-/*
- * (C) Copyright 2015-2016 Freescale Semiconductor, Inc.
- * Copyright 2017-2018,2020 NXP
- */
-
-#include <asm/io.h>
-#include <asm/arch/cse.h>
-#include <asm/arch-s32/soc.h>
-#include <common.h>
-#include <malloc.h>
-#include <linux/libfdt.h>
-#include <fs.h>
-#include <errno.h>
-#include <sram.h>
-
-#define CSE_TIMEOUT		1000000
-
-static inline void cse_cancel_cmd(void)
-{
-	writel(CSE_CMD_CANCEL, CSE_CMD);
-}
-
-static inline int cse_wait(int timeout)
-{
-	int delay = timeout;
-
-	while (delay--) {
-		udelay(1);
-		if (!(readl(CSE_SR) & CSE_SR_BSY))
-			return 0;
-	}
-
-	printf("cse_init: Timed out while waiting for CSE command\n");
-	return -1;
-}
-
-#ifdef CONFIG_FSL_CSE3
-
-/*
- * Load cse blob file from sdhc at CSE_BLOB_BASE address
- */
-static int mmc_load_cse_blob(void)
-{
-	const char mmc_dev_part[] = __stringify(CONFIG_SYS_MMC_ENV_DEV) ":"
-			__stringify(CONFIG_MMC_PART);
-	const char *filename;
-	loff_t bytes = 0, pos = 0, len_read;
-
-	filename = env_get("cse_file");
-	if (!filename)
-	{
-		printf("Failed to find \"cse_file\" environment variable! Default enviroment should be loaded.\n");
-		return -ENOENT;
-	}
-
-	if (fs_set_blk_dev("mmc", mmc_dev_part, FS_TYPE_FAT))
-		return -ENOENT;
-
-	if (fs_read(filename, CSE_BLOB_BASE, pos, bytes, &len_read))
-		return -ENOENT;
-
-	printf("%llu bytes read\n", len_read);
-
-	return 0;
-}
-
-int cse_init(void)
-{
-	uint32_t firmware;
-	uint32_t err;
-
-	/* check if CSE module is enabled */
-	if (readl(OCOTP_CFG3) & OCOTP_CFG3_EXPORT_CONTROL) {
-		printf("The security module (CSE3) is disabled.\n");
-		return -ENODEV;
-	}
-
-	/* check if secure boot is enabled on chip and if secure boot was
-	completed successfully in bootrom */
-	if ((readl(OCOTP_CFG5) & OCOTP_CFG5_SEC_BOOT_MODE) &&
-	    (readl(CSE_SR) & CSE_SR_BOK)) {
-		goto init_rng;
-	}
-
-	/* check if the firmware was not loaded before */
-	if (!readl(CSE_KIA0)) {
-		goto cse_firmware_loading;
-	} else {
-		/* check if init_cse was already done */
-		writel(CSE_CMD_INIT_RNG, CSE_CMD);
-
-		if (cse_wait(CSE_TIMEOUT))
-			return -ETIME;
-
-		err = readl(CSE_ECR);
-
-		if (err == CSE_SEQ_ERR)
-			goto init_cse;
-		else
-			goto init_rng;
-	}
-
-cse_firmware_loading:
-
-	/* check if CSE_BLOB_BASE is in SRAM and if it is, clear the area
-	 * between CSE_BLOB_BASE and CSE_BLOB_BASE + CSE_BLOB_SIZE */
-	if (is_addr_in_sram(CSE_BLOB_BASE))
-		sram_clr(CSE_BLOB_BASE, CSE_BLOB_SIZE);
-
-	if (mmc_load_cse_blob()) {
-		printf("CSE firmware loading failed\n");
-		return -ENOENT;
-	}
-
-	writel(KIA_BASE, CSE_KIA0);
-	writel(KIA_BASE, CSE_KIA1);
-
-init_cse:
-	if (readl(CSE_SR) & CSE_SR_BSY) {
-		cse_cancel_cmd();
-		if (cse_wait(CSE_TIMEOUT))
-			return -EIO;
-	}
-
-	/* Init CSE3 */
-	writel(virt_to_phys(&firmware), CSE_P1);
-	writel(CSE_CMD_INIT_CSE, CSE_CMD);
-
-	if (cse_wait(CSE_TIMEOUT))
-		return -EIO;
-
-	err = readl(CSE_ECR);
-
-	if (err && (err != CSE_SEQ_ERR))
-		return -EIO;
-
-	/* Open KRAM */
-	writel(KRAM_ADDR, CSE_P1);
-	writel(CSE_CMD_OPEN_SEC_RAM, CSE_CMD);
-
-	if (cse_wait(CSE_TIMEOUT))
-		return -EIO;
-
-	err = readl(CSE_ECR);
-
-	if (err && (err != CSE_SEQ_ERR))
-		return -EIO;
-
-init_rng:
-	/* Init RNG */
-	writel(CSE_CMD_INIT_RNG, CSE_CMD);
-
-	if (cse_wait(CSE_TIMEOUT))
-		return -EIO;
-	if (readl(CSE_ECR))
-		return -EIO;
-
-	return 0;
-}
-
-#ifdef CONFIG_SECURE_BOOT
-int cse_auth(ulong start_addr, unsigned long len, int key_id,
-			uint8_t *exp_mac)
-{
-	/* Verify MAC */
-	writel(key_id, CSE_P1);
-	writel(virt_to_phys(&len), CSE_P2);
-	writel(start_addr, CSE_P3);
-	writel(virt_to_phys(exp_mac), CSE_P4);
-	writel(MAC_LEN * 8, CSE_P5);
-	writel(CSE_CMD_VERIFY_MAC, CSE_CMD);
-
-	if (cse_wait(CSE_TIMEOUT))
-		return -ETIME;
-	if (readl(CSE_ECR))
-		return -EIO;
-	if (readl(CSE_P5))
-		return -EIO;
-
-	return 0;
-}
-
-int cse_genmac(ulong start_addr, unsigned long len, unsigned long key_id,
-		uint8_t mac[])
-{
-	/* CSE init */
-	int ret = cse_init();
-	if (ret) {
-		printf("CSE init failed\n");
-		return ret;
-	}
-
-	/* Generate MAC */
-	writel(key_id, CSE_P1);
-	writel(virt_to_phys(&len), CSE_P2);
-	writel(start_addr, CSE_P3);
-	writel(virt_to_phys(mac), CSE_P4);
-	writel(CSE_CMD_GENERATE_MAC, CSE_CMD);
-
-	if (cse_wait(CSE_TIMEOUT))
-		return -ETIME;
-	if (readl(CSE_ECR))
-		return -EIO;
-
-	return 0;
-}
-
-int do_genmac(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
-{
-	uint8_t mac[MAC_LEN];
-	int i;
-	int err = 0;
-	ulong start_addr;
-	unsigned long len, key_id;
-
-	if (argc != 4) {
-		printf("Usage : %s start_address length key_id\n", argv[0]);
-		printf("Example: %s 0xC0000000 0x$filesize 0x4\n", argv[0]);
-		return err;
-	}
-
-	start_addr = simple_strtoul(argv[1], NULL, 16);
-	len = simple_strtoul(argv[2], NULL, 10);
-	key_id = simple_strtoul(argv[3], NULL, 16);
-
-	err = cse_genmac(start_addr, len, key_id, mac);
-	if (err) {
-		return err;
-	}
-
-	/* Print generated MAC */
-	printf("Generated MAC is: ");
-	for (i = 0; i < MAC_LEN; i++)
-		printf("%02x", mac[i]);
-	printf("\nGenerated MAC (hex) is: ");
-	for (i = 0; i < MAC_LEN; i++)
-		printf("\\x%02x", mac[i]);
-	printf("\n");
-
-	return err;
-}
-
-U_BOOT_CMD(
-		genmac, CONFIG_SYS_MAXARGS, 1, do_genmac,
-		"generate MAC",
-		""
-	);
-
-#endif /* CONFIG_SECURE_BOOT */
-#endif /* CONFIG_FSL_CSE3 */
diff --git a/arch/arm/cpu/armv8/s32/dcu.c b/arch/arm/cpu/armv8/s32/dcu.c
deleted file mode 100644
index 18ca2f2565..0000000000
--- a/arch/arm/cpu/armv8/s32/dcu.c
+++ /dev/null
@@ -1,65 +0,0 @@
-// SPDX-License-Identifier:     GPL-2.0+
-/*
- * (C) Copyright 2017-2018,2020 NXP
- *
- * FSL DCU Framebuffer driver
- */
-
-#include <asm/arch/clock.h>
-#include <common.h>
-#include <fsl_dcu_fb.h>
-#include "dcu_sii9022a.h"
-#include "div64.h"
-
-struct fb_videomode fsl_dcu_mode_1920_1080 = {
-	.name = "1920x1080-60",
-	.refresh = 60,
-	.xres = 1920,
-	.yres = 1080,
-	/* .pixclock    = 56000,  LVDS */
-	.pixclock = 148500,	/* HDMI */
-	.left_margin = 148,
-	.right_margin = 88,
-	.upper_margin = 36,
-	.lower_margin = 4,
-	.hsync_len = 44,
-	.vsync_len = 5,
-	.sync = 0,
-	.vmode = FB_VMODE_NONINTERLACED,
-};
-
-unsigned int dcu_set_pixel_clock(unsigned int pixclock)
-{
-	unsigned long long div;
-
-	div = (unsigned long long)(mxc_get_clock(MXC_DCU_PIX_CLK) / 1000);
-	do_div(div, (unsigned long long)pixclock);
-
-	return div;
-}
-
-int platform_dcu_init(struct fb_info *fbinfo,
-		      unsigned int xres,
-		      unsigned int yres,
-		      const char *port,
-		      struct fb_videomode *dcu_fb_videomode)
-{
-	const char *name;
-	unsigned int pixel_format;
-
-	if (strncmp(port, "lcd", 3) == 0) {
-		name = "LVDS";
-	} else {
-		name = "HDMI";
-#ifdef	CONFIG_FSL_DCU_SII9022A
-		dcu_set_dvi_encoder(dcu_fb_videomode);
-#endif
-	}
-
-	printf("DCU: Switching to %s monitor @ %ux%u\n", name, xres, yres);
-
-	pixel_format = 32;
-	fsl_dcu_init(fbinfo, xres, yres, pixel_format);
-
-	return 0;
-}
diff --git a/arch/arm/cpu/armv8/s32/ddr3.c b/arch/arm/cpu/armv8/s32/ddr3.c
deleted file mode 100644
index 44a5bc12ef..0000000000
--- a/arch/arm/cpu/armv8/s32/ddr3.c
+++ /dev/null
@@ -1,149 +0,0 @@
-// SPDX-License-Identifier:     GPL-2.0+
-/*
- * (C) Copyright 2015-2016 Freescale Semiconductor, Inc.
- * (C) Copyright 2017 NXP
- */
-
-#include <common.h>
-#include <asm/io.h>
-#include <asm/arch/imx-regs.h>
-#include <asm/arch/siul.h>
-#include <asm/arch/ddr3.h>
-#include <asm/arch/mmdc.h>
-
-void ddr_config_iomux(uint8_t module)
-{
-	int i;
-
-	switch(module) {
-		case DDR0:
-			writel(DDR3_RESET_PAD, SIUL2_MSCRn(_DDR0_RESET));
-
-			writel(DDR3_CLK0_PAD, SIUL2_MSCRn(_DDR0_CLK0));
-
-			writel(DDR3_CAS_PAD, SIUL2_MSCRn(_DDR0_CAS));
-			writel(DDR3_RAS_PAD, SIUL2_MSCRn(_DDR0_RAS));
-
-			writel(DDR3_WE_B_PAD, SIUL2_MSCRn(_DDR0_WE_B));
-
-			writel(DDR3_CKEn_PAD, SIUL2_MSCRn(_DDR0_CKE0));
-			writel(DDR3_CKEn_PAD, SIUL2_MSCRn(_DDR0_CKE1));
-
-			writel(DDR3_CS_Bn_PAD, SIUL2_MSCRn(_DDR0_CS_B0));
-			writel(DDR3_CS_Bn_PAD, SIUL2_MSCRn(_DDR0_CS_B1));
-
-			for (i = _DDR0_BA0; i <= _DDR0_BA2; i++)
-				writel(DDR3_BAn_PAD, SIUL2_MSCRn(i));
-
-			for (i = _DDR0_DM0; i <= _DDR0_DM3; i++)
-				writel(DDR3_DMn_PAD, SIUL2_MSCRn(i));
-
-			for (i = _DDR0_DQS0; i <= _DDR0_DQS3; i++)
-				writel(DDR3_DQSn_PAD, SIUL2_MSCRn(i));
-
-			writel(DDR3_ODTn_PAD, SIUL2_MSCRn(_DDR0_ODT0));
-			writel(DDR3_ODTn_PAD, SIUL2_MSCRn(_DDR0_ODT1));
-
-			for (i = _DDR0_A0; i < _DDR0_A15; i++)
-				writel(DDR3_An_PAD, SIUL2_MSCRn(i));
-
-			for (i = _DDR0_D0; i <= _DDR0_D31; i++)
-				writel(DDR3_Dn_PAD, SIUL2_MSCRn(i));
-			break;
-		case DDR1:
-			writel(DDR3_RESET_PAD, SIUL2_MSCRn(_DDR1_RESET));
-
-			writel(DDR3_CLK0_PAD, SIUL2_MSCRn(_DDR1_CLK0));
-
-			writel(DDR3_CAS_PAD, SIUL2_MSCRn(_DDR1_CAS));
-			writel(DDR3_RAS_PAD, SIUL2_MSCRn(_DDR1_RAS));
-
-			writel(DDR3_WE_B_PAD, SIUL2_MSCRn(_DDR1_WE_B));
-
-			writel(DDR3_CKEn_PAD, SIUL2_MSCRn(_DDR1_CKE0));
-			writel(DDR3_CKEn_PAD, SIUL2_MSCRn(_DDR1_CKE1));
-
-			writel(DDR3_CS_Bn_PAD, SIUL2_MSCRn(_DDR1_CS_B0));
-			writel(DDR3_CS_Bn_PAD, SIUL2_MSCRn(_DDR1_CS_B1));
-
-			for (i = _DDR1_BA0; i <= _DDR1_BA2; i++)
-				writel(DDR3_BAn_PAD, SIUL2_MSCRn(i));
-
-			for (i = _DDR1_DM0; i <= _DDR1_DM3; i++)
-				writel(DDR3_DMn_PAD, SIUL2_MSCRn(i));
-
-			for (i = _DDR1_DQS0; i <= _DDR1_DQS3; i++)
-				writel(DDR3_DQSn_PAD, SIUL2_MSCRn(i));
-
-			writel(DDR3_ODTn_PAD, SIUL2_MSCRn(_DDR1_ODT0));
-			writel(DDR3_ODTn_PAD, SIUL2_MSCRn(_DDR1_ODT1));
-
-			for (i = _DDR1_A0; i < _DDR1_A15; i++)
-				writel(DDR3_An_PAD, SIUL2_MSCRn(i));
-
-			for (i = _DDR1_D0; i <= _DDR1_D31; i++)
-				writel(DDR3_Dn_PAD, SIUL2_MSCRn(i));
-			break;
-	}
-}
-
-void config_mmdc(uint8_t module)
-{
-	unsigned long mmdc_addr = (module)? MMDC1_BASE_ADDR : MMDC0_BASE_ADDR;
-
-
-	writel(MMDC_MDSCR_CFG_VALUE, mmdc_addr + MMDC_MDSCR);
-
-	writel(MMDC_MDCFG0_VALUE, mmdc_addr + MMDC_MDCFG0);
-	writel(MMDC_MDCFG1_VALUE, mmdc_addr + MMDC_MDCFG1);
-	writel(MMDC_MDCFG2_VALUE, mmdc_addr + MMDC_MDCFG2);
-	writel(MMDC_MDOTC_VALUE, mmdc_addr + MMDC_MDOTC);
-	writel(MMDC_MDMISC_VALUE, mmdc_addr + MMDC_MDMISC);
-	writel(MMDC_MDOR_VALUE, mmdc_addr + MMDC_MDOR);
-	writel(_MDCTL, mmdc_addr + MMDC_MDCTL);
-
-	/* Perform ZQ calibration */
-	writel(MMDC_MPZQHWCTRL_VALUE, mmdc_addr + MMDC_MPZQHWCTRL);
-	while (readl(mmdc_addr + MMDC_MPZQHWCTRL) & MMDC_MPZQHWCTRL_ZQ_HW_FOR) {}
-
-	/* Enable MMDC with CS0 */
-	writel(_MDCTL + 0x80000000, mmdc_addr + MMDC_MDCTL);
-
-	/* Complete the initialization sequence as defined by JEDEC */
-	writel(MMDC_MDSCR_MR2_VALUE, mmdc_addr + MMDC_MDSCR);
-	writel(MMDC_MDSCR_MR3_VALUE, mmdc_addr + MMDC_MDSCR);
-	writel(MMDC_MDSCR_MR1_VALUE, mmdc_addr + MMDC_MDSCR);
-	writel(MMDC_MDSCR_MR0_VALUE, mmdc_addr + MMDC_MDSCR);
-	writel(MMDC_MDSCR_ZQ_VALUE, mmdc_addr + MMDC_MDSCR);
-
-	/* Set the amount of DRAM */
-	/* Set DQS settings based on board type */
-	switch(module) {
-	case MMDC0:
-		writel(MMDC_MDASP_MODULE0_VALUE, mmdc_addr + MMDC_MDASP);
-		writel(MMDC_MPRDDLCTL_MODULE0_VALUE, mmdc_addr + MMDC_MPRDDLCTL);
-		writel(MMDC_MPWRDLCTL_MODULE0_VALUE, mmdc_addr + MMDC_MPWRDLCTL);
-		writel(MMDC_MPDGCTRL0_MODULE0_VALUE, mmdc_addr + MMDC_MPDGCTRL0);
-		writel(MMDC_MPDGCTRL1_MODULE0_VALUE, mmdc_addr + MMDC_MPDGCTRL1);
-	break;
-	case MMDC1:
-		writel(MMDC_MDASP_MODULE1_VALUE, mmdc_addr + MMDC_MDASP);
-		writel(MMDC_MPRDDLCTL_MODULE1_VALUE, mmdc_addr + MMDC_MPRDDLCTL);
-		writel(MMDC_MPWRDLCTL_MODULE1_VALUE, mmdc_addr + MMDC_MPWRDLCTL);
-		writel(MMDC_MPDGCTRL0_MODULE1_VALUE, mmdc_addr + MMDC_MPDGCTRL0);
-		writel(MMDC_MPDGCTRL1_MODULE1_VALUE, mmdc_addr + MMDC_MPDGCTRL1);
-		break;
-	}
-
-	writel(MMDC_MDRWD_VALUE, mmdc_addr + MMDC_MDRWD);
-	writel(MMDC_MDPDC_VALUE, mmdc_addr + MMDC_MDPDC);
-	writel(MMDC_MDREF_VALUE, mmdc_addr + MMDC_MDREF);
-	writel(MMDC_MPODTCTRL_VALUE, mmdc_addr + MMDC_MPODTCTRL);
-	writel(MMDC_MDSCR_RESET_VALUE, mmdc_addr + MMDC_MDSCR);
-
-#if defined(CONFIG_DDR_INIT_DELAY)
-	if (module == MMDC1)
-	    udelay(CONFIG_DDR_INIT_DELAY);
-#endif
-
-}
diff --git a/arch/arm/cpu/armv8/s32/fdt.c b/arch/arm/cpu/armv8/s32/fdt.c
index 954766d951..398baf599c 100644
--- a/arch/arm/cpu/armv8/s32/fdt.c
+++ b/arch/arm/cpu/armv8/s32/fdt.c
@@ -171,43 +171,6 @@ void ft_fixup_cpu(void *blob)
 }
 #endif /* CONFIG_MP */
 
-#ifdef CONFIG_S32V234
-void ft_fixup_soc_revision(void *blob)
-{
-	const u32 socmask_info = readl(SIUL2_MIDR1) &
-		(SIUL2_MIDR1_MINOR_MASK | SIUL2_MIDR1_MAJOR_MASK);
-	const char *path = "/chosen";
-	int ret;
-
-	/* The booting guest may implement its own fixups based on the chip
-	 * revision. One such example is PCIe erratum ERR009852, which can be
-	 * safely ignored iff the chip is newer than revision 0.
-	 * So pass this piece of info along in the FDT.
-	 */
-	ret = fdt_find_and_setprop(blob, path, "soc_revision", &socmask_info,
-			sizeof(u32), 1);
-	if (ret)
-		printf("WARNING: Could not fix up the S32V234 device-tree, err=%s\n",
-			fdt_strerror(ret));
-}
-
-void ft_fixup_clock_frequency(void *blob)
-{
-	const u32 cntfrq_be = cpu_to_be32(get_siul2_midr1_major() < 1 ?
-			COUNTER_FREQUENCY_CUT1 : COUNTER_FREQUENCY);
-	const char *path = "/timer";
-	int ret;
-
-	/* Update system clock_frequency according to the cpu detected version.
-	 */
-	ret = fdt_find_and_setprop(blob, path, "clock-frequency", &cntfrq_be,
-			sizeof(u32), 1);
-	if (ret)
-		printf("WARNING: Could not fix up the S32V234 device-tree clock frequency, err=%s\n",
-			fdt_strerror(ret));
-}
-#endif
-
 #ifdef CONFIG_SYS_ERRATUM_ERR050543
 static void ft_fixup_ddr_polling(void *blob)
 {
@@ -928,10 +891,6 @@ void ft_cpu_setup(void *blob, bd_t *bd)
 	ft_fixup_cpu(blob);
 #endif
 
-#ifdef CONFIG_S32V234
-	ft_fixup_soc_revision(blob);
-	ft_fixup_clock_frequency(blob);
-#endif
 	ft_fixup_memory(blob, bd);
 #ifdef CONFIG_SYS_ERRATUM_ERR050543
 	ft_fixup_ddr_polling(blob);
diff --git a/arch/arm/cpu/armv8/s32/lowlevel.S b/arch/arm/cpu/armv8/s32/lowlevel.S
index 476bd11834..41dc895675 100644
--- a/arch/arm/cpu/armv8/s32/lowlevel.S
+++ b/arch/arm/cpu/armv8/s32/lowlevel.S
@@ -23,7 +23,7 @@ ENTRY(lowlevel_init)
 
 	mov	x29, lr			/* Save LR */
 
-#if defined(CONFIG_S32_GEN1) && !defined(CONFIG_S32_ATF_BOOT_FLOW)
+#if !defined(CONFIG_S32_ATF_BOOT_FLOW)
 reset_registers_for_lockstep:
 	/*
 	 * Timers reset must be done when lockstep is enabled to avoid RCCU
@@ -78,23 +78,6 @@ reset_registers_for_lockstep:
 	branch_if_slave x0, 1f
 #endif
 
-#if defined(CONFIG_S32V234)
-watchdog_cortexm_disable:
-	/* disable SWT4 watchdog*/
-	ldr x0, =SWT_SR(SWT4_BASE_ADDR)
-	ldr w1, =0xC520
-	str w1, [x0]
-	ldr w1, =0xD928
-	str w1, [x0]
-	ldr x0, =SWT4_BASE_ADDR
-	ldr x1, [x0]
-	and x1, x1, 0xFFFFFFFE
-	str x1, [x0]
-	ldr x1, [x0]
-	orr x1, x1, 0x40
-	str x1, [x0]
-#endif
-
 /* Skip SRAM initialization if running with ATF and U-Boot in DDR */
 #if !(defined(CONFIG_S32_ATF_BOOT_FLOW) && defined(CONFIG_S32_SKIP_RELOC))
 sram_init:
@@ -107,12 +90,9 @@ sram_init:
 	ldr x0,  =__bss_start
 #ifdef CONFIG_TARGET_TYPE_S32GEN1_EMULATOR
 	ldr x1, =__bss_end
-#elif defined CONFIG_S32_GEN1
+#else
 	ldr x1, =CONFIG_SYS_TEXT_BASE
 	add x1, x1, #CONFIG_UBOOT_SRAM_FOOTPRINT
-#else	/* S32V234 */
-	ldr x1, = S32_SRAM_BASE
-	add x1, x1, S32_SRAM_SIZE
 #endif
 	sub x1, x1, x0
 
diff --git a/arch/arm/cpu/armv8/s32/lpddr2.c b/arch/arm/cpu/armv8/s32/lpddr2.c
deleted file mode 100644
index 8cfd684dfe..0000000000
--- a/arch/arm/cpu/armv8/s32/lpddr2.c
+++ /dev/null
@@ -1,146 +0,0 @@
-// SPDX-License-Identifier:     GPL-2.0+
-/*
- * (C) Copyright 2015 Freescale Semiconductor, Inc.
- * (C) Copyright 2017, 2020-2021 NXP
- */
-
-#include <common.h>
-#include <asm/io.h>
-#include <asm/arch/imx-regs.h>
-#include <asm/arch/siul.h>
-#include <asm/arch/lpddr2.h>
-#include <asm/arch/mmdc.h>
-#include <hang.h>
-
-volatile int mscr_offset_ck0;
-
-void ddr_config_iomux(uint8_t module)
-{
-	int i;
-
-	switch(module) {
-		case DDR0:
-			mscr_offset_ck0 = SIUL2_MSCRn(_DDR0_CKE0);
-			writel(LPDDR2_CLK0_PAD, SIUL2_MSCRn(_DDR0_CLK0));
-
-			writel(LPDDR2_CKEn_PAD, SIUL2_MSCRn(_DDR0_CKE0));
-			writel(LPDDR2_CKEn_PAD, SIUL2_MSCRn(_DDR0_CKE1));
-
-			writel(LPDDR2_CS_Bn_PAD, SIUL2_MSCRn(_DDR0_CS_B0));
-			writel(LPDDR2_CS_Bn_PAD, SIUL2_MSCRn(_DDR0_CS_B1));
-
-			for (i = _DDR0_DM0; i <= _DDR0_DM3; i++)
-				writel(LPDDR2_DMn_PAD, SIUL2_MSCRn(i));
-
-			for (i = _DDR0_DQS0; i <= _DDR0_DQS3; i++)
-				writel(LPDDR2_DQSn_PAD, SIUL2_MSCRn(i));
-
-			for (i = _DDR0_A0; i <= _DDR0_A9; i++)
-				writel(LPDDR2_An_PAD, SIUL2_MSCRn(i));
-
-			for (i = _DDR0_D0; i <= _DDR0_D31; i++)
-				writel(LPDDR2_Dn_PAD, SIUL2_MSCRn(i));
-			break;
-		case DDR1:
-			writel(LPDDR2_CLK0_PAD, SIUL2_MSCRn(_DDR1_CLK0));
-
-			writel(LPDDR2_CKEn_PAD, SIUL2_MSCRn(_DDR1_CKE0));
-			writel(LPDDR2_CKEn_PAD, SIUL2_MSCRn(_DDR1_CKE1));
-
-			writel(LPDDR2_CS_Bn_PAD, SIUL2_MSCRn(_DDR1_CS_B0));
-			writel(LPDDR2_CS_Bn_PAD, SIUL2_MSCRn(_DDR1_CS_B1));
-
-			for (i = _DDR1_DM0; i <= _DDR1_DM3; i++)
-				writel(LPDDR2_DMn_PAD, SIUL2_MSCRn(i));
-
-			for (i = _DDR1_DQS0; i <= _DDR1_DQS3; i++)
-				writel(LPDDR2_DQSn_PAD, SIUL2_MSCRn(i));
-
-			for (i = _DDR1_A0; i <= _DDR1_A9; i++)
-				writel(LPDDR2_An_PAD, SIUL2_MSCRn(i));
-
-			for (i = _DDR1_D0; i <= _DDR1_D31; i++)
-				writel(LPDDR2_Dn_PAD, SIUL2_MSCRn(i));
-			break;
-	}
-}
-
-void config_mmdc(uint8_t module)
-{
-	unsigned long mmdc_addr = (module)? MMDC1_BASE_ADDR : MMDC0_BASE_ADDR;
-	const struct lpddr2_config *config = s32_get_lpddr2_config();
-
-	if (!config) {
-		pr_err("DDR: LPDDR2 config not found\n");
-		hang();
-	}
-
-	writel(MMDC_MDSCR_CFG_VALUE, mmdc_addr + MMDC_MDSCR);
-
-	writel(config->mdcfg0, mmdc_addr + MMDC_MDCFG0);
-	writel(config->mdcfg1, mmdc_addr + MMDC_MDCFG1);
-	writel(config->mdcfg2, mmdc_addr + MMDC_MDCFG2);
-	writel(config->mdcfg3lp, mmdc_addr + MMDC_MDCFG3LP);
-	writel(MMDC_MDOTC_VALUE, mmdc_addr + MMDC_MDOTC);
-	writel(config->mdmisc, mmdc_addr + MMDC_MDMISC);
-	writel(MMDC_MDOR_VALUE, mmdc_addr + MMDC_MDOR);
-	writel(config->mdctl, mmdc_addr + MMDC_MDCTL);
-	writel(MMDC_MPMUR0_VALUE, mmdc_addr + MMDC_MPMUR0);
-
-	while (readl(mmdc_addr + MMDC_MPMUR0) & MMDC_MPMUR0_FRC_MSR) {}
-
-	/* Perform ZQ calibration */
-	writel(MMDC_MPZQLP2CTL_VALUE, mmdc_addr + MMDC_MPZQLP2CTL);
-	writel(MMDC_MPZQHWCTRL_VALUE, mmdc_addr + MMDC_MPZQHWCTRL);
-	while (readl(mmdc_addr + MMDC_MPZQHWCTRL) & MMDC_MPZQHWCTRL_ZQ_HW_FOR) {}
-
-	/* Enable MMDC with CS0 */
-	writel(config->mdctl + 0x80000000, mmdc_addr + MMDC_MDCTL);
-
-	/* Precharge all command per JEDEC */
-	/* Ensures robust DRAM initialization */
-	writel(MMDC_MDSCR_CS0_VALUE, mmdc_addr + MMDC_MDSCR);
-	writel(MMDC_MDSCR_CS1_VALUE, mmdc_addr + MMDC_MDSCR);
-
-	/* Complete the initialization sequence as defined by JEDEC */
-	writel(MMDC_MDSCR_RST_VALUE, mmdc_addr + MMDC_MDSCR);
-	writel(MMDC_MDSCR_MR1_VALUE, mmdc_addr + MMDC_MDSCR);
-	writel(config->mdscr_mr2, mmdc_addr + MMDC_MDSCR);
-	writel(config->mdscr_mr3, mmdc_addr + MMDC_MDSCR);
-	writel(MMDC_MDSCR_MR10_VALUE, mmdc_addr + MMDC_MDSCR);
-
-	/* Set the amount of DRAM */
-	/* Set DQS settings based on board type */
-
-	switch(module) {
-		case MMDC0:
-			writel(config->mdasp_module0, mmdc_addr + MMDC_MDASP);
-		writel(config->mprddlctl_module0,
-		       mmdc_addr + MMDC_MPRDDLCTL);
-		writel(config->mpwrdlctl_module0,
-		       mmdc_addr + MMDC_MPWRDLCTL);
-		writel(config->mpdgctrl0_module0,
-		       mmdc_addr + MMDC_MPDGCTRL0);
-		writel(config->mpdgctrl1_module0,
-		       mmdc_addr + MMDC_MPDGCTRL1);
-			break;
-		case MMDC1:
-			writel(config->mdasp_module1, mmdc_addr + MMDC_MDASP);
-		writel(config->mprddlctl_module1,
-		       mmdc_addr + MMDC_MPRDDLCTL);
-		writel(config->mpwrdlctl_module1,
-		       mmdc_addr + MMDC_MPWRDLCTL);
-		writel(config->mpdgctrl0_module1,
-		       mmdc_addr + MMDC_MPDGCTRL0);
-		writel(config->mpdgctrl1_module1,
-		       mmdc_addr + MMDC_MPDGCTRL1);
-			break;
-	}
-
-	writel(MMDC_MDRWD_VALUE, mmdc_addr + MMDC_MDRWD);
-	writel(MMDC_MDPDC_VALUE, mmdc_addr + MMDC_MDPDC);
-	writel(MMDC_MDREF_VALUE, mmdc_addr + MMDC_MDREF);
-	writel(MMDC_MPODTCTRL_VALUE, mmdc_addr + MMDC_MPODTCTRL);
-	writel(MMDC_MDSCR_DEASSERT_VALUE, mmdc_addr + MMDC_MDSCR);
-
-}
diff --git a/arch/arm/cpu/armv8/s32/lpddr4.c b/arch/arm/cpu/armv8/s32/lpddr4.c
deleted file mode 100644
index e633cbeab7..0000000000
--- a/arch/arm/cpu/armv8/s32/lpddr4.c
+++ /dev/null
@@ -1,131 +0,0 @@
-// SPDX-License-Identifier:     GPL-2.0+
-/*
- * (C) Copyright 2015 Freescale Semiconductor, Inc.
- * (C) Copyright 2017 NXP
- */
-
-#include <common.h>
-#include <asm/io.h>
-#include <asm/arch/imx-regs.h>
-#include <asm/arch/siul.h>
-#include <asm/arch/lpddr4.h>
-#include <asm/arch/mmdc.h>
-
-volatile int mscr_offset_ck0;
-
-void ddr_config_iomux(uint8_t module)
-{
-#if 0 /* TODO :  To be updated with LPDDR4 implementation */
-	int i;
-
-	switch(module) {
-		case DDR0:
-			mscr_offset_ck0 = SIUL2_MSCRn(_DDR0_CKE0);
-			writel(LPDDR2_CLK0_PAD, SIUL2_MSCRn(_DDR0_CLK0));
-
-			writel(LPDDR2_CKEn_PAD, SIUL2_MSCRn(_DDR0_CKE0));
-			writel(LPDDR2_CKEn_PAD, SIUL2_MSCRn(_DDR0_CKE1));
-
-			writel(LPDDR2_CS_Bn_PAD, SIUL2_MSCRn(_DDR0_CS_B0));
-			writel(LPDDR2_CS_Bn_PAD, SIUL2_MSCRn(_DDR0_CS_B1));
-
-			for (i = _DDR0_DM0; i <= _DDR0_DM3; i++)
-				writel(LPDDR2_DMn_PAD, SIUL2_MSCRn(i));
-
-			for (i = _DDR0_DQS0; i <= _DDR0_DQS3; i++)
-				writel(LPDDR2_DQSn_PAD, SIUL2_MSCRn(i));
-
-			for (i = _DDR0_A0; i <= _DDR0_A9; i++)
-				writel(LPDDR2_An_PAD, SIUL2_MSCRn(i));
-
-			for (i = _DDR0_D0; i <= _DDR0_D31; i++)
-				writel(LPDDR2_Dn_PAD, SIUL2_MSCRn(i));
-			break;
-		case DDR1:
-			writel(LPDDR2_CLK0_PAD, SIUL2_MSCRn(_DDR1_CLK0));
-
-			writel(LPDDR2_CKEn_PAD, SIUL2_MSCRn(_DDR1_CKE0));
-			writel(LPDDR2_CKEn_PAD, SIUL2_MSCRn(_DDR1_CKE1));
-
-			writel(LPDDR2_CS_Bn_PAD, SIUL2_MSCRn(_DDR1_CS_B0));
-			writel(LPDDR2_CS_Bn_PAD, SIUL2_MSCRn(_DDR1_CS_B1));
-
-			for (i = _DDR1_DM0; i <= _DDR1_DM3; i++)
-				writel(LPDDR2_DMn_PAD, SIUL2_MSCRn(i));
-
-			for (i = _DDR1_DQS0; i <= _DDR1_DQS3; i++)
-				writel(LPDDR2_DQSn_PAD, SIUL2_MSCRn(i));
-
-			for (i = _DDR1_A0; i <= _DDR1_A9; i++)
-				writel(LPDDR2_An_PAD, SIUL2_MSCRn(i));
-
-			for (i = _DDR1_D0; i <= _DDR1_D31; i++)
-				writel(LPDDR2_Dn_PAD, SIUL2_MSCRn(i));
-			break;
-	}
-#endif
-}
-
-void config_mmdc(uint8_t module)
-{
-#if 0 /* TODO :  To be updated with LPDDR4 implementation */
-	unsigned long mmdc_addr = (module)? MMDC1_BASE_ADDR : MMDC0_BASE_ADDR;
-
-	writel(MMDC_MDSCR_CFG_VALUE, mmdc_addr + MMDC_MDSCR);
-
-	writel(MMDC_MDCFG0_VALUE, mmdc_addr + MMDC_MDCFG0) ;
-	writel(MMDC_MDCFG1_VALUE, mmdc_addr + MMDC_MDCFG1);
-	writel(MMDC_MDCFG2_VALUE, mmdc_addr + MMDC_MDCFG2);
-	writel(MMDC_MDCFG3LP_VALUE, mmdc_addr + MMDC_MDCFG3LP);
-	writel(MMDC_MDOTC_VALUE, mmdc_addr + MMDC_MDOTC);
-	writel(MMDC_MDMISC_VALUE, mmdc_addr + MMDC_MDMISC);
-	writel(MMDC_MDOR_VALUE, mmdc_addr + MMDC_MDOR);
-	writel(_MDCTL, mmdc_addr + MMDC_MDCTL);
-
-	writel(MMDC_MPMUR0_VALUE, mmdc_addr + MMDC_MPMUR0);
-
-	while (readl(mmdc_addr + MMDC_MPMUR0) & MMDC_MPMUR0_FRC_MSR) {}
-
-	writel(MMDC_MDSCR_RST_VALUE, mmdc_addr + MMDC_MDSCR);
-
-	/* Perform ZQ calibration */
-	writel(MMDC_MPZQLP2CTL_VALUE, mmdc_addr + MMDC_MPZQLP2CTL);
-	writel(MMDC_MPZQHWCTRL_VALUE, mmdc_addr + MMDC_MPZQHWCTRL);
-	while (readl(mmdc_addr + MMDC_MPZQHWCTRL) & MMDC_MPZQHWCTRL_ZQ_HW_FOR) {}
-
-	/* Enable MMDC with CS0 */
-	writel(_MDCTL + 0x80000000, mmdc_addr + MMDC_MDCTL);
-
-	/* Complete the initialization sequence as defined by JEDEC */
-	writel(MMDC_MDSCR_MR1_VALUE, mmdc_addr + MMDC_MDSCR);
-	writel(MMDC_MDSCR_MR2_VALUE, mmdc_addr + MMDC_MDSCR);
-	writel(MMDC_MDSCR_MR3_VALUE, mmdc_addr + MMDC_MDSCR);
-	writel(MMDC_MDSCR_MR10_VALUE, mmdc_addr + MMDC_MDSCR);
-
-	/* Set the amount of DRAM */
-	/* Set DQS settings based on board type */
-
-	switch(module) {
-		case MMDC0:
-			writel(MMDC_MDASP_MODULE0_VALUE, mmdc_addr + MMDC_MDASP);
-			writel(MMDC_MPRDDLCTL_MODULE0_VALUE, mmdc_addr + MMDC_MPRDDLCTL);
-			writel(MMDC_MPWRDLCTL_MODULE0_VALUE, mmdc_addr + MMDC_MPWRDLCTL);
-			writel(MMDC_MPDGCTRL0_MODULE0_VALUE, mmdc_addr + MMDC_MPDGCTRL0);
-			writel(MMDC_MPDGCTRL1_MODULE0_VALUE, mmdc_addr + MMDC_MPDGCTRL1);
-			break;
-		case MMDC1:
-			writel(MMDC_MDASP_MODULE1_VALUE, mmdc_addr + MMDC_MDASP);
-			writel(MMDC_MPRDDLCTL_MODULE1_VALUE, mmdc_addr + MMDC_MPRDDLCTL);
-			writel(MMDC_MPWRDLCTL_MODULE1_VALUE, mmdc_addr + MMDC_MPWRDLCTL);
-			writel(MMDC_MPDGCTRL0_MODULE1_VALUE, mmdc_addr + MMDC_MPDGCTRL0);
-			writel(MMDC_MPDGCTRL1_MODULE1_VALUE, mmdc_addr + MMDC_MPDGCTRL1);
-			break;
-	}
-
-	writel(MMDC_MDRWD_VALUE, mmdc_addr + MMDC_MDRWD);
-	writel(MMDC_MDPDC_VALUE, mmdc_addr + MMDC_MDPDC);
-	writel(MMDC_MDREF_VALUE, mmdc_addr + MMDC_MDREF);
-	writel(MMDC_MPODTCTRL_VALUE, mmdc_addr + MMDC_MPODTCTRL);
-	writel(MMDC_MDSCR_DEASSERT_VALUE, mmdc_addr + MMDC_MDSCR);
-#endif
-}
diff --git a/arch/arm/cpu/armv8/s32/mp.c b/arch/arm/cpu/armv8/s32/mp.c
index 2120672c3c..10db32a2aa 100644
--- a/arch/arm/cpu/armv8/s32/mp.c
+++ b/arch/arm/cpu/armv8/s32/mp.c
@@ -16,46 +16,6 @@
 
 DECLARE_GLOBAL_DATA_PTR;
 
-#ifdef CONFIG_S32V234
-static bool is_core_active(int core)
-{
-	u32 core_mask = MC_ME_CS_A53(core);
-
-	return (readl(MC_ME_CS) & core_mask) == core_mask;
-}
-
-static unsigned long get_core_start_addr(int core)
-{
-	return readl(MC_ME_CADDR_A53(core)) & MC_ME_CADDRn_ADDR_MASK;
-}
-
-int fsl_s32_wake_secondary_cores(void)
-{
-	u32 start_addr = (u32)(uintptr_t)gd->relocaddr;
-
-	/* program the cores possible running modes */
-	writew(MC_ME_CCTL_DEASSERT_CORE, MC_ME_CCTL2);
-	writew(MC_ME_CCTL_DEASSERT_CORE, MC_ME_CCTL3);
-	writew(MC_ME_CCTL_DEASSERT_CORE, MC_ME_CCTL4);
-
-	/* write the cores' start address */
-	writel(start_addr | MC_ME_CADDRn_ADDR_EN, MC_ME_CADDR2);
-	writel(start_addr | MC_ME_CADDRn_ADDR_EN, MC_ME_CADDR3);
-	writel(start_addr | MC_ME_CADDRn_ADDR_EN, MC_ME_CADDR4);
-
-	writel( MC_ME_MCTL_RUN0 | MC_ME_MCTL_KEY, MC_ME_MCTL );
-	writel( MC_ME_MCTL_RUN0 | MC_ME_MCTL_INVERTEDKEY, MC_ME_MCTL );
-
-	while( (readl(MC_ME_GS) & MC_ME_GS_S_MTRANS) != 0x00000000 );
-
-	smp_kick_all_cpus();
-
-	printf("All (%d) cores are up.\n", cpu_numcores());
-
-	return 0;
-}
-
-#elif defined(CONFIG_S32_GEN1)
 static bool is_core_active(int core)
 {
 	u32 mask = MC_ME_PRTN_N_CORE_M_STAT_CCS;
@@ -157,9 +117,6 @@ int fsl_s32_wake_secondary_cores(void)
 
 	return 0;
 }
-#else
-#error "Incomplete platform definition"
-#endif
 
 #ifdef CONFIG_MP
 int is_core_valid(unsigned int core)
diff --git a/arch/arm/cpu/armv8/s32/s32v234/Makefile b/arch/arm/cpu/armv8/s32/s32v234/Makefile
deleted file mode 100644
index cd3e923afa..0000000000
--- a/arch/arm/cpu/armv8/s32/s32v234/Makefile
+++ /dev/null
@@ -1,10 +0,0 @@
-# SPDX-License-Identifier:	GPL-2.0+
-#
-# (C) Copyright 2018 NXP
-#
-
-obj-y					+= clock.o
-obj-y					+= soc.o
-obj-y					+= sram.o
-obj-$(CONFIG_S32V234_FLASH)		+= qspi_driver.o
-obj-$(CONFIG_S32V234_USES_FLASH)	+= qspi_iomux.o
diff --git a/arch/arm/cpu/armv8/s32/s32v234/clock.c b/arch/arm/cpu/armv8/s32/s32v234/clock.c
deleted file mode 100644
index 0e03eeee52..0000000000
--- a/arch/arm/cpu/armv8/s32/s32v234/clock.c
+++ /dev/null
@@ -1,524 +0,0 @@
-// SPDX-License-Identifier:     GPL-2.0+
-/*
- * (C) Copyright 2015-2016 Freescale Semiconductor, Inc.
- * (C) Copyright 2017-2018, 2020-2021 NXP
- */
-
-#include <asm/io.h>
-#include <asm/arch/src.h>
-#include <asm/arch/mc_cgm_regs.h>
-#include <asm/arch/mc_me_regs.h>
-#include <asm/arch/mc_rgm_regs.h>
-#include <asm/arch/clock.h>
-#include <asm/arch/lpddr2.h>
-#include <asm/arch-s32/siul.h>
-
-struct ddr_clk_params {
-	u32 phi0_freq;
-	u32 phi1_freq;
-	u32 prediv;
-	u32 mfd;
-	u32 mfn;
-};
-
-/* System Reset Controller is not yet available on VirtualPlatform */
-/*
- * Select the clock reference for required pll.
- * pll - ARM_PLL, PERIPH_PLL, ENET_PLL, DDR_PLL, VIDEO_PLL.
- * refclk_freq - input referece clock frequency (FXOSC - 40 MHZ, FIRC - 48 MHZ)
- */
-static int select_pll_source_clk( enum pll_type pll, u32 refclk_freq )
-{
-	u32 clk_src;
-	u32 pll_idx;
-	volatile struct src * src = (struct src *)SRC_SOC_BASE_ADDR;
-
-	/* select the pll clock source */
-	switch (refclk_freq) {
-		case FIRC_CLK_FREQ:
-			clk_src = SRC_GPR1_FIRC_CLK_SOURCE;
-			break;
-		case XOSC_CLK_FREQ:
-			clk_src = SRC_GPR1_XOSC_CLK_SOURCE;
-			break;
-		default:
-			/* The clock frequency for the source clock is unknown */
-			return -1;
-	}
-	/*
-	 * The hardware definition is not uniform, it has to calculate again
-	 * the recurrence formula.
-	 */
-	switch (pll) {
-		case PERIPH_PLL:
-			pll_idx = 3;
-			break;
-		case ENET_PLL:
-			pll_idx = 1;
-			break;
-		case DDR_PLL:
-		pll_idx = 2;
-			break;
-		default:
-			pll_idx = pll;
-	}
-
-	writel(readl(&src->gpr1) | SRC_GPR1_PLL_SOURCE(pll_idx, clk_src),
-	       &src->gpr1);
-
-	return 0;
-}
-
-void reset_misc(void)
-{
-	/*Reset 'Functional' Reset Escalation Threshold Register (MC_RGM_FRET)*/
-	writeb( 0xf, MC_RGM_FRET );
-}
-
-void entry_to_target_mode( u32 mode )
-{
-	writel( mode | MC_ME_MCTL_KEY, MC_ME_MCTL );
-	writel( mode | MC_ME_MCTL_INVERTEDKEY, MC_ME_MCTL );
-	while( (readl(MC_ME_GS) & MC_ME_GS_S_MTRANS) != 0x00000000 );
-}
-
-/*
- * Program the pll according to the input parameters.
- * pll - ARM_PLL, PERIPH_PLL, ENET_PLL, DDR_PLL, VIDEO_PLL.
- * refclk_freq - input reference clock frequency (FXOSC - 40 MHZ, FIRC - 48 MHZ)
- * freq - expected output frequency for PHY0
- * freq1 - expected output frequency for PHY1
- * dfs_nr - number of DFS modules for current PLL
- * dfs - array with the activation dfs field, mfn and mfi
- * plldv_prediv - divider of clkfreq_ref
- * plldv_mfd - loop multiplication factor divider
- * pllfd_mfn - numerator loop multiplication factor divider
- * Please consult the PLLDIG chapter of platform manual
- * before to use this function.
- *)
- */
-static int program_pll( enum pll_type pll, u32 refclk_freq, u32 freq0, u32 freq1,
-		       u32 dfs_nr, u32 dfs[][DFS_PARAMS_Nr], u32 plldv_prediv,
-		       u32 plldv_mfd, u32 pllfd_mfn)
-{
-	u32 i, rfdphi1, rfdphi, dfs_on = 0, fvco;
-
-	/*
-	 * This formula is from platform reference manual (Rev. 1, 6/2015), PLLDIG chapter.
-	 */
-	fvco = (refclk_freq / (float)plldv_prediv) *
-		(plldv_mfd + pllfd_mfn/(float)20480);
-
-	/*
-	 * VCO should have value in [ PLL_MIN_FREQ, PLL_MAX_FREQ ]. Please consult
-	 * the platform DataSheet in order to determine the allowed values.
-	 */
-
-	if (fvco < PLL_MIN_FREQ || fvco > PLL_MAX_FREQ)
-		return -1;
-
-	if (select_pll_source_clk(pll, refclk_freq) < 0)
-		return -1;
-
-	rfdphi = fvco/freq0;
-
-	rfdphi1 = (freq1 == 0) ? 0 : fvco/freq1;
-
-	writel(PLLDIG_PLLDV_RFDPHI1_SET(rfdphi1) |
-	       PLLDIG_PLLDV_RFDPHI_SET(rfdphi) |
-	       PLLDIG_PLLDV_PREDIV_SET(plldv_prediv) |
-	       PLLDIG_PLLDV_MFD(plldv_mfd), PLLDIG_PLLDV(pll));
-
-	writel(readl(PLLDIG_PLLFD(pll)) | PLLDIG_PLLFD_MFN_SET(pllfd_mfn) |
-	       PLLDIG_PLLFD_SMDEN, PLLDIG_PLLFD(pll));
-
-	writel(PLLDIG_PLLCAL1_ADVISED_VALUE, PLLDIG_PLLCAL1(pll));
-	writel(PLLDIG_PLLCAL2_ADVISED_VALUE, PLLDIG_PLLCAL2(pll));
-
-	/* switch on the pll in current mode */
-	writel( readl( MC_ME_RUNn_MC(0) ) |  MC_ME_RUNMODE_MC_PLL(pll),
-			MC_ME_RUNn_MC(0) );
-
-	entry_to_target_mode( MC_ME_MCTL_RUN0 );
-
-	/* Only ARM_PLL, ENET_PLL and DDR_PLL */
-	if (pll == ARM_PLL || pll == ENET_PLL || pll == DDR_PLL) {
-		/* DFS clk enable programming */
-		writel( DFS_CTRL_DLL_RESET, DFS_CTRL(pll) );
-
-		writel(DFS_DLLPRG1_CPICTRL_SET(0x7) |
-		       DFS_DLLPRG1_VSETTLCTRL_SET(0x1) |
-		       DFS_DLLPRG1_CALBYPEN_SET(0x0) |
-		       DFS_DLLPRG1_DACIN_SET(0x1) | DFS_DLLPRG1_LCKWT_SET(0x0) |
-		       DFS_DLLPRG1_V2IGC_SET(0x5), DFS_DLLPRG1(pll));
-
-		for (i = 0; i < dfs_nr; i++) {
-			if (dfs[i][0]) {
-				writel(DFS_DVPORTn_MFI_SET(dfs[i][2]) |
-				       DFS_DVPORTn_MFN_SET(dfs[i][1]),
-				       DFS_DVPORTn(pll, i));
-				dfs_on |= (dfs[i][0] << i);
-			}
-		}
-
-		writel(readl(DFS_CTRL(pll)) & ~DFS_CTRL_DLL_RESET,
-		       DFS_CTRL(pll));
-		writel( readl(DFS_PORTRESET(pll)) &
-				~DFS_PORTRESET_PORTRESET_SET(dfs_on),
-				DFS_PORTRESET(pll) );
-		while(  (readl(DFS_PORTSR(pll)) & dfs_on) != dfs_on );
-	}
-
-	entry_to_target_mode( MC_ME_MCTL_RUN0 );
-
-	return 0;
-
-}
-
-static void aux_source_clk_config(uintptr_t cgm_addr, u8 ac, u32 source)
-{
-	/* select the clock source */
-	writel( MC_CGM_ACn_SEL_SET(source), CGM_ACn_SC(cgm_addr, ac) );
-}
-static void aux_div_clk_config(uintptr_t cgm_addr, u8 ac, u8 dc, u32 divider)
-{
-	/* set the divider */
-	writel( MC_CGM_ACn_DCm_DE | MC_CGM_ACn_DCm_PREDIV(divider),
-			CGM_ACn_DCm(cgm_addr, ac, dc));
-}
-
-static void setup_sys_clocks( void )
-{
-
-	/* set ARM PLL DFS 1 as SYSCLK */
-	writel( (readl(MC_ME_RUNn_MC(0)) & ~MC_ME_RUNMODE_MC_SYSCLK_MASK) |
-			MC_ME_RUNMODE_MC_SYSCLK(0x2), MC_ME_RUNn_MC(0) );
-
-	entry_to_target_mode( MC_ME_MCTL_RUN0 );
-
-	/* select sysclks  ARMPLL, ARMPLLDFS2, ARMPLLDFS3 */
-	writel(MC_ME_RUNMODE_SEC_CC_I_SYSCLK(0x2, MC_ME_RUNMODE_SEC_CC_I_SYSCLK1_OFFSET)
-	       | MC_ME_RUNMODE_SEC_CC_I_SYSCLK(0x2, MC_ME_RUNMODE_SEC_CC_I_SYSCLK2_OFFSET)
-	       | MC_ME_RUNMODE_SEC_CC_I_SYSCLK(0x2, MC_ME_RUNMODE_SEC_CC_I_SYSCLK3_OFFSET),
-	       MC_ME_RUNn_SEC_CC_I(0));
-
-	/* setup the sys clock divider for CORE_CLK (1000MHz)*/
-	writel(MC_CGM_SC_DCn_DE | MC_CGM_SC_DCn_PREDIV(0x0),
-	       CGM_SC_DCn(MC_CGM1_BASE_ADDR, 0));
-
-	/* setup the sys clock divider for CORE2_CLK (500MHz)*/
-	writel(MC_CGM_SC_DCn_DE | MC_CGM_SC_DCn_PREDIV(0x1),
-	       CGM_SC_DCn(MC_CGM1_BASE_ADDR, 1));
-	/* setup the sys clock divider for SYS3_CLK (266 MHz)*/
-	writel(MC_CGM_SC_DCn_DE | MC_CGM_SC_DCn_PREDIV(0x0),
-	       CGM_SC_DCn(MC_CGM0_BASE_ADDR, 0));
-
-	/* setup the sys clock divider for SYS6_CLK (133 Mhz)*/
-	writel(MC_CGM_SC_DCn_DE | MC_CGM_SC_DCn_PREDIV(0x1),
-	       CGM_SC_DCn(MC_CGM0_BASE_ADDR, 1));
-
-	entry_to_target_mode( MC_ME_MCTL_RUN0 );
-
-}
-static void setup_aux_clocks( void )
-{
-	/*
-	 * setup the aux clock divider for PERI_CLK
-	 * (source: PERIPH_PLL_PHI_0/5, PERI_CLK - 80 MHz)
-	 */
-	aux_source_clk_config(MC_CGM0_BASE_ADDR, CGM_AC5_SC,
-			      MC_CGM_ACn_SEL_PERPLLDIVX);
-	aux_div_clk_config(MC_CGM0_BASE_ADDR, CGM_AC5_SC, CGM_ACn_DC0,
-			   PLLDIG_PLLDV_PREDIV_0);
-
-	/* setup the aux clock divider for CAN_CLK (40 MHz) */
-	aux_source_clk_config(MC_CGM0_BASE_ADDR, CGM_AC6_SC,
-			      MC_CGM_ACn_SEL_XOSC);
-	aux_div_clk_config(MC_CGM0_BASE_ADDR, CGM_AC6_SC, CGM_ACn_DC0,
-			   PLLDIG_PLLDV_PREDIV_0);
-
-	/* setup the aux clock divider for LIN_CLK (66 MHz) */
-	aux_source_clk_config(MC_CGM0_BASE_ADDR, CGM_AC3_SC,
-			      MC_CGM_ACn_SEL_PERPLLDIVX);
-	aux_div_clk_config(MC_CGM0_BASE_ADDR, CGM_AC3_SC, CGM_ACn_DC0,
-			   PLLDIG_PLLDV_PREDIV_1);
-
-	/* setup the aux clock divider for ENET_TIME_CLK (125MHz) */
-	aux_source_clk_config(MC_CGM0_BASE_ADDR, CGM_AC7_SC,
-			      MC_CGM_ACn_SEL_ENETPLL);
-	aux_div_clk_config(MC_CGM0_BASE_ADDR, CGM_AC7_SC, CGM_ACn_DC1,
-			   PLLDIG_PLLDV_PREDIV_3);
-
-	/* setup the aux clock divider for ENET_CLK (125MHz) */
-	aux_source_clk_config(MC_CGM2_BASE_ADDR, CGM_AC2_SC,
-			      MC_CGM_ACn_SEL_ENETPLL);
-	aux_div_clk_config(MC_CGM2_BASE_ADDR, CGM_AC2_SC, CGM_ACn_DC0,
-			   PLLDIG_PLLDV_PREDIV_3);
-
-	/* setup the aux clock divider for H264_DEC_CLK  (350MHz) */
-	aux_source_clk_config(MC_CGM0_BASE_ADDR, CGM_AC12_SC,
-			      MC_CGM_ACn_SEL_ENETPLL);
-	aux_div_clk_config(MC_CGM0_BASE_ADDR, CGM_AC12_SC, CGM_ACn_DC0,
-			   PLLDIG_PLLDV_PREDIV_0);
-
-	/* setup the aux clock divider for H264_ENC_CLK (350MHz) */
-	aux_source_clk_config(MC_CGM0_BASE_ADDR, CGM_AC13_SC,
-			      MC_CGM_ACn_SEL_ENETPLL);
-	aux_div_clk_config(MC_CGM0_BASE_ADDR, CGM_AC13_SC, CGM_ACn_DC0,
-			   PLLDIG_PLLDV_PREDIV_0);
-
-	/* setup the aux clock divider for QSPI_CLK  (target freq 40 MHz)*/
-	aux_source_clk_config(MC_CGM0_BASE_ADDR, CGM_AC14_SC,
-			      MC_CGM_ACn_SEL_XOSC);
-	aux_div_clk_config(MC_CGM0_BASE_ADDR, CGM_AC14_SC, CGM_ACn_DC0,
-			   PLLDIG_PLLDV_PREDIV_0);
-
-	/* setup the aux clock divider for SDHC_CLK (50 MHz). */
-	aux_source_clk_config(MC_CGM0_BASE_ADDR, CGM_AC15_SC,
-			      MC_CGM_ACn_SEL_ENETPLL);
-	aux_div_clk_config(MC_CGM0_BASE_ADDR, CGM_AC15_SC, CGM_ACn_DC0,
-			   PLLDIG_PLLDV_PREDIV_0);
-
-	/* setup the aux clock divider for DDR_CLK (533MHz) and APEX_SYS_CLK (266MHz) */
-	aux_source_clk_config(MC_CGM0_BASE_ADDR, CGM_AC8_SC,
-			      MC_CGM_ACn_SEL_DDRPLL);
-	aux_div_clk_config(MC_CGM0_BASE_ADDR, CGM_AC8_SC, CGM_ACn_DC0,
-			   PLLDIG_PLLDV_PREDIV_0);
-
-	/* setup the aux clock divider for DDR4_CLK (133,25MHz) */
-	aux_div_clk_config(MC_CGM0_BASE_ADDR, CGM_AC8_SC, CGM_ACn_DC1,
-			   PLLDIG_PLLDV_PREDIV_3);
-
-	/* setup the aux clock divider for SEQ_CLK (250MHz)
-	 * and ISP_CLK (500MHz))
-	 */
-	aux_source_clk_config(MC_CGM0_BASE_ADDR, CGM_AC0_SC,
-			      MC_CGM_ACn_SEL_DDRPLL);
-	aux_div_clk_config(MC_CGM0_BASE_ADDR, CGM_AC0_SC, CGM_ACn_DC0,
-			   PLLDIG_PLLDV_PREDIV_0);
-
-	/* setup the aux clock divider for APEX_APU_CLK (500MHz) */
-	aux_source_clk_config(MC_CGM0_BASE_ADDR, CGM_AC1_SC,
-			      MC_CGM_ACn_SEL_DDRPLL);
-	aux_div_clk_config(MC_CGM0_BASE_ADDR, CGM_AC1_SC, CGM_ACn_DC0,
-			   PLLDIG_PLLDV_PREDIV_0);
-
-	/* setup the aux clock divider for MJPEG_CLK (350MHz) */
-	aux_source_clk_config(MC_CGM0_BASE_ADDR, CGM_AC2_SC,
-			      MC_CGM_ACn_SEL_DDRPLL);
-	aux_div_clk_config(MC_CGM0_BASE_ADDR, CGM_AC2_SC, CGM_ACn_DC0,
-			   PLLDIG_PLLDV_PREDIV_0);
-
-	/* setup the aux clock source for DCU_AXI_CLK and DCU_PIX_CLK */
-	aux_source_clk_config(MC_CGM0_BASE_ADDR, CGM_AC9_SC,
-			      MC_CGM_ACn_SEL_VIDEOPLLDIV2);
-
-	/* setup the aux clock divider for DCU_AXI_CLK (300MHz) */
-	aux_div_clk_config(MC_CGM0_BASE_ADDR, CGM_AC9_SC, CGM_ACn_DC0,
-			   PLLDIG_PLLDV_PREDIV_0);
-
-	/* setup the aux clock divider for DCU_PIX_CLK (150MHz) */
-	aux_div_clk_config(MC_CGM0_BASE_ADDR, CGM_AC9_SC, CGM_ACn_DC1,
-			   PLLDIG_PLLDV_PREDIV_1);
-
-	entry_to_target_mode( MC_ME_MCTL_RUN0 );
-}
-
-static void enable_modules_clock( void )
-{
-	/* CRC0 */
-	writeb( MC_ME_PCTLn_RUNPCm(CFG_RUN_PC), MC_ME_PCTLn(CRC0_PCTL));
-	/* CRC1 */
-	writeb( MC_ME_PCTLn_RUNPCm(CFG_RUN_PC), MC_ME_PCTLn(CRC1_PCTL));
-	/* ENET */
-	writeb( MC_ME_PCTLn_RUNPCm(CFG_RUN_PC), MC_ME_PCTLn(ENET_PCTL));
-	/* HPSMI */
-	writeb( MC_ME_PCTLn_RUNPCm(CFG_RUN_PC), MC_ME_PCTLn(HPSMI_PCTL));
-	/* IIC0 */
-	writeb( MC_ME_PCTLn_RUNPCm(CFG_RUN_PC), MC_ME_PCTLn(IIC0_PCTL));
-	/* IIC1 */
-	writeb( MC_ME_PCTLn_RUNPCm(CFG_RUN_PC), MC_ME_PCTLn(IIC1_PCTL));
-	/* IIC2 */
-	writeb( MC_ME_PCTLn_RUNPCm(CFG_RUN_PC), MC_ME_PCTLn(IIC2_PCTL));
-	/* LINFLEX0 */
-	writeb( MC_ME_PCTLn_RUNPCm(CFG_RUN_PC), MC_ME_PCTLn(LINFLEX0_PCTL));
-	/* LINFLEX1 */
-	writeb( MC_ME_PCTLn_RUNPCm(CFG_RUN_PC), MC_ME_PCTLn(LINFLEX1_PCTL));
-	/* MBIST */
-	writeb( MC_ME_PCTLn_RUNPCm(CFG_RUN_PC), MC_ME_PCTLn(MBIST_PCTL));
-	/* MMDC0 */
-	writeb( MC_ME_PCTLn_RUNPCm(CFG_RUN_PC), MC_ME_PCTLn(MMDC0_PCTL));
-	/* MMDC1 */
-	writeb( MC_ME_PCTLn_RUNPCm(CFG_RUN_PC), MC_ME_PCTLn(MMDC1_PCTL));
-	/* QuadSPI */
-	writeb( MC_ME_PCTLn_RUNPCm(CFG_RUN_PC), MC_ME_PCTLn(QUADSPI0_PCTL));
-	/* DSPI */
-	writeb( MC_ME_PCTLn_RUNPCm(CFG_RUN_PC), MC_ME_PCTLn(DSPI0_PCTL));
-	/* SDHC */
-	writeb( MC_ME_PCTLn_RUNPCm(CFG_RUN_PC), MC_ME_PCTLn(SDHC_PCTL));
-
-	/*
-	 * The ungating for the clocks of the above IPs should be
-	 * removed from u-boot, because they are used only in kernel
-	 * drivers.
-	 */
-
-	/* DCU */
-	writeb(MC_ME_PCTLn_RUNPCm(CFG_RUN_PC), MC_ME_PCTLn(DCU_PCTL));
-	/* DEC200 */
-	writeb(MC_ME_PCTLn_RUNPCm(CFG_RUN_PC), MC_ME_PCTLn(DEC200_PCTL));
-
-	entry_to_target_mode( MC_ME_MCTL_RUN0 );
-}
-
-#if defined(CONFIG_S32_LPDDR2)
-static void initialize_ddr_clk_params(struct ddr_clk_params *params)
-{
-	switch (s32_get_lpddr2_config()->frequency) {
-	case 400:
-		*params = (struct ddr_clk_params) {
-			.phi0_freq = DDR_PLL_PHI0_FREQ_400MHZ,
-			.phi1_freq = DDR_PLL_PHI1_FREQ_400MHZ,
-			.prediv = DDR_PLL_PLLDV_PREDIV_400MHZ,
-			.mfd = DDR_PLL_PLLDV_MFD_400MHZ,
-			.mfn = DDR_PLL_PLLDV_MFN_400MHZ,
-		};
-		break;
-	case 533:
-	default:
-		*params = (struct ddr_clk_params) {
-			.phi0_freq = DDR_PLL_PHI0_FREQ_533MHZ,
-			.phi1_freq = DDR_PLL_PHI1_FREQ_533MHZ,
-			.prediv = DDR_PLL_PLLDV_PREDIV_533MHZ,
-			.mfd = DDR_PLL_PLLDV_MFD_533MHZ,
-			.mfn = DDR_PLL_PLLDV_MFN_533MHZ,
-		};
-	}
-}
-#else
-static void initialize_ddr_clk_params(struct ddr_clk_params *params)
-{
-	*params = (struct ddr_clk_params) {
-		.phi0_freq = DDR_PLL_PHI0_FREQ_533MHZ,
-		.phi1_freq = DDR_PLL_PHI1_FREQ_533MHZ,
-		.prediv = DDR_PLL_PLLDV_PREDIV_533MHZ,
-		.mfd = DDR_PLL_PLLDV_MFD_533MHZ,
-		.mfn = DDR_PLL_PLLDV_MFN_533MHZ,
-	};
-}
-#endif
-
-void ddr_program_pll(u32 ddr_dfs[][DFS_PARAMS_Nr])
-{
-	struct ddr_clk_params params;
-
-	initialize_ddr_clk_params(&params);
-	program_pll(DDR_PLL, XOSC_CLK_FREQ, params.phi0_freq,
-		    params.phi1_freq, DDR_PLL_PHI1_DFS_Nr, ddr_dfs,
-		    params.prediv, params.mfd, params.mfn);
-}
-
-void clock_init(void)
-{
-	unsigned int arm_1ghz_dfs[ARM_1GHZ_PLL_PHI1_DFS_Nr][DFS_PARAMS_Nr] = {
-		{ARM_1GHZ_PLL_PHI1_DFS1_EN, ARM_1GHZ_PLL_PHI1_DFS1_MFN,
-		 ARM_1GHZ_PLL_PHI1_DFS1_MFI},
-		{ARM_1GHZ_PLL_PHI1_DFS2_EN, ARM_1GHZ_PLL_PHI1_DFS2_MFN,
-		 ARM_1GHZ_PLL_PHI1_DFS2_MFI},
-		{ARM_1GHZ_PLL_PHI1_DFS3_EN, ARM_1GHZ_PLL_PHI1_DFS3_MFN,
-		 ARM_1GHZ_PLL_PHI1_DFS3_MFI}
-		};
-
-	unsigned int arm_800mhz_dfs[ARM_800MHZ_PLL_PHI1_DFS_Nr][DFS_PARAMS_Nr] = {
-		{ARM_800MHZ_PLL_PHI1_DFS1_EN, ARM_800MHZ_PLL_PHI1_DFS1_MFN,
-		 ARM_800MHZ_PLL_PHI1_DFS1_MFI},
-		{ARM_800MHZ_PLL_PHI1_DFS2_EN, ARM_800MHZ_PLL_PHI1_DFS2_MFN,
-		 ARM_800MHZ_PLL_PHI1_DFS2_MFI},
-		{ARM_800MHZ_PLL_PHI1_DFS3_EN, ARM_800MHZ_PLL_PHI1_DFS3_MFN,
-		 ARM_800MHZ_PLL_PHI1_DFS3_MFI}
-		};
-
-	unsigned int enet_dfs[ENET_PLL_PHI1_DFS_Nr][DFS_PARAMS_Nr] = {
-		{ENET_PLL_PHI1_DFS1_EN, ENET_PLL_PHI1_DFS1_MFN,
-		 ENET_PLL_PHI1_DFS1_MFI},
-		{ENET_PLL_PHI1_DFS2_EN, ENET_PLL_PHI1_DFS2_MFN,
-		 ENET_PLL_PHI1_DFS2_MFI},
-		{ENET_PLL_PHI1_DFS3_EN, ENET_PLL_PHI1_DFS3_MFN,
-		 ENET_PLL_PHI1_DFS3_MFI},
-		{ENET_PLL_PHI1_DFS4_EN, ENET_PLL_PHI1_DFS4_MFN,
-		 ENET_PLL_PHI1_DFS4_MFI}
-		};
-
-	unsigned int ddr_dfs[DDR_PLL_PHI1_DFS_Nr][DFS_PARAMS_Nr] = {
-		{DDR_PLL_PHI1_DFS1_EN, DDR_PLL_PHI1_DFS1_MFN,
-		 DDR_PLL_PHI1_DFS1_MFI},
-		{DDR_PLL_PHI1_DFS2_EN, DDR_PLL_PHI1_DFS2_MFN,
-		 DDR_PLL_PHI1_DFS2_MFI},
-		{DDR_PLL_PHI1_DFS3_EN, DDR_PLL_PHI1_DFS3_MFN,
-		 DDR_PLL_PHI1_DFS3_MFI}
-		};
-
-	writel( MC_ME_RUN_PCn_DRUN | MC_ME_RUN_PCn_RUN0 | MC_ME_RUN_PCn_RUN1 |
-		MC_ME_RUN_PCn_RUN2 | MC_ME_RUN_PCn_RUN3,
-		MC_ME_RUN_PCn(CFG_RUN_PC) );
-
-	writel(!(MC_ME_RUN_PCn_DRUN | MC_ME_RUN_PCn_RUN0 | MC_ME_RUN_PCn_RUN1 |
-	       MC_ME_RUN_PCn_RUN2 | MC_ME_RUN_PCn_RUN3),
-	       MC_ME_RUN_PCn(0));
-
-	/* turn on FXOSC */
-
-#if defined(CONFIG_S32V234_FAST_BOOT)
-	writel(MC_ME_RUNMODE_MC_PLL(ARM_PLL) | MC_ME_RUNMODE_MC_PLL(ENET_PLL) |
-	       MC_ME_RUNMODE_MC_MVRON | MC_ME_RUNMODE_MC_XOSCON |
-	       MC_ME_RUNMODE_MC_FIRCON | MC_ME_RUNMODE_MC_SYSCLK(0x1),
-	       MC_ME_RUNn_MC(0));
-#else
-	writel(MC_ME_RUNMODE_MC_MVRON | MC_ME_RUNMODE_MC_XOSCON |
-	       MC_ME_RUNMODE_MC_FIRCON | MC_ME_RUNMODE_MC_SYSCLK(0x1),
-	       MC_ME_RUNn_MC(0));
-#endif
-
-	entry_to_target_mode(MC_ME_MCTL_RUN0);
-
-	if (get_siul2_midr2_speed() == SIUL2_MIDR2_SPEED_800MHZ)
-		program_pll(ARM_PLL, XOSC_CLK_FREQ, ARM_800MHZ_PLL_PHI0_FREQ,
-			    ARM_800MHZ_PLL_PHI1_FREQ,
-			    ARM_800MHZ_PLL_PHI1_DFS_Nr, arm_800mhz_dfs,
-			    ARM_800MHZ_PLL_PLLDV_PREDIV,
-			    ARM_800MHZ_PLL_PLLDV_MFD, ARM_800MHZ_PLL_PLLDV_MFN
-			    );
-	else
-		/* If the speed grading is unsupported or unrecognized, fall
-		 * back to 1 GHz.
-		 */
-		program_pll(ARM_PLL, XOSC_CLK_FREQ, ARM_1GHZ_PLL_PHI0_FREQ,
-			    ARM_1GHZ_PLL_PHI1_FREQ,
-			    ARM_1GHZ_PLL_PHI1_DFS_Nr, arm_1ghz_dfs,
-			    ARM_1GHZ_PLL_PLLDV_PREDIV,
-			    ARM_1GHZ_PLL_PLLDV_MFD, ARM_1GHZ_PLL_PLLDV_MFN
-			    );
-
-	setup_sys_clocks();
-
-	program_pll(PERIPH_PLL, XOSC_CLK_FREQ, PERIPH_PLL_PHI0_FREQ,
-		    PERIPH_PLL_PHI1_FREQ, PERIPH_PLL_PHI1_DFS_Nr, NULL,
-		    PERIPH_PLL_PLLDV_PREDIV, PERIPH_PLL_PLLDV_MFD,
-		    PERIPH_PLL_PLLDV_MFN);
-
-	program_pll(ENET_PLL, XOSC_CLK_FREQ, ENET_PLL_PHI0_FREQ,
-		    ENET_PLL_PHI1_FREQ, ENET_PLL_PHI1_DFS_Nr, enet_dfs,
-		    ENET_PLL_PLLDV_PREDIV, ENET_PLL_PLLDV_MFD,
-		    ENET_PLL_PLLDV_MFN);
-
-	ddr_program_pll(ddr_dfs);
-
-	program_pll(VIDEO_PLL, XOSC_CLK_FREQ, VIDEO_PLL_PHI0_FREQ,
-		    VIDEO_PLL_PHI1_FREQ, VIDEO_PLL_PHI1_DFS_Nr, NULL,
-		    VIDEO_PLL_PLLDV_PREDIV, VIDEO_PLL_PLLDV_MFD,
-		    VIDEO_PLL_PLLDV_MFN);
-
-	setup_aux_clocks();
-	enable_modules_clock();
-
-}
diff --git a/arch/arm/cpu/armv8/s32/s32v234/memory_map.txt b/arch/arm/cpu/armv8/s32/s32v234/memory_map.txt
deleted file mode 100644
index 6b624caa8a..0000000000
--- a/arch/arm/cpu/armv8/s32/s32v234/memory_map.txt
+++ /dev/null
@@ -1,185 +0,0 @@
-# SPDX-License-Identifier:      GPL-2.0+
-#
-# Copyright 2016 Freescale Semiconductor
-#
-# Copyright 2017,2020 NXP
-#
-
-SRAM Layout
-============
-SRAM is from 0x3E800000 to 0x3EBFFFFF (4 MB)
-
-===================================================================================================================
-|                 |             U-boot            |              U-boot           |             Linux             |
-|  Reserved for   |        before relocation      |         after relocation      |   after all 4 cores started   |
-|=================|================|==============|================|==============|================|==============|
-|                 |Starting address|Ending address|Starting address|Ending address|Starting address|Ending address|
-|=================|================|==============|================|==============|================|==============|
-|Stack            |   0x3E800000   |  0x3E804000  |      -         |      -       |       -        |     -        |
-|-----------------|----------------|--------------|----------------|--------------|----------------|--------------|
-|CSE blob*        |                |              |   0x3E801000   |  0x3E805500  |   0x3E801000   |  0x3E805500  |
-|-----------------|----------------|--------------|----------------|--------------|----------------|--------------|
-|MMU Tables       |   0x3E804000   |  0x3E81c000  |      -         |      -       |       -        |     -        |
-|-----------------|----------------|--------------|----------------|--------------|----------------|--------------|
-|u-boot           |   0x3E820000   |  variable**  |   0x3E820000   |  variable**  |       -        |      -       |
-===================================================================================================================
-
-* CSE blob is reserved in SRAM just when CONFIG_FSL_CSE3 is enabled
-from menuconfig (<xyz> is the platform).
-** u-boot size is variable (depends on configuration).
-
-
-DDR Layout
-============
-
-The maximum addressable DDR regions from each type of core are:
-
-=========================================================================
-|      Core      | Region | Starting address | Ending address |   Size  |
-|----------------|--------|------------------|----------------|---------|
-|       M4       |  DDR0  |    0x80000000    |  0xBFFFFFFF    |  1024 MB|
-|                |  DDR1  |    0xC0000000    |  0xDFFFFFFF    |  512 MB |
-|----------------|--------|------------------|----------------|---------|
-|       A53      |  DDR0  |    0x80000000    |  0xBFFFFFFF    |  1024 MB|
-|                |  DDR1  |    0xC0000000    |  0xEFFFFFFF    |  1024 MB|
-=========================================================================
-
-Entire DDR region splits into two regions:
-
-=========================================================================
-|     Board      | Region | Starting address | Ending address |   Size  |
-|----------------|--------|------------------|----------------|---------|
-| EVB, PCIE,     |  DDR0  |    0x80000000    |  0x8FFFFFFF    |  256 MB |
-| FVB_REVB, TMDP |  DDR1  |    0xC0000000    |  0xCFFFFFFF    |  256 MB |
-|----------------|--------|------------------|----------------|---------|
-|  FVB           |  DDR0  |    0x80000000    |  0xBFFFFFFF    |  1024 MB|
-|                |  DDR1  |    0xC0000000    |  0xEFFFFFFF    |  1024 MB|
-=========================================================================
-
-DDR0 memory region is marked as non-cacheable.
-DDR1 memory region is marked as non-cacheable.
-
-Reserved regions:
-
-=========================================================================================================================
-|                 |             U-boot            |                U-boot               |             Linux             |
-|  Reserved for   |        before relocation      |           after relocation          |   after all 4 cores started   |
-|=================|================|==============|==================|==================|================|==============|
-|                 |Starting address|Ending address| Starting address |  Ending address  |Starting address|Ending address|
-|=================|================|==============|===============  =|==================|================|==============|
-|MMU tables       |       -        |      -       |   0x80000000     |    0x80010000    |   0x80000000   |  0x80010000  |
-|-----------------|----------------|--------------|------------------|------------------|----------------|--------------|
-|u-boot           |       -        |      -       | DDR0, variable***| DDR0, variable***|       -        |      -       |
-|-----------------|----------------|--------------|------------------|------------------|----------------|--------------|
-|linux            |       -        |      -       |       -          |      -           |   DDR0 + DDR1, See System.map |
-=========================================================================================================================
-
-*** u-boot address and size, after relocation, is variable (depends on configuration).
-
-
-Flash Layout
-============
-
-Flash memory is used for storage (u-boot image, for example).
-
-If CONFIG_ENV_IS_IN_FLASH is defined, the third sector of flash is reserved for storing the u-boot environment. 
-The sector size is defined in /include/configs/s32v234_common.h with the name FLASH_SECTOR_SIZE. Based on the default value
-of 256 KB, the reserved area ranges from 0x80000 to 0xBFFFF.
-
-Environment Variables
-=====================
-
-boot_mtd:       Select the booting method: bootm/booti. If CONFIG_USE_BOOTI is not defined
-                in the S32V234 SOC configuration bootm will be used by default.
-
-image:          It is the name of kernel image. Please note that the image has to be synchronised with
-                the used boot method.
-
-Configuration Defines
-=====================
-
-CSE_BLOB_BASE:  CSE (firmware + key image) blob loading address.
-
-CSE_BLOB_SIZE:  CSE (firmware + key image) blob size.
-
-KIA_BASE:       CSE key image start address.
-
-MMU Translation Tables
-======================
-
-(1) Early MMU Tables:
-
-     Level 0                   Level 1                   Level 2
-------------------        ------------------
-| 0x00_0000_0000 | -----> | 0x00_0000_0000 | -------|           ...
-------------------        ------------------        |   ------------------
-| 0x80_0000_0000 | --|    | 0x00_4000_0000 | -----| |-> | 0x00_2000_0000 |
-------------------   |    ------------------      | |   ------------------
-|    invalid     |   |    | 0x00_8000_0000 | ---| | |   | 0x00_2020_0000 |
-------------------   |    ------------------    | | |   ------------------
-                     |    | 0x00_c000_0000 | -| | | |   |       ...      |
-                     |    ------------------  | | | |   ------------------
-                     |    | 0x01_0000_0000 |  | | | |-> | 0x00_3E80_0000 |
-                     |    ------------------  | | |     ------------------
-                     |            ...         | | |     | 0x00_3EA0_0000 |
-                     |                        | | |     ------------------
-                     |                        | | |             ...
-                     |                        | | |
-                     |                        | | |     ------------------
-                     |                        | | |---> | 0x00_4000_0000 |
-                     |                        | |       ------------------
-                     |            ...         | |       | 0x00_4020_0000 |
-                     |    ------------------  | |       ------------------
-                     |--> | 0x80_0000_0000 |  | |               ...
-                          ------------------  | |
-                          | 0x80_4000_0000 |  | |       ------------------
-                          ------------------  | |-----> | 0x00_8000_0000 |
-                          | 0x80_8000_0000 |  |         ------------------
-                          ------------------  |         | 0x00_8020_0000 |
-                          | 0x80_c000_0000 |  |         ------------------
-                          ------------------  |         |       ...      |
-                          | 0x81_0000_0000 |  |         ------------------
-                          ------------------  |-------> | 0x00_C000_0000 |
-                                 ...                    ------------------
-                                                        | 0x00_C020_0000 |
-                                                        ------------------
-                                                                ...
-
-(2) Final MMU Tables:
-
-     Level 0                   Level 1                   Level 2
-------------------        ------------------
-| 0x00_0000_0000 | -----> | 0x00_0000_0000 | -------|           ...
-------------------        ------------------        |   ------------------
-| 0x80_0000_0000 | --|    | 0x00_4000_0000 | -----| |-> | 0x00_2000_0000 |
-------------------   |    ------------------      | |   ------------------
-|    invalid     |   |    | 0x00_8000_0000 | ---| | |   | 0x00_2020_0000 |
-------------------   |    ------------------    | | |   ------------------
-                     |    | 0x00_c000_0000 | -| | | |   |       ...      |
-                     |    ------------------  | | | |   ------------------
-                     |    | 0x01_0000_0000 |  | | | |-> | 0x00_3E80_0000 |
-                     |    ------------------  | | |     ------------------
-                     |            ...         | | |     | 0x00_3EA0_0000 |
-                     |                        | | |     ------------------
-                     |                        | | |             ...
-                     |                        | | |
-                     |                        | | |     ------------------
-                     |                        | | |---> | 0x00_4000_0000 |
-                     |                        | |       ------------------
-                     |            ...         | |       | 0x00_4020_0000 |
-                     |    ------------------  | |       ------------------
-                     |--> | 0x80_0000_0000 |  | |               ...
-                          ------------------  | |
-                          | 0x80_4000_0000 |  | |       ------------------
-                          ------------------  | |-----> | 0x00_8000_0000 |
-                          | 0x80_8000_0000 |  |         ------------------
-                          ------------------  |         | 0x00_8020_0000 |
-                          | 0x80_c000_0000 |  |         ------------------
-                          ------------------  |         |       ...      |
-                          | 0x81_0000_0000 |  |         ------------------
-                          ------------------  |-------> | 0x00_C000_0000 |
-                                 ...                    ------------------
-                                                        | 0x00_C020_0000 |
-                                                        ------------------
-                                                                ...
-
diff --git a/arch/arm/cpu/armv8/s32/s32v234/qspi_driver.c b/arch/arm/cpu/armv8/s32/s32v234/qspi_driver.c
deleted file mode 100644
index cff3a8d4a2..0000000000
--- a/arch/arm/cpu/armv8/s32/s32v234/qspi_driver.c
+++ /dev/null
@@ -1,619 +0,0 @@
-// SPDX-License-Identifier:     GPL-2.0+
-/*
- * Copyright 2015-2016 Freescale Semiconductor, Inc.
- * Copyright 2016-2020 NXP
- */
-
-#include <common.h>
-#include <vsprintf.h>
-#include <cpu_func.h>
-#include <asm/arch/qspi_s32v234.h>
-#include <asm/arch/siul.h>
-#include <asm/io.h>
-
-#define	SEQID_LUT			15
-
-#define QUADSPI_MCR			0x00
-#define QUADSPI_MCR_RESERVED_MASK	GENMASK(19, 16)
-#define QUADSPI_MCR_MDIS		BIT(14)
-#define QUADSPI_MCR_CLR_TXF		BIT(11)
-#define QUADSPI_MCR_CLR_RXF		BIT(10)
-#define QUADSPI_MCR_DDR_EN		BIT(7)
-#define QUADSPI_MCR_DQS_EN		BIT(6)
-#define QUADSPI_MCR_DQS_LAT_EN		BIT(5)
-#define QUADSPI_MCR_END_CFG_MASK	GENMASK(3, 2)
-#define QUADSPI_MCR_SWRSTHD		BIT(1)
-#define QUADSPI_MCR_SWRSTSD		BIT(0)
-
-#define QUADSPI_BUF3CR			0x1c
-
-#define QUADSPI_IPCR			0x08
-#define QUADSPI_IPCR_SEQID(x)		((x) << 24)
-
-#define QUADSPI_FLSHCR			0x0c
-#define QUADSPI_FLSHCR_TDH_VALUE	0x1
-#define QUADSPI_FLSHCR_TDH_MASK		GENMASK(17, 16)
-#define QUADSPI_FLSHCR_OFFSET		16
-#define QUADSPI_FLSHCR_TDH(x)		(((x) << QUADSPI_FLSHCR_OFFSET) & \
-					QUADSPI_FLSHCR_TDH_MASK)
-
-#define QUADSPI_BFGENCR			0x20
-
-#define QUADSPI_BUF0IND			0x30
-#define QUADSPI_BUF1IND			0x34
-#define QUADSPI_BUF2IND			0x38
-#define QUADSPI_SFAR			0x100
-
-#define QUADSPI_SFACR			0x104
-#define QUADSPI_SFACR_WA		BIT(16)
-#define QUADSPI_SFACR_CAS_VALUE		0x3
-#define QUADSPI_SFACR_CAS_MASK		GENMASK(3, 0)
-#define QUADSPI_SFACR_CAS_OFFSET	0
-#define QUADSPI_SFACR_CAS(x)		(((x) << QUADSPI_SFACR_CAS_OFFSET) & \
-					QUADSPI_SFACR_CAS_MASK)
-
-#define QUADSPI_RBSR			0x10C
-#define QUADSPI_RBSR_RDBFL_MASK		GENMASK(13, 8)
-#define QUADSPI_RBSR_RDBFL_OFFSET	0x8
-#define QUADSPI_RBSR_RDBFL_VALUE(x)	(((x) & QUADSPI_RBSR_RDBFL_MASK) >> \
-					QUADSPI_RBSR_RDBFL_OFFSET)
-
-#define QUADSPI_TBDR			0x154
-
-#define QUADSPI_SR			0x15C
-#define QUADSPI_SR_IP_ACC		BIT(1)
-#define QUADSPI_SR_AHB_ACC		BIT(2)
-
-#define QUADSPI_FR			0x160
-#define QUADSPI_FR_RBDF			BIT(16)
-#define QUADSPI_FR_TBFF			BIT(27)
-
-#define QUADSPI_SFA1AD			0x180
-#define QUADSPI_SFA2AD			0x184
-#define QUADSPI_SFB1AD			0x188
-#define QUADSPI_SFB2AD			0x18c
-#define QUADSPI_RBDR(x)			(0x200 + ((x) * 4))
-
-#define QUADSPI_LUTKEY			0x300
-#define QUADSPI_LUTKEY_VALUE		0x5AF05AF0
-
-#define QUADSPI_LCKCR			0x304
-#define QUADSPI_LCKER_LOCK		BIT(0)
-#define QUADSPI_LCKER_UNLOCK		BIT(1)
-
-#define QUADSPI_LUT_BASE		0x310
-#define QUADSPI_LUT_REG(idx)		(QUADSPI_LUT_BASE + (idx) * 4)
-
-/* QUADSPI Instructions */
-#define CMD		1
-#define ADDR		2
-#define DUMMY		3
-#define MODE		4
-#define MODE2		5
-#define MODE4		6
-#define READ		7
-#define WRITE		8
-#define JMP_ON_CS	9
-#define ADDR_DDR	10
-#define MODE_DDR	11
-#define MODE2_DDR	12
-#define MODE4_DDR	13
-#define READ_DDR	14
-#define WRITE_DDR	15
-#define DATA_LEARN	16
-#define CMD_DDR		17
-#define CADDR		18
-#define CADDR_DDR	19
-#define STOP		0
-
-#define QSPI_LUT(CMD1, PAD1, OP1, CMD0, PAD0, OP0)	\
-	((((CMD1) & 0x3f) << 26) | \
-	 (((PAD1) & 3) << 24) | \
-	 (((OP1) & 0xff) << 16) | \
-	 (((CMD0) & 0x3f) << 10) | \
-	 (((PAD0) & 3) << 8) | ((OP0) & 0xff))
-
-#define QSPI_BASE	QSPI_BASE_ADDR
-#define BURST_SIZE	512
-#define FLASH_HALF_PAGE_SIZE	16
-
-#define QSPI_LUT_0		0
-#define QSPI_LUT_1		1
-#define QSPI_LUT_2		2
-#define QSPI_LUT_60		60
-#define QSPI_LUT_61		61
-#define QSPI_LUT_62		62
-
-enum qspi_addr_t {
-	qspi_real_address = 1,
-	qspi_real_and_all
-};
-
-static void qspi_writel(unsigned int val, unsigned long addr)
-{
-	out_le32(addr + QSPI_BASE_ADDR, val);
-}
-
-static u32 qspi_readl(unsigned long addr)
-{
-	return in_le32(addr + QSPI_BASE_ADDR);
-}
-
-static void quadspi_set_lut(u32 index, u32 value)
-{
-	/* unlock LUT */
-	qspi_writel(QUADSPI_LUTKEY_VALUE, QUADSPI_LUTKEY);
-	qspi_writel(QUADSPI_LCKER_UNLOCK, QUADSPI_LCKCR);
-
-	qspi_writel(value, QUADSPI_LUT_REG(index));
-
-	/* lock LUT */
-	qspi_writel(QUADSPI_LUTKEY_VALUE, QUADSPI_LUTKEY);
-	qspi_writel(QUADSPI_LCKER_LOCK, QUADSPI_LCKCR);
-}
-
-static void quadspi_read_hyp(void)
-{
-	quadspi_set_lut(QSPI_LUT_0,
-			QSPI_LUT(ADDR_DDR, 3, 24, CMD_DDR, 3, 0xA0));
-	quadspi_set_lut(QSPI_LUT_1,
-			QSPI_LUT(DUMMY, 3, 15, CADDR_DDR, 3, 16));
-	quadspi_set_lut(QSPI_LUT_2,
-			QSPI_LUT(STOP, 3, 0, READ_DDR, 3, 128));
-	qspi_writel(0, QUADSPI_BFGENCR);
-}
-
-/*
- * If we have changed the content of the flash by writing or erasing,
- * we need to invalidate the AHB buffer. If we do not do so, we may read out
- * the wrong data. The spec tells us reset the AHB domain and Serial Flash
- * domain at the same time.
- */
-static inline void qspi_ahb_invalid(void)
-{
-	u32 reg;
-
-	reg = qspi_readl(QUADSPI_MCR);
-	reg |= QUADSPI_MCR_SWRSTHD | QUADSPI_MCR_SWRSTSD;
-	qspi_writel(reg, QUADSPI_MCR);
-
-	/*
-	 * The minimum delay : 1 AHB + 2 SFCK clocks.
-	 * Delay 1 us is enough.
-	 */
-	udelay(1);
-
-	reg &= ~(QUADSPI_MCR_SWRSTHD | QUADSPI_MCR_SWRSTSD);
-	qspi_writel(reg, QUADSPI_MCR);
-}
-
-static void qspi_setup_hyp(void)
-{
-	qspi_iomux();
-
-#ifdef CONFIG_DEBUG_S32_QSPI
-	eprintf("ERROR: %s HAS NO QuadSPI settings and definitions", __func__);
-#else
-	debug("%s uses baremetal QuadSPI settings and definitions", __func__);
-
-	qspi_writel(qspi_readl(QUADSPI_MCR) &
-		    ~QUADSPI_MCR_MDIS, QUADSPI_MCR);
-	/* set AHB buffer size (64bits) */
-	qspi_writel(0, QUADSPI_BUF0IND);
-	/* set top address of FA1 (size 512Mbit) */
-	qspi_writel(CONFIG_SYS_FLASH_BASE + 0x4000000, QUADSPI_SFA1AD);
-	/* set top address of FA2 (size 0Mbit) */
-	qspi_writel(CONFIG_SYS_FLASH_BASE + 0x4000000, QUADSPI_SFA2AD);
-	/* set top address of FB1 (size 512Mbit) */
-	qspi_writel(FLASH_BASE_ADR2 + 0x4000000, QUADSPI_SFB1AD);
-	/* set top address of FB2 (size 0Mbit) 0x203FFFFF */
-	qspi_writel(FLASH_BASE_ADR2 + 0x4000000, QUADSPI_SFB2AD);
-
-	qspi_writel(0x100, QUADSPI_BUF0IND);	/* buffer0 size 512 bytes */
-	qspi_writel(0x200, QUADSPI_BUF1IND);	/* buffer1 size 0 bytes */
-	qspi_writel(0x200, QUADSPI_BUF2IND);	/* buffer2 size 0 bytes */
-	qspi_writel(0x80000000, QUADSPI_BUF3CR);/* All masters use buffer 3 */
-
-	qspi_writel(CONFIG_SYS_FLASH_BASE, QUADSPI_SFAR);
-	qspi_writel(qspi_readl(QUADSPI_MCR) | QUADSPI_MCR_DQS_LAT_EN |
-		    QUADSPI_MCR_DDR_EN | QUADSPI_MCR_DQS_EN,
-		    QUADSPI_MCR);
-	qspi_writel(QUADSPI_SFACR_WA |
-		    QUADSPI_SFACR_CAS(QUADSPI_SFACR_CAS_VALUE),
-		    QUADSPI_SFACR);
-	qspi_writel((qspi_readl(QUADSPI_FLSHCR) & ~QUADSPI_FLSHCR_TDH_MASK) |
-		    QUADSPI_FLSHCR_TDH(QUADSPI_FLSHCR_TDH_VALUE),
-		    QUADSPI_FLSHCR);
-
-	/* Set-up Read command for hyperflash. The command will be used
-	 * by default for any AHB access to the flash memory.
-	 */
-	quadspi_read_hyp();
-#endif
-}
-
-static void quadspi_send_instruction_hyp(unsigned int address, unsigned int cmd)
-{
-	qspi_writel(address & 0xFFFFFFFE, QUADSPI_SFAR);
-	quadspi_set_lut(QSPI_LUT_60,
-			QSPI_LUT(ADDR_DDR, 3, 0x18, CMD_DDR, 3, 0x00));
-	quadspi_set_lut(QSPI_LUT_61,
-			QSPI_LUT(CMD_DDR, 3, cmd >> 8, CADDR_DDR, 3, 0x10));
-	quadspi_set_lut(QSPI_LUT_62,
-			QSPI_LUT(STOP, 0, 0, CMD_DDR, 3, cmd));
-	qspi_writel(QUADSPI_IPCR_SEQID(SEQID_LUT), QUADSPI_IPCR);
-	while (qspi_readl(QUADSPI_SR) & QUADSPI_SR_IP_ACC)
-		;
-}
-
-static unsigned int quadspi_status_hyp(void)
-{
-	unsigned int data;
-
-	quadspi_send_instruction_hyp(CONFIG_SYS_FLASH_BASE + 0xAAA, 0x70);
-
-	qspi_writel(CONFIG_SYS_FLASH_BASE + 0x2, QUADSPI_SFAR);
-	quadspi_set_lut(QSPI_LUT_60,
-			QSPI_LUT(ADDR_DDR, 3, 0x18, CMD_DDR, 3, 0x80));
-	quadspi_set_lut(QSPI_LUT_61,
-			QSPI_LUT(DUMMY, 3, 15, CADDR_DDR, 3, 0x10));
-	quadspi_set_lut(QSPI_LUT_62, QSPI_LUT(STOP, 0, 0, READ_DDR, 3, 0x2));
-
-	qspi_writel(qspi_readl(QUADSPI_MCR) |
-		    QUADSPI_MCR_CLR_RXF, QUADSPI_MCR);
-	qspi_writel(QUADSPI_FR_RBDF, QUADSPI_FR);
-	/* fill the RX buffer */
-	qspi_writel(2 | QUADSPI_IPCR_SEQID(SEQID_LUT), QUADSPI_IPCR);
-	while (qspi_readl(QUADSPI_SR) & QUADSPI_SR_IP_ACC)
-		;
-	while (QUADSPI_RBSR_RDBFL_VALUE(qspi_readl(QUADSPI_RBSR)) != 1)
-		;
-
-	data = qspi_readl(QUADSPI_RBDR(0));
-	return data;
-}
-
-/* address = -1 means chip erase */
-static void quadspi_erase_hyp(int address)
-{
-	int address_start = address & ~(FLASH_SECTOR_SIZE - 1);
-
-	/* Invalidate all cache data. */
-	qspi_ahb_invalid();
-	invalidate_icache_all();
-	if (address == -1)
-		invalidate_dcache_range(CONFIG_SYS_FLASH_BASE,
-					CONFIG_SYS_FLASH_BASE +
-					CONFIG_SYS_FSL_FLASH0_SIZE);
-	else
-		invalidate_dcache_range(address_start,
-					address_start + FLASH_SECTOR_SIZE);
-
-	//check status, wait to be ready
-	while ((quadspi_status_hyp() & 0x8000) == 0)
-		;
-
-	quadspi_send_instruction_hyp(CONFIG_SYS_FLASH_BASE + 0xAAA, 0xAA);
-	quadspi_send_instruction_hyp(CONFIG_SYS_FLASH_BASE + 0x554, 0x55);
-
-	quadspi_send_instruction_hyp(CONFIG_SYS_FLASH_BASE + 0xAAA, 0x80);
-	quadspi_send_instruction_hyp(CONFIG_SYS_FLASH_BASE + 0xAAA, 0xAA);
-
-	quadspi_send_instruction_hyp(CONFIG_SYS_FLASH_BASE + 0x554, 0x55);
-
-	if (address == -1)
-		quadspi_send_instruction_hyp(CONFIG_SYS_FLASH_BASE + 0xAAA,
-					     0x10);
-	else
-		quadspi_send_instruction_hyp((address & 0xfffffffe), 0x30);
-
-	//check status, wait to be ready
-	while ((quadspi_status_hyp() & 0x8000) == 0)
-		;
-}
-
-static void quadspi_program_hyp(unsigned int address, uintptr_t pdata,
-				unsigned int bytes)
-{
-	/* i: number total of bytes to flash
-	 * k: number of bytes to flash at the next command
-	 * m :number of dword (32 bits) to flash at the next command
-	 */
-	int i, j, k, m;
-	unsigned int *data;
-
-	data = (unsigned int *)pdata;
-	i = bytes;
-
-	/* Invalidate all cache data. */
-	qspi_ahb_invalid();
-	invalidate_icache_all();
-	invalidate_dcache_range(address, address + i);
-
-	//check status, wait to be ready
-	while ((quadspi_status_hyp() & 0x8000) == 0)
-		;
-
-	while (i > 0) {
-		/* 128 is the circular TX Buffer depth. */
-		k = i >= 128 ? 128 : i;
-
-		/* 512-byte address boundary should not be crossed so write
-		 * the minimum number between k and the left number of bytes
-		 * in the current burst area.
-		 */
-		k = min(k, (int)(BURST_SIZE - address % BURST_SIZE));
-
-		/* Compute the number of dwords. */
-		m = k >> 2;
-
-		quadspi_send_instruction_hyp(CONFIG_SYS_FLASH_BASE + 0xAAA,
-					     0xAA);
-		quadspi_send_instruction_hyp(CONFIG_SYS_FLASH_BASE + 0x554,
-					     0x55);
-		quadspi_send_instruction_hyp(CONFIG_SYS_FLASH_BASE + 0xAAA,
-					     0xA0);
-
-#ifndef CONFIG_DEBUG_S32_QSPI
-		debug("%s uses baremetal QuadSPI settings and definitions",
-		      __func__);
-#endif
-		/* prepare write/program instruction */
-		qspi_writel(address, QUADSPI_SFAR);
-		quadspi_set_lut(QSPI_LUT_60,
-				QSPI_LUT(ADDR_DDR, 3, 0x18, CMD_DDR, 3, 0x00));
-		quadspi_set_lut(QSPI_LUT_61,
-				QSPI_LUT(WRITE_DDR, 3, 2, CADDR_DDR, 3, 0x10));
-		quadspi_set_lut(QSPI_LUT_62, 0);
-		/* tx buffer */
-		qspi_writel(qspi_readl(QUADSPI_MCR) |
-			    QUADSPI_MCR_CLR_TXF, QUADSPI_MCR);
-		qspi_writel(QUADSPI_FR_TBFF, QUADSPI_FR);
-		/* load write data */
-		for (j = 0; j < m; j++)
-			qspi_writel(*data++, QUADSPI_TBDR);
-		qspi_writel(k | QUADSPI_IPCR_SEQID(SEQID_LUT), QUADSPI_IPCR);
-		/* wait for cmd to be sent */
-		while (qspi_readl(QUADSPI_SR) & QUADSPI_SR_IP_ACC)
-			;
-		/* check status, wait to be done */
-		while ((quadspi_status_hyp() & 0x8000) == 0)
-			;
-
-		address += k;
-		i -= k;
-	}
-
-	/* check status, wait to be ready */
-	while ((quadspi_status_hyp() & 0x8000) == 0)
-		;
-}
-
-int do_qspinor_setup(cmd_tbl_t *cmdtp, int flag, int argc,
-		     char * const argv[])
-{
-	printf("SD/eMMC is disabled. Hyperflash is active and can be used!\n");
-	qspi_setup_hyp();
-	return 0;
-}
-
-static bool is_flash_addr(unsigned int address, enum qspi_addr_t addr_type)
-{
-	bool isflash = 0;
-
-	isflash |= (address >= CONFIG_SYS_FLASH_BASE &&
-		    address < CONFIG_SYS_FLASH_BASE + CONFIG_SYS_FSL_FLASH0_SIZE);
-	isflash |= (addr_type == qspi_real_and_all) && (address == -1);
-	if (!isflash) {
-		printf("Incorrect address '0x%.8x'.\n"
-		       "Must an address above or equal to '0x%.8x' (or '-1',"
-		       " if the command accepts it)\n", address,
-		       CONFIG_SYS_FLASH_BASE);
-		return 0;
-	}
-	return 1;
-}
-
-static bool flash_lock = 1;
-static int do_qspinor_prog(cmd_tbl_t *cmdtp, int flag, int argc,
-			   char * const argv[])
-{
-	unsigned int fladdr, bufaddr, size;
-
-	if (argc != 4) {
-		printf("This command needs exactly three parameters (flashaddr buffaddr and size).\n");
-		return 1;
-	}
-
-	fladdr = simple_strtol(argv[1], NULL, 16);
-	if (!is_flash_addr(fladdr, qspi_real_address))
-		return 1;
-
-	if (fladdr % FLASH_HALF_PAGE_SIZE != 0)
-		printf("Address should be %d bytes aligned.\n",
-		       FLASH_HALF_PAGE_SIZE);
-
-	bufaddr = simple_strtol(argv[2], NULL, 16);
-	size = simple_strtol(argv[3], NULL, 16);
-
-	/* It is strongly recommended that a multiple of 16-byte half-pages be
-	 * written and each half-page written only once.
-	 */
-	if (size < FLASH_HALF_PAGE_SIZE || size % FLASH_HALF_PAGE_SIZE != 0) {
-		printf("The written size must be multiple of %d.\n",
-		       FLASH_HALF_PAGE_SIZE);
-		return 1;
-	}
-
-	if (!flash_lock)
-		quadspi_program_hyp(fladdr, (uintptr_t)bufaddr, size);
-	else
-		printf("Flash write and erase operations are locked!\n");
-
-	return 0;
-}
-
-static int do_qspinor_erase(cmd_tbl_t *cmdtp, int flag, int argc,
-			    char * const argv[])
-{
-	long addr_start;
-
-	if (argc != 2) {
-		printf("This command needs exactly one parameter\n");
-		return 1;
-	}
-
-	addr_start = simple_strtol(argv[1], NULL, 16);
-	if (!is_flash_addr(addr_start, qspi_real_and_all))
-		return 1;
-
-	if (!flash_lock)
-		quadspi_erase_hyp(addr_start);
-	else
-		printf("Flash write and erase operations are locked!\n");
-	return 0;
-}
-
-/* we only need our own SW protect until we implement proper protection via HW
- * mechanisms; until then we need not conflict with those commands
- */
-#ifndef CONFIG_CMD_FLASH
-/* we clean (set to 0) the LUTs used for write and erase to make sure no
- * accidental writes or erases can happen
- */
-void quadspi_rm_write_erase_luts(void)
-{
-	quadspi_set_lut(QSPI_LUT_60, 0);
-	quadspi_set_lut(QSPI_LUT_61, 0);
-	quadspi_set_lut(QSPI_LUT_62, 0);
-}
-
-static int do_swprotect(cmd_tbl_t *cmdtp, int flag, int argc,
-			char * const argv[])
-{
-	if (argc != 2) {
-		printf("This command needs exactly one parameter (on/off).\n");
-		return 1;
-	}
-
-	if (!strcmp(argv[1], "on")) {
-		quadspi_rm_write_erase_luts();
-		flash_lock = 1;
-		return 0;
-	}
-
-	if (!strcmp(argv[1], "off")) {
-		flash_lock = 0;
-		return 0;
-	}
-
-	printf("Unexpected parameter. This command accepts only 'on' and 'off' as parameter.\n");
-	return 1;
-}
-
-/* simple SW protection */
-U_BOOT_CMD(protect, 2, 1, do_swprotect,
-	   "protect on/off the flash memory against write and erase operations",
-	   "on\n"
-	   "    - enable protection and forbid erase and write operations\n"
-	   "protect off\n"
-	   "    - disable protection allowing write and erase operations\n"
-	   ""
-	  );
-
-/* quadspi_erase_hyp */
-U_BOOT_CMD(erase, 3, 1, do_qspinor_erase,
-	   "erase FLASH from address 'START'",
-	   "erase START / -1\n"
-	   "    - erase flash starting from START address\n"
-	   "    - if START=-1, erase the entire chip\n"
-	  );
-#else
-#warning "Using U-Boot's protect and erase commands, not our custom ones"
-#endif
-
-/* quadspi_erase_hyp */
-U_BOOT_CMD(flwrite, 4, 1, do_qspinor_prog,
-	   "write a data buffer into hyperflash",
-	   "ADDR BUFF HEXLEN\n"
-	   "    - write into flash starting with address ADDR\n"
-	   "      the first HEXLEN bytes contained in the memory\n"
-	   "      buffer at address BUFF.\n"
-	   "      Note: all numbers are in hexadecimal format\n"
-	  );
-
-#ifdef CONFIG_ENV_IS_IN_FLASH
-
-flash_info_t flash_info[CONFIG_SYS_MAX_FLASH_BANKS];
-
-/*
- * Wrappers for our flash memory functions, since
- * common/env_flash.c's saveenv function expects those
- * with different signatures. Done to enable the saving
- * of u-boot's environment to flash memory. Temporary
- * solution until this driver is updated to adhere to
- * the U-boot Driver Model.
- */
-
-int flash_sect_protect(int protect_on, unsigned long flash_begin_addr,
-		       unsigned long flash_end_addr)
-{
-	if (protect_on) {
-		quadspi_rm_write_erase_luts();
-		flash_lock = 1;
-	} else {
-		flash_lock = 0;
-	}
-
-	return 0;
-}
-
-int flash_sect_erase(unsigned long flash_begin_addr,
-		     unsigned long flash_end_addr)
-{
-	if (!is_flash_addr((long)flash_begin_addr, qspi_real_and_all))
-		return 1;
-
-	if (!flash_lock)
-		quadspi_erase_hyp(flash_begin_addr);
-	else
-		return -1;
-
-	return 0;
-}
-
-unsigned long flash_init(void)
-{
-	int i;
-
-	flash_info[0].size = CONFIG_SYS_MAX_FLASH_SECT * FLASH_SECTOR_SIZE;
-	flash_info[0].sector_count = CONFIG_SYS_MAX_FLASH_SECT;
-	flash_info[0].flash_id = 0;
-
-	flash_info[0].start[0] = CONFIG_SYS_FLASH_BASE;
-	flash_info[0].protect[0] = 0;
-
-	for (i = 1; i < flash_info[0].sector_count; i++) {
-		flash_info[0].start[i] = flash_info[0].start[i - 1] +
-				CONFIG_ENV_SECT_SIZE; /* 256 KB */
-		flash_info[0].protect[i] = 0;
-	}
-
-	return flash_info[0].size;
-}
-
-int flash_write(char *data, ulong flash_addr, ulong bytes)
-{
-	quadspi_program_hyp((unsigned int)flash_addr, (uintptr_t)data,
-			    (unsigned int)bytes);
-	return 0;
-}
-
-/* The flash_perror() function is only called with return codes from
- * flash_write(). Since we have a custom implementation for the later
- * which always returns 0, there is nothing to be done in flash_perror().
- */
-
-void flash_perror(int rc) {}
-
-#endif
diff --git a/arch/arm/cpu/armv8/s32/s32v234/qspi_iomux.c b/arch/arm/cpu/armv8/s32/s32v234/qspi_iomux.c
deleted file mode 100644
index fae161b7f6..0000000000
--- a/arch/arm/cpu/armv8/s32/s32v234/qspi_iomux.c
+++ /dev/null
@@ -1,138 +0,0 @@
-// SPDX-License-Identifier:     GPL-2.0+
-/*
- * (C) Copyright 2015, 2016, Freescale Semiconductor, Inc.
- * (C) Copyright 2016-2018,2020 NXP
- */
-
-#include <common.h>
-#include <asm/arch/qspi_s32v234.h>
-#include <asm/arch/siul.h>
-#include <asm/io.h>
-
-void qspi_iomux(void)
-{
-	/* CS0, SCK and CK2 use the same base pinmux settings
-	 * 0x0020d700 - SIUL2_PORT_MSCR_CTRL_QSPI_CLK_BASE
-	 */
-
-	/* QSPI0_A_CS0 - U25 - PK5 */
-	writel(SIUL2_PK5_MSCR_MUX_MODE_QSPI_A_CS0 |
-	       SIUL2_PORT_MSCR_CTRL_QSPI_CLK_BASE, SIUL2_MSCRn(SIUL2_PK5_MSCR));
-	/* QSPI0_A_SCK - V25 - PK6 */
-	writel(SIUL2_PK6_MSCR_MUX_MODE_QSPI_A_SCK |
-	       SIUL2_PORT_MSCR_CTRL_QSPI_CLK_BASE, SIUL2_MSCRn(SIUL2_PK6_MSCR));
-
-#ifdef CONFIG_S32V234_FLASH
-	/*
-	 * XXX: This signal should not be needed with hyperflash powered at 3V,
-	 * but it seems the AHB access blocks without it
-	 */
-	/* QSPI0_CK2 - B_SCK? V24 - PK13 */
-	writel(SIUL2_PK13_MSCR_MUX_MODE_QSPI_CK2 |
-	       SIUL2_PORT_MSCR_CTRL_QSPI_CLK_BASE,
-	       SIUL2_MSCRn(SIUL2_PK13_MSCR));
-
-	/* QSPI0_A_DQS - U22 - PK7 */
-	writel(SIUL2_PORT_MSCR_CTRL_QSPI_A_DQS, SIUL2_MSCRn(SIUL2_PK7_MSCR));
-	writel(SIUL2_PK7_IMCR_MUX_MODE_QSPI_A_DQS,
-	       SIUL2_IMCRn(SIUL2_PK7_IMCR_QSPI_A_DQS));
-#else
-
-	/* QSPI0_B_CS0 - W25 - PK12 */
-	writel(SIUL2_PK12_MSCR_MUX_MODE_QSPI_B_CS0 |
-	       SIUL2_PORT_MSCR_CTRL_QSPI_CLK_BASE,
-	       SIUL2_MSCRn(SIUL2_PK12_MSCR));
-	/* QSPI0_B_SCK - V24 - PK13 */
-	writel(SIUL2_PK13_MSCR_MUX_MODE_QSPI_B_SCK |
-	       SIUL2_PORT_MSCR_CTRL_QSPI_CLK_BASE,
-	       SIUL2_MSCRn(SIUL2_PK13_MSCR));
-
-#endif
-
-	/* note: an alternative A_DATA0_3/4_7 CTRL is 0x0028C301/0x0028C302 */
-	/* A_DATA 0-3 */
-	/* QSPI0_A_D3 - V22 - PK11 */
-	writel(SIUL2_PORT_MSCR_CTRL_QSPI_A_DATA0_3,
-	       SIUL2_MSCRn(SIUL2_PK11_MSCR));
-	writel(SIUL2_PORT_IMCR_MUX_MODE_QSPI_A_DATA0_7,
-	       SIUL2_IMCRn(SIUL2_PK11_IMCR_QSPI_A_DATA3));
-
-	/* QSPI0_A_D2 - V21 - PK10 */
-	writel(SIUL2_PORT_MSCR_CTRL_QSPI_A_DATA0_3,
-	       SIUL2_MSCRn(SIUL2_PK10_MSCR));
-	writel(SIUL2_PORT_IMCR_MUX_MODE_QSPI_A_DATA0_7,
-	       SIUL2_IMCRn(SIUL2_PK10_IMCR_QSPI_A_DATA2));
-
-	/* QSPI0_A_D1 - U23 - PK9 */
-	writel(SIUL2_PORT_MSCR_CTRL_QSPI_A_DATA0_3,
-	       SIUL2_MSCRn(SIUL2_PK9_MSCR));
-	writel(SIUL2_PORT_IMCR_MUX_MODE_QSPI_A_DATA0_7,
-	       SIUL2_IMCRn(SIUL2_PK9_IMCR_QSPI_A_DATA1));
-
-	/* QSPI0_A_D0 - V23 - PK8 */
-	writel(SIUL2_PORT_MSCR_CTRL_QSPI_A_DATA0_3,
-	       SIUL2_MSCRn(SIUL2_PK8_MSCR));
-	writel(SIUL2_PORT_IMCR_MUX_MODE_QSPI_A_DATA0_7,
-	       SIUL2_IMCRn(SIUL2_PK8_IMCR_QSPI_A_DATA0));
-
-#ifdef CONFIG_S32V234_FLASH
-	/* A_DATA 4-7 */
-	/* QSPI0_A_DATA7 - R21 - PL2 */
-	writel(SIUL2_PORT_MSCR_CTRL_QSPI_A_DATA4_7,
-	       SIUL2_MSCRn(SIUL2_PL2_MSCR));
-	writel(SIUL2_PORT_IMCR_MUX_MODE_QSPI_A_DATA0_7,
-	       SIUL2_IMCRn(SIUL2_PL2_IMCR_QSPI_A_DATA7));
-
-	/* QSPI0_A_DATA6 - U24 - PL1 */
-	writel(SIUL2_PORT_MSCR_CTRL_QSPI_A_DATA4_7,
-	       SIUL2_MSCRn(SIUL2_PL1_MSCR));
-	writel(SIUL2_PORT_IMCR_MUX_MODE_QSPI_A_DATA0_7,
-	       SIUL2_IMCRn(SIUL2_PL1_IMCR_QSPI_A_DATA6));
-
-	/* QSPI0_A_DATA5 - U21 - PL0 */
-	writel(SIUL2_PORT_MSCR_CTRL_QSPI_A_DATA4_7,
-	       SIUL2_MSCRn(SIUL2_PL0_MSCR));
-	writel(SIUL2_PORT_IMCR_MUX_MODE_QSPI_A_DATA0_7,
-	       SIUL2_IMCRn(SIUL2_PL0_IMCR_QSPI_A_DATA5));
-
-	/* QSPI0_A_DATA4 - W23 - PK15 */
-	writel(SIUL2_PORT_MSCR_CTRL_QSPI_A_DATA4_7,
-	       SIUL2_MSCRn(SIUL2_PK15_MSCR));
-	writel(SIUL2_PORT_IMCR_MUX_MODE_QSPI_A_DATA0_7,
-	       SIUL2_IMCRn(SIUL2_PK15_IMCR_QSPI_A_DATA4));
-
-#else
-	/* B_DATA 0-3 */
-	/* QSPI0_B_DATA7 - R21 - PL2 */
-	writel(SIUL2_PORT_MSCR_CTRL_QSPI_B_DATA0_3,
-	       SIUL2_MSCRn(SIUL2_PL2_MSCR));
-	writel(SIUL2_PORT_IMCR_MUX_MODE_QSPI_B_DATA0_3,
-	       SIUL2_IMCRn(SIUL2_PL2_IMCR_QSPI_B_DATA3));
-
-	/* QSPI0_B_DATA6 - U24 - PL1 */
-	writel(SIUL2_PORT_MSCR_CTRL_QSPI_B_DATA0_3,
-	       SIUL2_MSCRn(SIUL2_PL1_MSCR));
-	writel(SIUL2_PORT_IMCR_MUX_MODE_QSPI_B_DATA0_3,
-	       SIUL2_IMCRn(SIUL2_PL1_IMCR_QSPI_B_DATA2));
-
-	/* QSPI0_B_DATA5 - U21 - PL0 */
-	writel(SIUL2_PORT_MSCR_CTRL_QSPI_B_DATA0_3,
-	       SIUL2_MSCRn(SIUL2_PL0_MSCR));
-	writel(SIUL2_PORT_IMCR_MUX_MODE_QSPI_B_DATA0_3,
-	       SIUL2_IMCRn(SIUL2_PL0_IMCR_QSPI_B_DATA1));
-
-	/* QSPI0_B_DATA4 - W23 - PK15 */
-	writel(SIUL2_PORT_MSCR_CTRL_QSPI_B_DATA0_3,
-	       SIUL2_MSCRn(SIUL2_PK15_MSCR));
-	writel(SIUL2_PORT_IMCR_MUX_MODE_QSPI_B_DATA0_3,
-	       SIUL2_IMCRn(SIUL2_PK15_IMCR_QSPI_B_DATA0));
-#endif
-}
-
-/* qspinor setup */
-U_BOOT_CMD(flsetup, 1, 1, do_qspinor_setup,
-	   "setup qspi pinmuxing and qspi registers for access to flash",
-	   "\n"
-	   "Set up the pinmuxing and qspi registers to access the flash\n"
-	   "    and disconnect from the SD/eMMC.\n"
-	  );
diff --git a/arch/arm/cpu/armv8/s32/s32v234/soc.c b/arch/arm/cpu/armv8/s32/s32v234/soc.c
deleted file mode 100644
index b5e613d372..0000000000
--- a/arch/arm/cpu/armv8/s32/s32v234/soc.c
+++ /dev/null
@@ -1,1162 +0,0 @@
-// SPDX-License-Identifier:     GPL-2.0+
-/*
- * (C) Copyright 2013-2016 Freescale Semiconductor, Inc.
- * Copyright 2016-2021 NXP
- */
-
-#include <common.h>
-#include <hang.h>
-#include <asm/io.h>
-#include <asm/arch/soc.h>
-#include <fsl_esdhc_imx.h>
-#include <mmc.h>
-#include <netdev.h>
-#include <div64.h>
-#include <errno.h>
-#include <asm/arch/cse.h>
-#include <asm/arch/imx-regs.h>
-#ifdef CONFIG_FSL_DSPI
-#include <fsl_dspi.h>
-#endif
-
-#define DFS_NONE	0
-#define DFS0		1
-#define DFS1		2
-#define DFS2		3
-#define DFS3		4
-
-#define PERIPH_PLL_PHI0_DIV3	3
-#define PERIPH_PLL_PHI0_DIV5	5
-#define VIDEO_PLL_PHI0_DIV2	2
-
-#define MHZ	1000000
-#define MAC_ADDR_STR_LEN	17
-
-#ifdef CONFIG_DCU_QOS_FIX
-#define S32V234_NIC_FASTDMA1_IB_READ_QOS	(0x40012380)
-#define S32V234_NIC_FASTDMA1_IB_WRITE_QOS	(0x40012384)
-#define S32V234_NIC_GPU0_READ_QOS		(0x40012480)
-#define S32V234_NIC_GPU0_WRITE_QOS		(0x40012484)
-#define S32V234_NIC_H264DEC_READ_QOS		(0x40012580)
-#define S32V234_NIC_H264DEC_WRITE_QOS		(0x40012584)
-#define S32V234_NIC_GPU1_READ_QOS		(0x40012680)
-#define S32V234_NIC_GPU1_WRITE_QOS		(0x40012684)
-#define S32V234_NIC_CORES_CCI1_IB_READ_QOS	(0x40012780)
-#define S32V234_NIC_CORES_CCI1_IB_WRITE_QOS	(0x40012784)
-#define S32V234_NIC_APEX0_DMA_READ_QOS		(0x40012880)
-#define S32V234_NIC_APEX0_DMA_WRITE_QOS		(0x40012884)
-#define S32V234_NIC_APEX0_BLKDM_A_READ_QOS	(0x40012980)
-#define S32V234_NIC_APEX0_BLKDM_A_WRITE_QOS	(0x40012984)
-#define S32V234_NIC_APEX1_DMA_READ_QOS		(0x40012A80)
-#define S32V234_NIC_APEX1_DMA_WRITE_QOS		(0x40012A84)
-#define S32V234_NIC_APEX1_BLKDMA_READ_QOS	(0x40012B80)
-#define S32V234_NIC_APEX1_BLKDMA_WRITE_QOS	(0x40012B84)
-#define S32V234_NIC_PCIE_READ_QOS		(0x40012C80)
-#define S32V234_NIC_PCIE_WRITE_QOS		(0x40012C84)
-#define S32V234_NIC_ENET0_READ_QOS		(0x40012D80)
-#define S32V234_NIC_ENET0_WRITE_QOS		(0x40012D84)
-#define S32V234_NIC_ENET1_READ_QOS		(0x40012E80)
-#define S32V234_NIC_ENET1_WRITE_QOS		(0x40012E84)
-#define S32V234_NIC_CORES_CCI0_READ_QOS		(0x40012F80)
-#define S32V234_NIC_CORES_CCI0_WRITE_QOS	(0x40012F84)
-#define S32V234_NIC_AXBS_READ_QOS		(0x40013080)
-#define S32V234_NIC_AXBS_WRITE_QOS		(0x40013084)
-#define S32V234_NIC_PDI0_READ_QOS		(0x40013180)
-#define S32V234_NIC_PDI0_WRITE_QOS		(0x40013184)
-#define S32V234_NIC_PDI1_READ_QOS		(0x40013280)
-#define S32V234_NIC_PDI1_WRITE_QOS		(0x40013284)
-#define S32V234_NIC_AXBS_RAM_READ_QOS		(0x40013380)
-#define S32V234_NIC_AXBS_RAM_WRITE_QOS		(0x40013384)
-#define S32V234_NIC_FASTDMA0_READ_QOS		(0x40013480)
-#define S32V234_NIC_FASTDMA0_WRITE_QOS		(0x40013484)
-
-#define S32V234_NIC_RESET			(0x0)
-
-/* SRC_GPR8 bit fields */
-#define SRC_GPR8_2D_ACE_QOS_OFFSET				0
-#define MIN_DCU_QOS_PRIORITY					0xD
-
-#endif /* CONFIG_DCU_QOS_FIX */
-DECLARE_GLOBAL_DATA_PTR;
-
-u32 get_cpu_rev(void)
-{
-	struct mscm_ir *mscmir = (struct mscm_ir *)MSCM_BASE_ADDR;
-	u32 cpu = readl(&mscmir->cpxtype);
-
-	return cpu;
-}
-
-u32 cpu_mask(void)
-{
-	return readl(MC_ME_CS);
-}
-
-/*
- * Return the number of cores on this SOC.
- */
-int cpu_numcores(void)
-{
-	int numcores;
-	u32 mask;
-
-	mask = cpu_mask();
-	numcores = hweight32(cpu_mask());
-
-	/* Verify if M4 is deactivated */
-	if (mask & 0x1)
-		numcores--;
-
-	return numcores;
-}
-
-static u32 get_pllfreq(u32 pll, u32 refclk_freq, u32 plldv,
-		u32 pllfd, u32 selected_output)
-{
-	u32 plldv_prediv = 0, plldv_mfd = 0,	pllfd_mfn = 0;
-	u32 plldv_rfdphi_div = 0, fout = 0;
-	u32 dfs_portn = 0, dfs_mfn = 0, dfs_mfi = 0;
-	double vco = 0;
-
-	if (selected_output > DFS_MAXNUMBER)
-		return 0;
-
-	plldv_prediv =
-	    (plldv & PLLDIG_PLLDV_PREDIV_MASK) >> PLLDIG_PLLDV_PREDIV_OFFSET;
-	plldv_mfd = (plldv & PLLDIG_PLLDV_MFD_MASK);
-
-	pllfd_mfn = (pllfd & PLLDIG_PLLFD_MFN_MASK);
-
-	plldv_prediv = plldv_prediv == 0 ? 1 : plldv_prediv;
-
-	/* The formula for VCO is from TR manual, rev. 1 */
-	vco = (refclk_freq / (double)plldv_prediv) *
-		(plldv_mfd + pllfd_mfn / (double)20480);
-
-	if (selected_output != DFS_NONE) {
-		/* Determine the RFDPHI for PHI1 */
-		plldv_rfdphi_div =
-		    (plldv & PLLDIG_PLLDV_RFDPHI1_MASK) >>
-			PLLDIG_PLLDV_RFDPHI1_OFFSET;
-		plldv_rfdphi_div = plldv_rfdphi_div == 0 ? 1 : plldv_rfdphi_div;
-		if (pll == ARM_PLL || pll == ENET_PLL || pll == DDR_PLL) {
-			dfs_portn =
-			    readl(DFS_DVPORTn(pll, selected_output - 1));
-			dfs_mfi =
-			    (dfs_portn & DFS_DVPORTn_MFI_MASK) >>
-				DFS_DVPORTn_MFI_OFFSET;
-			dfs_mfn =
-			    (dfs_portn & DFS_DVPORTn_MFN_MASK) >>
-				DFS_DVPORTn_MFN_OFFSET;
-
-			dfs_mfi <<= 8;
-			vco /= plldv_rfdphi_div;
-			fout = vco / (dfs_mfi + dfs_mfn);
-			fout <<= 8;
-
-		} else {
-			fout = vco / plldv_rfdphi_div;
-		}
-	} else {
-		/* Determine the RFDPHI for PHI0 */
-		plldv_rfdphi_div =
-		    (plldv & PLLDIG_PLLDV_RFDPHI_MASK) >>
-			PLLDIG_PLLDV_RFDPHI_OFFSET;
-		fout = vco / plldv_rfdphi_div;
-	}
-	return fout;
-}
-
-/* Implemented for ARMPLL, PERIPH_PLL, ENET_PLL, DDR_PLL, VIDEO_LL */
-static u32 decode_pll(enum pll_type pll, u32 refclk_freq,
-		u32 selected_output)
-{
-	u32 plldv, pllfd;
-
-	plldv = readl(PLLDIG_PLLDV(pll));
-	pllfd = readl(PLLDIG_PLLFD(pll));
-
-	return get_pllfreq(pll, refclk_freq, plldv, pllfd, selected_output);
-}
-
-static u32 sys_source_clk_get(uintptr_t cgm_addr)
-{
-	return MC_CGM_SC_SEL_GET(readl(CGM_SC_SS(cgm_addr)));
-}
-
-static u32 sys_div_clk_get(uintptr_t cgm_addr, u8 dc)
-{
-	return MC_CGM_SC_DIV_GET(readl(CGM_SC_DCn(cgm_addr, dc)));
-}
-
-static u32 aux_source_clk_get(uintptr_t cgm_addr, u8 ac)
-{
-	return MC_CGM_ACn_SEL_GET(readl(CGM_ACn_SS(cgm_addr, ac)));
-}
-
-static u32 aux_div_clk_get(uintptr_t cgm_addr, u8 ac, u8 dc)
-{
-	return MC_CGM_ACn_DIV_GET(readl(CGM_ACn_DCm(cgm_addr, ac, dc)));
-}
-
-static u32 get_mcu_main_clk(void)
-{
-	u32 coreclk_div;
-	u32 sysclk_sel;
-	u32 freq = 0;
-
-	sysclk_sel = sys_source_clk_get(MC_CGM1_BASE_ADDR);
-	coreclk_div = sys_div_clk_get(MC_CGM1_BASE_ADDR, CGM_SCn_DC0);
-
-	switch (sysclk_sel) {
-	case MC_CGM_SC_SEL_FIRC:
-		freq = FIRC_CLK_FREQ;
-		break;
-	case MC_CGM_SC_SEL_XOSC:
-		freq = XOSC_CLK_FREQ;
-		break;
-	case MC_CGM_SC_SEL_ARMPLL:
-		/* ARMPLL has as source XOSC and CORE_CLK has as input PHI0 */
-		freq = decode_pll(ARM_PLL, XOSC_CLK_FREQ, DFS_NONE);
-		break;
-	case MC_CGM_SC_SEL_CLKDISABLE:
-		printf("Sysclk is disabled\n");
-		break;
-	default:
-		printf("unsupported system clock select\n");
-		freq = 0;
-	}
-
-	return freq / coreclk_div;
-}
-
-static u32 get_sys_clk(u32 number)
-{
-	u32 sysclk_div, sysclk_div_number;
-	u32 sysclk_sel;
-	u32 freq = 0;
-
-	switch (number) {
-	case MXC_SYS3_CLK:
-		sysclk_div_number = CGM_SCn_DC0;
-		break;
-	case MXC_SYS6_CLK:
-		sysclk_div_number = CGM_SCn_DC1;
-		break;
-	default:
-		printf("unsupported system clock\n");
-		sysclk_div_number = 0;
-	}
-	sysclk_sel = sys_source_clk_get(MC_CGM0_BASE_ADDR);
-	sysclk_div = sys_div_clk_get(MC_CGM0_BASE_ADDR, sysclk_div_number);
-
-	switch (sysclk_sel) {
-	case MC_CGM_SC_SEL_FIRC:
-		freq = FIRC_CLK_FREQ;
-		break;
-	case MC_CGM_SC_SEL_XOSC:
-		freq = XOSC_CLK_FREQ;
-		break;
-	case MC_CGM_SC_SEL_ARMPLL:
-		/* ARMPLL has as source XOSC and SYSn_CLK has as input DFS1 */
-		freq = decode_pll(ARM_PLL, XOSC_CLK_FREQ, DFS0);
-		break;
-	case MC_CGM_SC_SEL_CLKDISABLE:
-		printf("Sysclk is disabled\n");
-		freq = 0;
-		break;
-	default:
-		printf("unsupported system clock select\n");
-		freq = 0;
-	}
-	return freq / sysclk_div;
-}
-
-static u32 get_peripherals_clk(void)
-{
-	u32 auxclk5_div, auxclk5_sel, freq = 0;
-
-	auxclk5_sel = aux_source_clk_get(MC_CGM0_BASE_ADDR, CGM_AC5_SC);
-	auxclk5_div = aux_div_clk_get(MC_CGM0_BASE_ADDR, CGM_AC5_SC,
-				      CGM_ACn_DC0);
-
-	switch (auxclk5_sel) {
-	case MC_CGM_ACn_SEL_FIRC:
-		freq = FIRC_CLK_FREQ;
-		break;
-	case MC_CGM_ACn_SEL_XOSC:
-		freq = XOSC_CLK_FREQ;
-		break;
-	case MC_CGM_ACn_SEL_PERPLLDIVX:
-		freq = decode_pll(PERIPH_PLL, XOSC_CLK_FREQ, DFS_NONE) /
-				  PERIPH_PLL_PHI0_DIV5;
-		break;
-	default:
-		printf("unsupported source clock\n");
-		freq = 0;
-	}
-
-	return freq / auxclk5_div;
-}
-
-static u32 get_uart_clk(void)
-{
-	u32 auxclk3_div, auxclk3_sel, freq = 0;
-
-	auxclk3_sel = aux_source_clk_get(MC_CGM0_BASE_ADDR, CGM_AC3_SC);
-	auxclk3_div = aux_div_clk_get(MC_CGM0_BASE_ADDR, CGM_AC3_SC,
-				      CGM_ACn_DC0);
-
-	switch (auxclk3_sel) {
-	case MC_CGM_ACn_SEL_FIRC:
-		freq = FIRC_CLK_FREQ;
-		break;
-	case MC_CGM_ACn_SEL_XOSC:
-		freq = XOSC_CLK_FREQ;
-		break;
-	case MC_CGM_ACn_SEL_PERPLLDIVX:
-		freq = decode_pll(PERIPH_PLL, XOSC_CLK_FREQ, DFS_NONE) /
-			PERIPH_PLL_PHI0_DIV3;
-		break;
-	case MC_CGM_ACn_SEL_SYSCLK:
-		freq = get_sys_clk(MXC_SYS6_CLK);
-		break;
-	default:
-		printf("unsupported system clock select\n");
-		freq = 0;
-	}
-
-	return freq/auxclk3_div;
-}
-
-static u32 get_fec_clk(void)
-{
-	u32 auxclk2_div;
-	u32 freq = 0;
-
-	auxclk2_div = aux_div_clk_get(MC_CGM2_BASE_ADDR, CGM_AC2_SC,
-				      CGM_ACn_DC0);
-
-	freq = decode_pll(ENET_PLL, XOSC_CLK_FREQ, DFS_NONE);
-
-	return freq / auxclk2_div;
-}
-
-static u32 get_usdhc_clk(void)
-{
-	u32 auxclk15_div;
-	u32 freq = 0;
-
-	auxclk15_div = aux_div_clk_get(MC_CGM0_BASE_ADDR, CGM_AC15_SC,
-				       CGM_ACn_DC0);
-
-	freq = decode_pll(ENET_PLL, XOSC_CLK_FREQ, DFS3);
-
-	return freq / auxclk15_div;
-}
-
-
-
-static u32 get_i2c_clk(void)
-{
-	return get_peripherals_clk();
-}
-
-static u32 get_qspi_clk(void)
-{
-	u32 auxclk14_div, auxclk14_sel, freq = 0;
-
-	auxclk14_sel = aux_source_clk_get(MC_CGM0_BASE_ADDR, CGM_AC14_SC);
-	auxclk14_div = aux_div_clk_get(MC_CGM0_BASE_ADDR, CGM_AC14_SC,
-				       CGM_ACn_DC0);
-
-	switch (auxclk14_sel) {
-	case MC_CGM_ACn_SEL_FIRC:
-		freq = FIRC_CLK_FREQ;
-		break;
-	case MC_CGM_ACn_SEL_XOSC:
-		freq = XOSC_CLK_FREQ;
-		break;
-	case MC_CGM_ACn_SEL_ENETPLL:
-		freq = decode_pll(ENET_PLL, XOSC_CLK_FREQ, DFS2);
-		break;
-	default:
-		printf("unsupported system clock select\n");
-		freq = 0;
-	}
-
-	return freq/auxclk14_div;
-}
-
-static u32 get_dcu_pix_clk(void)
-{
-	u32 auxclk9_div, auxclk9_sel;
-	u32 freq = 0;
-
-	auxclk9_sel = aux_source_clk_get(MC_CGM0_BASE_ADDR, CGM_AC9_SC);
-	auxclk9_div = aux_div_clk_get(MC_CGM0_BASE_ADDR, CGM_AC9_SC,
-				      CGM_ACn_DC1);
-
-	switch (auxclk9_sel) {
-	case MC_CGM_ACn_SEL_FIRC:
-		freq = FIRC_CLK_FREQ;
-		break;
-	case MC_CGM_ACn_SEL_XOSC:
-		freq = XOSC_CLK_FREQ;
-		break;
-	case MC_CGM_ACn_SEL_VIDEOPLLDIV2:
-		freq = decode_pll(VIDEO_PLL, XOSC_CLK_FREQ, DFS_NONE) /
-				VIDEO_PLL_PHI0_DIV2;
-		break;
-	default:
-		printf("unsupported source clock select\n");
-		freq = 0;
-	}
-
-	return freq/auxclk9_div;
-}
-
-static u32 get_dspi_clk(void)
-{
-	return get_sys_clk(MXC_SYS6_CLK);
-}
-
-/* return clocks in Hz */
-unsigned int mxc_get_clock(enum mxc_clock clk)
-{
-	switch (clk) {
-	case MXC_ARM_CLK:
-		return get_mcu_main_clk();
-	case MXC_PERIPHERALS_CLK:
-		return get_peripherals_clk();
-	case MXC_UART_CLK:
-		return get_uart_clk();
-	case MXC_FEC_CLK:
-		return get_fec_clk();
-	case MXC_I2C_CLK:
-		return get_i2c_clk();
-	case MXC_USDHC_CLK:
-		return get_usdhc_clk();
-	case MXC_SYS6_CLK:
-		return get_sys_clk(6);
-	case MXC_QSPI_CLK:
-		return get_qspi_clk();
-	case MXC_DCU_PIX_CLK:
-		return get_dcu_pix_clk();
-	case MXC_DSPI_CLK:
-		return get_dspi_clk();
-	default:
-		break;
-	}
-	printf("Error: Unsupported function to read the frequency! Please define it correctly!");
-	return 0;
-}
-
-int do_s32_showclocks(cmd_tbl_t *cmdtp, int flag, int argc,
-		char * const argv[])
-{
-	printf("Root clocks:\n");
-	printf("CPU clock:%5d MHz\n",
-	       mxc_get_clock(MXC_ARM_CLK) / MHZ);
-	printf("PERIPHERALS clock: %5d MHz\n",
-	       mxc_get_clock(MXC_PERIPHERALS_CLK) / MHZ);
-	printf("uSDHC clock:	%5d MHz\n",
-	       mxc_get_clock(MXC_USDHC_CLK) / MHZ);
-	printf("FEC clock:	%5d MHz\n",
-	       mxc_get_clock(MXC_FEC_CLK) / MHZ);
-	printf("UART clock:	%5d MHz\n",
-	       mxc_get_clock(MXC_UART_CLK) / MHZ);
-	printf("QSPI clock:	%5d MHz\n",
-	       mxc_get_clock(MXC_QSPI_CLK) / MHZ);
-	printf("DSPI clock:	%5d MHz\n",
-	       mxc_get_clock(MXC_DSPI_CLK) / MHZ);
-
-	return 0;
-}
-
-U_BOOT_CMD(clocks, CONFIG_SYS_MAXARGS, 1, do_s32_showclocks,
-	   "display clocks",
-	   ""
-	 );
-
-#ifdef CONFIG_FEC_MXC
-__weak void imx_get_mac_from_fuse(int dev_id, unsigned char *mac)
-{
-	const char *mac_str = S32V234_FEC_DEFAULT_ADDR;
-
-	if ((!env_get("ethaddr")) ||
-	    (strncasecmp(mac_str, env_get("ethaddr"), MAC_ADDR_STR_LEN) == 0)) {
-		printf("\nWarning: System is using default MAC address. ");
-		printf("Please set a new value\n");
-		string_to_enetaddr(mac_str, mac);
-	} else {
-		string_to_enetaddr(env_get("ethdaddr"), mac);
-	}
-}
-#endif
-
-#if defined(CONFIG_DISPLAY_CPUINFO)
-static char *get_reset_cause(void)
-{
-	u32 cause = readl(MC_RGM_FES);
-
-	switch (cause) {
-	case F_SWT4:
-		return "WDOG";
-	case F_JTAG:
-		return "JTAG";
-	case F_FCCU_SOFT:
-		return "FCCU soft reaction";
-	case F_FCCU_HARD:
-		return "FCCU hard reaction";
-	case F_SOFT_FUNC:
-		return "Software Functional reset";
-	case F_ST_DONE:
-		return "Self Test done reset";
-	case F_EXT_RST:
-		return "External reset";
-	default:
-		return "unknown reset";
-	}
-}
-
-void reset_cpu(ulong addr)
-{
-	entry_to_target_mode(MC_ME_MCTL_RESET);
-
-	/* If we get there, we are not in good shape */
-	mdelay(1000);
-	printf("FATAL: Reset Failed!\n");
-	hang();
-};
-
-int print_cpuinfo(void)
-{
-	int speed;
-	u32 osc_freq;
-	struct src *src = (struct src *)SRC_SOC_BASE_ADDR;
-
-	speed = get_siul2_midr2_speed();
-	if (speed != SIUL2_MIDR2_SPEED_1GHZ &&
-	    speed != SIUL2_MIDR2_SPEED_800MHZ) {
-		printf("Warning: ");
-		if (speed == SIUL2_MIDR2_SPEED_600MHZ)
-			printf("Unsupported speed grading: 600 MHz. ");
-		else
-			printf("Unknown speed grading: %#x. ", speed);
-		if (readl(&src->gpr1) &
-		    (SRC_GPR1_PLL_SOURCE_MASK << SRC_GPR1_PLL_OFFSET))
-			osc_freq = XOSC_CLK_FREQ;
-		else
-			osc_freq = FIRC_CLK_FREQ;
-		printf("ARM-PLL frequency was configured to %u MHz\n",
-		       decode_pll(ARM_PLL, osc_freq, 0) / MHZ);
-	}
-
-	printf("CPU:   NXP S32V234 V%d.%d at %d MHz\n",
-	       get_siul2_midr1_major() + 1, get_siul2_midr1_minor(),
-	       mxc_get_clock(MXC_ARM_CLK) / MHZ);
-	printf("Reset cause: %s\n", get_reset_cause());
-
-	return 0;
-}
-#endif
-
-int cpu_eth_init(bd_t *bis)
-{
-	int rc = -ENODEV;
-
-#if defined(CONFIG_FEC_MXC)
-	volatile struct src *src_regs = (struct src *)SRC_SOC_BASE_ADDR;
-
-	/* enable RGMII mode */
-#if (CONFIG_FEC_XCV_TYPE == RGMII)
-	clrsetbits_le32(&src_regs->gpr3, SRC_GPR3_ENET_MODE,
-			SRC_GPR3_ENET_MODE);
-#else
-	clrsetbits_le32(&src_regs->gpr3, SRC_GPR3_ENET_MODE,
-			0);
-#endif
-
-#ifdef CONFIG_FEC_MXC_PHYADDR
-	rc = fecmxc_initialize(bis);
-#endif /* CONFIG_FEC_MXC_PHYADDR */
-
-#endif /* CONFIG_FEC_MXC */
-
-	return rc;
-}
-
-void cpu_pci_clock_init(const int clockexternal)
-{
-	volatile struct src *src_regs = (struct src *)SRC_SOC_BASE_ADDR;
-
-
-	clrsetbits_le32(&src_regs->gpr3,
-			SRC_GPR3_PCIE_RFCC_CLK,
-			(clockexternal) ? SRC_GPR3_PCIE_RFCC_CLK : 0);
-	/* The RM does not state that a delay is required.
-	 * I want to be on the safe side however to ensure clock
-	 * stability before checking the link. With respect to boot
-	 * time delays, this can be revisited later on.
-	 */
-	udelay(100);
-}
-
-static int detect_boot_interface(void)
-{
-	volatile struct src *src = (struct src *)SRC_SOC_BASE_ADDR;
-
-	u32 reg_val;
-	int value;
-	reg_val = readl(&src->bmr1);
-	value = reg_val & SRC_BMR1_CFG1_MASK;
-	value = value >> SRC_BMR1_CFG1_BOOT_SHIFT;
-
-	if (value != SRC_BMR1_CFG1_QuadSPI &&
-	    value != SRC_BMR1_CFG1_SD &&
-	    value != SRC_BMR1_CFG1_eMMC) {
-		printf("Unknown booting environment\n");
-		value = -1;
-	}
-
-	return value;
-}
-
-int get_clocks(void)
-{
-#ifdef CONFIG_FSL_ESDHC_IMX
-	gd->arch.sdhc_clk = mxc_get_clock(MXC_USDHC_CLK);
-#endif
-	return 0;
-}
-
-__weak void setup_iomux_enet(void)
-{
-#ifndef CONFIG_PHY_RGMII_DIRECT_CONNECTED
-	/* set PC13 - MSCR[45] - for MDC */
-	writel(SIUL2_MSCR_ENET_MDC, SIUL2_MSCRn(SIUL2_MSCR_PC13));
-
-	/* set PC14 - MSCR[46] - for MDIO */
-	writel(SIUL2_MSCR_ENET_MDIO, SIUL2_MSCRn(SIUL2_MSCR_PC14));
-	writel(SIUL2_MSCR_ENET_MDIO_IN, SIUL2_MSCRn(SIUL2_MSCR_PC14_IN));
-#endif
-
-#ifdef CONFIG_PHY_RGMII_DIRECT_CONNECTED
-	/* set PC15 - MSCR[47] - for TX CLK SWITCH */
-	writel(SIUL2_MSCR_ENET_TX_CLK_SWITCH,
-	       SIUL2_MSCRn(SIUL2_MSCR_PC15_SWITCH));
-#else
-	/* set PC15 - MSCR[47] - for TX CLK */
-	writel(SIUL2_MSCR_ENET_TX_CLK, SIUL2_MSCRn(SIUL2_MSCR_PC15));
-#endif
-	writel(SIUL2_MSCR_ENET_TX_CLK_IN, SIUL2_MSCRn(SIUL2_MSCR_PC15_IN));
-
-	/* set PD0 - MSCR[48] - for RX_CLK */
-	writel(SIUL2_MSCR_ENET_RX_CLK, SIUL2_MSCRn(SIUL2_MSCR_PD0));
-	writel(SIUL2_MSCR_ENET_RX_CLK_IN, SIUL2_MSCRn(SIUL2_MSCR_PD0_IN));
-
-	/* set PD1 - MSCR[49] - for RX_D0 */
-	writel(SIUL2_MSCR_ENET_RX_D0, SIUL2_MSCRn(SIUL2_MSCR_PD1));
-	writel(SIUL2_MSCR_ENET_RX_D0_IN, SIUL2_MSCRn(SIUL2_MSCR_PD1_IN));
-
-	/* set PD2 - MSCR[50] - for RX_D1 */
-	writel(SIUL2_MSCR_ENET_RX_D1, SIUL2_MSCRn(SIUL2_MSCR_PD2));
-	writel(SIUL2_MSCR_ENET_RX_D1_IN, SIUL2_MSCRn(SIUL2_MSCR_PD2_IN));
-
-	/* set PD3 - MSCR[51] - for RX_D2 */
-	writel(SIUL2_MSCR_ENET_RX_D2, SIUL2_MSCRn(SIUL2_MSCR_PD3));
-	writel(SIUL2_MSCR_ENET_RX_D2_IN, SIUL2_MSCRn(SIUL2_MSCR_PD3_IN));
-
-	/* set PD4 - MSCR[52] - for RX_D3 */
-	writel(SIUL2_MSCR_ENET_RX_D3, SIUL2_MSCRn(SIUL2_MSCR_PD4));
-	writel(SIUL2_MSCR_ENET_RX_D3_IN, SIUL2_MSCRn(SIUL2_MSCR_PD4_IN));
-
-	/* set PD5 - MSCR[53] - for RX_DV */
-	writel(SIUL2_MSCR_ENET_RX_DV, SIUL2_MSCRn(SIUL2_MSCR_PD5));
-	writel(SIUL2_MSCR_ENET_RX_DV_IN, SIUL2_MSCRn(SIUL2_MSCR_PD5_IN));
-
-	/* set PD7 - MSCR[55] - for TX_D0 */
-	writel(SIUL2_MSCR_ENET_TX_D0, SIUL2_MSCRn(SIUL2_MSCR_PD7));
-	/* set PD8 - MSCR[56] - for TX_D1 */
-	writel(SIUL2_MSCR_ENET_TX_D1, SIUL2_MSCRn(SIUL2_MSCR_PD8));
-	/* set PD9 - MSCR[57] - for TX_D2 */
-	writel(SIUL2_MSCR_ENET_TX_D2, SIUL2_MSCRn(SIUL2_MSCR_PD9));
-	/* set PD10 - MSCR[58] - for TX_D3 */
-	writel(SIUL2_MSCR_ENET_TX_D3, SIUL2_MSCRn(SIUL2_MSCR_PD10));
-	/* set PD11 - MSCR[59] - for TX_EN */
-	writel(SIUL2_MSCR_ENET_TX_EN, SIUL2_MSCRn(SIUL2_MSCR_PD11));
-}
-
-#ifdef CONFIG_FSL_DCU_FB
-
-__weak void setup_iomux_dcu(void)
-{
-	/* set PH8 - MSCR[120] - for HSYNC_C1 */
-	writel(SIUL2_MSCR_DCU_CFG, SIUL2_MSCRn(SIUL2_MSCR_PH8));
-	/* set PH9 - MSCR[121] - for VSYNC_C2 */
-	writel(SIUL2_MSCR_DCU_CFG, SIUL2_MSCRn(SIUL2_MSCR_PH9));
-	/* set PH10 - MSCR[122] - for DE_C3 */
-	writel(SIUL2_MSCR_DCU_CFG, SIUL2_MSCRn(SIUL2_MSCR_PH10));
-	/* set PH12 - MSCR[124] - for PCLK_D1 */
-	writel(SIUL2_MSCR_DCU_CFG, SIUL2_MSCRn(SIUL2_MSCR_PH12));
-	/* set PH13 - MSCR[125] - for R0_D2 */
-	writel(SIUL2_MSCR_DCU_CFG, SIUL2_MSCRn(SIUL2_MSCR_PH13));
-	/* set PH14 - MSCR[126] - for R1_D3 */
-	writel(SIUL2_MSCR_DCU_CFG, SIUL2_MSCRn(SIUL2_MSCR_PH14));
-	/* set PH15 - MSCR[127] - for R2_D4 */
-	writel(SIUL2_MSCR_DCU_CFG, SIUL2_MSCRn(SIUL2_MSCR_PH15));
-	/* set PJ0 - MSCR[128] - for R3_D5 */
-	writel(SIUL2_MSCR_DCU_CFG, SIUL2_MSCRn(SIUL2_MSCR_PJ0));
-	/* set PJ1 - MSCR[129] - for R4_D6 */
-	writel(SIUL2_MSCR_DCU_CFG, SIUL2_MSCRn(SIUL2_MSCR_PJ1));
-	/* set PJ2 - MSCR[130] - for R5_D7 */
-	writel(SIUL2_MSCR_DCU_CFG, SIUL2_MSCRn(SIUL2_MSCR_PJ2));
-	/* set PJ3 - MSCR[131] - for R6_D8 */
-	writel(SIUL2_MSCR_DCU_CFG, SIUL2_MSCRn(SIUL2_MSCR_PJ3));
-	/* set PJ4 - MSCR[132] - for R7_D9 */
-	writel(SIUL2_MSCR_DCU_CFG, SIUL2_MSCRn(SIUL2_MSCR_PJ4));
-	/* set PJ5 - MSCR[133] - for G0_D10 */
-	writel(SIUL2_MSCR_DCU_CFG, SIUL2_MSCRn(SIUL2_MSCR_PJ5));
-	/* set PJ6 - MSCR[134] - for G1_D11 */
-	writel(SIUL2_MSCR_DCU_CFG, SIUL2_MSCRn(SIUL2_MSCR_PJ6));
-	/* set PJ7 - MSCR[135] - for G2_D12 */
-	writel(SIUL2_MSCR_DCU_CFG, SIUL2_MSCRn(SIUL2_MSCR_PJ7));
-	/* set PJ8 - MSCR[136] - for G3_D13 */
-	writel(SIUL2_MSCR_DCU_CFG, SIUL2_MSCRn(SIUL2_MSCR_PJ8));
-	/* set PJ9 - MSCR[137] - for G4_D14 */
-	writel(SIUL2_MSCR_DCU_CFG, SIUL2_MSCRn(SIUL2_MSCR_PJ9));
-	/* set PJ10 - MSCR[138] - for G5_D15 */
-	writel(SIUL2_MSCR_DCU_CFG, SIUL2_MSCRn(SIUL2_MSCR_PJ10));
-	/* set PJ11 - MSCR[139] - for G6_D16 */
-	writel(SIUL2_MSCR_DCU_CFG, SIUL2_MSCRn(SIUL2_MSCR_PJ11));
-	/* set PJ12 - MSCR[140] - for G7_D17 */
-	writel(SIUL2_MSCR_DCU_CFG, SIUL2_MSCRn(SIUL2_MSCR_PJ12));
-	/* set PJ13 - MSCR[141] - for B0_D18 */
-	writel(SIUL2_MSCR_DCU_CFG, SIUL2_MSCRn(SIUL2_MSCR_PJ13));
-	/* set PJ14 - MSCR[142] - for B1_D19 */
-	writel(SIUL2_MSCR_DCU_CFG, SIUL2_MSCRn(SIUL2_MSCR_PJ14));
-	/* set PJ15 - MSCR[143] - for B2_D20 */
-	writel(SIUL2_MSCR_DCU_CFG, SIUL2_MSCRn(SIUL2_MSCR_PJ15));
-	/* set PK0 - MSCR[144] - for B3_D21 */
-	writel(SIUL2_MSCR_DCU_CFG, SIUL2_MSCRn(SIUL2_MSCR_PK0));
-	/* set PK1 - MSCR[145] - for B4_D22 */
-	writel(SIUL2_MSCR_DCU_CFG, SIUL2_MSCRn(SIUL2_MSCR_PK1));
-	/* set PK2 - MSCR[146] - for B5_D23 */
-	writel(SIUL2_MSCR_DCU_CFG, SIUL2_MSCRn(SIUL2_MSCR_PK2));
-	/* set PK3 - MSCR[147] - for B6_D24 */
-	writel(SIUL2_MSCR_DCU_CFG, SIUL2_MSCRn(SIUL2_MSCR_PK3));
-	/* set PK4 - MSCR[148] - for B7_D25 */
-	writel(SIUL2_MSCR_DCU_CFG, SIUL2_MSCRn(SIUL2_MSCR_PK4));
-}
-
-#endif
-
-#ifdef CONFIG_DCU_QOS_FIX
-int board_dcu_qos(void)
-{
-	/*
-	 * SRC_GPR8.2D_ACE_QOS was introduced in TR2.0 and is used to set
-	 * the minimum QOS value for DCU DMA master. Depending on the pixel
-	 * output rate of the display, the real time requirements of the 2D-ACE
-	 * have to be ensured to avoid underruns of its local buffers. This
-	 * requires that other masters of the device interconnect should receive
-	 * a lower QoS than programmed by SRC_GPR8.
-	 */
-	if (get_siul2_midr1_major() == TREERUNNER_GENERATION_2_MAJOR) {
-		struct src *src_regs = (struct src *)SRC_SOC_BASE_ADDR;
-		u32 val = readl(&src_regs->gpr8);
-
-		writel(val |
-		       (MIN_DCU_QOS_PRIORITY << SRC_GPR8_2D_ACE_QOS_OFFSET),
-		       &src_regs->gpr8);
-	}
-
-	/* m_fastdma1_ib */
-	writel(S32V234_NIC_RESET, S32V234_NIC_FASTDMA1_IB_READ_QOS);
-	writel(S32V234_NIC_RESET, S32V234_NIC_FASTDMA1_IB_WRITE_QOS);
-
-	/* m_gpu0 */
-	writel(S32V234_NIC_RESET, S32V234_NIC_GPU0_READ_QOS);
-	writel(S32V234_NIC_RESET, S32V234_NIC_GPU0_WRITE_QOS);
-
-	/* m_h264dec */
-	writel(S32V234_NIC_RESET, S32V234_NIC_H264DEC_READ_QOS);
-	writel(S32V234_NIC_RESET, S32V234_NIC_H264DEC_WRITE_QOS);
-
-	/* m_gpu1 */
-	writel(S32V234_NIC_RESET, S32V234_NIC_GPU1_READ_QOS);
-	writel(S32V234_NIC_RESET, S32V234_NIC_GPU1_WRITE_QOS);
-
-	/* m_cores_cci1_ib */
-	writel(S32V234_NIC_RESET, S32V234_NIC_CORES_CCI1_IB_READ_QOS);
-	writel(S32V234_NIC_RESET, S32V234_NIC_CORES_CCI1_IB_WRITE_QOS);
-
-	/* m_apex0_dma */
-	writel(S32V234_NIC_RESET, S32V234_NIC_APEX0_DMA_READ_QOS);
-	writel(S32V234_NIC_RESET, S32V234_NIC_APEX0_DMA_WRITE_QOS);
-
-	/* m_apex0_blkdm a */
-	writel(S32V234_NIC_RESET, S32V234_NIC_APEX0_BLKDM_A_READ_QOS);
-	writel(S32V234_NIC_RESET, S32V234_NIC_APEX0_BLKDM_A_WRITE_QOS);
-
-	/* m_apex1_dma */
-	writel(S32V234_NIC_RESET, S32V234_NIC_APEX1_DMA_READ_QOS);
-	writel(S32V234_NIC_RESET, S32V234_NIC_APEX1_DMA_WRITE_QOS);
-
-	/* m_apex1_blkdma */
-	writel(S32V234_NIC_RESET, S32V234_NIC_APEX1_BLKDMA_READ_QOS);
-	writel(S32V234_NIC_RESET, S32V234_NIC_APEX1_BLKDMA_WRITE_QOS);
-
-	/* m_pcie */
-	writel(S32V234_NIC_RESET, S32V234_NIC_PCIE_READ_QOS);
-	writel(S32V234_NIC_RESET, S32V234_NIC_PCIE_WRITE_QOS);
-
-	/* m_enet0 */
-	writel(S32V234_NIC_RESET, S32V234_NIC_ENET0_READ_QOS);
-	writel(S32V234_NIC_RESET, S32V234_NIC_ENET0_WRITE_QOS);
-
-	/* m_enet1 */
-	writel(S32V234_NIC_RESET, S32V234_NIC_ENET1_READ_QOS);
-	writel(S32V234_NIC_RESET, S32V234_NIC_ENET1_WRITE_QOS);
-
-	/* m_cores_cci0 */
-	writel(S32V234_NIC_RESET, S32V234_NIC_CORES_CCI0_READ_QOS);
-	writel(S32V234_NIC_RESET, S32V234_NIC_CORES_CCI0_WRITE_QOS);
-
-	/* m_axbs */
-	writel(S32V234_NIC_RESET, S32V234_NIC_AXBS_READ_QOS);
-	writel(S32V234_NIC_RESET, S32V234_NIC_AXBS_WRITE_QOS);
-
-	/* m_pdi0 */
-	writel(S32V234_NIC_RESET, S32V234_NIC_PDI0_READ_QOS);
-	writel(S32V234_NIC_RESET, S32V234_NIC_PDI0_WRITE_QOS);
-
-	/* m_pdi1 */
-	writel(S32V234_NIC_RESET, S32V234_NIC_PDI1_READ_QOS);
-	writel(S32V234_NIC_RESET, S32V234_NIC_PDI1_WRITE_QOS);
-
-	/* m_axbs_ram */
-	writel(S32V234_NIC_RESET, S32V234_NIC_AXBS_RAM_READ_QOS);
-	writel(S32V234_NIC_RESET, S32V234_NIC_AXBS_RAM_WRITE_QOS);
-
-	/* m_fastdma0 */
-	writel(S32V234_NIC_RESET, S32V234_NIC_FASTDMA0_READ_QOS);
-	writel(S32V234_NIC_RESET, S32V234_NIC_FASTDMA0_WRITE_QOS);
-
-	return 0;
-}
-#endif
-
-__weak void setup_iomux_sdhc(void)
-{
-	/* Set iomux PADS for USDHC */
-
-	/* PK6 pad: uSDHC clk */
-	writel(SIUL2_USDHC_PAD_CTRL_CLK, SIUL2_MSCRn(150));
-	writel(0x3, SIUL2_MSCRn(902));
-
-	/* PK7 pad: uSDHC CMD */
-	writel(SIUL2_USDHC_PAD_CTRL_CMD, SIUL2_MSCRn(151));
-	writel(0x3, SIUL2_MSCRn(901));
-
-	/* PK8 pad: uSDHC DAT0 */
-	writel(SIUL2_USDHC_PAD_CTRL_DAT0_3, SIUL2_MSCRn(152));
-	writel(0x3, SIUL2_MSCRn(903));
-
-	/* PK9 pad: uSDHC DAT1 */
-	writel(SIUL2_USDHC_PAD_CTRL_DAT0_3, SIUL2_MSCRn(153));
-	writel(0x3, SIUL2_MSCRn(904));
-
-	/* PK10 pad: uSDHC DAT2 */
-	writel(SIUL2_USDHC_PAD_CTRL_DAT0_3, SIUL2_MSCRn(154));
-	writel(0x3, SIUL2_MSCRn(905));
-
-	/* PK11 pad: uSDHC DAT3 */
-	writel(SIUL2_USDHC_PAD_CTRL_DAT0_3, SIUL2_MSCRn(155));
-	writel(0x3, SIUL2_MSCRn(906));
-
-	/* PK15 pad: uSDHC DAT4 */
-	writel(SIUL2_USDHC_PAD_CTRL_DAT4_7, SIUL2_MSCRn(159));
-	writel(0x3, SIUL2_MSCRn(907));
-
-	/* PL0 pad: uSDHC DAT5 */
-	writel(SIUL2_USDHC_PAD_CTRL_DAT4_7, SIUL2_MSCRn(160));
-	writel(0x3, SIUL2_MSCRn(908));
-
-	/* PL1 pad: uSDHC DAT6 */
-	writel(SIUL2_USDHC_PAD_CTRL_DAT4_7, SIUL2_MSCRn(161));
-	writel(0x3, SIUL2_MSCRn(909));
-
-	/* PL2 pad: uSDHC DAT7 */
-	writel(SIUL2_USDHC_PAD_CTRL_DAT4_7, SIUL2_MSCRn(162));
-	writel(0x3, SIUL2_MSCRn(910));
-}
-
-#ifdef CONFIG_FSL_ESDHC_IMX
-struct fsl_esdhc_cfg esdhc_cfg[1] = {
-	{USDHC_BASE_ADDR},
-};
-
-__weak int board_mmc_getcd(struct mmc *mmc)
-{
-	/* eSDHC1 is always present */
-	return 1;
-}
-__weak int sdhc_setup(bd_t *bis)
-{
-	esdhc_cfg[0].sdhc_clk = mxc_get_clock(MXC_USDHC_CLK);
-
-	setup_iomux_sdhc();
-
-	return fsl_esdhc_initialize(bis, &esdhc_cfg[0]);
-}
-int board_mmc_init(bd_t *bis)
-{
-	int ret = detect_boot_interface();
-	if (ret < 0)
-		return -1;
-
-	if (ret != SRC_BMR1_CFG1_QuadSPI)
-		return sdhc_setup(bis);
-	else
-		return 0;
-}
-
-static int do_sdhc_setup(cmd_tbl_t *cmdtp, int flag, int argc,
-		char * const argv[])
-{
-	int ret;
-	struct mmc *mmc = find_mmc_device(0);
-
-	printf("Hyperflash is disabled. SD/eMMC is active and can be used\n");
-
-	if (!mmc)
-		return sdhc_setup(gd->bd);
-
-	/* set the sdhc pinmuxing */
-	setup_iomux_sdhc();
-
-	/* reforce the mmc's initialization */
-	ret = mmc_init(mmc);
-	if (ret) {
-		printf("Impossible to configure the SDHC controller. Please check the SDHC jumpers\n");
-		return 1;
-	}
-	return 0;
-}
-/* sdhc setup */
-U_BOOT_CMD(sdhcsetup, 1, 1, do_sdhc_setup,
-	   "setup sdhc pinmuxing and sdhc registers for access to SD",
-	   "\n"
-	   "Set up the sdhc pinmuxing and sdhc registers to access the SD\n"
-	   "and disconnect from the Hyperflash.\n"
-	 );
-#endif
-
-void setup_iomux_ddr(void)
-{
-	ddr_config_iomux(DDR0);
-	ddr_config_iomux(DDR1);
-}
-
-void ddr_ctrl_init(void)
-{
-	config_mmdc(0);
-	config_mmdc(1);
-}
-
-#ifdef CONFIG_DDR_HANDSHAKE_AT_RESET
-void ddr_check_post_func_reset(uint8_t module)
-{
-	u32 ddr_self_ref_clr, mmdc_mapsr;
-	unsigned long mmdc_addr;
-	volatile struct src *src = (struct src *)SRC_SOC_BASE_ADDR;
-
-	mmdc_addr = (module) ? MMDC1_BASE_ADDR : MMDC0_BASE_ADDR;
-	ddr_self_ref_clr = (module) ? SRC_DDR_EN_SELF_REF_CTRL_DDR1_SLF_REF_CLR
-		: SRC_DDR_EN_SELF_REF_CTRL_DDR0_SLF_REF_CLR;
-
-	/* Check if DDR is still in refresh mode */
-	if (src->ddr_self_ref_ctrl & ddr_self_ref_clr) {
-		mmdc_mapsr = readl(mmdc_addr + MMDC_MAPSR);
-		writel(mmdc_mapsr | MMDC_MAPSR_EN_SLF_REF,
-		       mmdc_addr + MMDC_MAPSR);
-
-		src->ddr_self_ref_ctrl =
-			src->ddr_self_ref_ctrl | ddr_self_ref_clr;
-
-		mmdc_mapsr = readl(mmdc_addr + MMDC_MAPSR);
-		writel(mmdc_mapsr & ~MMDC_MAPSR_EN_SLF_REF,
-		       mmdc_addr + MMDC_MAPSR);
-	}
-}
-#endif
-
-__weak int dram_init(void)
-{
-#ifndef CONFIG_S32_SKIP_RELOC
-#ifdef CONFIG_DDR_HANDSHAKE_AT_RESET
-	u32 enabled_hs_events, func_event;
-
-	if (readl(MC_RGM_DDR_HE) & MC_RGM_DDR_HE_EN) {
-		/* Enable DDR handshake for all functional events */
-		volatile struct src *src = (struct src *)SRC_SOC_BASE_ADDR;
-
-		src->ddr_self_ref_ctrl = src->ddr_self_ref_ctrl |
-			SRC_DDR_EN_SLF_REF_VALUE;
-
-		/* If reset event was received, check DDR state */
-		func_event = readl(MC_RGM_FES);
-		enabled_hs_events = readl(MC_RGM_FRHE);
-		if (func_event & enabled_hs_events) {
-			if (func_event & MC_RGM_FES_ANY_FUNC_EVENT) {
-				/* Check if DDR handshake was done */
-				while (!(readl(MC_RGM_DDR_HS) &
-						MC_RGM_DDR_HS_HNDSHK_DONE))
-					;
-
-				ddr_check_post_func_reset(DDR0);
-				ddr_check_post_func_reset(DDR1);
-			}
-		}
-	} else {
-		/*
-		 * First boot so the handshake isn't necessary.
-		 * We should only enable it for future functional resets.
-		 */
-		writel(MC_RGM_DDR_HE_VALUE, MC_RGM_DDR_HE);
-		writel(MC_RGM_FRHE_ALL_VALUE, MC_RGM_FRHE);
-	}
-
-#endif
-	setup_iomux_ddr();
-
-	ddr_ctrl_init();
-#endif
-
-	return 0;
-}
-
-/* start M4 core */
-static int do_start_m4(cmd_tbl_t *cmdtp, int flag, int argc,
-		       char * const argv[])
-{
-	unsigned long addr;
-	char *ep;
-
-	if (argc < 2)
-		return CMD_RET_USAGE;
-
-	addr = simple_strtoul(argv[1], &ep, 16);
-	if (ep == argv[1] || *ep != '\0')
-		return CMD_RET_USAGE;
-
-	if (!is_addr_in_sram(addr)) {
-		printf("ERROR: Address 0x%08lX not in internal SRAM ...\n",
-		       addr);
-		return CMD_RET_USAGE;
-	}
-
-	printf("Starting core M4 at SRAM address 0x%08lX ...\n", addr);
-
-	/* Write the M4 core's start address
-	 * address is required by the hardware to be odd
-	 */
-	writel(addr | 0x1, MC_ME_CADDR0);
-
-	/* enable CM4 to be active during all modes of operation */
-	writew(MC_MC_CCTL_CORE_ACTIVE, MC_MC_CCTL0);
-
-	/* mode_enter(DRUN_M) */
-	writel(MC_ME_MCTL_RUN0 | MC_ME_MCTL_KEY, MC_ME_MCTL);
-	writel(MC_ME_MCTL_RUN0 | MC_ME_MCTL_INVERTEDKEY, MC_ME_MCTL)
-		;
-
-	printf("Wait while mode entry is in progress ...\n");
-
-	/* wait while mode entry is in process */
-	while ((readl(MC_ME_GS) & MC_ME_GS_S_MTRANS) != 0x00000000)
-		;
-
-	printf("Wait for the run mode to be entered ...\n");
-
-	/* check if the mode has been entered */
-	while ((readl(MC_ME_GS) & MC_ME_GS_S_CRT_MODE_DRUN) != 0x00000000)
-		;
-
-	printf("M4 started.\n");
-
-	return CMD_RET_SUCCESS;
-}
-
-U_BOOT_CMD(startm4,	2,	1,	do_start_m4,
-	   "start M4 core from SRAM address",
-	   "startAddress"
-	   );
-
-#ifdef CONFIG_ARCH_MISC_INIT
-int arch_misc_init(void)
-{
-#ifdef CONFIG_FSL_CSE3
-	int ret;
-	ret = cse_init();
-	if (ret && ret != -ENODEV)
-		printf("Failed to initialize CSE3 security engine\n");
-#endif
-	return 0;
-}
-#endif
-
-#ifdef CONFIG_FSL_DSPI
-int mmap_dspi(unsigned short bus, struct dspi **base_addr)
-{
-	unsigned long addr;
-
-	switch (bus) {
-	case 0:
-		addr = SPI0_BASE_ADDR;
-		break;
-	case 1:
-		addr = SPI1_BASE_ADDR;
-		break;
-	case 2:
-		addr = SPI2_BASE_ADDR;
-		break;
-	case 3:
-		addr = SPI3_BASE_ADDR;
-		break;
-	default:
-		return -ENODEV;
-	}
-
-	*base_addr = (struct dspi *)addr;
-	return 0;
-}
-#endif
-
-u32 cpu_pos_mask(void)
-{
-	/* 4 cores */
-	return 0xFU;
-}
-
-u32 cpu_pos_mask_cluster0(void)
-{
-	return BIT(0) | BIT(1);
-}
-
-u32 cpu_pos_mask_cluster1(void)
-{
-	return BIT(2) | BIT(3);
-}
-
-u32 get_sram_size(void)
-{
-	return S32_SRAM_SIZE;
-}
-
-u64 fdt_to_cpu_id(u64 fdt_id)
-{
-	return (fdt_id & 0x3u) | (fdt_id >> 0x7u);
-}
diff --git a/arch/arm/cpu/armv8/s32/s32v234/sram.S b/arch/arm/cpu/armv8/s32/s32v234/sram.S
deleted file mode 100644
index 7ecc679721..0000000000
--- a/arch/arm/cpu/armv8/s32/s32v234/sram.S
+++ /dev/null
@@ -1,108 +0,0 @@
-/* SPDX-License-Identifier:     GPL-2.0+ */
-/*
- * Copyright 2020 NXP
- */
-
-/* Allow inclusion assembly macros */
-#define __INCLUDE_ASSEMBLY_MACROS__
-
-#include <config.h>
-#include <linux/linkage.h>
-
-/*************************************************************************
- *
- * void sram_clr(start, size);
- *
- * Clear a memory region of size 'size' starting with address 'start'
- * (using DMA)
- *
- *************************************************************************/
-
-ENTRY(sram_clr)
-	/*
-	 * x0: start address of memory to clear
-	 * x1: size of memory area to clear
-	 * x0: return 0 on error or size of memory cleared on success
-	 */
-
-	/* DMA_TCDn_SADDR */
-	ldr x9, =DMA_TCD_N_SADDR(DMA_CHANNEL_1)
-	ldr x10, =initvar
-	/* Point DMA source address to initialization data block */
-	str w10, [x9]
-
-	/* DMA_TCDn_SOFF */
-	/* DMA_TCDn_ATTR */
-	ldr x9, =DMA_TCD_N_SOFF(DMA_CHANNEL_1)
-	/* no offset reread same source address each interation */
-	/* 32 byte burst */
-	ldr x10, =0x05050000
-	str w10, [x9]
-
-	/* DMA_TCDn_NBYTES_MLNO */
-	ldr x9, =DMA_TCD_N_NBYTES_MLNO(DMA_CHANNEL_1)
-	/* load the size */
-	mov x10, x1
-	str x10, [x9]
-
-	/* DMA_TCDn_DADDR */
-	ldr x9, =DMA_TCD_N_DADDR(DMA_CHANNEL_1)
-	/* load the start address */
-	mov x10, x0
-	str x10, [x9]
-
-	/* DMA_TCDn_DOFF          */
-	/* DMA_TCDn_CITER_ELINKNO */
-	ldr x9, =DMA_TCD_N_DOFF(DMA_CHANNEL_1)
-	/* Increment destination address by 0x20 each interation */
-	/* ELINKNO CITER = 0X0001 single service request */
-	ldr w10, =0x00010020
-	str w10, [x9]
-
-	/* DMA_TCDn_BITER_ELINKNO */
-	/* ELINKNO BITER = 0X0001 single service request */
-	ldr x9, =DMA_TCD_N_BITER_ELINKNO(DMA_CHANNEL_1)
-	ldr w10, =0x1
-	strb w10, [x9]
-
-	/* Start transfer */
-	/* DMA_TCDn_CSR */
-	ldr x9, =DMA_TCD_N_CSR(DMA_CHANNEL_1)
-	ldr w10, =0x1
-	strb w10, [x9]
-
-	/* loop until write is done */
-ctrl_status:
-	/* DMA_ES */
-	ldr x9, =DMA_ES
-	ldr w10, [x9]
-	ldr x11, =0x80000000
-	/* Check error bit */
-	and w10, w10, #0x80000000
-	sub w10, w10, w11
-	cbz w10, ret_error
-	/* Check transfer done */
-	check_done_bit
-	cbnz w10, ctrl_status
-	/* clear DONE bit */
-	clear_done_bit
-	/* return bytes written */
-	mov x0, x1
-
-	ret
-
-ret_error:
-	/* error return zero bytes written */
-	ldr x0, =0x0
-	clear_channel_err
-	ret
-
-ENDPROC(sram_clr)
-
-	.data
-initvar:
-	.quad 0x0
-	.quad 0x0
-	.quad 0x0
-	.quad 0x0
-
diff --git a/arch/arm/include/asm/arch-s32/clock.h b/arch/arm/include/asm/arch-s32/clock.h
index 90eca939a9..023f6f5bc6 100644
--- a/arch/arm/include/asm/arch-s32/clock.h
+++ b/arch/arm/include/asm/arch-s32/clock.h
@@ -1,7 +1,7 @@
 /* SPDX-License-Identifier: GPL-2.0+ */
 /*
  * (C) Copyright 2015-2016 Freescale Semiconductor, Inc.
- * (C) Copyright 2017-2018, 2020 NXP
+ * (C) Copyright 2017-2018, 2020-2021 NXP
  *
  */
 
@@ -12,47 +12,14 @@
 #include <common.h>
 #endif
 
-#if defined(CONFIG_S32V234)
 enum mxc_clock {
-	MXC_ARM_CLK = 0,
-	MXC_BUS_CLK,
-	MXC_PERIPHERALS_CLK,
 	MXC_UART_CLK,
-	MXC_USDHC_CLK,
 	MXC_ESDHC_CLK,
-	MXC_FEC_CLK,
 	MXC_I2C_CLK,
-	MXC_SYS3_CLK,
-	MXC_SYS6_CLK,
-	MXC_QSPI_CLK,
-	MXC_DCU_PIX_CLK,
 	MXC_DSPI_CLK,
-	MXC_XBAR_CLK,
-	MXC_DDR_CLK,
 };
 
-enum pll_type {
-	ARM_PLL = 0,
-	PERIPH_PLL,
-	ENET_PLL,
-	DDR_PLL,
-	VIDEO_PLL,
-};
-#endif
-
-#ifdef CONFIG_S32_GEN1
-enum mxc_clock {
-	MXC_UART_CLK,
-	MXC_ESDHC_CLK,
-	MXC_I2C_CLK,
-	MXC_DSPI_CLK,
-};
-#endif
-
 #ifdef __KERNEL__
-#if defined(CONFIG_S32V234)
-void clock_init(void);
-#endif
 
 unsigned int mxc_get_clock(enum mxc_clock clk);
 void entry_to_target_mode( u32 mode );
diff --git a/arch/arm/include/asm/arch-s32/cpu.h b/arch/arm/include/asm/arch-s32/cpu.h
index c028c63a28..4086e4b455 100644
--- a/arch/arm/include/asm/arch-s32/cpu.h
+++ b/arch/arm/include/asm/arch-s32/cpu.h
@@ -16,11 +16,7 @@
 
 #define CONFIG_SYS_FSL_PERIPH_BASE      0x40000000
 
-#if defined(CONFIG_S32V234)
-#define CONFIG_SYS_FSL_PERIPH_SIZE      0x40000000
-#elif defined(CONFIG_S32_GEN1)
 #define CONFIG_SYS_FSL_PERIPH_SIZE      0x20000000
-#endif
 
 #ifdef CONFIG_PCIE_S32GEN1
 /* TODO: These should go to defconfig, or even better,
diff --git a/arch/arm/include/asm/arch-s32/ddr.h b/arch/arm/include/asm/arch-s32/ddr.h
deleted file mode 100644
index ebbef6ff14..0000000000
--- a/arch/arm/include/asm/arch-s32/ddr.h
+++ /dev/null
@@ -1,159 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0+ */
-/*
- * (C) Copyright 2015-2016 Freescale Semiconductor, Inc.
- * Copyright 2020 NXP
- */
-
-#ifndef __ARCH_ARM_MACH_S32V234_DDR_H__
-#define __ARCH_ARM_MACH_S32V234_DDR_H__
-
-#define DDR0	0
-#define DDR1	1
-
-/* DDR offset in MSCR register */
-#define _DDR0_RESET	168
-#define _DDR0_CLK0	169
-#define _DDR0_CAS	170
-#define _DDR0_RAS	171
-#define _DDR0_WE_B	172
-#define _DDR0_CKE0	173
-#define _DDR0_CKE1	174
-#define _DDR0_CS_B0	175
-#define _DDR0_CS_B1	176
-#define _DDR0_BA0	177
-#define _DDR0_BA1	178
-#define _DDR0_BA2	179
-#define _DDR0_A0	180
-#define _DDR0_A1	181
-#define _DDR0_A2	182
-#define _DDR0_A3	183
-#define _DDR0_A4	184
-#define _DDR0_A5	185
-#define _DDR0_A6	186
-#define _DDR0_A7	187
-#define _DDR0_A8	188
-#define _DDR0_A9	189
-#define _DDR0_A10	190
-#define _DDR0_A11	191
-#define _DDR0_A12	192
-#define _DDR0_A13	193
-#define _DDR0_A14	194
-#define _DDR0_A15	195
-#define _DDR0_DM0	196
-#define _DDR0_DM1	197
-#define _DDR0_DM2	198
-#define _DDR0_DM3	199
-#define _DDR0_DQS0	200
-#define _DDR0_DQS1	201
-#define _DDR0_DQS2	202
-#define _DDR0_DQS3	203
-#define _DDR0_D0	204
-#define _DDR0_D1	205
-#define _DDR0_D2	206
-#define _DDR0_D3	207
-#define _DDR0_D4	208
-#define _DDR0_D5	209
-#define _DDR0_D6	210
-#define _DDR0_D7	211
-#define _DDR0_D8	212
-#define _DDR0_D9	213
-#define _DDR0_D10	214
-#define _DDR0_D11	215
-#define _DDR0_D12	216
-#define _DDR0_D13	217
-#define _DDR0_D14	218
-#define _DDR0_D15	219
-#define _DDR0_D16	220
-#define _DDR0_D17	221
-#define _DDR0_D18	222
-#define _DDR0_D19	223
-#define _DDR0_D20	224
-#define _DDR0_D21	225
-#define _DDR0_D22	226
-#define _DDR0_D23	227
-#define _DDR0_D24	228
-#define _DDR0_D25	229
-#define _DDR0_D26	230
-#define _DDR0_D27	231
-#define _DDR0_D28	232
-#define _DDR0_D29	233
-#define _DDR0_D30	234
-#define _DDR0_D31	235
-#define _DDR0_ODT0	236
-#define _DDR0_ODT1	237
-#define _DDR0_ZQ	238
-#define _DDR1_RESET	239
-#define _DDR1_CLK0	240
-#define _DDR1_CAS	241
-#define _DDR1_RAS	242
-#define _DDR1_WE_B	243
-#define _DDR1_CKE0	244
-#define _DDR1_CKE1	245
-#define _DDR1_CS_B0	246
-#define _DDR1_CS_B1	247
-#define _DDR1_BA0	248
-#define _DDR1_BA1	249
-#define _DDR1_BA2	250
-#define _DDR1_A0	251
-#define _DDR1_A1	252
-#define _DDR1_A2	253
-#define _DDR1_A3	254
-#define _DDR1_A4	255
-#define _DDR1_A5	256
-#define _DDR1_A6	257
-#define _DDR1_A7	258
-#define _DDR1_A8	259
-#define _DDR1_A9	260
-#define _DDR1_A10	261
-#define _DDR1_A11	262
-#define _DDR1_A12	263
-#define _DDR1_A13	264
-#define _DDR1_A14	265
-#define _DDR1_A15	266
-#define _DDR1_DM0	267
-#define _DDR1_DM1	268
-#define _DDR1_DM2	269
-#define _DDR1_DM3	270
-#define _DDR1_DQS0	271
-#define _DDR1_DQS1	272
-#define _DDR1_DQS2	273
-#define _DDR1_DQS3	274
-#define _DDR1_D0	275
-#define _DDR1_D1	276
-#define _DDR1_D2	277
-#define _DDR1_D3	278
-#define _DDR1_D4	279
-#define _DDR1_D5	280
-#define _DDR1_D6	281
-#define _DDR1_D7	282
-#define _DDR1_D8	283
-#define _DDR1_D9	284
-#define _DDR1_D10	285
-#define _DDR1_D11	286
-#define _DDR1_D12	287
-#define _DDR1_D13	288
-#define _DDR1_D14	289
-#define _DDR1_D15	290
-#define _DDR1_D16	291
-#define _DDR1_D17	292
-#define _DDR1_D18	293
-#define _DDR1_D19	294
-#define _DDR1_D20	295
-#define _DDR1_D21	296
-#define _DDR1_D22	297
-#define _DDR1_D23	298
-#define _DDR1_D24	299
-#define _DDR1_D25	300
-#define _DDR1_D26	301
-#define _DDR1_D27	302
-#define _DDR1_D28	303
-#define _DDR1_D29	304
-#define _DDR1_D30	305
-#define _DDR1_D31	306
-#define _DDR1_ODT0	307
-#define _DDR1_ODT1	308
-#define _DDR1_ZQ	309
-
-
-#endif
-
diff --git a/arch/arm/include/asm/arch-s32/ddr3.h b/arch/arm/include/asm/arch-s32/ddr3.h
deleted file mode 100644
index 311de7dc8d..0000000000
--- a/arch/arm/include/asm/arch-s32/ddr3.h
+++ /dev/null
@@ -1,184 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0+ */
-/*
- * (C) Copyright 2015-2016 Freescale Semiconductor, Inc.
- * (C) Copyright 2016-2017,2020 NXP
- *
- */
-
-#ifndef __ARCH_ARM_MACH_S32_DDR3_H__
-#define __ARCH_ARM_MACH_S32_DDR3_H__
-
-/* definitions for DDR3 PAD values */
-
-#define DDR3_RESET_PAD	\
-	(SIUL2_MSCR_DDR_SEL_DDR3 | SIUL2_MSCR_DDR_INPUT_DIFF_DDR | \
-	SIUL2_MSCR_DSE_34ohm |	\
-	 SIUL2_MSCR_DDR_ODT_60ohm | SIUL2_MSCR_PUS_100K_UP)
-#define DDR3_CLK0_PAD	\
-	(SIUL2_MSCR_DDR_SEL_DDR3 | SIUL2_MSCR_DSE_34ohm | \
-	SIUL2_MSCR_CRPOINT_TRIM_1 | \
-	 SIUL2_MSCR_DCYCLE_TRIM_NONE | SIUL2_MSCR_DDR_INPUT_DIFF_DDR | \
-	SIUL2_MSCR_DDR_ODT_120ohm | \
-	SIUL2_MSCR_PUS_100K_UP)
-#define DDR3_CAS_PAD		\
-	(SIUL2_MSCR_DDR_SEL_DDR3 | SIUL2_MSCR_DSE_34ohm | \
-	SIUL2_MSCR_DDR_ODT_60ohm | \
-	 SIUL2_MSCR_DDR_INPUT_DIFF_DDR | SIUL2_MSCR_PUS_100K_UP)
-#define DDR3_RAS_PAD		\
-	(SIUL2_MSCR_DDR_SEL_DDR3 | SIUL2_MSCR_DSE_34ohm | \
-	SIUL2_MSCR_DDR_ODT_60ohm | \
-	 SIUL2_MSCR_DDR_INPUT_DIFF_DDR | SIUL2_MSCR_PUS_100K_UP)
-#define DDR3_WE_B_PAD	\
-	(SIUL2_MSCR_DDR_SEL_DDR3 | SIUL2_MSCR_DSE_34ohm | \
-	SIUL2_MSCR_DDR_ODT_60ohm | \
-	 SIUL2_MSCR_DDR_INPUT_DIFF_DDR | SIUL2_MSCR_PUS_100K_UP)
-#define DDR3_CKEn_PAD	\
-	(SIUL2_MSCR_DDR_SEL_DDR3 | SIUL2_MSCR_DSE_34ohm | \
-	SIUL2_MSCR_DDR_ODT_60ohm | \
-	 SIUL2_MSCR_DDR_INPUT_DIFF_DDR | SIUL2_MSCR_PUS_100K_UP)
-#define DDR3_CS_Bn_PAD	\
-	(SIUL2_MSCR_DDR_SEL_DDR3 | SIUL2_MSCR_DSE_34ohm | \
-	SIUL2_MSCR_DDR_ODT_60ohm | \
-	 SIUL2_MSCR_DDR_INPUT_DIFF_DDR | SIUL2_MSCR_PUS_100K_UP)
-#define DDR3_BAn_PAD	\
-	(SIUL2_MSCR_DDR_SEL_DDR3 | SIUL2_MSCR_DSE_34ohm | \
-	SIUL2_MSCR_DDR_DO_TRIM_50PS | \
-	 SIUL2_MSCR_DCYCLE_TRIM_LEFT | SIUL2_MSCR_DDR_ODT_60ohm | \
-	SIUL2_MSCR_DDR_INPUT_DIFF_DDR |	\
-	SIUL2_MSCR_PUS_100K_UP)
-#define DDR3_DMn_PAD	\
-	(SIUL2_MSCR_DDR_SEL_DDR3 | SIUL2_MSCR_DSE_34ohm | \
-	SIUL2_MSCR_DDR_ODT_60ohm | \
-	SIUL2_MSCR_DDR_INPUT_DIFF_DDR | SIUL2_MSCR_PUS_100K_UP)
-#define DDR3_DQSn_PAD	\
-	(SIUL2_MSCR_DDR_SEL_DDR3 | SIUL2_MSCR_DSE_34ohm | \
-	SIUL2_MSCR_CRPOINT_TRIM_1 | \
-	 SIUL2_MSCR_DCYCLE_TRIM_NONE | SIUL2_MSCR_DDR_ODT_120ohm | \
-	SIUL2_MSCR_DDR_INPUT_DIFF_DDR |	\
-	 SIUL2_MSCR_PUS_100K_UP)
-#define DDR3_ODTn_PAD	\
-	(SIUL2_MSCR_DDR_SEL_DDR3 | SIUL2_MSCR_DSE_34ohm | \
-	SIUL2_MSCR_DDR_DO_TRIM_50PS | \
-	 SIUL2_MSCR_DCYCLE_TRIM_LEFT | SIUL2_MSCR_DDR_INPUT_DIFF_DDR | \
-	SIUL2_MSCR_PUS_100K_UP | \
-	 SIUL2_MSCR_DDR_ODT_120ohm)
-#define DDR3_An_PAD	\
-	(SIUL2_MSCR_DDR_SEL_DDR3 | SIUL2_MSCR_DSE_34ohm | \
-	SIUL2_MSCR_DDR_DO_TRIM_50PS | \
-	 SIUL2_MSCR_DCYCLE_TRIM_LEFT | SIUL2_MSCR_DDR_ODT_60ohm | \
-	SIUL2_MSCR_DDR_INPUT_DIFF_DDR |	\
-	SIUL2_MSCR_PUS_100K_UP)
-#define DDR3_Dn_PAD	\
-	(SIUL2_MSCR_DDR_SEL_DDR3 | SIUL2_MSCR_DSE_34ohm | \
-	SIUL2_MSCR_DDR_DO_TRIM_50PS | \
-	 SIUL2_MSCR_DCYCLE_TRIM_LEFT | SIUL2_MSCR_DDR_ODT_60ohm | \
-	SIUL2_MSCR_DDR_INPUT_DIFF_DDR |	\
-	SIUL2_MSCR_PUS_100K_UP)
-
-/* values of MMDC registers */
-
-#define _MDCTL 0x04190000
-
-/* Set MDSCR[CON_REQ] (configuration request) */
-#define MMDC_MDSCR_CFG_VALUE	0x00008000
-/* tRFC=139 (260ns),tXS=144 (tRFC+10ns),tXP=4 (6ns),tXPDLL=13 (24ns),
- * tFAW=19(35ns),tCL=7
- */
-#define MMDC_MDCFG0_VALUE	0x8A8F7924
-/* tRCD=8 (13.75ns),tRP=6 (13,75ns),tRC=26 (48.75ns),tRAS=19 (35ns),
- * tRPA=1,tWR=8 (15ns),tMRD=4,tCWL=6
- */
-#define MMDC_MDCFG1_VALUE	0xFF328E64
-/* tDLLK=512,tRTP=4,tWTR=4,tRRD=4 */
-#define MMDC_MDCFG2_VALUE	0x01FF00DB
-/* tAOFPD=3,tAONPD=3,tANPD=5 (tCWL-1),tAXPD=5 (tCWL-1),tODTLon=4 (WL-2),
- * tODT_idle_off=7
- */
-#define MMDC_MDOTC_VALUE	0x09444070
-/* WALAT=0, BI bank interleave on, MIF3=3, RALAT=1, 8 banks, DDR3 */
-#define MMDC_MDMISC_VALUE	0x00001640
-/* tXPR=144 (tRFC+10ns), SDE_to_RST=14, RST_to_CKE=33 */
-#define MMDC_MDOR_VALUE		0x008F1023
-
-/* P_form ZQ calibration */
-#define MMDC_MPZQHWCTRL_VALUE	0xA1390003	/* Force h/w calibration */
-
-/* Complete the initialization sequence as defined by JEDEC */
-/* Configure MR2: CWL=6, self-refresh=off, self-refresh temp=normal */
-#define MMDC_MDSCR_MR2_VALUE	0x00088032
-/* Configure MR3: normal operation */
-#define MMDC_MDSCR_MR3_VALUE	0x00008033
-/* Configure MR1: enable DLL, drive strength=34R, AL off, ODT=60R,
- * write levelling off, TDQS=0, Qoff=on
- */
-#define MMDC_MDSCR_MR1_VALUE	0x00068031
-/* Configure MR0: BL=8, CL=7, DLL reset, write recovery=4, precharge PD off */
-#define MMDC_MDSCR_MR0_VALUE	0x09308030
-#define MMDC_MDSCR_ZQ_VALUE		0x04008040  /* DDR ZQ calibration */
-
-/* Set the amount of DRAM */
-/* Set DQS settings based on board type */
-#if defined(CONFIG_S32V234EVB_29288) || defined(CONFIG_S32V234BBMINI_29406)
-/* 1 GB memory */
-#define MMDC_MDASP_MODULE0_VALUE	0x0000007F
-/* Read delay line offset */
-#define MMDC_MPRDDLCTL_MODULE0_VALUE	0x44434442
-/* Write delay line offset */
-#define MMDC_MPWRDLCTL_MODULE0_VALUE	0x42434041
-/* Read DQS gating control 0 */
-#define MMDC_MPDGCTRL0_MODULE0_VALUE	0x41470138
-/* Read DQS gating control 1 */
-#define MMDC_MPDGCTRL1_MODULE0_VALUE	0x012E0135
-
-/* 1 GB memory */
-#define MMDC_MDASP_MODULE1_VALUE	0x0000007F
-/* Read delay line offset */
-#define MMDC_MPRDDLCTL_MODULE1_VALUE	0x44434442
-/* write delay line offset */
-#define MMDC_MPWRDLCTL_MODULE1_VALUE	0x3F3F4242
-/* Read DQS gating control 0 */
-#define MMDC_MPDGCTRL0_MODULE1_VALUE	0x414B0138
-/* Read DQS gating control 1 */
-#define MMDC_MPDGCTRL1_MODULE1_VALUE	0x01320142
-#else
-/* 1 GB memory */
-#define MMDC_MDASP_MODULE0_VALUE	0x0000007F
-/* Read delay line offset */
-#define MMDC_MPRDDLCTL_MODULE0_VALUE	0x46464644
-/* Write delay line offset */
-#define MMDC_MPWRDLCTL_MODULE0_VALUE	0x3B333837
-/* Read DQS gating control 0 */
-#define MMDC_MPDGCTRL0_MODULE0_VALUE	0x4177016C
-/* Read DQS gating control 1 */
-#define MMDC_MPDGCTRL1_MODULE0_VALUE	0x013A0141
-
-/* 1 GB memory */
-#define MMDC_MDASP_MODULE1_VALUE	0x0000007F
-/* Read delay line offset */
-#define MMDC_MPRDDLCTL_MODULE1_VALUE	0x45474645
-/* write delay line offset */
-#define MMDC_MPWRDLCTL_MODULE1_VALUE	0x3E333836
-/* Read DQS gating control 0 */
-#define MMDC_MPDGCTRL0_MODULE1_VALUE	0x417A0169
-/* Read DQS gating control 1 */
-#define MMDC_MPDGCTRL1_MODULE1_VALUE	0x0137013F
-#endif
-
-/* Read/write command delay - default */
-#define MMDC_MDRWD_VALUE		0x000026D2
-/* Power down control */
-#define MMDC_MDPDC_VALUE		0x00020036
-/* Refresh control, 1 refresh each 3.9us */
-#define MMDC_MDREF_VALUE		0x08208000
-/* 60R nominal */
-#define MMDC_MPODTCTRL_VALUE		0x0002222F
-/* Deassert the configuration request */
-#define MMDC_MDSCR_RESET_VALUE		0x00000000
-/* DVFS and LPMD request */
-#define MMDC_MAPSR_EN_SLF_REF		0x00300000
-
-/* set I/O pads for DDR */
-void ddr_config_iomux(uint8_t module);
-void config_mmdc(uint8_t module);
-
-#endif
diff --git a/arch/arm/include/asm/arch-s32/imx-regs.h b/arch/arm/include/asm/arch-s32/imx-regs.h
index 6edb74cf7a..d4ea7c3c2f 100644
--- a/arch/arm/include/asm/arch-s32/imx-regs.h
+++ b/arch/arm/include/asm/arch-s32/imx-regs.h
@@ -1,7 +1,7 @@
 /* SPDX-License-Identifier:     GPL-2.0+ */
 /*
  * (C) Copyright 2013-2016 Freescale Semiconductor, Inc.
- * Copyright 2017-2020 NXP
+ * Copyright 2017-2021 NXP
  */
 
 #ifndef __ASM_ARCH_IMX_REGS_H__
@@ -10,15 +10,7 @@
 
 #define ARCH_MXC
 
-#if defined(CONFIG_S32V234)
-#include "s32v234/s32v234-regs.h"
-#elif defined(CONFIG_S32_GEN1)
 #include "s32-gen1/s32-gen1-regs.h"
-#else
-#error "Incomplete platform definition"
-#endif
-
-#define CCI400_BASE_ADDR			(0x7E090000)
 
 /* TODO Remove this after the IOMUX framework is implemented */
 #define IOMUXC_BASE_ADDR SIUL2_BASE_ADDR
@@ -26,56 +18,11 @@
 /* MUX mode and PAD ctrl are in one register */
 #define CONFIG_IOMUX_SHARE_CONF_REG
 
-#define FEC_QUIRK_ENET_MAC
 #define I2C_QUIRK_REG
 
 #if !(defined(__KERNEL_STRICT_NAMES) || defined(__ASSEMBLY__))
 #include <asm/types.h>
 
-/* Periodic Interrupt Timer (PIT) */
-struct pit_reg {
-	u32 mcr;
-	u32 recv0[55];
-	u32 ltmr64h;
-	u32 ltmr64l;
-	u32 recv1[6];
-	u32 ldval0;
-	u32 cval0;
-	u32 tctrl0;
-	u32 tflg0;
-	u32 ldval1;
-	u32 cval1;
-	u32 tctrl1;
-	u32 tflg1;
-	u32 ldval2;
-	u32 cval2;
-	u32 tctrl2;
-	u32 tflg2;
-	u32 ldval3;
-	u32 cval3;
-	u32 tctrl3;
-	u32 tflg3;
-	u32 ldval4;
-	u32 cval4;
-	u32 tctrl4;
-	u32 tflg4;
-	u32 ldval5;
-	u32 cval5;
-	u32 tctrl5;
-	u32 tflg5;
-};
-
-/* Watchdog Timer (WDOG) */
-struct wdog_regs {
-	u32 cr;
-	u32 ir;
-	u32 to;
-	u32 wn;
-	u32 sr;
-	u32 co;
-	u32 sk;
-};
-
 /* UART */
 struct linflex_fsl {
 	u32 lincr1;
@@ -94,31 +41,7 @@ struct linflex_fsl {
 	u32 bidr;
 	u32 bdrl;
 	u32 bdrm;
-#if !defined(CONFIG_S32_GEN1)
-	u32 ifer;
-	u32 ifmi;
-	u32 ifmr;
-#ifdef CONFIG_LINFLEX_MASTER_SLAVE_MODE
-	u32 ifcr0;
-	u32 ifcr1;
-	u32 ifcr2;
-	u32 ifcr3;
-	u32 ifcr4;
-	u32 ifcr5;
-	u32 ifcr6;
-	u32 ifcr7;
-	u32 ifcr8;
-	u32 ifcr9;
-	u32 ifcr10;
-	u32 ifcr11;
-	u32 ifcr12;
-	u32 ifcr13;
-	u32 ifcr14;
-	u32 ifcr15;
-#endif
-#else
 	u32 reserved[3];
-#endif
 	u32 gcr;
 	u32 uartpto;
 	u32 uartcto;
@@ -126,51 +49,6 @@ struct linflex_fsl {
 	u32 dmarxe;
 };
 
-#define CCI400_CTRLORD_TERM_BARRIER	0x00000008
-#define CCI400_CTRLORD_EN_BARRIER	0
-#define CCI400_SHAORD_NON_SHAREABLE	0x00000002
-#define CCI400_DVM_MESSAGE_REQ_EN	0x00000002
-#define CCI400_SNOOP_REQ_EN		0x00000001
-struct ccsr_cci400 {
-	u32 ctrl_ord;			/* Control Override */
-	u32 spec_ctrl;			/* Speculation Control */
-	u32 secure_access;		/* Secure Access */
-	u32 status;			/* Status */
-	u32 impr_err;			/* Imprecise Error */
-	u8 res_14[0x100 - 0x14];
-	u32 pmcr;			/* Performance Monitor Control */
-	u8 res_104[0xfd0 - 0x104];
-	u32 pid[8];			/* Peripheral ID */
-	u32 cid[4];			/* Component ID */
-	struct {
-		u32 snoop_ctrl;		/* Snoop Control */
-		u32 sha_ord;		/* Shareable Override */
-		u8 res_1008[0x1100 - 0x1008];
-		u32 rc_qos_ord;		/* read channel QoS Value Override */
-		u32 wc_qos_ord;		/* read channel QoS Value Override */
-		u8 res_1108[0x110c - 0x1108];
-		u32 qos_ctrl;		/* QoS Control */
-		u32 max_ot;		/* Max OT */
-		u8 res_1114[0x1130 - 0x1114];
-		u32 target_lat;		/* Target Latency */
-		u32 latency_regu;	/* Latency Regulation */
-		u32 qos_range;		/* QoS Range */
-		u8 res_113c[0x2000 - 0x113c];
-	} slave[5];			/* Slave Interface */
-	u8 res_6000[0x9004 - 0x6000];
-	u32 cycle_counter;		/* Cycle counter */
-	u32 count_ctrl;			/* Count Control */
-	u32 overflow_status;		/* Overflow Flag Status */
-	u8 res_9010[0xa000 - 0x9010];
-	struct {
-		u32 event_select;	/* Event Select */
-		u32 event_count;	/* Event Count */
-		u32 counter_ctrl;	/* Counter Control */
-		u32 overflow_status;	/* Overflow Flag Status */
-		u8 res_a010[0xb000 - 0xa010];
-	} pcounter[4];			/* Performance Counter */
-	u8 res_e004[0x10000 - 0xe004];
-};
 #endif	/* __ASSEMBLER__*/
 
 #endif	/* __ASM_ARCH_IMX_REGS_H__ */
diff --git a/arch/arm/include/asm/arch-s32/lpddr2.h b/arch/arm/include/asm/arch-s32/lpddr2.h
deleted file mode 100644
index d3e6d0f034..0000000000
--- a/arch/arm/include/asm/arch-s32/lpddr2.h
+++ /dev/null
@@ -1,106 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0+ */
-/*
- * Copyright 2015-2016 Freescale Semiconductor, Inc.
- * Copyright 2017, 2020-2021 NXP
- */
-
-#ifndef __ARCH_ARM_MACH_S32_LPDDR2_H__
-#define __ARCH_ARM_MACH_S32_LPDDR2_H__
-
-/* definitions for LPDDR2 PAD values */
-#define LPDDR2_CLK0_PAD	\
-	(SIUL2_MSCR_DDR_SEL_LPDDR2 | SIUL2_MSCR_DDR_INPUT_DIFF_DDR | SIUL2_MSCR_DDR_ODT_120ohm |\
-	 SIUL2_MSCR_DSE_48ohm | SIUL2_MSCR_PUS_100K_UP | SIUL2_MSCR_CRPOINT_TRIM_1 |			\
-	 SIUL2_MSCR_DCYCLE_TRIM_NONE)
-#define LPDDR2_CKEn_PAD	\
-	(SIUL2_MSCR_DDR_SEL_LPDDR2 | SIUL2_MSCR_DDR_INPUT_DIFF_DDR | SIUL2_MSCR_DDR_ODT_120ohm |\
-	 SIUL2_MSCR_PUS_100K_UP | SIUL2_MSCR_DSE_48ohm)
-#define LPDDR2_CS_Bn_PAD	\
-	(SIUL2_MSCR_DDR_SEL_LPDDR2 | SIUL2_MSCR_DDR_INPUT_DIFF_DDR | SIUL2_MSCR_DDR_ODT_120ohm |\
-	 SIUL2_MSCR_PUS_100K_UP | SIUL2_MSCR_DSE_48ohm)
-#define LPDDR2_DMn_PAD	\
-	(SIUL2_MSCR_DDR_SEL_LPDDR2 | SIUL2_MSCR_DDR_INPUT_DIFF_DDR | SIUL2_MSCR_DDR_ODT_120ohm |\
-	 SIUL2_MSCR_PUS_100K_UP | SIUL2_MSCR_DSE_48ohm)
-#define LPDDR2_DQSn_PAD	\
-	(SIUL2_MSCR_DDR_SEL_LPDDR2 | SIUL2_MSCR_DDR_INPUT_DIFF_DDR | SIUL2_MSCR_DDR_ODT_120ohm |	\
-	 SIUL2_MSCR_DSE_48ohm | SIUL2_MSCR_PUE_EN | SIUL2_MSCR_PUS_100K_DOWN |						\
-	 SIUL2_MSCR_PKE_EN | SIUL2_MSCR_CRPOINT_TRIM_1 | SIUL2_MSCR_DCYCLE_TRIM_NONE)
-#define LPDDR2_An_PAD	\
-	(SIUL2_MSCR_DDR_SEL_LPDDR2 | SIUL2_MSCR_DDR_INPUT_DIFF_DDR | SIUL2_MSCR_DDR_ODT_120ohm |	\
-	 SIUL2_MSCR_DSE_48ohm | SIUL2_MSCR_DDR_DO_TRIM_50PS | SIUL2_MSCR_DCYCLE_TRIM_LEFT		|	\
-	 SIUL2_MSCR_PUS_100K_UP)
-#define LPDDR2_Dn_PAD	\
-	(SIUL2_MSCR_DDR_SEL_LPDDR2 | SIUL2_MSCR_DDR_INPUT_DIFF_DDR | SIUL2_MSCR_DDR_ODT_120ohm |	\
-	 SIUL2_MSCR_DSE_48ohm | SIUL2_MSCR_DDR_DO_TRIM_50PS | SIUL2_MSCR_DCYCLE_TRIM_LEFT		|	\
-	 SIUL2_MSCR_PUS_100K_UP)
-
-/* Set MDSCR[CON_REQ] (configuration request) */
-#define MMDC_MDSCR_CFG_VALUE		0x00008000
-/* Precharge-all command CS0 */
-#define MMDC_MDSCR_CS0_VALUE		0x00008010
-/* Precharge-all command CS1 */
-#define MMDC_MDSCR_CS1_VALUE		0x00008018
-/* tAOFPD=n/a,tAONPD=n/a,tANPD=n/a,tAXPD=n/a,tODTLon=n/a,tODT_idle_off=n/a */
-#define MMDC_MDOTC_VALUE		0x00000000
-/* tXPR=n/a , SDE_to_RST=n/a, RST_to_CKE=14 */
-#define MMDC_MDOR_VALUE			0x00000010
-/* Force delay line initialisation */
-#define MMDC_MPMUR0_VALUE		0x00000800
-/* Reset command CS0 */
-#define MMDC_MDSCR_RST_VALUE		0x003F8030
-/* ZQ_LP2_HW_ZQCS=0x1B (90ns spec), ZQ_LP2_HW_ZQCL=0x5F (160ns spec),
- * ZQ_LP2_HW_ZQINIT=0x109 (1us spec)
- */
-#define MMDC_MPZQLP2CTL_VALUE		0x1B5F0109
-/* ZQ_EARLY_COMPARATOR_EN_TIMER=0x14, TZQ_CS=n/a, TZQ_OPER=n/a,
- * TZQ_INIT=n/a, ZQ_HW_FOR=1, ZQ_HW_PER=0, ZQ_MODE=3
- */
-#define MMDC_MPZQHWCTRL_VALUE		0xA0010003
-/* Configure MR1: BL 4, burst type interleaved,
- * wrap control no wrap, tWR cycles 8
- */
-#define MMDC_MDSCR_MR1_VALUE		0xC2018030
-/* Configure MR10: Calibration at init */
-#define MMDC_MDSCR_MR10_VALUE		0xFF0A8030
-/* Read/write command delay - default used */
-#define MMDC_MDRWD_VALUE		0x0F9F26D2
-/* Power down control */
-#define MMDC_MDPDC_VALUE		0x00020024
-/* Refresh control */
-#define MMDC_MDREF_VALUE		0x30B01800
-/* No ODT */
-#define MMDC_MPODTCTRL_VALUE		0x00000000
-/* Deassert the configuration request */
-#define MMDC_MDSCR_DEASSERT_VALUE	0x00000000
-/* DVFS and LPMD request */
-#define MMDC_MAPSR_EN_SLF_REF		0x00300000
-
-struct lpddr2_config {
-	u32 mdasp_module0;
-	u32 mdasp_module1;
-	u32 mdcfg0;
-	u32 mdcfg1;
-	u32 mdcfg2;
-	u32 mdcfg3lp;
-	u32 mdctl;
-	u32 mdmisc;
-	u32 mdscr_mr2;
-	u32 mdscr_mr3;
-	u32 mprddlctl_module0;
-	u32 mprddlctl_module1;
-	u32 mpwrdlctl_module0;
-	u32 mpwrdlctl_module1;
-	u32 mpdgctrl0_module0;
-	u32 mpdgctrl1_module0;
-	u32 mpdgctrl0_module1;
-	u32 mpdgctrl1_module1;
-	u32 frequency;
-};
-
-const struct lpddr2_config *s32_get_lpddr2_config(void);
-
-/* set I/O pads for DDR */
-void ddr_config_iomux(uint8_t module);
-void config_mmdc(uint8_t module);
-
-#endif
diff --git a/arch/arm/include/asm/arch-s32/lpddr4.h b/arch/arm/include/asm/arch-s32/lpddr4.h
deleted file mode 100644
index 0597703bcd..0000000000
--- a/arch/arm/include/asm/arch-s32/lpddr4.h
+++ /dev/null
@@ -1,78 +0,0 @@
-/*
- * (C) Copyright 2015-2016 Freescale Semiconductor, Inc.
- * (C) Copyright 2017 NXP
- *
- * SPDX-License-Identifier:	GPL-2.0+
- */
-
-#ifndef __ARCH_ARM_MACH_S32_LPDDR4_H__
-#define __ARCH_ARM_MACH_S32_LPDDR4_H__
-
-/* definitions for LPDDR2 PAD values */
-#define LPDDR2_CLK0_PAD	\
-	(SIUL2_MSCR_DDR_SEL_LPDDR2 | SIUL2_MSCR_DDR_INPUT_DIFF_DDR | SIUL2_MSCR_DDR_ODT_120ohm |\
-	 SIUL2_MSCR_DSE_48ohm | SIUL2_MSCR_PUS_100K_UP | SIUL2_MSCR_CRPOINT_TRIM_1 |			\
-	 SIUL2_MSCR_DCYCLE_TRIM_NONE)
-#define LPDDR2_CKEn_PAD	\
-	(SIUL2_MSCR_DDR_SEL_LPDDR2 | SIUL2_MSCR_DDR_INPUT_DIFF_DDR | SIUL2_MSCR_DDR_ODT_120ohm |\
-	 SIUL2_MSCR_PUS_100K_UP | SIUL2_MSCR_DSE_48ohm)
-#define LPDDR2_CS_Bn_PAD	\
-	(SIUL2_MSCR_DDR_SEL_LPDDR2 | SIUL2_MSCR_DDR_INPUT_DIFF_DDR | SIUL2_MSCR_DDR_ODT_120ohm |\
-	 SIUL2_MSCR_PUS_100K_UP | SIUL2_MSCR_DSE_48ohm)
-#define LPDDR2_DMn_PAD	\
-	(SIUL2_MSCR_DDR_SEL_LPDDR2 | SIUL2_MSCR_DDR_INPUT_DIFF_DDR | SIUL2_MSCR_DDR_ODT_120ohm |\
-	 SIUL2_MSCR_PUS_100K_UP | SIUL2_MSCR_DSE_48ohm)
-#define LPDDR2_DQSn_PAD	\
-	(SIUL2_MSCR_DDR_SEL_LPDDR2 | SIUL2_MSCR_DDR_INPUT_DIFF_DDR | SIUL2_MSCR_DDR_ODT_120ohm |	\
-	 SIUL2_MSCR_DSE_48ohm | SIUL2_MSCR_PUE_EN | SIUL2_MSCR_PUS_100K_DOWN |						\
-	 SIUL2_MSCR_PKE_EN | SIUL2_MSCR_CRPOINT_TRIM_1 | SIUL2_MSCR_DCYCLE_TRIM_NONE)
-#define LPDDR2_An_PAD	\
-	(SIUL2_MSCR_DDR_SEL_LPDDR2 | SIUL2_MSCR_DDR_INPUT_DIFF_DDR | SIUL2_MSCR_DDR_ODT_120ohm |	\
-	 SIUL2_MSCR_DSE_48ohm | SIUL2_MSCR_DDR_DO_TRIM_50PS | SIUL2_MSCR_DCYCLE_TRIM_LEFT		|	\
-	 SIUL2_MSCR_PUS_100K_UP)
-#define LPDDR2_Dn_PAD	\
-	(SIUL2_MSCR_DDR_SEL_LPDDR2 | SIUL2_MSCR_DDR_INPUT_DIFF_DDR | SIUL2_MSCR_DDR_ODT_120ohm |	\
-	 SIUL2_MSCR_DSE_48ohm | SIUL2_MSCR_DDR_DO_TRIM_50PS | SIUL2_MSCR_DCYCLE_TRIM_LEFT		|	\
-	 SIUL2_MSCR_PUS_100K_UP)
-
-#define _MDCTL							0x03010000
-
-#define MMDC_MDSCR_CFG_VALUE		0x00008000  /* Set MDSCR[CON_REQ] (configuration request) */
-#define MMDC_MDCFG0_VALUE		0x464F61A5  /* tRFCab=70 (=130ns),tXSR=80 (=tRFCab+10ns),tXP=4 (=7.5ns),tXPDLL=n/a,tFAW=27 (50 ns),tCL(RL)=8 */
-#define MMDC_MDCFG1_VALUE		0x00180E63  /* tRCD=n/a,tRPpb=n/a,tRC=n/a ,tRAS=25 (=47ns),tRPA=n/a,tWR=8 (=15.0ns),tMRD=3,tWL=4 */
-#define MMDC_MDCFG2_VALUE		0x000000DD  /* tDLLK=n/a,tRTP=4 (=7.5ns),tWTR=4 (=7.5ns),tRRD=6 (=10ns) */
-#define MMDC_MDCFG3LP_VALUE		0x001F099B  /* RC_LP=tRAS+tRPab=32 (>60ns), tRCD_LP=10 (18ns) , tRPpb_LP=10 (18ns), tRPab_LP=12 (21ns) */
-#define MMDC_MDOTC_VALUE		0x00000000  /* tAOFPD=n/a,tAONPD=n/a,tANPD=n/a,tAXPD=n/a,tODTLon=n/a,tODT_idle_off=n/a */
-#define MMDC_MDMISC_VALUE		0x000017C8  /* WALAT=0, BI bank interleave on, LPDDR2_S2=0, MIF3=3, RALAT=5, 8 banks, LPDDR2 */
-#define MMDC_MDOR_VALUE			0x00000010  /* tXPR=n/a , SDE_to_RST=n/a, RST_to_CKE=14 */
-#define MMDC_MPMUR0_VALUE		0x00000800  /* Force delay line initialisation */
-#define MMDC_MDSCR_RST_VALUE		0x003F8030  /* Reset command CS0 */
-#define MMDC_MPZQLP2CTL_VALUE		0x1B5F0109  /* ZQ_LP2_HW_ZQCS=0x1B (90ns spec), ZQ_LP2_HW_ZQCL=0x5F (160ns spec), ZQ_LP2_HW_ZQINIT=0x109 (1us spec) */
-#define MMDC_MPZQHWCTRL_VALUE		0xA0010003  /* ZQ_EARLY_COMPARATOR_EN_TIMER=0x14, TZQ_CS=n/a, TZQ_OPER=n/a, TZQ_INIT=n/a, ZQ_HW_FOR=1, ZQ_HW_PER=0, ZQ_MODE=3 */
-#define MMDC_MDSCR_MR1_VALUE		0xC2018030  /* Configure MR1: BL 4, burst type interleaved, wrap control no wrap, tWR cycles 8 */
-#define MMDC_MDSCR_MR2_VALUE		0x06028030  /* Configure MR2: RL=8, WL=4 */
-#define MMDC_MDSCR_MR3_VALUE		0x01038030  /* Configure MR3: DS=34R */
-#define MMDC_MDSCR_MR10_VALUE		0xFF0A8030  /* Configure MR10: Calibration at init */
-#define MMDC_MDASP_MODULE0_VALUE	0x00000048  /* 2Gb, 256 MB memory so CS0 is 256 MB  (0x90000000) */
-#define MMDC_MPRDDLCTL_MODULE0_VALUE	0x4D4B4F4B  /* Read delay line offsets */
-#define MMDC_MPWRDLCTL_MODULE0_VALUE	0x38383737  /* Write delay line offsets */
-#define MMDC_MPDGCTRL0_MODULE0_VALUE	0x20000000  /* Read DQS gating control 0 (disabled) */
-#define MMDC_MPDGCTRL1_MODULE0_VALUE	0x00000000  /* Read DQS gating control 1 */
-#define MMDC_MDASP_MODULE1_VALUE	0x00000068  /* 2Gb, 256 MB memory so CS0 is 256 MB  (0xD0000000) */
-#define MMDC_MPRDDLCTL_MODULE1_VALUE	0x49484848  /* Read delay line offsets */
-#define MMDC_MPWRDLCTL_MODULE1_VALUE	0x3E403E3F  /* Write delay line offsets */
-#define MMDC_MPDGCTRL0_MODULE1_VALUE	0x20000000  /* Read DQS gating control 0 (disabled) */
-#define MMDC_MPDGCTRL1_MODULE1_VALUE	0x00000000  /* Read DQS gating control 1 */
-#define MMDC_MDRWD_VALUE		0x0F9F26D2  /* Read/write command delay - default used */
-#define MMDC_MDPDC_VALUE		0x00020024  /* Power down control */
-#define MMDC_MDREF_VALUE		0x30B01800  /* Refresh control */
-#define MMDC_MPODTCTRL_VALUE		0x00000000  /* No ODT */
-#define MMDC_MDSCR_DEASSERT_VALUE	0x00000000  /* Deassert the configuration request */
-
-#define MMDC_MAPSR_EN_SLF_REF		0x00300000  /* DVFS and LPMD request */
-
-/* set I/O pads for DDR */
-void ddr_config_iomux(uint8_t module);
-void config_mmdc(uint8_t module);
-
-#endif
diff --git a/arch/arm/include/asm/arch-s32/mc_cgm_regs.h b/arch/arm/include/asm/arch-s32/mc_cgm_regs.h
index 2246619ac4..446bcfc994 100644
--- a/arch/arm/include/asm/arch-s32/mc_cgm_regs.h
+++ b/arch/arm/include/asm/arch-s32/mc_cgm_regs.h
@@ -1,8 +1,7 @@
+/* SPDX-License-Identifier: GPL-2.0+ */
 /*
  * (C) Copyright 2015 Freescale Semiconductor, Inc.
- * (C) Copyright 2017-2018 NXP
- *
- * SPDX-License-Identifier:	GPL-2.0+
+ * (C) Copyright 2017-2018,2021 NXP
  */
 
 #ifndef __ARCH_ARM_MACH_S32_MCCGM_REGS_H__
@@ -10,10 +9,6 @@
 
 #include <config.h>
 
-#if defined(CONFIG_S32V234)
-#include "s32v234/mc_cgm_regs.h"
-#elif defined(CONFIG_S32_GEN1)
 #include "s32-gen1/mc_cgm_regs.h"
-#endif
 
 #endif /*__ARCH_ARM_MACH_S32_MCCGM_REGS_H__ */
diff --git a/arch/arm/include/asm/arch-s32/mc_me_regs.h b/arch/arm/include/asm/arch-s32/mc_me_regs.h
index ffeb6fa510..c0cef080b4 100644
--- a/arch/arm/include/asm/arch-s32/mc_me_regs.h
+++ b/arch/arm/include/asm/arch-s32/mc_me_regs.h
@@ -1,7 +1,6 @@
+/* SPDX-License-Identifier: GPL-2.0+ */
 /*
- * (C) Copyright 2017 NXP
- *
- * SPDX-License-Identifier:	GPL-2.0+
+ * (C) Copyright 2017,2021 NXP
  */
 
 #ifndef __ARCH_ARM_MACH_S32_MCME_REGS_H__
@@ -9,13 +8,7 @@
 
 #include <config.h>
 
-#if defined(CONFIG_S32V234)
-#include "s32v234/mc_me_regs.h"
-#elif defined(CONFIG_S32_GEN1)
 #include "s32-gen1/mc_me_regs.h"
-#else
-#error "Incomplete platform definition"
-#endif
 
 #endif /*__ARCH_ARM_MACH_S32_MCME_REGS_H__ */
 
diff --git a/arch/arm/include/asm/arch-s32/mc_rgm_regs.h b/arch/arm/include/asm/arch-s32/mc_rgm_regs.h
index d661c8ce8a..11c1ae3fc2 100644
--- a/arch/arm/include/asm/arch-s32/mc_rgm_regs.h
+++ b/arch/arm/include/asm/arch-s32/mc_rgm_regs.h
@@ -1,8 +1,7 @@
+/* SPDX-License-Identifier: GPL-2.0+ */
 /*
  * (C) Copyright 2015-2016 Freescale Semiconductor, Inc.
- * (C) Copyright 2016-2017 NXP
- *
- * SPDX-License-Identifier:	GPL-2.0+
+ * (C) Copyright 2016-2017,2021 NXP
  */
 
 #ifndef __ARCH_ARM_MACH_S32_MCRGM_REGS_H__
@@ -10,13 +9,7 @@
 
 #include <config.h>
 
-#if defined(CONFIG_S32V234)
-#include "s32v234/mc_rgm_regs.h"
-#elif defined(CONFIG_S32_GEN1)
 #include "s32-gen1/mc_rgm_regs.h"
-#else
-#error "Incomplete platform definition"
-#endif
 
 #endif /*__ARCH_ARM_MACH_S32_MCRGM_REGS_H__ */
 
diff --git a/arch/arm/include/asm/arch-s32/mmdc.h b/arch/arm/include/asm/arch-s32/mmdc.h
index 63167be3fe..bfaf84c8ce 100644
--- a/arch/arm/include/asm/arch-s32/mmdc.h
+++ b/arch/arm/include/asm/arch-s32/mmdc.h
@@ -1,11 +1,11 @@
 /* SPDX-License-Identifier: GPL-2.0+ */
 /*
  * (C) Copyright 2015 Freescale Semiconductor, Inc.
- * Copyright 2020 NXP
+ * Copyright 2020-2021 NXP
  */
 
-#ifndef __ARCH_ARM_MACH_S32V234_MMDC_H__
-#define __ARCH_ARM_MACH_S32V234_MMDC_H__
+#ifndef __ARCH_ARM_MACH_S32_MMDC_H__
+#define __ARCH_ARM_MACH_S32_MMDC_H__
 
 #define MMDC0				0
 #define MMDC1				1
diff --git a/arch/arm/include/asm/arch-s32/qspi_s32v234.h b/arch/arm/include/asm/arch-s32/qspi_s32v234.h
deleted file mode 100644
index 25738ab0a2..0000000000
--- a/arch/arm/include/asm/arch-s32/qspi_s32v234.h
+++ /dev/null
@@ -1,25 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0+ */
-/*
- * (C) Copyright 2016-2018,2020 NXP
- *
- */
-
-#ifndef QSPI_COMMON_H_
-#define QSPI_COMMON_H_
-
-void qspi_iomux(void);
-
-#ifdef CONFIG_S32V234_FLASH
-int do_qspinor_setup(cmd_tbl_t *cmdtp, int flag, int argc,
-		     char * const argv[]);
-#else
-int do_qspinor_setup(cmd_tbl_t *cmdtp, int flag, int argc,
-		     char * const argv[])
-{
-	printf("SD/eMMC is disabled. SPI flash is active and can be used!\n");
-	qspi_iomux();
-	return 0;
-}
-#endif
-
-#endif /* QSPI_COMMON_H_ */
diff --git a/arch/arm/include/asm/arch-s32/s32v234/dma_macros.h b/arch/arm/include/asm/arch-s32/s32v234/dma_macros.h
deleted file mode 100644
index 58a92ba8aa..0000000000
--- a/arch/arm/include/asm/arch-s32/s32v234/dma_macros.h
+++ /dev/null
@@ -1,49 +0,0 @@
-/*
- * Copyright 2018 NXP
- *
- * SPDX-License-Identifier:	GPL-2.0+
- */
-
-#ifndef __DMA_MACROS_H__
-#define __DMA_MACROS_H__
-
-/* eDMA controller */
-#define DMA_CHANNEL_1			1
-#define DMA_TCD_BASE_ADDRESS	(EDMA_BASE_ADDR + 0x1000)
-#define DMA_CHANNEL(channel)	(DMA_TCD_BASE_ADDRESS + 0x20 * (channel))
-#define DMA_CR				(EDMA_BASE_ADDR)
-#define DMA_ES				(EDMA_BASE_ADDR + 0x4)
-#define DMA_ERR				(EDMA_BASE_ADDR + 0x2C)
-#define DMA_TCD_N_SADDR(channel)	(DMA_CHANNEL(channel))
-#define DMA_TCD_N_SOFF(channel)		(DMA_CHANNEL(channel) + 0x4)
-#define DMA_TCD_N_NBYTES_MLNO(channel)	(DMA_CHANNEL(channel) + 0x8)
-#define DMA_TCD_N_DADDR(channel)	(DMA_CHANNEL(channel) + 0x10)
-#define DMA_TCD_N_DOFF(channel)		(DMA_CHANNEL(channel) + 0x14)
-#define DMA_TCD_N_CITER_ELINKNO(channel)(DMA_CHANNEL(channel) + 0x16)
-#define DMA_TCD_N_CSR(channel)		(DMA_CHANNEL(channel) + 0x1C)
-#define DMA_TCD_N_BITER_ELINKNO(channel)(DMA_CHANNEL(channel) + 0x1E)
-
-#ifdef __INCLUDE_ASSEMBLY_MACROS__
-.macro check_done_bit
-	ldr x9, =DMA_TCD_N_CSR(DMA_CHANNEL_1)
-	ldr w10, [x9]
-	/* Check transfer done */
-	and w10, w10, #0x0080
-	sub w10, w10, #0x0080
-.endm
-
-.macro clear_done_bit
-	ldr x9, =DMA_TCD_N_CSR(DMA_CHANNEL_1)
-	ldr w10, =0x0
-	strb w10, [x9]
-.endm
-
-.macro clear_channel_err
-	/* DMA_ERR */
-	ldr x9, =DMA_ERR
-	/* Clear error bit for channel */
-	ldr x10, =0x00000002
-	str w10, [x9]
-.endm
-#endif
-#endif /* __DMA_MACROS_H__ */
diff --git a/arch/arm/include/asm/arch-s32/s32v234/mc_cgm_regs.h b/arch/arm/include/asm/arch-s32/s32v234/mc_cgm_regs.h
deleted file mode 100644
index 7550f24dcb..0000000000
--- a/arch/arm/include/asm/arch-s32/s32v234/mc_cgm_regs.h
+++ /dev/null
@@ -1,369 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0+
- * (C) Copyright 2015 Freescale Semiconductor, Inc.
- * (C) Copyright 2017-2018, 2020-2021 NXP
- *
- */
-
-#ifndef __ARCH_ARM_MACH_S32V234_MCCGM_REGS_H__
-#define __ARCH_ARM_MACH_S32V234_MCCGM_REGS_H__
-
-#include <config.h>
-
-#ifndef __ASSEMBLY__
-
-/* MC_CGM registers definitions */
-/* MC_CGM_SC_SS */
-#define CGM_SC_SS(cgm_addr)		(((cgm_addr) + 0x000007E4))
-#define MC_CGM_SC_SEL_FIRC		(0x0)
-#define MC_CGM_SC_SEL_XOSC		(0x1)
-#define MC_CGM_SC_SEL_ARMPLL		(0x2)
-#define MC_CGM_SC_SEL_CLKDISABLE	(0xF)
-
-/* MC_CGM_SC_DCn */
-#define CGM_SC_DCn(cgm_addr, dc)		(((cgm_addr) + 0x000007E8) + \
-					 ((dc) * 0x4))
-#define MC_CGM_SC_DCn_PREDIV(val)	(MC_CGM_SC_DCn_PREDIV_MASK & \
-					 ((val) << MC_CGM_SC_DCn_PREDIV_OFFSET))
-#define MC_CGM_SC_DCn_PREDIV_MASK	(0x00070000)
-#define MC_CGM_SC_DCn_PREDIV_OFFSET	(16)
-#define MC_CGM_SC_DCn_DE		(1 << 31)
-#define MC_CGM_SC_SEL_MASK		(0x0F000000)
-#define MC_CGM_SC_SEL_OFFSET		(24)
-
-#define MC_CGM_SC_SEL_GET(sc_ss)	(((sc_ss) & MC_CGM_SC_SEL_MASK) >> \
-					MC_CGM_SC_SEL_OFFSET)
-#define MC_CGM_SC_DIV_GET(sc_ss)	\
-				((((sc_ss) & MC_CGM_SC_DCn_PREDIV_MASK) >> \
-				MC_CGM_SC_DCn_PREDIV_OFFSET) + 1)
-
-#define CGM_SCn_DC0	0
-#define CGM_SCn_DC1	1
-#define CGM_SCn_DC2	2
-
-/* MC_CGM_ACn_DCm */
-#define CGM_ACn_DCm(cgm_addr, ac, dc)	(((cgm_addr) + 0x00000808) + \
-					 ((ac) * 0x20) + ((dc) * 0x4))
-#define MC_CGM_ACn_DCm_PREDIV(val)	(MC_CGM_ACn_DCm_PREDIV_MASK & \
-		((val) << MC_CGM_ACn_DCm_PREDIV_OFFSET))
-
-/*
- * MC_CGM_ACn_DCm_PREDIV_MASK is on 5 bits because practical test has shown
- * that the 5th bit is always ignored during writes if the current
- * MC_CGM_ACn_DCm_PREDIV field has only 4 bits
- *
- * The manual states only selectors 1, 5 and 15 have DC0_PREDIV on 5 bits
- *
- * This should be changed if any problems occur.
- */
-#define MC_CGM_ACn_DCm_PREDIV_MASK	(0x001F0000)
-#define MC_CGM_ACn_DCm_PREDIV_OFFSET	(16)
-#define MC_CGM_ACn_DCm_DE		(1 << 31)
-
-/*
- * MC_CGM_ACn_SC/MC_CGM_ACn_SS
- */
-#define CGM_ACn_SC(cgm_addr, ac)	((cgm_addr + 0x00000800) + \
-					 ((ac) * 0x20))
-#define CGM_ACn_SS(cgm_addr, ac)	((cgm_addr + 0x00000804) + \
-					 ((ac) * 0x20))
-#define MC_CGM_ACn_SEL_MASK		(0x0F000000)
-#define MC_CGM_ACn_SEL_SET(source)	(MC_CGM_ACn_SEL_MASK & \
-		(((source) & 0xF) << MC_CGM_ACn_SEL_OFFSET))
-#define MC_CGM_ACn_SEL_OFFSET		(24)
-
-#define MC_CGM_ACn_SEL_GET(ac)		(((ac) & MC_CGM_ACn_SEL_MASK) >> \
-					MC_CGM_ACn_SEL_OFFSET)
-
-#define MC_CGM_ACn_DIV_GET(ac)		\
-				((((ac) & MC_CGM_ACn_DCm_PREDIV_MASK) >> \
-				MC_CGM_ACn_DCm_PREDIV_OFFSET) + 1)
-
-#define MC_CGM_ACn_SEL_FIRC		(0x0)
-#define MC_CGM_ACn_SEL_XOSC		(0x1)
-#define MC_CGM_ACn_SEL_ARMPLL		(0x2)
-/*
- * According to the manual some PLL can be divided by X (X={1,3,5}):
- * PERPLLDIVX, VIDEOPLLDIVX.
- */
-#define MC_CGM_ACn_SEL_PERPLLDIVX	(0x3)
-#define MC_CGM_ACn_SEL_ENETPLL		(0x4)
-#define MC_CGM_ACn_SEL_DDRPLL		(0x5)
-#define MC_CGM_ACn_SEL_EXTSRCPAD	(0x7)
-#define MC_CGM_ACn_SEL_SYSCLK		(0x8)
-#define MC_CGM_ACn_SEL_VIDEOPLLDIV2	(0x9)
-#define MC_CGM_ACn_SEL_PERCLK		(0xA)
-
-#define CGM_AC0_SC	0
-#define CGM_AC1_SC	1
-#define CGM_AC2_SC	2
-#define CGM_AC3_SC	3
-#define CGM_AC5_SC	5
-#define CGM_AC6_SC	6
-#define CGM_AC7_SC	7
-#define CGM_AC8_SC	8
-#define CGM_AC9_SC	9
-#define CGM_AC12_SC	12
-#define CGM_AC13_SC	13
-#define CGM_AC14_SC	14
-#define CGM_AC15_SC	15
-
-#define CGM_ACn_DC0	0
-#define CGM_ACn_DC1	1
-#define CGM_ACn_DC2	2
-
-#define PLLDIG_PLLDV_PREDIV_0	0
-#define PLLDIG_PLLDV_PREDIV_1	1
-#define PLLDIG_PLLDV_PREDIV_3	3
-
-/* PLLDIG PLL Divider Register (PLLDIG_PLLDV) */
-#define PLLDIG_PLLDV(pll)		((MC_CGM0_BASE_ADDR + 0x00000028) + \
-					 ((pll) * 0x80))
-#define PLLDIG_PLLDV_MFD(div)		(PLLDIG_PLLDV_MFD_MASK & (div))
-#define PLLDIG_PLLDV_MFD_MASK		(0x000000FF)
-
-/*
- * PLLDIG_PLLDV_RFDPHIB has a different format for /32 according to
- * the reference manual. This other value respect the formula 2^[RFDPHIBY+1]
- */
-#define PLLDIG_PLLDV_RFDPHI_SET(val)	(PLLDIG_PLLDV_RFDPHI_MASK & \
-		(((val) & PLLDIG_PLLDV_RFDPHI_MAXVALUE) \
-		 << PLLDIG_PLLDV_RFDPHI_OFFSET))
-#define PLLDIG_PLLDV_RFDPHI_MASK	(0x003F0000)
-#define PLLDIG_PLLDV_RFDPHI_MAXVALUE	(0x3F)
-#define PLLDIG_PLLDV_RFDPHI_OFFSET	(16)
-
-#define PLLDIG_PLLDV_RFDPHI1_SET(val)	(PLLDIG_PLLDV_RFDPHI1_MASK & \
-		(((val) & PLLDIG_PLLDV_RFDPHI1_MAXVALUE) << \
-		 PLLDIG_PLLDV_RFDPHI1_OFFSET))
-#define PLLDIG_PLLDV_RFDPHI1_MASK	(0x7E000000)
-#define PLLDIG_PLLDV_RFDPHI1_MAXVALUE	(0x3F)
-#define PLLDIG_PLLDV_RFDPHI1_OFFSET	(25)
-
-#define PLLDIG_PLLDV_PREDIV_SET(val)	(PLLDIG_PLLDV_PREDIV_MASK & \
-		(((val) & PLLDIG_PLLDV_PREDIV_MAXVALUE) \
-		 << PLLDIG_PLLDV_PREDIV_OFFSET))
-#define PLLDIG_PLLDV_PREDIV_MASK	(0x00007000)
-#define PLLDIG_PLLDV_PREDIV_MAXVALUE	(0x7)
-#define PLLDIG_PLLDV_PREDIV_OFFSET	(12)
-
-
-/* PLLDIG PLL Fractional  Divide Register (PLLDIG_PLLFD) */
-#define PLLDIG_PLLFD(pll)		((MC_CGM0_BASE_ADDR + 0x00000030) + \
-					 ((pll) * 0x80))
-#define PLLDIG_PLLFD_MFN_SET(val)	(PLLDIG_PLLFD_MFN_MASK & (val))
-#define PLLDIG_PLLFD_MFN_MASK		(0x00007FFF)
-#define PLLDIG_PLLFD_SMDEN		(1 << 30)
-
-/* PLL Calibration Register 1 (PLLDIG_PLLCAL1) */
-#define PLLDIG_PLLCAL1(pll)		((MC_CGM0_BASE_ADDR + 0x00000038) + \
-					 ((pll) * 0x80))
-#define PLLDIG_PLLCAL1_NDAC1_SET(val)	(PLLDIG_PLLCAL1_NDAC1_MASK & \
-					 ((val) << PLLDIG_PLLCAL1_NDAC1_OFFSET))
-#define PLLDIG_PLLCAL1_NDAC1_OFFSET	(24)
-#define PLLDIG_PLLCAL1_NDAC1_MASK	(0x7F000000)
-
-/* PLL Calibration Register 2 (PLLDIG_PLLCAL2) */
-#define PLLDIG_PLLCAL2(pll)		((MC_CGM0_BASE_ADDR + 0x0000003c) + \
-					 ((pll) * 0x80))
-
-/* These values must be written into PLLCAL1 and PLLCAL2 according
- * to the S32V234 Reference Manual Revision 4
- */
-#define PLLDIG_PLLCAL1_ADVISED_VALUE	0x44000000
-#define PLLDIG_PLLCAL2_ADVISED_VALUE	0x0001002b
-
-/* Digital Frequency Synthesizer (DFS) */
-/* According to the manual there are 3 DFS modules only for
- * ARM_PLL, DDR_PLL, ENET_PLL
- */
-#define DFS0_BASE_ADDR			(MC_CGM0_BASE_ADDR + 0x00000040)
-
-/* DFS DLL Program Register 1 */
-#define DFS_DLLPRG1(pll)		(DFS0_BASE_ADDR + 0x00000000 + \
-					 ((pll) * 0x80))
-
-#define DFS_DLLPRG1_V2IGC_SET(val)	(DFS_DLLPRG1_V2IGC_MASK & \
-					 ((val) << DFS_DLLPRG1_V2IGC_OFFSET))
-#define DFS_DLLPRG1_V2IGC_OFFSET	(0)
-#define DFS_DLLPRG1_V2IGC_MASK		(0x00000007)
-
-#define DFS_DLLPRG1_LCKWT_SET(val)	(DFS_DLLPRG1_LCKWT_MASK & \
-					 ((val) << DFS_DLLPRG1_LCKWT_OFFSET))
-#define DFS_DLLPRG1_LCKWT_OFFSET	(4)
-#define DFS_DLLPRG1_LCKWT_MASK		(0x00000030)
-
-#define DFS_DLLPRG1_DACIN_SET(val)	(DFS_DLLPRG1_DACIN_MASK & \
-					 ((val) << DFS_DLLPRG1_DACIN_OFFSET))
-#define DFS_DLLPRG1_DACIN_OFFSET	(6)
-#define DFS_DLLPRG1_DACIN_MASK		(0x000001C0)
-
-#define DFS_DLLPRG1_CALBYPEN_SET(val)	(DFS_DLLPRG1_CALBYPEN_MASK & \
-					 ((val) << DFS_DLLPRG1_CALBYPEN_OFFSET))
-#define DFS_DLLPRG1_CALBYPEN_OFFSET	(9)
-#define DFS_DLLPRG1_CALBYPEN_MASK	(0x00000200)
-
-#define DFS_DLLPRG1_VSETTLCTRL_SET(val)	(DFS_DLLPRG1_VSETTLCTRL_MASK & \
-		((val) << DFS_DLLPRG1_VSETTLCTRL_OFFSET))
-#define DFS_DLLPRG1_VSETTLCTRL_OFFSET	(10)
-#define DFS_DLLPRG1_VSETTLCTRL_MASK	(0x00000C00)
-
-#define DFS_DLLPRG1_CPICTRL_SET(val)	(DFS_DLLPRG1_CPICTRL_MASK & \
-					 ((val) << DFS_DLLPRG1_CPICTRL_OFFSET))
-#define DFS_DLLPRG1_CPICTRL_OFFSET	(12)
-#define DFS_DLLPRG1_CPICTRL_MASK	(0x00007000)
-
-/* DFS Control Register (DFS_CTRL) */
-#define DFS_CTRL(pll)			(DFS0_BASE_ADDR + 0x00000018 + \
-					 ((pll) * 0x80))
-#define DFS_CTRL_DLL_LOLIE		(1 << 0)
-#define DFS_CTRL_DLL_RESET		(1 << 1)
-
-/* DFS Port Status Register (DFS_PORTSR) */
-#define DFS_PORTSR(pll)				(DFS0_BASE_ADDR + 0x0000000C +\
-						 ((pll) * 0x80))
-/* DFS Port Reset Register (DFS_PORTRESET) */
-#define DFS_PORTRESET(pll)			(DFS0_BASE_ADDR + 0x00000014 +\
-						 ((pll) * 0x80))
-#define DFS_PORTRESET_PORTRESET_SET(val)	\
-				(((val) & DFS_PORTRESET_PORTRESET_MASK) \
-				<< DFS_PORTRESET_PORTRESET_OFFSET)
-#define DFS_PORTRESET_PORTRESET_MAXVAL		(0xF)
-#define DFS_PORTRESET_PORTRESET_MASK		(0x0000000F)
-#define DFS_PORTRESET_PORTRESET_OFFSET		(0)
-
-/* DFS Divide Register Portn (DFS_DVPORTn) */
-#define DFS_DVPORTn(pll, n)		(DFS0_BASE_ADDR + ((pll) * 0x80) + \
-					 (0x0000001C + ((n) * 0x4)))
-
-/*
- * The mathematical formula for fdfs_clockout is the following:
- * fdfs_clckout = fdfs_clkin / ( DFS_DVPORTn[MFI] + (DFS_DVPORTn[MFN]/256))
- */
-#define DFS_DVPORTn_MFI_SET(val)	(DFS_DVPORTn_MFI_MASK & \
-		(((val) & DFS_DVPORTn_MFI_MAXVAL) << DFS_DVPORTn_MFI_OFFSET))
-#define DFS_DVPORTn_MFN_SET(val)	(DFS_DVPORTn_MFN_MASK & \
-		(((val) & DFS_DVPORTn_MFN_MAXVAL) << DFS_DVPORTn_MFN_OFFSET))
-#define DFS_DVPORTn_MFI_MASK		(0x0000FF00)
-#define DFS_DVPORTn_MFN_MASK		(0x000000FF)
-#define DFS_DVPORTn_MFI_MAXVAL		(0xFF)
-#define DFS_DVPORTn_MFN_MAXVAL		(0xFF)
-#define DFS_DVPORTn_MFI_OFFSET		(8)
-#define DFS_DVPORTn_MFN_OFFSET		(0)
-#define DFS_MAXNUMBER			(4)
-
-#define DFS_PARAMS_Nr			(3)
-
-#define FXOSC_CTL			(MC_CGM0_BASE_ADDR + 0x280)
-#define FXOSC_CTL_FASTBOOT_VALUE	(0x018020f0)
-
-/* Frequencies are in Hz */
-#define FIRC_CLK_FREQ			(48000000)
-#define XOSC_CLK_FREQ			(40000000)
-
-#define PLL_MIN_FREQ			(650000000)
-#define PLL_MAX_FREQ			(1300000000)
-
-/* 1 GHz ARM version */
-#define ARM_1GHZ_PLL_PHI0_FREQ			(1000000000)
-#define ARM_1GHZ_PLL_PHI1_FREQ			(1000000000)
-/* ARM_1GHz_PLL_PHI1_DFS1_FREQ - 266 Mhz */
-#define ARM_1GHZ_PLL_PHI1_DFS1_EN		(1)
-#define ARM_1GHZ_PLL_PHI1_DFS1_MFI		(3)
-#define ARM_1GHZ_PLL_PHI1_DFS1_MFN		(195)
-/* ARM_1GHz_PLL_PHI1_DFS2_REQ - 600 Mhz */
-#define ARM_1GHZ_PLL_PHI1_DFS2_EN		(1)
-#define ARM_1GHZ_PLL_PHI1_DFS2_MFI		(1)
-#define ARM_1GHZ_PLL_PHI1_DFS2_MFN		(171)
-/* ARM_1GHz_PLL_PHI1_DFS3_FREQ - 600 Mhz */
-#define ARM_1GHZ_PLL_PHI1_DFS3_EN		(1)
-#define ARM_1GHZ_PLL_PHI1_DFS3_MFI		(1)
-#define ARM_1GHZ_PLL_PHI1_DFS3_MFN		(171)
-#define ARM_1GHZ_PLL_PHI1_DFS_Nr		(3)
-#define ARM_1GHZ_PLL_PLLDV_PREDIV		(2)
-#define ARM_1GHZ_PLL_PLLDV_MFD			(50)
-#define ARM_1GHZ_PLL_PLLDV_MFN			(0)
-
-/* 800 MHz ARM version */
-#define ARM_800MHZ_PLL_PHI0_FREQ		(800000000)
-#define ARM_800MHZ_PLL_PHI1_FREQ		(800000000)
-/* ARM_800MHz_PLL_PHI1_DFS1_FREQ - 266 Mhz */
-#define ARM_800MHZ_PLL_PHI1_DFS1_EN		(1)
-#define ARM_800MHZ_PLL_PHI1_DFS1_MFI		(3)
-#define ARM_800MHZ_PLL_PHI1_DFS1_MFN		(2)
-/* ARM_800MHz_PLL_PHI1_DFS2_REQ - 600 Mhz */
-#define ARM_800MHZ_PLL_PHI1_DFS2_EN		(1)
-#define ARM_800MHZ_PLL_PHI1_DFS2_MFI		(1)
-#define ARM_800MHZ_PLL_PHI1_DFS2_MFN		(86)
-/* ARM_800MHz_PLL_PHI1_DFS3_FREQ - 600 Mhz */
-#define ARM_800MHZ_PLL_PHI1_DFS3_EN		(1)
-#define ARM_800MHZ_PLL_PHI1_DFS3_MFI		(1)
-#define ARM_800MHZ_PLL_PHI1_DFS3_MFN		(86)
-#define ARM_800MHZ_PLL_PHI1_DFS_Nr		(3)
-#define ARM_800MHZ_PLL_PLLDV_PREDIV		(2)
-#define ARM_800MHZ_PLL_PLLDV_MFD		(40)
-#define ARM_800MHZ_PLL_PLLDV_MFN		(0)
-
-#define PERIPH_PLL_PHI0_FREQ		(400000000)
-#define PERIPH_PLL_PHI1_FREQ		(100000000)
-#define PERIPH_PLL_PHI1_DFS_Nr		(0)
-#define PERIPH_PLL_PLLDV_PREDIV		(1)
-#define PERIPH_PLL_PLLDV_MFD		(30)
-#define PERIPH_PLL_PLLDV_MFN		(0)
-
-#define ENET_PLL_PHI0_FREQ		(500000000)
-#define ENET_PLL_PHI1_FREQ		(1000000000)
-/* ENET_PLL_PHI1_DFS1_FREQ - 350 Mhz*/
-#define ENET_PLL_PHI1_DFS1_EN		(1)
-#define ENET_PLL_PHI1_DFS1_MFI		(2)
-#define ENET_PLL_PHI1_DFS1_MFN		(220)
-/* ENET_PLL_PHI1_DFS2_FREQ - 350 Mhz*/
-#define ENET_PLL_PHI1_DFS2_EN		(1)
-#define ENET_PLL_PHI1_DFS2_MFI		(2)
-#define ENET_PLL_PHI1_DFS2_MFN		(220)
-/* ENET_PLL_PHI1_DFS3_FREQ - 320 Mhz*/
-#define ENET_PLL_PHI1_DFS3_EN		(1)
-#define ENET_PLL_PHI1_DFS3_MFI		(3)
-#define ENET_PLL_PHI1_DFS3_MFN		(33)
-/* ENET_PLL_PHI1_DFS4_FREQ - 50 Mhz*/
-#define ENET_PLL_PHI1_DFS4_EN		(1)
-#define ENET_PLL_PHI1_DFS4_MFI		(20)
-#define ENET_PLL_PHI1_DFS4_MFN		(1)
-#define ENET_PLL_PHI1_DFS_Nr		(4)
-#define ENET_PLL_PLLDV_PREDIV		(2)
-#define ENET_PLL_PLLDV_MFD		(50)
-#define ENET_PLL_PLLDV_MFN		(0)
-
-#define DDR_PLL_PHI0_FREQ_533MHZ	(533000000)
-#define DDR_PLL_PHI1_FREQ_533MHZ	(1066000000)
-#define DDR_PLL_PHI0_FREQ_400MHZ	(400000000)
-#define DDR_PLL_PHI1_FREQ_400MHZ	(800000000)
-/* DDR_PLL_PHI1_DFS1_FREQ - 500 Mhz */
-#define DDR_PLL_PHI1_DFS1_EN		(1)
-#define DDR_PLL_PHI1_DFS1_MFI		(2)
-#define DDR_PLL_PHI1_DFS1_MFN		(34)
-/* DDR_PLL_PHI1_DFS2_REQ - 500 Mhz */
-#define DDR_PLL_PHI1_DFS2_EN		(1)
-#define DDR_PLL_PHI1_DFS2_MFI		(2)
-#define DDR_PLL_PHI1_DFS2_MFN		(34)
-/* DDR_PLL_PHI1_DFS3_FREQ - 350 Mhz */
-#define DDR_PLL_PHI1_DFS3_EN		(1)
-#define DDR_PLL_PHI1_DFS3_MFI		(3)
-#define DDR_PLL_PHI1_DFS3_MFN		(12)
-#define DDR_PLL_PHI1_DFS_Nr		(3)
-#define DDR_PLL_PLLDV_PREDIV_533MHZ	(2)
-#define DDR_PLL_PLLDV_MFD_533MHZ	(53)
-#define DDR_PLL_PLLDV_MFN_533MHZ	(6144)
-#define DDR_PLL_PLLDV_PREDIV_400MHZ	(1)
-#define DDR_PLL_PLLDV_MFD_400MHZ	(20)
-#define DDR_PLL_PLLDV_MFN_400MHZ	(0)
-
-#define VIDEO_PLL_PHI0_FREQ		(600000000)
-#define VIDEO_PLL_PHI1_FREQ		(0)
-#define VIDEO_PLL_PHI1_DFS_Nr		(0)
-#define VIDEO_PLL_PLLDV_PREDIV		(1)
-#define VIDEO_PLL_PLLDV_MFD		(30)
-#define VIDEO_PLL_PLLDV_MFN		(0)
-
-#endif
-
-#endif /*__ARCH_ARM_MACH_S32V234_MCCGM_REGS_H__ */
diff --git a/arch/arm/include/asm/arch-s32/s32v234/mc_me_regs.h b/arch/arm/include/asm/arch-s32/s32v234/mc_me_regs.h
deleted file mode 100644
index 4d55817bf9..0000000000
--- a/arch/arm/include/asm/arch-s32/s32v234/mc_me_regs.h
+++ /dev/null
@@ -1,206 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0+ */
-/*
- * (C) Copyright 2015-2016 Freescale Semiconductor, Inc.
- * (C) Copyright 2017,2020 NXP
- *
- */
-
-#ifndef __ARCH_ARM_MACH_S32V234_MCME_REGS_H__
-#define __ARCH_ARM_MACH_S32V234_MCME_REGS_H__
-
-#ifndef __ASSEMBLY__
-
-/* MC_ME registers definitions */
-
-/* MC_ME_GS */
-#define MC_ME_GS				(MC_ME_BASE_ADDR + 0x00000000)
-
-#define MC_ME_GS_S_SYSCLK_FIRC			(0x0 << 0)
-#define MC_ME_GS_S_SYSCLK_FXOSC			(0x1 << 0)
-#define MC_ME_GS_S_SYSCLK_ARMPLL		(0x2 << 0)
-#define MC_ME_GS_S_STSCLK_DISABLE		(0xF << 0)
-#define MC_ME_GS_S_FIRC				BIT(4)
-#define MC_ME_GS_S_XOSC				BIT(5)
-#define MC_ME_GS_S_ARMPLL			BIT(6)
-#define MC_ME_GS_S_PERPLL			BIT(7)
-#define MC_ME_GS_S_ENETPLL			BIT(8)
-#define MC_ME_GS_S_DDRPLL			BIT(9)
-#define MC_ME_GS_S_VIDEOPLL			BIT(10)
-#define MC_ME_GS_S_MVR				BIT(20)
-#define MC_ME_GS_S_PDO				BIT(23)
-#define MC_ME_GS_S_MTRANS			BIT(27)
-#define MC_ME_GS_S_CRT_MODE_RESET		(0x0 << 28)
-#define MC_ME_GS_S_CRT_MODE_TEST		(0x1 << 28)
-#define MC_ME_GS_S_CRT_MODE_DRUN		(0x3 << 28)
-#define MC_ME_GS_S_CRT_MODE_RUN0		(0x4 << 28)
-#define MC_ME_GS_S_CRT_MODE_RUN1		(0x5 << 28)
-#define MC_ME_GS_S_CRT_MODE_RUN2		(0x6 << 28)
-#define MC_ME_GS_S_CRT_MODE_RUN3		(0x7 << 28)
-
-/* MC_ME_MCTL */
-#define MC_ME_MCTL				(MC_ME_BASE_ADDR + 0x00000004)
-
-#define MC_ME_MCTL_KEY				(0x00005AF0)
-#define MC_ME_MCTL_INVERTEDKEY			(0x0000A50F)
-#define MC_ME_MCTL_RESET			(0x0 << 28)
-#define MC_ME_MCTL_TEST				(0x1 << 28)
-#define MC_ME_MCTL_DRUN				(0x3 << 28)
-#define MC_ME_MCTL_RUN0				(0x4 << 28)
-#define MC_ME_MCTL_RUN1				(0x5 << 28)
-#define MC_ME_MCTL_RUN2				(0x6 << 28)
-#define MC_ME_MCTL_RUN3				(0x7 << 28)
-
-
-/* MC_ME_ME */
-#define MC_ME_ME				(MC_ME_BASE_ADDR + 0x00000008)
-
-#define MC_ME_ME_RESET_FUNC			BIT(0)
-#define MC_ME_ME_TEST				BIT(1)
-#define MC_ME_ME_DRUN				BIT(3)
-#define MC_ME_ME_RUN0				BIT(4)
-#define MC_ME_ME_RUN1				BIT(5)
-#define MC_ME_ME_RUN2				BIT(6)
-#define MC_ME_ME_RUN3				BIT(7)
-
-/* MC_ME_RUN_PCn */
-#define MC_ME_RUN_PCn(n)			(MC_ME_BASE_ADDR + \
-						 0x00000080 + 0x4 * (n))
-
-#define MC_ME_RUN_PCn_RESET			BIT(0)
-#define MC_ME_RUN_PCn_TEST			BIT(1)
-#define MC_ME_RUN_PCn_DRUN			BIT(3)
-#define MC_ME_RUN_PCn_RUN0			BIT(4)
-#define MC_ME_RUN_PCn_RUN1			BIT(5)
-#define MC_ME_RUN_PCn_RUN2			BIT(6)
-#define MC_ME_RUN_PCn_RUN3			BIT(7)
-
-/*
- * MC_ME_RESET_MC/MC_ME_TEST_MC
- * MC_ME_DRUN_MC
- * MC_ME_RUNn_MC
- */
-#define MC_ME_RESET_MC		(MC_ME_BASE_ADDR + 0x00000020)
-#define MC_ME_TEST_MC		(MC_ME_BASE_ADDR + 0x00000024)
-#define MC_ME_DRUN_MC		(MC_ME_BASE_ADDR + 0x0000002C)
-#define MC_ME_RUNn_MC(n)	(MC_ME_BASE_ADDR + 0x00000030 + 0x4 * (n))
-
-#define MC_ME_RUNMODE_MC_SYSCLK(val)	(MC_ME_RUNMODE_MC_SYSCLK_MASK & (val))
-#define MC_ME_RUNMODE_MC_SYSCLK_MASK		(0x0000000F)
-#define MC_ME_RUNMODE_MC_FIRCON			(1 << 4)
-#define MC_ME_RUNMODE_MC_XOSCON			(1 << 5)
-#define MC_ME_RUNMODE_MC_PLL(pll)		(1 << (6 + (pll)))
-#define MC_ME_RUNMODE_MC_MVRON			(1 << 20)
-#define MC_ME_RUNMODE_MC_PDO			(1 << 23)
-#define MC_ME_RUNMODE_MC_PWRLVL0		(1 << 28)
-#define MC_ME_RUNMODE_MC_PWRLVL1		(1 << 29)
-#define MC_ME_RUNMODE_MC_PWRLVL2		(1 << 30)
-
-#define DRUN_MC_RESETVAL			(0x00100010)
-#define SYSCLK_FXOSC				(1 << 0)
-#define SYSCLK_ARM_PLL_DFS_1			BIT(1)
-
-/* MC_ME_DRUN_SEC_CC_I */
-#define MC_ME_DRUN_SEC_CC_I			(MC_ME_BASE_ADDR + 0x260)
-/* MC_ME_RUNn_SEC_CC_I */
-#define MC_ME_RUNn_SEC_CC_I(n)	(MC_ME_BASE_ADDR + 0x270 + (n) * 0x10)
-#define MC_ME_RUNMODE_SEC_CC_I_SYSCLK(val, offset)	\
-	((MC_ME_RUNMODE_SEC_CC_I_SYSCLK_MASK & (val)) << offset)
-#define MC_ME_RUNMODE_SEC_CC_I_SYSCLK1_OFFSET	(4)
-#define MC_ME_RUNMODE_SEC_CC_I_SYSCLK2_OFFSET	(8)
-#define MC_ME_RUNMODE_SEC_CC_I_SYSCLK3_OFFSET	(12)
-#define MC_ME_RUNMODE_SEC_CC_I_SYSCLK_MASK	(0x3)
-
-/*
- * ME_PCTLn
- * Please note that these registers are 8 bits width, so
- * the operations over them should be done using 8 bits operations.
- */
-#define MC_ME_PCTLn_RUNPCm(n)		((n) & MC_ME_PCTLn_RUNPCm_MASK)
-#define MC_ME_PCTLn_RUNPCm_MASK		(0x7)
-
-#define MC_ME_PCTLn(n)		(MC_ME_BASE_ADDR + 0xC0 + 4 * ((n) >> 2) \
-				 + (3 - (n) % 4))
-
-/* Peripherals PCTL indexes */
-#define DEC200_PCTL     39
-#define DCU_PCTL        40
-#define CSI0_PCTL       48
-#define DMACHMUX0_PCTL  49
-#define ENET_PCTL       50
-#define FRAY_PCTL       52
-#define MMDC0_PCTL      54
-#define PIT0_PCTL       58
-#define SARADC0_PCTL    77
-#define FlexTIMER0_PCTL 79
-#define IIC0_PCTL       81
-#define LINFLEX0_PCTL   83
-#define CANFD0_PCTL     85
-#define DSPI0_PCTL      87
-#define DSPI2_PCTL      89
-#define CRC0_PCTL       91
-#define SDHC_PCTL       93
-#define VIU0_PCTL       100
-#define HPSMI_PCTL      104
-#define SIPI_PCTL       116
-#define LFAST_PCTL      120
-#define CSI1_PCTL       160
-#define DMACHMUX1_PCTL  161
-#define MMDC1_PCTL      162
-#define QUADSPI0_PCTL   166
-#define PIT1_PCTL       170
-#define FlexTIMER1_PCTL 182
-#define IIC1_PCTL       184
-#define IIC2_PCTL       186
-#define LINFLEX1_PCTL   188
-#define CANFD1_PCTL     190
-#define DSPI1_PCTL      192
-#define DSPI3_PCTL      194
-#define CRC1_PCTL       204
-#define TSENS_PCTL      206
-#define VIU1_PCTL       208
-#define JPEG_PCTL       212
-#define H264_DEC_PCTL   216
-#define H264_ENC_PCTL   220
-#define MBIST_PCTL      236
-
-/* Core status register */
-#define MC_ME_CS               (MC_ME_BASE_ADDR + 0x000001C0)
-#define MC_ME_CS_A53(n)		BIT((n) + 1)
-
-/* Cortex-M4 Core Control Register */
-#define MC_MC_CCTL0            (MC_ME_BASE_ADDR + 0x000001C6)
-/* Cortex-A53 - Core 0 Core Control Register */
-#define MC_ME_CCTL1            (MC_ME_BASE_ADDR + 0x000001C4)
-/* Cortex-A53 - Core 1 Core Control Register */
-#define MC_ME_CCTL2            (MC_ME_BASE_ADDR + 0x000001CA)
-/* Cortex-A53 - Core 2 Core Control Register */
-#define MC_ME_CCTL3            (MC_ME_BASE_ADDR + 0x000001C8)
-/* Cortex-A53 - Core 3 Control Register */
-#define MC_ME_CCTL4            (MC_ME_BASE_ADDR + 0x000001CE)
-
-/* Cortex-M4 core */
-#define MC_MC_CCTL_CORE_ACTIVE         (0xF8)
-/* Cortex-A53 cores */
-#define MC_ME_CCTL_DEASSERT_CORE       (0xFA)
-
-/* Cortex-M4 Core Address Register */
-#define MC_ME_CADDR0		(MC_ME_BASE_ADDR + 0x000001E0)
-/* Cortex-A53 Core 0 - Core Address Register */
-#define MC_ME_CADDR1		(MC_ME_BASE_ADDR + 0x000001E4)
-/* Cortex-A53 Core 1 - Core Address Register */
-#define MC_ME_CADDR2		(MC_ME_BASE_ADDR + 0x000001E8)
-/* Cortex-A53 Core 2 - Core Address Register */
-#define MC_ME_CADDR3		(MC_ME_BASE_ADDR + 0x000001EC)
-/* Cortex-A53 Core 3 - Core Address Register */
-#define MC_ME_CADDR4		(MC_ME_BASE_ADDR + 0x000001F0)
-#define MC_ME_CADDR_A53(n)	(MC_ME_CADDR1 + (n) * 4)
-
-#define MC_ME_CADDRn_ADDR_EN	BIT(0)
-#define MC_ME_CADDRn_ADDR_MASK	(0xFFFFFFFC)
-
-/* Default used values */
-#define CFG_RUN_PC	MC_ME_PCTLn_RUNPCm(1)
-
-#endif
-
-#endif /*__ARCH_ARM_MACH_S32V234_MCME_REGS_H__ */
diff --git a/arch/arm/include/asm/arch-s32/s32v234/mc_rgm_regs.h b/arch/arm/include/asm/arch-s32/s32v234/mc_rgm_regs.h
deleted file mode 100644
index 26d961ed18..0000000000
--- a/arch/arm/include/asm/arch-s32/s32v234/mc_rgm_regs.h
+++ /dev/null
@@ -1,43 +0,0 @@
-/*
- * (C) Copyright 2015-2016 Freescale Semiconductor, Inc.
- * (C) Copyright 2016-2017 NXP
- *
- * SPDX-License-Identifier:	GPL-2.0+
- */
-
-#ifndef __ARCH_ARM_MACH_S32V234_MCRGM_REGS_H__
-#define __ARCH_ARM_MACH_S32V234_MCRGM_REGS_H__
-
-#define MC_RGM_DES			(MC_RGM_BASE_ADDR)
-#define MC_RGM_FES			(MC_RGM_BASE_ADDR + 0x300)
-#define MC_RGM_FERD			(MC_RGM_BASE_ADDR + 0x310)
-#define MC_RGM_FBRE			(MC_RGM_BASE_ADDR + 0x330)
-#define MC_RGM_FESS			(MC_RGM_BASE_ADDR + 0x340)
-#define MC_RGM_DDR_HE			(MC_RGM_BASE_ADDR + 0x350)
-#define MC_RGM_DDR_HS			(MC_RGM_BASE_ADDR + 0x354)
-#define MC_RGM_FRHE			(MC_RGM_BASE_ADDR + 0x358)
-#define MC_RGM_FREC			(MC_RGM_BASE_ADDR + 0x600)
-#define MC_RGM_FRET			(MC_RGM_BASE_ADDR + 0x607)
-#define MC_RGM_DRET			(MC_RGM_BASE_ADDR + 0x60B)
-
-/* function reset sources mask */
-#define F_SWT4				0x8000
-#define F_JTAG				0x400
-#define F_FCCU_SOFT			0x40
-#define F_FCCU_HARD			0x20
-#define F_SOFT_FUNC			0x8
-#define F_ST_DONE			0x4
-#define F_EXT_RST			0x1
-
-/* DDR Handshake timeout value in IRC clocks */
-#define HNDSHK_TO_VAL			160
-
-#define MC_RGM_FES_ANY_FUNC_EVENT	0x846D
-#define MC_RGM_DDR_HE_EN		(0x1)
-#define MC_RGM_DDR_HE_VALUE		\
-	(HNDSHK_TO_VAL << 16) | (MC_RGM_DDR_HE_EN)
-#define MC_RGM_FRHE_ALL_VALUE		0x846D
-#define MC_RGM_DDR_HS_HNDSHK_DONE	0x2
-
-#endif /* __ARCH_ARM_MACH_S32V234_MCRGM_REGS_H__ */
-
diff --git a/arch/arm/include/asm/arch-s32/s32v234/s32v234-regs.h b/arch/arm/include/asm/arch-s32/s32v234/s32v234-regs.h
deleted file mode 100644
index 24711b0b36..0000000000
--- a/arch/arm/include/asm/arch-s32/s32v234/s32v234-regs.h
+++ /dev/null
@@ -1,180 +0,0 @@
-/* SPDX-License-Identifier:     GPL-2.0+ */
-/*
- * (C) Copyright 2013-2016 Freescale Semiconductor, Inc.
- * (C) Copyright 2017-2020 NXP
- */
-
-#ifndef __ASM_ARCH_S32V234_REGS_H__
-#define __ASM_ARCH_S32V234_REGS_H__
-
-#if !defined(__ASSEMBLER__)
-#define AIPS0_BASE_ADDR		(0x40000000UL)
-#define AIPS1_BASE_ADDR		(0x40080000UL)
-#else
-#define AIPS0_BASE_ADDR		(0x40000000)
-#define AIPS1_BASE_ADDR		(0x40080000)
-#endif
-
-/* AIPS 0 */
-#define AXBS_BASE_ADDR					(AIPS0_BASE_ADDR + 0x00000000)
-#define CSE3_BASE_ADDR					(AIPS0_BASE_ADDR + 0x00001000)
-#define EDMA_BASE_ADDR					(AIPS0_BASE_ADDR + 0x00002000)
-#define XRDC_BASE_ADDR					(AIPS0_BASE_ADDR + 0x00004000)
-#define SWT0_BASE_ADDR					(AIPS0_BASE_ADDR + 0x0000A000)
-#define SWT1_BASE_ADDR					(AIPS0_BASE_ADDR + 0x0000B000)
-#define STM0_BASE_ADDR					(AIPS0_BASE_ADDR + 0x0000D000)
-#define NIC301_BASE_ADDR				(AIPS0_BASE_ADDR + 0x00010000)
-#define GC3000_BASE_ADDR				(AIPS0_BASE_ADDR + 0x00020000)
-#define DEC200_DECODER_BASE_ADDR			(AIPS0_BASE_ADDR + 0x00026000)
-#define DEC200_ENCODER_BASE_ADDR			(AIPS0_BASE_ADDR + 0x00027000)
-#define TWOD_ACE_BASE_ADDR				(AIPS0_BASE_ADDR + 0x00028000)
-#define MIPI_CSI0_BASE_ADDR				(AIPS0_BASE_ADDR + 0x00030000)
-#define DMAMUX0_BASE_ADDR				(AIPS0_BASE_ADDR + 0x00031000)
-#define ENET_BASE_ADDR					(AIPS0_BASE_ADDR + 0x00032000)
-#define FLEXRAY_BASE_ADDR				(AIPS0_BASE_ADDR + 0x00034000)
-#define MMDC0_BASE_ADDR					(AIPS0_BASE_ADDR + 0x00036000)
-#define MEW0_BASE_ADDR					(AIPS0_BASE_ADDR + 0x00037000)
-#define MONITOR_DDR0_BASE_ADDR				(AIPS0_BASE_ADDR + 0x00038000)
-#define MONITOR_CCI0_BASE_ADDR				(AIPS0_BASE_ADDR + 0x00039000)
-#define PIT0_BASE_ADDR					(AIPS0_BASE_ADDR + 0x0003A000)
-#define MC_CGM0_BASE_ADDR				(AIPS0_BASE_ADDR + 0x0003C000)
-#define MC_CGM1_BASE_ADDR				(AIPS0_BASE_ADDR + 0x0003F000)
-#define MC_CGM2_BASE_ADDR				(AIPS0_BASE_ADDR + 0x00042000)
-#define MC_CGM3_BASE_ADDR				(AIPS0_BASE_ADDR + 0x00045000)
-#define MC_RGM_BASE_ADDR				(AIPS0_BASE_ADDR + 0x00048000)
-#define MC_ME_BASE_ADDR					(AIPS0_BASE_ADDR + 0x0004A000)
-#define MC_PCU_BASE_ADDR				(AIPS0_BASE_ADDR + 0x0004B000)
-#define ADC0_BASE_ADDR					(AIPS0_BASE_ADDR + 0x0004D000)
-#define FLEXTIMER_BASE_ADDR				(AIPS0_BASE_ADDR + 0x0004F000)
-#define I2C1_BASE_ADDR					(AIPS0_BASE_ADDR + 0x00051000)
-#define LINFLEXD0_BASE_ADDR				(AIPS0_BASE_ADDR + 0x00053000)
-#define FLEXCAN0_BASE_ADDR				(AIPS0_BASE_ADDR + 0x00055000)
-#define SPI0_BASE_ADDR					(AIPS0_BASE_ADDR + 0x00057000)
-#define SPI2_BASE_ADDR					(AIPS0_BASE_ADDR + 0x00059000)
-#define CRC0_BASE_ADDR					(AIPS0_BASE_ADDR + 0x0005B000)
-#define USDHC_BASE_ADDR					(AIPS0_BASE_ADDR + 0x0005D000)
-#define OCOTP_CONTROLLER_BASE_ADDR			(AIPS0_BASE_ADDR + 0x0005F000)
-#define WKPU_BASE_ADDR					(AIPS0_BASE_ADDR + 0x00063000)
-#define VIU0_BASE_ADDR					(AIPS0_BASE_ADDR + 0x00064000)
-#define HPSMI_SRAM_CONTROLLER_BASE_ADDR			(AIPS0_BASE_ADDR + 0x00068000)
-#define SIUL2_BASE_ADDR					(AIPS0_BASE_ADDR + 0x0006C000)
-#define SIPI_BASE_ADDR					(AIPS0_BASE_ADDR + 0x00074000)
-#define LFAST_BASE_ADDR					(AIPS0_BASE_ADDR + 0x00078000)
-#define SSE_BASE_ADDR					(AIPS0_BASE_ADDR + 0x00079000)
-#define SRC_SOC_BASE_ADDR				(AIPS0_BASE_ADDR + 0x0007C000)
-
-
-/* AIPS 1 */
-#define ERM_BASE_ADDR					(AIPS1_BASE_ADDR + 0x00000000)
-#define MSCM_BASE_ADDR					(AIPS1_BASE_ADDR + 0x00001000)
-#define SEMA42_BASE_ADDR				(AIPS1_BASE_ADDR + 0x00002000)
-#define INTC_MON_BASE_ADDR				(AIPS1_BASE_ADDR + 0x00003000)
-#define SWT2_BASE_ADDR					(AIPS1_BASE_ADDR + 0x00004000)
-#define SWT3_BASE_ADDR					(AIPS1_BASE_ADDR + 0x00005000)
-#define SWT4_BASE_ADDR					(AIPS1_BASE_ADDR + 0x00006000)
-#define STM1_BASE_ADDR					(AIPS1_BASE_ADDR + 0x00007000)
-#define EIM_BASE_ADDR					(AIPS1_BASE_ADDR + 0x00008000)
-#define APB_BASE_ADDR					(AIPS1_BASE_ADDR + 0x00009000)
-#define XBIC_BASE_ADDR					(AIPS1_BASE_ADDR + 0x00012000)
-#define MIPI_BASE_ADDR					(AIPS1_BASE_ADDR + 0x00020000)
-#define DMAMUX1_BASE_ADDR				(AIPS1_BASE_ADDR + 0x00021000)
-#define MMDC1_BASE_ADDR					(AIPS1_BASE_ADDR + 0x00022000)
-#define MEW1_BASE_ADDR					(AIPS1_BASE_ADDR + 0x00023000)
-#define DDR1_BASE_ADDR					(AIPS1_BASE_ADDR + 0x00024000)
-#define CCI1_BASE_ADDR					(AIPS1_BASE_ADDR + 0x00025000)
-#define QUADSPI0_BASE_ADDR				(AIPS1_BASE_ADDR + 0x00026000)
-#define PIT1_BASE_ADDR					(AIPS1_BASE_ADDR + 0x0002A000)
-#define FCCU_BASE_ADDR					(AIPS1_BASE_ADDR + 0x00030000)
-#define FLEXTIMER_FTM1_BASE_ADDR			(AIPS1_BASE_ADDR + 0x00036000)
-#define I2C2_BASE_ADDR					(AIPS1_BASE_ADDR + 0x00038000)
-#define I2C3_BASE_ADDR					(AIPS1_BASE_ADDR + 0x0003A000)
-#define LINFLEXD1_BASE_ADDR				(AIPS1_BASE_ADDR + 0x0003C000)
-#define FLEXCAN1_BASE_ADDR				(AIPS1_BASE_ADDR + 0x0003E000)
-#define SPI1_BASE_ADDR					(AIPS1_BASE_ADDR + 0x00040000)
-#define SPI3_BASE_ADDR					(AIPS1_BASE_ADDR + 0x00042000)
-#define IPL_BASE_ADDR					(AIPS1_BASE_ADDR + 0x00043000)
-#define CGM_CMU_BASE_ADDR				(AIPS1_BASE_ADDR + 0x00044000)
-#define PMC_BASE_ADDR					(AIPS1_BASE_ADDR + 0x00048000)
-#define CRC1_BASE_ADDR					(AIPS1_BASE_ADDR + 0x0004C000)
-#define TMU_BASE_ADDR					(AIPS1_BASE_ADDR + 0x0004E000)
-#define VIU1_BASE_ADDR					(AIPS1_BASE_ADDR + 0x00050000)
-#define JPEG_BASE_ADDR					(AIPS1_BASE_ADDR + 0x00054000)
-#define H264_DEC_BASE_ADDR				(AIPS1_BASE_ADDR + 0x00058000)
-#define H264_ENC_BASE_ADDR				(AIPS1_BASE_ADDR + 0x0005C000)
-#define MEMU_BASE_ADDR					(AIPS1_BASE_ADDR + 0x00060000)
-#define STCU_BASE_ADDR					(AIPS1_BASE_ADDR + 0x00064000)
-#define SLFTST_CTRL_BASE_ADDR				(AIPS1_BASE_ADDR + 0x00066000)
-#define MCT_BASE_ADDR					(AIPS1_BASE_ADDR + 0x00068000)
-#define REP_BASE_ADDR					(AIPS1_BASE_ADDR + 0x0006A000)
-#define MBIST_CONTROLLER_BASE_ADDR			(AIPS1_BASE_ADDR + 0x0006C000)
-#define BOOT_LOADER_BASE_ADDR				(AIPS1_BASE_ADDR + 0x0006F000)
-
-/* MSCM interrupt router */
-#define MSCM_IRSPRC_CPn_EN		3
-#define MSCM_IRSPRC_NUM			176
-#define MSCM_CPXTYPE_RYPZ_MASK		0xFF
-#define MSCM_CPXTYPE_RYPZ_OFFSET	0
-#define MSCM_CPXTYPE_PERS_MASK		0xFFFFFF00
-#define MSCM_CPXTYPE_PERS_OFFSET	8
-#define MSCM_CPXTYPE_PERS_A53		0x413533
-#define MSCM_CPXTYPE_PERS_CM4		0x434d34
-
-#if !(defined(__KERNEL_STRICT_NAMES) || defined(__ASSEMBLY__))
-#include <asm/types.h>
-
-/* MSCM Interrupt Router */
-struct mscm_ir {
-	u32 cpxtype;		/* Processor x Type Register			*/
-	u32 cpxnum;			/* Processor x Number Register			*/
-	u32 cpxmaster;		/* Processor x Master Number Register	*/
-	u32 cpxcount;		/* Processor x Count Register			*/
-	u32 cpxcfg0;		/* Processor x Configuration 0 Register */
-	u32 cpxcfg1;		/* Processor x Configuration 1 Register */
-	u32 cpxcfg2;		/* Processor x Configuration 2 Register */
-	u32 cpxcfg3;		/* Processor x Configuration 3 Register */
-	u32 cp0type;		/* Processor 0 Type Register			*/
-	u32 cp0num;			/* Processor 0 Number Register			*/
-	u32 cp0master;		/* Processor 0 Master Number Register	*/
-	u32 cp0count;		/* Processor 0 Count Register			*/
-	u32 cp0cfg0;		/* Processor 0 Configuration 0 Register	*/
-	u32 cp0cfg1;		/* Processor 0 Configuration 1 Register	*/
-	u32 cp0cfg2;		/* Processor 0 Configuration 2 Register	*/
-	u32 cp0cfg3;		/* Processor 0 Configuration 3 Register	*/
-	u32 cp1type;		/* Processor 1 Type Register			*/
-	u32 cp1num;			/* Processor 1 Number Register			*/
-	u32 cp1master;		/* Processor 1 Master Number Register	*/
-	u32 cp1count;		/* Processor 1 Count Register			*/
-	u32 cp1cfg0;		/* Processor 1 Configuration 0 Register	*/
-	u32 cp1cfg1;		/* Processor 1 Configuration 1 Register	*/
-	u32 cp1cfg2;		/* Processor 1 Configuration 2 Register	*/
-	u32 cp1cfg3;		/* Processor 1 Configuration 3 Register	*/
-	u32 reserved_0x060[232];
-	u32 ocmdr0;			/* On-Chip Memory Descriptor Register	*/
-	u32 reserved_0x404[2];
-	u32 ocmdr3;			/* On-Chip Memory Descriptor Register	*/
-	u32 reserved_0x410[28];
-	u32 tcmdr[4];		/* Generic Tightly Coupled Memory Descriptor Register	*/
-	u32 reserved_0x490[28];
-	u32 cpce0;			/* Core Parity Checking Enable Register 0				*/
-	u32 reserved_0x504[191];
-	u32 ircp0ir;		/* Interrupt Router CP0 Interrupt Register				*/
-	u32 ircp1ir;		/* Interrupt Router CP1 Interrupt Register				*/
-	u32 reserved_0x808[6];
-	u32 ircpgir;		/* Interrupt Router CPU Generate Interrupt Register		*/
-	u32 reserved_0x824[23];
-	u16 irsprc[MSCM_IRSPRC_NUM];	/* Interrupt Router Shared Peripheral Routing Control Register	*/
-	u32 reserved_0x9e0[136];
-	u32 iahbbe0;		/* Gasket Burst Enable Register							*/
-	u32 reserved_0xc04[63];
-	u32 ipcge;			/* Interconnect Parity Checking Global Enable Register	*/
-	u32 reserved_0xd04[3];
-	u32 ipce[4];		/* Interconnect Parity Checking Enable Register			*/
-	u32 reserved_0xd20[8];
-	u32 ipcgie;			/* Interconnect Parity Checking Global Injection Enable Register	*/
-	u32 reserved_0xd44[3];
-	u32 ipcie[4];           /* Interconnect Parity Checking Injection Enable Register       */
-};
-#endif
-#include "dma_macros.h"
-
-#endif	/* __ASM_ARCH_S32V234_REGS_H__ */
diff --git a/arch/arm/include/asm/arch-s32/siul-s32v234.h b/arch/arm/include/asm/arch-s32/siul-s32v234.h
deleted file mode 100644
index ecc89cf4bf..0000000000
--- a/arch/arm/include/asm/arch-s32/siul-s32v234.h
+++ /dev/null
@@ -1,715 +0,0 @@
-/* SPDX-License-Identifier:     GPL-2.0+ */
-/*
- * (C) Copyright 2015-2016 Freescale Semiconductor, Inc.
- * (C) Copyright 2017-2019,2020 NXP
- * (C) Copyright 2017 MicroSys Electronics GmbH
- */
-
-#ifndef __ARCH_ARM_MACH_S32V234_SIUL_H__
-#define __ARCH_ARM_MACH_S32V234_SIUL_H__
-
-/* SIUL2_MIDR2 fields */
-#define SIUL2_MIDR2_SPEED_SHIFT		(23)
-#define SIUL2_MIDR2_SPEED_GRADING	(0xF << SIUL2_MIDR2_SPEED_SHIFT)
-
-#define SIUL2_MIDR2_SPEED_600MHZ	(0xA)
-#define SIUL2_MIDR2_SPEED_800MHZ	(0xB)
-#define SIUL2_MIDR2_SPEED_1GHZ		(0xC)
-
-static inline int get_siul2_midr2_speed(void)
-{
-	return (readl(SIUL2_MIDR2) & SIUL2_MIDR2_SPEED_GRADING)
-			>> SIUL2_MIDR2_SPEED_SHIFT;
-}
-
-/* SIUL2_MSCR specifications as stated in Reference Manual:
- * 0 - 359 Output Multiplexed Signal Configuration Registers
- * 512- 1023 Input Multiplexed Signal Configuration Registers */
-#define SIUL2_MSCR_BASE			(SIUL2_BASE_ADDR + 0x00000240)
-#define SIUL2_MSCRn(i)			(SIUL2_MSCR_BASE + 4 * (i))
-
-#define SIUL2_IMCR_BASE			(SIUL2_BASE_ADDR + 0x00000A40)
-#define SIUL2_IMCRn(i)			(SIUL2_IMCR_BASE +  4 * (i))
-
-#define SIUL2_GPDO_BASE			(SIUL2_BASE_ADDR + 0x00001300)
-#define SIUL2_GPDO_N(i)			(SIUL2_GPDO_BASE + 4 * (i))
-
-#define SIUL2_GPDI_BASE			(SIUL2_BASE_ADDR + 0x00001500)
-#define SIUL2_GPDI_N(i)			(SIUL2_GPDI_BASE + 4 * (i))
-
-#define SIUL2_PGPDO_BASE		(SIUL2_BASE_ADDR + 0x00001700)
-#define SIUL2_PGPDOn(i)			(SIUL2_PGPDO_BASE + \
-						((i / 2) * 4) + \
-						((i % 2) ? 0 : 2))
-
-#define SIUL2_PGPDI_BASE		(SIUL2_BASE_ADDR + 0x00001740)
-#define SIUL2_PGPDIn(i)			(SIUL2_PGPDI_BASE + \
-						((i / 2) * 4) + \
-						((i % 2) ? 0 : 2))
-
-#define SIUL2_MPGPDO_BASE		(SIUL2_BASE_ADDR + 0x00001780)
-#define SIUL2_MPGPDOn(i)		(SIUL2_MPGPDO_BASE + 4 * (i))
-
-/* GPIO */
-/* 163 GPIOs in output mode, we assume the GPIO number is in range */
-#define SIUL2_GPDO_FOR_GPIO(i)		(((i) & (~0x3)) >> 2)
-#define SIUL2_GPDO_PDO_OFF_FOR_GPIO(i)	(~(i) & (0x3))
-#define SIUL2_PDO_N(i) \
-	(SIUL2_GPDO_N(SIUL2_GPDO_FOR_GPIO(i)) + \
-	 SIUL2_GPDO_PDO_OFF_FOR_GPIO(i))
-
-#define SIUL2_PGPDO_FOR_GPIO(i)		((i) >> 4)
-#define SIUL2_PGPDO_PPDO_OFF_FOR_GPIO(i)	((i) & BIT(3) ? 0 : 1)
-#define SIUL2_PPDO_BYTE(i) \
-	(SIUL2_PGPDOn(SIUL2_PGPDO_FOR_GPIO(i)) + \
-	 SIUL2_PGPDO_PPDO_OFF_FOR_GPIO(i))
-
-#define SIUL2_PPDIO_BIT(i)		BIT(~(i) & 0x7)
-#define SIUL2_GPIO_VALUE0		(0x00)
-#define SIUL2_GPIO_VALUE1		(0x01)
-
-/* SIUL2_MSCR masks */
-#define SIUL2_MSCR_DDR_DO_TRIM(v)	((v) & 0xC0000000)
-#define SIUL2_MSCR_DDR_DO_TRIM_MIN	(0 << 30)
-#define SIUL2_MSCR_DDR_DO_TRIM_50PS	(1 << 30)
-#define SIUL2_MSCR_DDR_DO_TRIM_100PS	(2 << 30)
-#define SIUL2_MSCR_DDR_DO_TRIM_150PS	(3 << 30)
-
-#define SIUL2_MSCR_DDR_INPUT(v)		((v) & 0x20000000)
-#define SIUL2_MSCR_DDR_INPUT_CMOS	(0 << 29)
-#define SIUL2_MSCR_DDR_INPUT_DIFF_DDR	(1 << 29)
-
-#define SIUL2_MSCR_DDR_SEL(v)		((v) & 0x18000000)
-#define SIUL2_MSCR_DDR_SEL_DDR3		(0 << 27)
-#define SIUL2_MSCR_DDR_SEL_LPDDR2	(2 << 27)
-
-#define SIUL2_MSCR_DDR_ODT(v)		((v) & 0x07000000)
-#define SIUL2_MSCR_DDR_ODT_120ohm	(1 << 24)
-#define SIUL2_MSCR_DDR_ODT_60ohm	(2 << 24)
-#define SIUL2_MSCR_DDR_ODT_40ohm	(3 << 24)
-#define SIUL2_MSCR_DDR_ODT_30ohm	(4 << 24)
-#define SIUL2_MSCR_DDR_ODT_24ohm	(5 << 24)
-#define SIUL2_MSCR_DDR_ODT_20ohm	(6 << 24)
-#define SIUL2_MSCR_DDR_ODT_17ohm	(7 << 24)
-
-#define SIUL2_MSCR_DCYCLE_TRIM(v)	((v) & 0x00C00000)
-#define SIUL2_MSCR_DCYCLE_TRIM_NONE	(0 << 22)
-#define SIUL2_MSCR_DCYCLE_TRIM_LEFT	(1 << 22)
-#define SIUL2_MSCR_DCYCLE_TRIM_RIGHT	(2 << 22)
-
-#define SIUL2_MSCR_OBE(v)		((v) & 0x00200000)
-#define SIUL2_MSCR_OBE_EN		(1 << 21)
-
-#define SIUL2_MSCR_ODE(v)		((v) & 0x00100000)
-#define SIUL2_MSCR_ODE_EN		(1 << 20)
-
-#define SIUL2_MSCR_IBE(v)		((v) & 0x00010000)
-#define SIUL2_MSCR_IBE_EN		(1 << 19)
-
-#define SIUL2_MSCR_HYS(v)		((v) & 0x00400000)
-#define SIUL2_MSCR_HYS_EN		(1 << 18)
-
-#define SIUL2_MSCR_INV(v)		((v) & 0x00020000)
-#define SIUL2_MSCR_INV_EN		(1 << 17)
-
-#define SIUL2_MSCR_PKE(v)		((v) & 0x00010000)
-#define SIUL2_MSCR_PKE_EN		(1 << 16)
-
-#define SIUL2_MSCR_SRE(v)		((v) & 0x0000C000)
-#define SIUL2_MSCR_SRE_SPEED_LOW_50	(0 << 14)
-#define SIUL2_MSCR_SRE_SPEED_LOW_100	(1 << 14)
-#define SIUL2_MSCR_SRE_SPEED_HIGH_100	(2 << 14)
-#define SIUL2_MSCR_SRE_SPEED_HIGH_200	(3 << 14)
-
-#define SIUL2_MSCR_PUE(v)		((v) & 0x00002000)
-#define SIUL2_MSCR_PUE_EN		(1 << 13)
-
-#define SIUL2_MSCR_PUS(v)		((v) & 0x00001800)
-#define SIUL2_MSCR_PUS_100K_DOWN	(0 << 11)
-#define SIUL2_MSCR_PUS_50K_UP		(1 << 11)
-#define SIUL2_MSCR_PUS_100K_UP		(2 << 11)
-#define SIUL2_MSCR_PUS_33K_UP		(3 << 11)
-
-#define SIUL2_MSCR_DSE(v)			((v) & 0x00000700)
-#define SIUL2_MSCR_DSE_240ohm		(1 << 8)
-#define SIUL2_MSCR_DSE_120ohm		(2 << 8)
-#define SIUL2_MSCR_DSE_80ohm		(3 << 8)
-#define SIUL2_MSCR_DSE_60ohm		(4 << 8)
-#define SIUL2_MSCR_DSE_48ohm		(5 << 8)
-#define SIUL2_MSCR_DSE_40ohm		(6 << 8)
-#define SIUL2_MSCR_DSE_34ohm		(7 << 8)
-
-#define SIUL2_MSCR_CRPOINT_TRIM(v)	((v) & 0x000000C0)
-#define SIUL2_MSCR_CRPOINT_TRIM_1	(1 << 6)
-
-#define SIUL2_MSCR_SMC(v)		((v) & 0x00000020)
-#define SIUL2_MSCR_MUX_MODE(v)		((v) & 0x0000000f)
-#define SIUL2_MSCR_MUX_MODE_ALT0	(0x0)
-#define SIUL2_MSCR_MUX_MODE_ALT1	(0x1)
-#define SIUL2_MSCR_MUX_MODE_ALT2	(0x2)
-#define SIUL2_MSCR_MUX_MODE_ALT3	(0x3)
-#define SIUL2_MSCR_MUX_MODE_ALT4	(0x4)
-/* UART settings */
-
-/* UART0 */
-/* TXD */
-#define SIUL2_MSCR_PA12		12
-/* RXD */
-#define SIUL2_MSCR_PA11		11
-#define SIUL2_IMCR_UART0_RXD	200
-
-/* UART1 */
-/* TXD */
-#define SIUL2_MSCR_PA14		14
-/* RXD */
-#define SIUL2_MSCR_PA13		13
-#define SIUL2_IMCR_UART1_RXD	202
-
-/* UART MSCR settings */
-#define SIUL2_MSCR_PORT_CTRL_UART_TXD \
-	(SIUL2_MSCR_OBE_EN | \
-	 SIUL2_MSCR_PUS_100K_UP | \
-	 SIUL2_MSCR_DSE_60ohm |	\
-	 SIUL2_MSCR_SRE_SPEED_LOW_100 | \
-	 SIUL2_MSCR_MUX_MODE_ALT1)
-#define SIUL2_MSCR_PORT_CTRL_UART_RXD \
-	(SIUL2_MSCR_PUE_EN | \
-	 SIUL2_MSCR_IBE_EN | \
-	 SIUL2_MSCR_DCYCLE_TRIM_RIGHT)
-
-/* UART IMCR mux modes */
-#define SIUL2_IMCR_UART_RXD_to_pad	(SIUL2_MSCR_MUX_MODE_ALT2)
-
-/* uSDHC settings */
-#define SIUL2_USDHC_PAD_CTRL_BASE \
-	(SIUL2_MSCR_SRE_SPEED_HIGH_200 | \
-	 SIUL2_MSCR_OBE_EN | \
-	 SIUL2_MSCR_DSE_34ohm | \
-	 SIUL2_MSCR_PKE_EN | \
-	 SIUL2_MSCR_IBE_EN | \
-	 SIUL2_MSCR_PUS_100K_UP | \
-	 SIUL2_MSCR_PUE_EN)
-#define SIUL2_USDHC_PAD_CTRL_CMD \
-	(SIUL2_USDHC_PAD_CTRL_BASE | \
-	 SIUL2_MSCR_MUX_MODE_ALT1)
-#define SIUL2_USDHC_PAD_CTRL_CLK \
-	(SIUL2_USDHC_PAD_CTRL_BASE | \
-	 SIUL2_MSCR_MUX_MODE_ALT2)
-#define SIUL2_USDHC_PAD_CTRL_DAT0_3 \
-	(SIUL2_USDHC_PAD_CTRL_BASE | \
-	 SIUL2_MSCR_MUX_MODE_ALT2)
-#define SIUL2_USDHC_PAD_CTRL_DAT4_7 \
-	(SIUL2_USDHC_PAD_CTRL_BASE | \
-	SIUL2_MSCR_MUX_MODE_ALT3)
-
-/* I2C settings */
-#define SIUL2_MSCR_PA15			15
-#define SIUL2_MSCR_PB0			16
-#define SIUL2_MSCR_PB1			17
-#define SIUL2_MSCR_PB2			18
-#define SIUL2_MSCR_PB3			19
-#define SIUL2_MSCR_PB4			20
-#define SIUL2_MSCR_PG3			99
-#define SIUL2_MSCR_PG4			100
-#define SIUL2_MSCR_PG5			101
-#define SIUL2_MSCR_PG6			102
-
-#define SIUL2_IMCR_I2C0_DATA		269
-#define SIUL2_IMCR_I2C0_CLK		268
-#define SIUL2_IMCR_I2C1_DATA		271
-#define SIUL2_IMCR_I2C1_CLK		270
-#define SIUL2_IMCR_I2C2_DATA		273
-#define SIUL2_IMCR_I2C2_CLK		272
-
-/* I2C0 - Serial Data Input AC15 */
-#define SIUL2_PAD_CTRL_I2C_COMMON \
-	(SIUL2_MSCR_OBE_EN | \
-	 SIUL2_MSCR_IBE_EN | \
-	 SIUL2_MSCR_ODE_EN | \
-	 SIUL2_MSCR_DSE_34ohm)
-
-#define SIUL2_PAD_CTRL_I2C0_MSCR_SDA_AC15 \
-	(SIUL2_MSCR_MUX_MODE_ALT2 | \
-	 SIUL2_PAD_CTRL_I2C_COMMON)
-#define SIUL2_PAD_CTRL_I2C0_IMCR_SDA_AC15	(SIUL2_MSCR_MUX_MODE_ALT3)
-
-/* I2C0 - Serial Clock Input AE15 */
-#define SIUL2_PAD_CTRL_I2C0_MSCR_SCLK_AE15 \
-	(SIUL2_MSCR_MUX_MODE_ALT2 | \
-	 SIUL2_PAD_CTRL_I2C_COMMON)
-#define SIUL2_PAD_CTRL_I2C0_IMCR_SCLK_AE15	(SIUL2_MSCR_MUX_MODE_ALT3)
-
-/* I2C0 - Serial Data Input F11 */
-#define SIUL2_PAD_CTRL_I2C0_MSCR_SDA_F11 \
-	(SIUL2_MSCR_MUX_MODE_ALT1 | \
-	 SIUL2_PAD_CTRL_I2C_COMMON)
-#define SIUL2_PAD_CTRL_I2C0_IMCR_SDA_F11	(SIUL2_MSCR_MUX_MODE_ALT2)
-
-/* I2C0 - Serial Clock Input F12 */
-#define SIUL2_PAD_CTRL_I2C0_MSCR_SCLK_F12 \
-	(SIUL2_MSCR_MUX_MODE_ALT1 | \
-	 SIUL2_PAD_CTRL_I2C_COMMON)
-#define SIUL2_PAD_CTRL_I2C0_IMCR_SCLK_F12	(SIUL2_MSCR_MUX_MODE_ALT2)
-
-/* I2C1 - Serial Data Input */
-#define SIUL2_PAD_CTRL_I2C1_MSCR_SDA \
-	(SIUL2_MSCR_MUX_MODE_ALT2 | \
-	 SIUL2_PAD_CTRL_I2C_COMMON)
-#define SIUL2_PAD_CTRL_I2C1_IMCR_SDA	(SIUL2_MSCR_MUX_MODE_ALT3)
-
-/* I2C1 - Serial Clock Input */
-#define SIUL2_PAD_CTRL_I2C1_MSCR_SCLK \
-	(SIUL2_MSCR_MUX_MODE_ALT2 | \
-	 SIUL2_PAD_CTRL_I2C_COMMON)
-#define SIUL2_PAD_CTRL_I2C1_IMCR_SCLK	(SIUL2_MSCR_MUX_MODE_ALT3)
-
-/* I2C2 - Serial Data Input */
-#define SIUL2_PAD_CTRL_I2C2_MSCR_SDA \
-	(SIUL2_MSCR_MUX_MODE_ALT1 | \
-	 SIUL2_PAD_CTRL_I2C_COMMON)
-#define SIUL2_PAD_CTRL_I2C2_IMCR_SDA	(SIUL2_MSCR_MUX_MODE_ALT2)
-
-/* I2C2 - Serial Clock Input */
-#define SIUL2_PAD_CTRL_I2C2_MSCR_SCLK \
-	(SIUL2_MSCR_MUX_MODE_ALT1 | \
-	 SIUL2_PAD_CTRL_I2C_COMMON)
-#define SIUL2_PAD_CTRL_I2C2_IMCR_SCLK	(SIUL2_MSCR_MUX_MODE_ALT2)
-
-/* I2C settings MPXS32V234-R1 */
-/* I2C0 - Serial Data Input */
-#define SIUL2_PAD_CTRL_I2C0_MSCR1_SDA \
-		(SIUL2_MSCR_MUX_MODE_ALT1 | \
-		 SIUL2_MSCR_OBE_EN | \
-		 SIUL2_MSCR_IBE_EN | \
-		 SIUL2_MSCR_ODE_EN | \
-		 SIUL2_MSCR_DSE_34ohm)
-#define SIUL2_PAD_CTRL_I2C0_IMCR1_SDA	(SIUL2_MSCR_MUX_MODE_ALT2)
-
-/* I2C0 - Serial Clock Input */
-#define SIUL2_PAD_CTRL_I2C0_MSCR1_SCLK \
-		(SIUL2_MSCR_MUX_MODE_ALT1 | \
-		 SIUL2_MSCR_OBE_EN | \
-		 SIUL2_MSCR_IBE_EN | \
-		 SIUL2_MSCR_ODE_EN | \
-		 SIUL2_MSCR_DSE_34ohm)
-#define SIUL2_PAD_CTRL_I2C0_IMCR1_SCLK	(SIUL2_MSCR_MUX_MODE_ALT2)
-
-/* I2C1 - Serial Data Input */
-#define SIUL2_PAD_CTRL_I2C1_MSCR1_SDA \
-		(SIUL2_MSCR_MUX_MODE_ALT1 |\
-		 SIUL2_MSCR_OBE_EN | \
-		 SIUL2_MSCR_IBE_EN | \
-		 SIUL2_MSCR_ODE_EN | \
-		 SIUL2_MSCR_DSE_34ohm)
-#define SIUL2_PAD_CTRL_I2C1_IMCR1_SDA	(SIUL2_MSCR_MUX_MODE_ALT2)
-
-/* I2C1 - Serial Clock Input */
-#define SIUL2_PAD_CTRL_I2C1_MSCR1_SCLK \
-		(SIUL2_MSCR_MUX_MODE_ALT1 | \
-		 SIUL2_MSCR_OBE_EN | \
-		 SIUL2_MSCR_IBE_EN | \
-		 SIUL2_MSCR_ODE_EN | \
-		 SIUL2_MSCR_DSE_34ohm)
-#define SIUL2_PAD_CTRL_I2C1_IMCR1_SCLK	(SIUL2_MSCR_MUX_MODE_ALT2)
-
-/* ENET settings */
-
-#define SIUL2_MSCR_PC13		45
-#define SIUL2_MSCR_PC14		46
-#define SIUL2_MSCR_PC14_IN	981
-
-#define SIUL2_MSCR_PC15_SWITCH	47
-#define SIUL2_MSCR_PC15		47
-#define SIUL2_MSCR_PC15_IN	978
-
-#define SIUL2_MSCR_PD0		48
-#define SIUL2_MSCR_PD0_IN	979
-
-#define SIUL2_MSCR_PD1		49
-#define SIUL2_MSCR_PD1_IN	974
-
-#define SIUL2_MSCR_PD2		50
-#define SIUL2_MSCR_PD2_IN	975
-
-#define SIUL2_MSCR_PD3		51
-#define SIUL2_MSCR_PD3_IN	976
-
-#define SIUL2_MSCR_PD4		52
-#define SIUL2_MSCR_PD4_IN	977
-
-#define SIUL2_MSCR_PD5		53
-#define SIUL2_MSCR_PD5_IN	973
-
-#define SIUL2_MSCR_PD6		54
-#define SIUL2_MSCR_PD6_IN	970
-
-#define SIUL2_MSCR_PD7		55
-#define SIUL2_MSCR_PD8		56
-#define SIUL2_MSCR_PD9		57
-#define SIUL2_MSCR_PD10		58
-#define SIUL2_MSCR_PD11		59
-
-/* ENET - SIUL2_MSCR_ENET_MDC = 0x20c701 */
-#define SIUL2_MSCR_ENET_MDC \
-	(SIUL2_MSCR_DSE_34ohm | \
-	 SIUL2_MSCR_SRE_SPEED_HIGH_200 |\
-	 SIUL2_MSCR_OBE_EN | \
-	 SIUL2_MSCR_MUX_MODE_ALT1)
-
-/* ENET - SIUL2_MSCR_ENET_MDIO = 0x28c701 */
-#define SIUL2_MSCR_ENET_MDIO \
-	(SIUL2_MSCR_DSE_34ohm | \
-	 SIUL2_MSCR_SRE_SPEED_HIGH_200 | \
-	 SIUL2_MSCR_OBE_EN | \
-	 SIUL2_MSCR_IBE_EN | \
-	 SIUL2_MSCR_MUX_MODE_ALT1)
-
-/* ENET - SIUL2_MSCR_ENET_MDIO_IN = 0x00000002 */
-#define SIUL2_MSCR_ENET_MDIO_IN	SIUL2_MSCR_MUX_MODE_ALT2
-
-/* ENET - SIUL2_MSCR_ENET_TX_CLK_SWITCH = 0x20c701 */
-#define SIUL2_MSCR_ENET_TX_CLK_SWITCH \
-	(SIUL2_MSCR_DSE_34ohm | \
-	 SIUL2_MSCR_SRE_SPEED_HIGH_200 | \
-	 SIUL2_MSCR_OBE_EN | \
-	 SIUL2_MSCR_MUX_MODE_ALT1)
-
-/* ENET - SIUL2_MSCR_ENET_TX_CLK = 0x00203701 */
-#define SIUL2_MSCR_ENET_TX_CLK \
-	(SIUL2_MSCR_DSE_34ohm | \
-	 SIUL2_MSCR_PUS_100K_UP | \
-	 SIUL2_MSCR_PUE_EN | \
-	 SIUL2_MSCR_OBE_EN | \
-	 SIUL2_MSCR_MUX_MODE_ALT1)
-
-/* ENET - SIUL2_MSCR_ENET_TX_CLK_IN = 0x00000002*/
-#define SIUL2_MSCR_ENET_TX_CLK_IN	SIUL2_MSCR_MUX_MODE_ALT2
-
-/* ENET - SIUL2_MSCR_ENET_RX_CLK = 0x8c700 */
-#define SIUL2_MSCR_ENET_RX_CLK \
-	(SIUL2_MSCR_DSE_34ohm | \
-	 SIUL2_MSCR_SRE_SPEED_HIGH_200 | \
-	 SIUL2_MSCR_IBE_EN)
-
-/* ENET - SIUL2_MSCR_ENET_RX_CLK_IN = 0x00000002*/
-#define SIUL2_MSCR_ENET_RX_CLK_IN	SIUL2_MSCR_MUX_MODE_ALT2
-
-/* ENET - SIUL2_MSCR_ENET_RX_D0 = 0x8c700 */
-#define SIUL2_MSCR_ENET_RX_D0 \
-	(SIUL2_MSCR_DSE_34ohm | \
-	 SIUL2_MSCR_SRE_SPEED_HIGH_200 | \
-	 SIUL2_MSCR_IBE_EN)
-
-/* ENET - SIUL2_MSCR_ENET_RX_D0_IN = 0x00000002*/
-#define SIUL2_MSCR_ENET_RX_D0_IN	SIUL2_MSCR_MUX_MODE_ALT2
-
-/* ENET - SIUL2_MSCR_ENET_RX_D1 = 0x8c700 */
-#define SIUL2_MSCR_ENET_RX_D1 \
-	(SIUL2_MSCR_DSE_34ohm | \
-	 SIUL2_MSCR_SRE_SPEED_HIGH_200 | \
-	 SIUL2_MSCR_IBE_EN)
-
-/* ENET - SIUL2_MSCR_ENET_RX_D1_IN = 0x00000002*/
-#define SIUL2_MSCR_ENET_RX_D1_IN	SIUL2_MSCR_MUX_MODE_ALT2
-
-/* ENET - SIUL2_MSCR_ENET_RX_D2 = 0x8c700 */
-#define SIUL2_MSCR_ENET_RX_D2 \
-	(SIUL2_MSCR_DSE_34ohm | \
-	 SIUL2_MSCR_SRE_SPEED_HIGH_200 | \
-	 SIUL2_MSCR_IBE_EN)
-
-/* ENET - SIUL2_MSCR_ENET_RX_D2_IN = 0x00000002*/
-#define SIUL2_MSCR_ENET_RX_D2_IN	SIUL2_MSCR_MUX_MODE_ALT2
-
-/* ENET - SIUL2_MSCR_ENET_RX_D3 = 0x8c700 */
-#define SIUL2_MSCR_ENET_RX_D3 \
-	(SIUL2_MSCR_DSE_34ohm | \
-	 SIUL2_MSCR_SRE_SPEED_HIGH_200 | \
-	 SIUL2_MSCR_IBE_EN)
-
-/* ENET - SIUL2_MSCR_ENET_RX_D3_IN = 0x00000002*/
-#define SIUL2_MSCR_ENET_RX_D3_IN	SIUL2_MSCR_MUX_MODE_ALT2
-
-/* ENET - SIUL2_MSCR_ENET_RX_DV = 0x8c700 */
-#define SIUL2_MSCR_ENET_RX_DV \
-	(SIUL2_MSCR_DSE_34ohm | \
-	 SIUL2_MSCR_SRE_SPEED_HIGH_200 | \
-	 SIUL2_MSCR_IBE_EN)
-
-/* ENET - SIUL2_MSCR_ENET_RX_DV_IN = 0x00000002*/
-#define SIUL2_MSCR_ENET_RX_DV_IN	SIUL2_MSCR_MUX_MODE_ALT2
-
-/* ENET - SIUL2_MSCR_ENET_RX_ER = 0x0008c700 */
-#define SIUL2_MSCR_ENET_RX_ER \
-	(SIUL2_MSCR_DSE_34ohm | \
-	 SIUL2_MSCR_SRE_SPEED_HIGH_200 | \
-	 SIUL2_MSCR_IBE_EN)
-
-/* ENET - SIUL2_MSCR_ENET_RX_ER_IN = 0x00000002 */
-#define SIUL2_MSCR_ENET_RX_ER_IN	SIUL2_MSCR_MUX_MODE_ALT2
-
-/* ENET - SIUL2_MSCR_ENET_TX_D0 = 0x20c701 */
-#define SIUL2_MSCR_ENET_TX_D0 \
-	(SIUL2_MSCR_DSE_34ohm | \
-	 SIUL2_MSCR_SRE_SPEED_HIGH_200 | \
-	 SIUL2_MSCR_OBE_EN | \
-	 SIUL2_MSCR_MUX_MODE_ALT1)
-
-/* ENET - SIUL2_MSCR_ENET_TX_D1 = 0x20c701 */
-#define SIUL2_MSCR_ENET_TX_D1 \
-	(SIUL2_MSCR_DSE_34ohm |	\
-	 SIUL2_MSCR_SRE_SPEED_HIGH_200 | \
-	 SIUL2_MSCR_OBE_EN | \
-	 SIUL2_MSCR_MUX_MODE_ALT1)
-
-/* ENET - SIUL2_MSCR_ENET_TX_D2 = 0x20c701 */
-#define SIUL2_MSCR_ENET_TX_D2 \
-	(SIUL2_MSCR_DSE_34ohm | \
-	 SIUL2_MSCR_SRE_SPEED_HIGH_200 | \
-	 SIUL2_MSCR_OBE_EN | \
-	 SIUL2_MSCR_MUX_MODE_ALT1)
-
-/* ENET - SIUL2_MSCR_ENET_TX_D3 = 0x20c701 */
-#define SIUL2_MSCR_ENET_TX_D3 \
-	(SIUL2_MSCR_DSE_34ohm |	\
-	 SIUL2_MSCR_SRE_SPEED_HIGH_200 | \
-	 SIUL2_MSCR_OBE_EN | \
-	 SIUL2_MSCR_MUX_MODE_ALT1)
-
-/* ENET - SIUL2_MSCR_ENET_TX_EN = 0x20c701 */
-#define SIUL2_MSCR_ENET_TX_EN \
-	(SIUL2_MSCR_DSE_34ohm |	\
-	 SIUL2_MSCR_SRE_SPEED_HIGH_200 | \
-	 SIUL2_MSCR_OBE_EN | \
-	 SIUL2_MSCR_MUX_MODE_ALT1)
-
-/* ENET - SIUL2_MSCR_ENET_RMII_CLK_REF_IP = 0x0008c700 */
-#define SIUL2_MSCR_ENET_RMII_CLK_REF_IP \
-	(SIUL2_MSCR_DSE_34ohm | \
-	 SIUL2_MSCR_SRE_SPEED_HIGH_200 | \
-	 SIUL2_MSCR_IBE_EN)
-
-/* QuadSPI settings */
-
-#define SIUL2_PK6_MSCR	150
-#define SIUL2_PK6_MSCR_MUX_MODE_QSPI_A_SCK	SIUL2_MSCR_MUX_MODE_ALT1
-
-#define SIUL2_PK5_MSCR	149
-#define SIUL2_PK5_MSCR_MUX_MODE_QSPI_A_CS0	SIUL2_MSCR_MUX_MODE_ALT1
-
-#define SIUL2_PK13_MSCR	157
-#define SIUL2_PK13_MSCR_MUX_MODE_QSPI_B_SCK	SIUL2_MSCR_MUX_MODE_ALT1
-#define SIUL2_PK13_MSCR_MUX_MODE_QSPI_CK2	SIUL2_MSCR_MUX_MODE_ALT2
-
-#define SIUL2_PK12_MSCR	156
-#define SIUL2_PK12_MSCR_MUX_MODE_QSPI_B_CS0	SIUL2_MSCR_MUX_MODE_ALT1
-
-#define SIUL2_PORT_MSCR_CTRL_QSPI_AB_DATA_BASE \
-		(SIUL2_MSCR_DSE_34ohm | \
-		SIUL2_MSCR_SRE_SPEED_HIGH_200 | \
-		SIUL2_MSCR_IBE_EN | \
-		SIUL2_MSCR_OBE_EN)
-#define SIUL2_PORT_MSCR_CTRL_QSPI_A_DATA0_3 \
-		(SIUL2_MSCR_MUX_MODE_ALT1 | \
-		SIUL2_PORT_MSCR_CTRL_QSPI_AB_DATA_BASE)
-#define SIUL2_PORT_MSCR_CTRL_QSPI_A_DATA4_7 \
-		(SIUL2_MSCR_MUX_MODE_ALT2 | \
-		SIUL2_PORT_MSCR_CTRL_QSPI_AB_DATA_BASE)
-
-#define SIUL2_PORT_MSCR_CTRL_QSPI_B_DATA0_3 \
-		(SIUL2_MSCR_MUX_MODE_ALT1 | \
-		SIUL2_PORT_MSCR_CTRL_QSPI_AB_DATA_BASE)
-
-#define SIUL2_PORT_IMCR_MUX_MODE_QSPI_A_DATA0_7	SIUL2_MSCR_MUX_MODE_ALT2
-
-#define SIUL2_PORT_IMCR_MUX_MODE_QSPI_B_DATA0_3	SIUL2_MSCR_MUX_MODE_ALT2
-
-/* 0x0009E000 + SIUL2_MSCR_PUS_100K_DOWN */
-#define SIUL2_PORT_MSCR_CTRL_QSPI_A_DQS	\
-		(SIUL2_MSCR_IBE_EN | \
-		SIUL2_MSCR_PKE_EN | \
-		SIUL2_MSCR_SRE_SPEED_HIGH_200 |	\
-		SIUL2_MSCR_PUE_EN | \
-		SIUL2_MSCR_PUS_100K_DOWN)
-
-#define SIUL2_PORT_MSCR_CTRL_QSPI_CLK_BASE	\
-		(	\
-		SIUL2_MSCR_DSE_34ohm |	\
-		SIUL2_MSCR_PUS_100K_UP |	\
-		SIUL2_MSCR_SRE_SPEED_HIGH_200 |	\
-		SIUL2_MSCR_OBE_EN)
-
-#define SIUL2_PK11_MSCR	155
-#define SIUL2_PK11_MSCR_MUX_MODE_QSPI_A_DATA3	SIUL2_MSCR_MUX_MODE_ALT1
-#define SIUL2_PK11_IMCR_QSPI_A_DATA3	(823 - 512)
-#define SIUL2_PK11_IMCR_MUX_MODE_QSPI_A_DATA3	SIUL2_MSCR_MUX_MODE_ALT2
-
-#define SIUL2_PK10_MSCR	154
-#define SIUL2_PK10_MSCR_MUX_MODE_QSPI_A_DATA2	SIUL2_MSCR_MUX_MODE_ALT1
-#define SIUL2_PK10_IMCR_QSPI_A_DATA2	(822 - 512)
-#define SIUL2_PK10_IMCR_MUX_MODE_QSPI_A_DATA2	SIUL2_MSCR_MUX_MODE_ALT2
-
-#define SIUL2_PK9_MSCR	153
-#define SIUL2_PK9_MSCR_MUX_MODE_QSPI_A_DATA1	SIUL2_MSCR_MUX_MODE_ALT1
-#define SIUL2_PK9_IMCR_QSPI_A_DATA1	(821 - 512)
-#define SIUL2_PK9_IMCR_MUX_MODE_QSPI_A_DATA1	SIUL2_MSCR_MUX_MODE_ALT2
-
-#define SIUL2_PK8_MSCR	152
-#define SIUL2_PK8_MSCR_MUX_MODE_QSPI_A_DATA0	SIUL2_MSCR_MUX_MODE_ALT1
-#define SIUL2_PK8_IMCR_QSPI_A_DATA0	(820 - 512)
-#define SIUL2_PK8_IMCR_MUX_MODE_QSPI_A_DATA0	SIUL2_MSCR_MUX_MODE_ALT2
-
-#define SIUL2_PK7_MSCR	151
-#define SIUL2_PK7_IMCR_QSPI_A_DQS	(819 - 512)
-#define SIUL2_PK7_IMCR_MUX_MODE_QSPI_A_DQS	SIUL2_MSCR_MUX_MODE_ALT2
-
-#define SIUL2_PL2_MSCR	162
-#define SIUL2_PL2_MSCR_MUX_MODE_QSPI_B_DATA3	SIUL2_MSCR_MUX_MODE_ALT1
-#define SIUL2_PL2_MSCR_MUX_MODE_QSPI_A_DATA7	SIUL2_MSCR_MUX_MODE_ALT2
-#define SIUL2_PL2_IMCR_QSPI_A_DATA7	(827 - 512)
-#define SIUL2_PL2_IMCR_QSPI_B_DATA3	(832 - 512)
-#define SIUL2_PL2_IMCR_MUX_MODE_QSPI_A_DATA7	SIUL2_MSCR_MUX_MODE_ALT2
-#define SIUL2_PL2_IMCR_MUX_MODE_QSPI_B_DATA3	SIUL2_MSCR_MUX_MODE_ALT2
-
-#define SIUL2_PL1_MSCR	161
-#define SIUL2_PL1_MSCR_MUX_MODE_QSPI_B_DATA2	SIUL2_MSCR_MUX_MODE_ALT1
-#define SIUL2_PL1_MSCR_MUX_MODE_QSPI_A_DATA6	SIUL2_MSCR_MUX_MODE_ALT2
-#define SIUL2_PL1_IMCR_QSPI_A_DATA6	(826 - 512)
-#define SIUL2_PL1_IMCR_QSPI_B_DATA2	(831 - 512)
-#define SIUL2_PL1_IMCR_MUX_MODE_QSPI_A_DATA6	SIUL2_MSCR_MUX_MODE_ALT2
-#define SIUL2_PL1_IMCR_MUX_MODE_QSPI_B_DATA2	SIUL2_MSCR_MUX_MODE_ALT2
-
-#define SIUL2_PL0_MSCR	160
-#define SIUL2_PL0_MSCR_MUX_MODE_QSPI_B_DATA1	SIUL2_MSCR_MUX_MODE_ALT1
-#define SIUL2_PL0_MSCR_MUX_MODE_QSPI_A_DATA5	SIUL2_MSCR_MUX_MODE_ALT2
-#define SIUL2_PL0_IMCR_QSPI_A_DATA5	(825 - 512)
-#define SIUL2_PL0_IMCR_QSPI_B_DATA1	(830 - 512)
-#define SIUL2_PL0_IMCR_MUX_MODE_QSPI_A_DATA5	SIUL2_MSCR_MUX_MODE_ALT2
-#define SIUL2_PL0_IMCR_MUX_MODE_QSPI_B_DATA1	SIUL2_MSCR_MUX_MODE_ALT2
-
-#define SIUL2_PK15_MSCR	159
-#define SIUL2_PK15_MSCR_MUX_MODE_QSPI_B_DATA0	SIUL2_MSCR_MUX_MODE_ALT1
-#define SIUL2_PK15_MSCR_MUX_MODE_QSPI_A_DATA4	SIUL2_MSCR_MUX_MODE_ALT2
-#define SIUL2_PK15_IMCR_QSPI_A_DATA4	(824 - 512)
-#define SIUL2_PK15_IMCR_QSPI_B_DATA0	(829 - 512)
-#define SIUL2_PK15_IMCR_MUX_MODE_QSPI_A_DATA4	SIUL2_MSCR_MUX_MODE_ALT2
-#define SIUL2_PK15_IMCR_MUX_MODE_QSPI_B_DATA0	SIUL2_MSCR_MUX_MODE_ALT2
-
-/* DSPI Settings */
-
-#define SIUL2_MSCR_PB5  21
-#define SIUL2_MSCR_PB6  22
-#define SIUL2_MSCR_PB7  23
-#define SIUL2_MSCR_PB8  24
-#define SIUL2_MSCR_PB13 29
-#define SIUL2_MSCR_PB14 30
-#define SIUL2_MSCR_PB15 31
-#define SIUL2_MSCR_PC0  32
-#define SIUL2_MSCR_PC1  33
-#define SIUL2_MSCR_PC2  34
-#define SIUL2_MSCR_PC3  35
-
-#define SIUL2_PAD_CTRL_MSCR_CSx	 \
-				(SIUL2_MSCR_OBE_EN | SIUL2_MSCR_PUS_100K_UP | \
-				 SIUL2_MSCR_DSE_34ohm | SIUL2_MSCR_PUE_EN)
-
-#define SIUL2_PAD_CTRL_DSPI0_MSCR_CS0_OUT	(SIUL2_PAD_CTRL_MSCR_CSx | \
-				SIUL2_MSCR_MUX_MODE_ALT1)
-
-#define SIUL2_PAD_CTRL_DSPI0_MSCR_CS1_OUT	(SIUL2_PAD_CTRL_MSCR_CSx | \
-				SIUL2_MSCR_MUX_MODE_ALT3)
-
-#define SIUL2_PAD_CTRL_DSPI0_MSCR_CS2_OUT	(SIUL2_PAD_CTRL_MSCR_CSx | \
-				SIUL2_MSCR_MUX_MODE_ALT3)
-
-#define SIUL2_PAD_CTRL_DSPI0_MSCR_CS3_OUT	(SIUL2_PAD_CTRL_MSCR_CSx | \
-				SIUL2_MSCR_MUX_MODE_ALT2)
-
-#define SIUL2_PAD_CTRL_DSPI0_MSCR_CS4_OUT	(SIUL2_PAD_CTRL_MSCR_CSx | \
-				SIUL2_MSCR_MUX_MODE_ALT3)
-
-#define SIUL2_PAD_CTRL_DSPI0_MSCR_CS5_OUT	(SIUL2_PAD_CTRL_MSCR_CSx | \
-				SIUL2_MSCR_MUX_MODE_ALT3)
-
-#define SIUL2_PAD_CTRL_DSPI0_MSCR_CS6_OUT	(SIUL2_PAD_CTRL_MSCR_CSx | \
-				SIUL2_MSCR_MUX_MODE_ALT3)
-
-#define SIUL2_PAD_CTRL_DSPI0_MSCR_CS7_OUT	(SIUL2_PAD_CTRL_MSCR_CSx | \
-				SIUL2_MSCR_MUX_MODE_ALT2)
-
-#define SIUL2_PAD_CTRL_DSPI0_MSCR_SOUT_OUT	(SIUL2_MSCR_OBE_EN | \
-				SIUL2_MSCR_DSE_34ohm | SIUL2_MSCR_MUX_MODE_ALT1)
-
-#define SIUL2_PAD_CTRL_DSPI0_MSCR_SCK_OUT	(SIUL2_MSCR_OBE_EN | \
-				SIUL2_MSCR_DSE_34ohm | SIUL2_MSCR_MUX_MODE_ALT1)
-
-#define SIUL2_PAD_CTRL_DSPI0_MSCR_SIN_OUT	(SIUL2_MSCR_PUE_EN | \
-				SIUL2_MSCR_IBE_EN | SIUL2_MSCR_PUS_50K_UP)
-
-#define SIUL2_PB7_IMCR_SPI0_SIN    (800 - 512)
-
-#define SIUL2_PAD_CTRL_DSPI0_IMCR_SIN_IN	(SIUL2_MSCR_MUX_MODE_ALT2)
-
-#ifdef CONFIG_FSL_DCU_FB
-
-/* DCU Settings */
-
-#define SIUL2_MSCR_PH8  120
-#define SIUL2_MSCR_PH9  121
-#define SIUL2_MSCR_PH10 122
-#define SIUL2_MSCR_PH12 124
-#define SIUL2_MSCR_PH13 125
-#define SIUL2_MSCR_PH14 126
-#define SIUL2_MSCR_PH15 127
-#define SIUL2_MSCR_PJ0  128
-#define SIUL2_MSCR_PJ1  129
-#define SIUL2_MSCR_PJ2  130
-#define SIUL2_MSCR_PJ3  131
-#define SIUL2_MSCR_PJ4  132
-#define SIUL2_MSCR_PJ5  133
-#define SIUL2_MSCR_PJ6  134
-#define SIUL2_MSCR_PJ7  135
-#define SIUL2_MSCR_PJ8  136
-#define SIUL2_MSCR_PJ9  137
-#define SIUL2_MSCR_PJ10 138
-#define SIUL2_MSCR_PJ11 139
-#define SIUL2_MSCR_PJ12 140
-#define SIUL2_MSCR_PJ13 141
-#define SIUL2_MSCR_PJ14 142
-#define SIUL2_MSCR_PJ15 143
-#define SIUL2_MSCR_PK0  144
-#define SIUL2_MSCR_PK1  145
-#define SIUL2_MSCR_PK2  146
-#define SIUL2_MSCR_PK3  147
-#define SIUL2_MSCR_PK4  148
-
-/* DCU CFG = 0x20C101 */
-#define SIUL2_MSCR_DCU_CFG \
-	(SIUL2_MSCR_DSE_80ohm | \
-	 SIUL2_MSCR_SRE_SPEED_HIGH_200 | \
-	 SIUL2_MSCR_OBE_EN | SIUL2_MSCR_IBE_EN | \
-	 SIUL2_MSCR_MUX_MODE_ALT1)
-
-#endif /* CONFIG_FSL_DCU_FB */
-
-/* GPIO Settings */
-
-#define SIUL2_MSCR_PF9  89
-#define SIUL2_MSCR_PF11 91
-#define SIUL2_MSCR_PF12 92
-#define SIUL2_MSCR_PF13 93
-
-/* SIUL2 - General Purpose Input */
-#define SIUL2_MSCR_GPI \
-	(SIUL2_MSCR_MUX_MODE_ALT0 | \
-	 SIUL2_MSCR_IBE_EN | \
-	 SIUL2_MSCR_PKE_EN | \
-	 SIUL2_MSCR_PUE_EN)
-
-/* SIUL2 - General Purpose Output */
-#define SIUL2_MSCR_GPO \
-	(SIUL2_MSCR_MUX_MODE_ALT0 | \
-	 SIUL2_MSCR_OBE_EN | \
-	 SIUL2_MSCR_DSE_34ohm)
-
-#endif /*__ARCH_ARM_MACH_S32V234_SIUL_H__ */
diff --git a/arch/arm/include/asm/arch-s32/siul.h b/arch/arm/include/asm/arch-s32/siul.h
index 4f66878d0f..02e1518278 100644
--- a/arch/arm/include/asm/arch-s32/siul.h
+++ b/arch/arm/include/asm/arch-s32/siul.h
@@ -12,9 +12,8 @@
 #include <asm/io.h>
 #include <asm/arch/imx-regs.h>
 #include <linux/bitops.h>
-#include "ddr.h"
 
-#if defined(CONFIG_S32_GEN1) && !defined(CONFIG_TARGET_TYPE_S32GEN1_SIMULATOR)
+#if !defined(CONFIG_TARGET_TYPE_S32GEN1_SIMULATOR)
 #define SIUL2_MIDR1				(SIUL2_0_BASE_ADDR + 0x00000004)
 #define SIUL2_MIDR2				(SIUL2_0_BASE_ADDR + 0x00000008)
 #define SIUL2_DISR0				(SIUL2_0_BASE_ADDR + 0x00000010)
@@ -74,13 +73,7 @@
 
 #define TREERUNNER_GENERATION_2_MAJOR	1
 
-#if defined(CONFIG_S32V234)
-#include "siul-s32v234.h"
-#elif defined(CONFIG_S32_GEN1)
 #include "siul-s32-gen1.h"
-#else
-#error "Incomplete platform definition"
-#endif
 
 #ifdef CONFIG_NXP_S32G2XX
 enum s32g2_derivative {
@@ -147,7 +140,7 @@ static inline u32 get_siul2_midr2_freq(void)
 			>> SIUL2_MIDR2_FREQ_SHIFT);
 }
 
-#if defined(CONFIG_S32_GEN1) && !defined(CONFIG_TARGET_TYPE_S32GEN1_SIMULATOR)
+#if !defined(CONFIG_TARGET_TYPE_S32GEN1_SIMULATOR)
 
 static inline int get_siul2_midr2_subminor(void)
 {
@@ -162,4 +155,4 @@ static inline int is_serdes_subsystem_present(void)
 
 #endif  /* CONFIG_S32_GEN1 */
 
-#endif /*__ARCH_ARM_MACH_S32V234_SIUL_H__ */
+#endif /*____ARCH_ARM_MACH_S32_SIUL_H__ */
diff --git a/arch/arm/include/asm/arch-s32/soc.h b/arch/arm/include/asm/arch-s32/soc.h
index bad57d7b95..3a88c2a99f 100644
--- a/arch/arm/include/asm/arch-s32/soc.h
+++ b/arch/arm/include/asm/arch-s32/soc.h
@@ -1,7 +1,7 @@
 /* SPDX-License-Identifier: GPL-2.0+ */
 /*
  * Copyright 2015 Freescale Semiconductor
- * (C) Copyright 2017-2018,2020 NXP
+ * (C) Copyright 2017-2018,2020-2021 NXP
  */
 #ifndef __ARCH_S32_SOC_H
 #define __ARCH_S32_SOC_H
@@ -9,30 +9,13 @@
 #include <asm/arch/imx-regs.h>
 #include <asm/arch/siul.h>
 #include <asm/arch/clock.h>
-#include <asm/arch/xrdc.h>
 #include <asm/arch/mc_cgm_regs.h>
 #include <asm/arch/mc_me_regs.h>
 #include <asm/arch/mc_rgm_regs.h>
-#include <asm/arch/src.h>
 #include <asm/arch/mmdc.h>
-#include <asm/arch/ddr.h>
-#if defined(CONFIG_S32_LPDDR2)
-#include <asm/arch/lpddr2.h>
-#elif defined(CONFIG_S32_DDR3)
-#include <asm/arch/ddr3.h>
-#elif defined(CONFIG_S32_LPDDR4)
-#include <asm/arch/lpddr4.h>
-#else
-#error "Please define the DDR type!"
-#endif
-
 
 void setup_iomux_enet(void);
 
-#ifdef CONFIG_FSL_DCU_FB
-void setup_iomux_dcu(void);
-#endif
-
 #ifdef CONFIG_DCU_QOS_FIX
 int board_dcu_qos(void);
 #endif
diff --git a/arch/arm/include/asm/arch-s32/src.h b/arch/arm/include/asm/arch-s32/src.h
deleted file mode 100644
index 32e4370d44..0000000000
--- a/arch/arm/include/asm/arch-s32/src.h
+++ /dev/null
@@ -1,129 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0+ */
-/*
- * (C) Copyright 2017-2018,2020 NXP
- */
-
-#ifndef __ASM_ARCH_SRC_H__
-#define __ASM_ARCH_SRC_H__
-
-/*
- * SRC_BMR1 bit fields
- */
-#define SRC_BMR1_CFG1_MASK					(0xC0 << 0x0)
-#define SRC_BMR1_CFG1_BOOT_SHIFT				(6)
-#define SRC_BMR1_CFG1_QuadSPI					(0x0)
-#define SRC_BMR1_CFG1_SD					(0x2)
-#define SRC_BMR1_CFG1_eMMC					(0x3)
-
-/*
- * SRC_GPR1 bit fields
- */
-#define SRC_GPR1_PLL_SOURCE(pll,val)( ((val) & SRC_GPR1_PLL_SOURCE_MASK) << \
-					(SRC_GPR1_PLL_OFFSET + (pll)) )
-#define SRC_GPR1_PLL_SOURCE_MASK	(0x1)
-
-#define SRC_GPR1_PLL_OFFSET			(27)
-#define SRC_GPR1_FIRC_CLK_SOURCE	(0x0)
-#define SRC_GPR1_XOSC_CLK_SOURCE	(0x1)
-
-/* SRC_GPR3 */
-#define SRC_GPR3_ENET_MODE					BIT(1)
-#define SRC_GPR3_PCIE_RFCC_CLK					BIT(5)
-#define SRC_GPR3_PCCAS						BIT(4)
-
-/*
- * SRC_GPR5 bit fields
- */
-#define SRC_GPR5_PCIE_APPS_PM_XMT_PME				0
-#define SRC_GPR5_PCIE_DEVICE_TYPE_EP				(0x0 << 1)
-#define SRC_GPR5_PCIE_DEVICE_TYPE_RC				(0x4 << 1)
-#define SRC_GPR5_PCIE_DEVICE_TYPE_MASK				(0xf << 1)
-
-#define SRC_GPR5_PCIE_DIAG_CTRL_BUS_MASK			(0x7 << 5)
-#define SRC_GPR5_GPR_PCIE_SYS_INT				BIT(8)
-#define SRC_GPR5_PCIE_APP_LTSSM_ENABLE				BIT(9)
-#define SRC_GPR5_GPR_PCIE_APP_INIT_RST				BIT(11)
-#define SRC_GPR5_GPR_PCIE_APP_REQ_ENTR_L1			BIT(12)
-#define SRC_GPR5_GPR_PCIE_APP_READY_ENTR_L23			BIT(13)
-#define SRC_GPR5_GPR_PCIE_APP_REQ_EXIT_L1			BIT(14)
-#define SRC_GPR5_GPR_PCIE_BUTTON_RST_N				BIT(15)
-#define SRC_GPR5_GPR_PCIE_PERST_N				BIT(16)
-#define SRC_GPR5_PCIE_APPS_PM_XMT_TURNOFF			BIT(17)
-#define SRC_GPR5_PCIE_PHY_LOS_BIAS_MASK				(0x7 << 19)
-
-#define SRC_GPR5_PCIE_PHY_LOS_LEVEL_9				(0x9 << 22)
-#define SRC_GPR5_PCIE_PHY_LOS_LEVEL_MASK			(0x1f << 22)
-
-#define SRC_GPR5_PCIE_PHY_RX0_EQ_2					(0x2 << 27)
-#define SRC_GPR5_PCIE_PHY_RX0_EQ_MASK				(0x7 << 27)
-/*
- * SRC_GPR6 bit fields
- */
-#define SRC_GPR6_PCIE_PCS_TX_DEEMPH_GEN1_OFFSET			12
-#define SRC_GPR6_PCIE_PCS_TX_DEEMPH_GEN1_MASK			(0x3f << \
-				SRC_GPR6_PCIE_PCS_TX_DEEMPH_GEN1_OFFSET)
-#define SRC_GPR6_PCIE_PCS_TX_DEEMPH_GEN2_3P5DB_OFFSET		0
-#define SRC_GPR6_PCIE_PCS_TX_DEEMPH_GEN2_3P5DB_MASK		(0x3f << \
-				SRC_GPR6_PCIE_PCS_TX_DEEMPH_GEN2_3P5DB_OFFSET)
-#define SRC_GPR6_PCIE_PCS_TX_DEEMPH_GEN2_6DB_OFFSET		6
-#define SRC_GPR6_PCIE_PCS_TX_DEEMPH_GEN2_6DB_MASK		(0x3f << \
-				SRC_GPR6_PCIE_PCS_TX_DEEMPH_GEN2_6DB_OFFSET)
-#define SRC_GPR6_PCIE_PCS_TX_SWING_FULL_OFFSET			18
-#define SRC_GPR6_PCIE_PCS_TX_SWING_FULL_MASK			(0x7f << \
-				SRC_GPR6_PCIE_PCS_TX_SWING_FULL_OFFSET)
-#define SRC_GPR6_PCIE_PCS_TX_SWING_LOW_OFFSET			25
-
-/* SRC_DDR_SELF_REF_CTRL bit fields */
-#define SRC_DDR_EN_SELF_REF_CTRL_DDR0_EN_SLF_REF_RST		BIT(2)
-#define SRC_DDR_EN_SELF_REF_CTRL_DDR1_EN_SLF_REF_RST		BIT(3)
-#define SRC_DDR_EN_SELF_REF_CTRL_DDR0_SLF_REF_CLR		BIT(1)
-#define SRC_DDR_EN_SELF_REF_CTRL_DDR1_SLF_REF_CLR		1
-
-/* SRC registers values */
-#define SRC_DDR_EN_SLF_REF_VALUE \
-	(SRC_DDR_EN_SELF_REF_CTRL_DDR0_EN_SLF_REF_RST | \
-	SRC_DDR_EN_SELF_REF_CTRL_DDR1_EN_SLF_REF_RST)
-
-/* System Reset Controller (SRC) */
-struct src {
-	u32 bmr1;
-	u32 bmr2;
-	u32 gpr1_boot;
-	u32 reserved_0x00C[61];
-	u32 gpr1;
-	u32 gpr2;
-	u32 gpr3;
-	u32 gpr4;
-	u32 gpr5;
-	u32 gpr6;
-	u32 gpr7;		/* TREERUNNER_GENERATION_1 specific */
-	u32 gpr8;		/* TREERUNNER_GENERATION_2 specific */
-	u32 reserved_0x120[1];
-	u32 gpr10;
-	u32 gpr11;
-	u32 gpr12;
-	u32 gpr13;
-	u32 gpr14;
-	u32 gpr15;
-	u32 gpr16;
-	u32 reserved_0x140[1];
-	u32 gpr18;
-	u32 gpr19;
-	u32 gpr20;
-	u32 gpr21;
-	u32 gpr22;
-	u32 gpr23;
-	u32 gpr24;
-	u32 gpr25;
-	u32 gpr26;
-	u32 gpr27;
-	u32 reserved_0x16C[5];
-	u32 pcie_config1;
-	u32 ddr_self_ref_ctrl;
-	u32 pcie_config0;
-	u32 reserved_0x18C[3];
-	u32 soc_misc_config2;
-};
-
-#endif	/* __ASM_ARCH_SRC_H__ */
-
diff --git a/arch/arm/include/asm/arch-s32/xrdc.h b/arch/arm/include/asm/arch-s32/xrdc.h
deleted file mode 100644
index 247d462116..0000000000
--- a/arch/arm/include/asm/arch-s32/xrdc.h
+++ /dev/null
@@ -1,32 +0,0 @@
-/*
- * (C) Copyright 2015 Freescale Semiconductor, Inc.
- *
- * SPDX-License-Idenfifier:	GPL-2.0+
- */
-
-#ifndef __ASM_ARCH_XRDC_H
-#define __ASM_ARCH_XRDC_H
-
-#include "imx-regs.h"
-
-#define XRDC_ADDR_MIN    (0x00000000)
-#define XRDC_ADDR_MAX    (0xffffffff)
-#define XRDC_VALID       (0x80000000)
-
-#define XRDC_MRGD_W0_16   (XRDC_BASE_ADDR + 0x2200L)
-#define XRDC_MRGD_W1_16   (XRDC_BASE_ADDR + 0x2204L)
-#define XRDC_MRGD_W3_16   (XRDC_BASE_ADDR + 0x220CL)
-
-#define XRDC_MRGD_W0_17   (XRDC_BASE_ADDR + 0x2220L)
-#define XRDC_MRGD_W1_17   (XRDC_BASE_ADDR + 0x2224L)
-#define XRDC_MRGD_W3_17   (XRDC_BASE_ADDR + 0x222CL)
-
-#define XRDC_MRGD_W0_18   (XRDC_BASE_ADDR + 0x2240L)
-#define XRDC_MRGD_W1_18   (XRDC_BASE_ADDR + 0x2244L)
-#define XRDC_MRGD_W3_18   (XRDC_BASE_ADDR + 0x224CL)
-
-#define XRDC_MRGD_W0_19   (XRDC_BASE_ADDR + 0x2260L)
-#define XRDC_MRGD_W1_19   (XRDC_BASE_ADDR + 0x2264L)
-#define XRDC_MRGD_W3_19   (XRDC_BASE_ADDR + 0x226CL)
-
-#endif /* __ASM_ARCH_XRDC_H */
diff --git a/board/freescale/Kconfig b/board/freescale/Kconfig
index 5dddc99a89..b740936b7e 100644
--- a/board/freescale/Kconfig
+++ b/board/freescale/Kconfig
@@ -52,6 +52,4 @@ config XEN_SUPPORT
 	  to directly load the Xen Image which will use a given Kernel Image as
 	  Dom0.
 
-if S32_GEN1
 source "board/freescale/s32-gen1/Kconfig"
-endif
diff --git a/board/freescale/s32-gen1/Kconfig b/board/freescale/s32-gen1/Kconfig
index 347889f615..ba7f65b41d 100644
--- a/board/freescale/s32-gen1/Kconfig
+++ b/board/freescale/s32-gen1/Kconfig
@@ -80,7 +80,7 @@ config SYS_CONFIG_NAME
 
 config SYS_ERRATUM_ERR050543
 	bool "Workaround for NXP Erratum ERR050543"
-	default y if S32_LPDDR4 && (NXP_S32G2XX || NXP_S32R45) && \
+	default y if (NXP_S32G2XX || NXP_S32R45) && \
 			!TARGET_TYPE_S32GEN1_EMULATOR
 	help
 	  This option enables a workaround for NXP Erratum ERR050543
diff --git a/board/freescale/s32-gen1/board_common.h b/board/freescale/s32-gen1/board_common.h
index a6ec796ab4..a109659e84 100644
--- a/board/freescale/s32-gen1/board_common.h
+++ b/board/freescale/s32-gen1/board_common.h
@@ -16,9 +16,7 @@ void setup_iomux_uart(void);
 	void setup_iomux_dspi(void);
 #endif
 
-#if defined(CONFIG_S32_GEN1)
 void setup_iomux_uart0_pc09_pc10(void);
-#endif
 
 #if defined(CONFIG_TARGET_S32G274ASIM) || \
 	defined(CONFIG_TARGET_S32G274AEMU) || \
diff --git a/board/freescale/s32-gen1/ddr_utils.h b/board/freescale/s32-gen1/ddr_utils.h
index b0ddcae6ef..e2fc60351a 100644
--- a/board/freescale/s32-gen1/ddr_utils.h
+++ b/board/freescale/s32-gen1/ddr_utils.h
@@ -32,12 +32,7 @@
 #ifndef DDR_UTILS_H_
 #define DDR_UTILS_H_
 
-#ifndef CONFIG_S32_GEN1
-#include "io.h"
-#else
 #include <asm/io.h>
-#endif
-
 #include <stdbool.h>
 
 /* Possible errors */
diff --git a/common/image.c b/common/image.c
index 9febcd007c..25bf8de226 100644
--- a/common/image.c
+++ b/common/image.c
@@ -153,7 +153,6 @@ static const table_entry_t uimage_type[] = {
 	{	IH_TYPE_KERNEL_NOLOAD, "kernel_noload",  "Kernel Image (no loading done)", },
 	{	IH_TYPE_KWBIMAGE,   "kwbimage",   "Kirkwood Boot Image",},
 	{	IH_TYPE_IMXIMAGE,   "imximage",   "Freescale i.MX Boot Image",},
-	{	IH_TYPE_S32V234IMAGE,	"s32v234image",	"NXP S32V234 Boot Image",},
 	{	IH_TYPE_S32GEN1IMAGE,	"s32gen1image",	"NXP S32GEN1 Boot Image",},
 	{	IH_TYPE_IMX8IMAGE,  "imx8image",  "NXP i.MX8 Boot Image",},
 	{	IH_TYPE_IMX8MIMAGE, "imx8mimage", "NXP i.MX8M Boot Image",},
diff --git a/configs/s32g274a_emu_defconfig b/configs/s32g274a_emu_defconfig
index 98a957b570..3de5616bd0 100644
--- a/configs/s32g274a_emu_defconfig
+++ b/configs/s32g274a_emu_defconfig
@@ -4,7 +4,6 @@ CONFIG_ENV_SIZE=0x2000
 CONFIG_ENV_OFFSET=0x1e0000
 CONFIG_NR_DRAM_BANKS=3
 CONFIG_TARGET_S32G274AEMU=y
-CONFIG_S32_LPDDR4=y
 CONFIG_DISTRO_DEFAULTS=y
 # CONFIG_SYS_MALLOC_F is not set
 # CONFIG_SYS_MALLOC_CLEAR_ON_INIT is not set
diff --git a/configs/s32g274a_sim_defconfig b/configs/s32g274a_sim_defconfig
index d6c035e3b0..3aa8c248d7 100644
--- a/configs/s32g274a_sim_defconfig
+++ b/configs/s32g274a_sim_defconfig
@@ -4,7 +4,6 @@ CONFIG_SYS_TEXT_BASE=0x380a0000
 CONFIG_ENV_SIZE=0x2000
 CONFIG_NR_DRAM_BANKS=3
 CONFIG_TARGET_S32G274ASIM=y
-CONFIG_S32_LPDDR4=y
 CONFIG_DISTRO_DEFAULTS=y
 # CONFIG_SYS_MALLOC_F is not set
 CONFIG_FIT=y
diff --git a/configs/s32g274abluebox3_defconfig b/configs/s32g274abluebox3_defconfig
index 7c678c2f5c..badfec3592 100644
--- a/configs/s32g274abluebox3_defconfig
+++ b/configs/s32g274abluebox3_defconfig
@@ -4,7 +4,6 @@ CONFIG_ENV_SIZE=0x2000
 CONFIG_ENV_OFFSET=0x1e0000
 CONFIG_NR_DRAM_BANKS=3
 CONFIG_TARGET_S32G274ABLUEBOX3=y
-CONFIG_S32_LPDDR4=y
 # CONFIG_S32GEN1_DRAM_INLINE_ECC is not set
 CONFIG_DISTRO_DEFAULTS=y
 # CONFIG_SYS_MALLOC_F is not set
diff --git a/configs/s32g274abluebox3_qspi_defconfig b/configs/s32g274abluebox3_qspi_defconfig
index 422ca645bf..1d5c12d40d 100644
--- a/configs/s32g274abluebox3_qspi_defconfig
+++ b/configs/s32g274abluebox3_qspi_defconfig
@@ -6,7 +6,6 @@ CONFIG_ENV_SECT_SIZE=0x1000
 CONFIG_ENV_OFFSET=0x1e0000
 CONFIG_NR_DRAM_BANKS=3
 CONFIG_TARGET_S32G274ABLUEBOX3=y
-CONFIG_S32_LPDDR4=y
 # CONFIG_S32GEN1_DRAM_INLINE_ECC is not set
 CONFIG_DISTRO_DEFAULTS=y
 # CONFIG_SYS_MALLOC_F is not set
diff --git a/configs/s32g274ardb2_defconfig b/configs/s32g274ardb2_defconfig
index 3270ada808..a56b9235dc 100644
--- a/configs/s32g274ardb2_defconfig
+++ b/configs/s32g274ardb2_defconfig
@@ -4,7 +4,6 @@ CONFIG_ENV_SIZE=0x2000
 CONFIG_ENV_OFFSET=0x1e0000
 CONFIG_NR_DRAM_BANKS=3
 CONFIG_TARGET_S32G274ARDB=y
-CONFIG_S32_LPDDR4=y
 CONFIG_DISTRO_DEFAULTS=y
 # CONFIG_SYS_MALLOC_F is not set
 CONFIG_TOOLS_DEBUG=y
diff --git a/configs/s32g274ardb2_qspi_defconfig b/configs/s32g274ardb2_qspi_defconfig
index 7b465f5c51..252ab014da 100644
--- a/configs/s32g274ardb2_qspi_defconfig
+++ b/configs/s32g274ardb2_qspi_defconfig
@@ -6,7 +6,6 @@ CONFIG_ENV_SECT_SIZE=0x10000
 CONFIG_ENV_OFFSET=0x1e0000
 CONFIG_NR_DRAM_BANKS=3
 CONFIG_TARGET_S32G274ARDB=y
-CONFIG_S32_LPDDR4=y
 CONFIG_DISTRO_DEFAULTS=y
 # CONFIG_SYS_MALLOC_F is not set
 CONFIG_TOOLS_DEBUG=y
diff --git a/configs/s32g2xxaevb_defconfig b/configs/s32g2xxaevb_defconfig
index 78b0361eab..3f263b8ce4 100644
--- a/configs/s32g2xxaevb_defconfig
+++ b/configs/s32g2xxaevb_defconfig
@@ -4,7 +4,6 @@ CONFIG_ENV_SIZE=0x2000
 CONFIG_ENV_OFFSET=0x1e0000
 CONFIG_NR_DRAM_BANKS=3
 CONFIG_TARGET_S32G2XXAEVB=y
-CONFIG_S32_LPDDR4=y
 CONFIG_DISTRO_DEFAULTS=y
 # CONFIG_SYS_MALLOC_F is not set
 CONFIG_TOOLS_DEBUG=y
diff --git a/configs/s32g2xxaevb_qspi_defconfig b/configs/s32g2xxaevb_qspi_defconfig
index 9ccba12c84..b911e5c915 100644
--- a/configs/s32g2xxaevb_qspi_defconfig
+++ b/configs/s32g2xxaevb_qspi_defconfig
@@ -6,7 +6,6 @@ CONFIG_ENV_SECT_SIZE=0x10000
 CONFIG_ENV_OFFSET=0x1e0000
 CONFIG_NR_DRAM_BANKS=3
 CONFIG_TARGET_S32G2XXAEVB=y
-CONFIG_S32_LPDDR4=y
 CONFIG_DISTRO_DEFAULTS=y
 # CONFIG_SYS_MALLOC_F is not set
 CONFIG_TOOLS_DEBUG=y
diff --git a/configs/s32g399a_emu_defconfig b/configs/s32g399a_emu_defconfig
index b9014bb76f..3bef596f3f 100644
--- a/configs/s32g399a_emu_defconfig
+++ b/configs/s32g399a_emu_defconfig
@@ -4,7 +4,6 @@ CONFIG_ENV_SIZE=0x2000
 CONFIG_ENV_OFFSET=0x1e0000
 CONFIG_NR_DRAM_BANKS=3
 CONFIG_TARGET_S32G399AEMU=y
-CONFIG_S32_LPDDR4=y
 CONFIG_DISTRO_DEFAULTS=y
 # CONFIG_SYS_MALLOC_F is not set
 # CONFIG_SYS_MALLOC_CLEAR_ON_INIT is not set
diff --git a/configs/s32g3xxaevb_defconfig b/configs/s32g3xxaevb_defconfig
index efbbba15d0..8d0ec92276 100644
--- a/configs/s32g3xxaevb_defconfig
+++ b/configs/s32g3xxaevb_defconfig
@@ -4,7 +4,6 @@ CONFIG_ENV_SIZE=0x2000
 CONFIG_ENV_OFFSET=0x1e0000
 CONFIG_NR_DRAM_BANKS=3
 CONFIG_TARGET_S32G3XXAEVB=y
-CONFIG_S32_LPDDR4=y
 CONFIG_DISTRO_DEFAULTS=y
 # CONFIG_SYS_MALLOC_F is not set
 CONFIG_TOOLS_DEBUG=y
diff --git a/configs/s32g3xxaevb_qspi_defconfig b/configs/s32g3xxaevb_qspi_defconfig
index bd01b09503..a70895d8b9 100644
--- a/configs/s32g3xxaevb_qspi_defconfig
+++ b/configs/s32g3xxaevb_qspi_defconfig
@@ -6,7 +6,6 @@ CONFIG_ENV_SECT_SIZE=0x10000
 CONFIG_ENV_OFFSET=0x1e0000
 CONFIG_NR_DRAM_BANKS=3
 CONFIG_TARGET_S32G3XXAEVB=y
-CONFIG_S32_LPDDR4=y
 CONFIG_DISTRO_DEFAULTS=y
 # CONFIG_SYS_MALLOC_F is not set
 CONFIG_TOOLS_DEBUG=y
diff --git a/configs/s32r45_emu_defconfig b/configs/s32r45_emu_defconfig
index a308da3ccf..bd3c18d582 100644
--- a/configs/s32r45_emu_defconfig
+++ b/configs/s32r45_emu_defconfig
@@ -4,7 +4,6 @@ CONFIG_ARCH_S32=y
 CONFIG_ENV_SIZE=0x2000
 CONFIG_NR_DRAM_BANKS=3
 CONFIG_TARGET_S32R45EMU=y
-CONFIG_S32_LPDDR4=y
 CONFIG_DISTRO_DEFAULTS=y
 # CONFIG_SYS_MALLOC_F is not set
 # CONFIG_SYS_MALLOC_CLEAR_ON_INIT is not set
diff --git a/configs/s32r45_sim_defconfig b/configs/s32r45_sim_defconfig
index eb8956eeb3..02cf4e7dec 100644
--- a/configs/s32r45_sim_defconfig
+++ b/configs/s32r45_sim_defconfig
@@ -4,7 +4,6 @@ CONFIG_SYS_TEXT_BASE=0x380a0000
 CONFIG_ENV_SIZE=0x2000
 CONFIG_NR_DRAM_BANKS=3
 CONFIG_TARGET_S32R45SIM=y
-CONFIG_S32_LPDDR4=y
 CONFIG_DISTRO_DEFAULTS=y
 # CONFIG_SYS_MALLOC_F is not set
 CONFIG_FIT=y
diff --git a/configs/s32r45evb_defconfig b/configs/s32r45evb_defconfig
index c9fbc1b901..82d92cac3f 100644
--- a/configs/s32r45evb_defconfig
+++ b/configs/s32r45evb_defconfig
@@ -4,7 +4,6 @@ CONFIG_ENV_SIZE=0x2000
 CONFIG_ENV_OFFSET=0x1e0000
 CONFIG_NR_DRAM_BANKS=3
 CONFIG_TARGET_S32R45EVB=y
-CONFIG_S32_LPDDR4=y
 CONFIG_DISTRO_DEFAULTS=y
 # CONFIG_SYS_MALLOC_F is not set
 # CONFIG_SYS_MALLOC_CLEAR_ON_INIT is not set
diff --git a/configs/s32r45evb_qspi_defconfig b/configs/s32r45evb_qspi_defconfig
index 42a9013c2d..91559f6797 100644
--- a/configs/s32r45evb_qspi_defconfig
+++ b/configs/s32r45evb_qspi_defconfig
@@ -6,7 +6,6 @@ CONFIG_ENV_SECT_SIZE=0x10000
 CONFIG_ENV_OFFSET=0x1e0000
 CONFIG_NR_DRAM_BANKS=3
 CONFIG_TARGET_S32R45EVB=y
-CONFIG_S32_LPDDR4=y
 CONFIG_DISTRO_DEFAULTS=y
 # CONFIG_SYS_MALLOC_F is not set
 # CONFIG_SYS_MALLOC_CLEAR_ON_INIT is not set
diff --git a/drivers/i2c/mxc_i2c.c b/drivers/i2c/mxc_i2c.c
index 0a75e3b7fd..860efc89fa 100644
--- a/drivers/i2c/mxc_i2c.c
+++ b/drivers/i2c/mxc_i2c.c
@@ -698,7 +698,7 @@ static int bus_i2c_write(struct mxc_i2c_bus *i2c_bus, u8 chip, u32 addr,
 
 static struct mxc_i2c_bus mxc_i2c_buses[] = {
 #if defined(CONFIG_LS1021A) || defined(CONFIG_VF610) || \
-	defined(CONFIG_FSL_LAYERSCAPE) || defined(CONFIG_S32V234) || \
+	defined(CONFIG_FSL_LAYERSCAPE) || \
 	defined(CONFIG_SAC58R) || defined(CONFIG_MAC57D5XH) || \
 	defined(CONFIG_S32_GEN1)
 	{ 0, I2C1_BASE_ADDR, I2C_QUIRK_FLAG },
diff --git a/drivers/net/dwc_eth_qos_s32cc.c b/drivers/net/dwc_eth_qos_s32cc.c
index 2ae2de8148..5924c854c0 100644
--- a/drivers/net/dwc_eth_qos_s32cc.c
+++ b/drivers/net/dwc_eth_qos_s32cc.c
@@ -6,7 +6,7 @@
 
 /*
  * s32cc:
- *    NXP S32G/S32R/S32V chips.
+ *    NXP S32G and S32R chips.
  *    Based on Synopsys DW EQOS MAC 5.10a
  *
  */
diff --git a/drivers/net/fec_mxc.c b/drivers/net/fec_mxc.c
index 9006afb97d..30d12c181d 100644
--- a/drivers/net/fec_mxc.c
+++ b/drivers/net/fec_mxc.c
@@ -1,6 +1,6 @@
 // SPDX-License-Identifier: GPL-2.0+
 /*
- * (C) Copyright 2018,2020 NXP
+ * (C) Copyright 2018,2020-2021 NXP
  * (C) Copyright 2009 Ilya Yanok, Emcraft Systems Ltd <yanok@emcraft.com>
  * (C) Copyright 2008,2009 Eric Jarrige <eric.jarrige@armadeus.org>
  * (C) Copyright 2008 Armadeus Systems nc
@@ -625,10 +625,8 @@ static int fec_init(struct eth_device *dev, bd_t *bd)
 			writel(0, i);
 		for (i = mib_ptr_start2; i < mib_ptr_end2; i++)
 			writel(0, i);
-#if !defined(CONFIG_S32V234)
 		/* FIFO receive start register */
 		writel(0x520, &fec->eth->r_fstart);
-#endif
 	}
 
 	/* size and address of each buffer */
diff --git a/drivers/net/fec_mxc.h b/drivers/net/fec_mxc.h
index f0cfd6e660..d68980f8a5 100644
--- a/drivers/net/fec_mxc.h
+++ b/drivers/net/fec_mxc.h
@@ -96,13 +96,8 @@ struct ethernet_regs {
 	uint32_t ieee_t_sqe;		/* MBAR_ETH + 0x26C */
 	uint32_t t_fdxfc;		/* MBAR_ETH + 0x270 */
 	uint32_t ieee_t_octets_ok;	/* MBAR_ETH + 0x274 */
-
-#if defined(CONFIG_S32V234)
-	uint32_t res13[3];		/* MBAR_ETH + 0x278-280 */
-#else
 	uint32_t res13[2];		/* MBAR_ETH + 0x278-27C */
 	uint32_t rmon_r_drop;		/* MBAR_ETH + 0x280 */
-#endif
 	uint32_t rmon_r_packets;	/* MBAR_ETH + 0x284 */
 	uint32_t rmon_r_bc_pkt;		/* MBAR_ETH + 0x288 */
 	uint32_t rmon_r_mc_pkt;		/* MBAR_ETH + 0x28C */
diff --git a/drivers/pci/Makefile b/drivers/pci/Makefile
index dfe7f9b72e..d2942d1c73 100644
--- a/drivers/pci/Makefile
+++ b/drivers/pci/Makefile
@@ -24,7 +24,6 @@ obj-$(CONFIG_PCI_GT64120) += pci_gt64120.o
 obj-$(CONFIG_PCI_MPC85XX) += pci_mpc85xx.o
 obj-$(CONFIG_PCI_MSC01) += pci_msc01.o
 obj-$(CONFIG_PCIE_IMX) += pcie_imx.o
-obj-$(CONFIG_PCIE_S32V234) += pcie_s32v2xx.o
 obj-$(CONFIG_SERDES_S32GEN1) += serdes_s32gen1.o
 obj-$(CONFIG_PCIE_S32GEN1) += pcie_s32gen1.o
 obj-$(CONFIG_FTPCI100) += pci_ftpci100.o
diff --git a/drivers/pci/pcie_s32v2xx.c b/drivers/pci/pcie_s32v2xx.c
deleted file mode 100644
index b7aa56dcdc..0000000000
--- a/drivers/pci/pcie_s32v2xx.c
+++ /dev/null
@@ -1,819 +0,0 @@
-/*
- * Freescale S32V234 PCI Express driver
- *
- * Copyright (C) 2016 Heinz Wrobel <heinz.wrobel@nxp.com>
- * Copyright (C) 2015 Aurelian Voicu <aurelian.voicu@nxp.com>
- * Copyright 2016-2017, 2020 NXP
- * (C) Copyright 2018 MicroSys Electronics GmbH
- *
- * Based on upstream iMX U-Boot driver:
- * pcie_imx.c:		Marek Vasut <marex@denx.de>
- *
- * SPDX-License-Identifier:	GPL-2.0
- */
-
-/* #define DEBUG */
-
-#include <common.h>
-#include <pci.h>
-#include <hwconfig.h>
-#include <asm/arch/clock.h>
-#include <asm/arch/siul.h>
-#include <asm/arch/soc.h>
-#include <asm/arch/src.h>
-#include <asm/arch/mc_me_regs.h>
-#include <asm/arch/mc_cgm_regs.h>
-#include <asm/io.h>
-#include <asm/gicsupport.h>
-#include <linux/sizes.h>
-#include <errno.h>
-
-#define PCI_ACCESS_READ  0
-#define PCI_ACCESS_WRITE 1
-
-#define MMDC0_ARB_BASE_ADDR	0x80000000
-#define S32V234_DBI_ADDR	0x72FFC000
-#define S32V234_IO_ADDR		0x72000000
-#define S32V234_MEM_ADDR	0x72100000
-#define S32V234_ROOT_ADDR	0x72f00000
-#define S32V234_DBI_SIZE	0x4000
-#define S32V234_IO_SIZE		0x100000
-#define S32V234_MEM_SIZE	0xe00000
-#define S32V234_ROOT_SIZE	0xfc000
-
-/* PCIe Port Logic registers (memory-mapped) */
-#define PL_OFFSET 0x700
-#define PCIE_PHY_DEBUG_R0 (PL_OFFSET + 0x28)
-#define PCIE_PHY_DEBUG_R1 (PL_OFFSET + 0x2c)
-#define PCIE_PHY_DEBUG_R1_LINK_UP		(1 << 4)
-#define PCIE_PHY_DEBUG_R1_LINK_IN_TRAINING	(1 << 29)
-
-#define PCIE_PHY_CTRL (PL_OFFSET + 0x114)
-#define PCIE_PHY_CTRL_DATA_LOC 0
-#define PCIE_PHY_CTRL_CAP_ADR_LOC 16
-#define PCIE_PHY_CTRL_CAP_DAT_LOC 17
-#define PCIE_PHY_CTRL_WR_LOC 18
-#define PCIE_PHY_CTRL_RD_LOC 19
-
-#define PCIE_PHY_STAT (PL_OFFSET + 0x110)
-#define PCIE_PHY_STAT_DATA_LOC 0
-#define PCIE_PHY_STAT_ACK_LOC 16
-
-/* PHY registers (not memory-mapped) */
-#define PCIE_PHY_RX_ASIC_OUT 0x100D
-
-#define PHY_RX_OVRD_IN_LO 0x1005
-#define PHY_RX_OVRD_IN_LO_RX_DATA_EN (1 << 5)
-#define PHY_RX_OVRD_IN_LO_RX_PLL_EN (1 << 3)
-
-/* iATU registers */
-#define PCIE_ATU_VIEWPORT		0x900
-#define PCIE_ATU_REGION_INBOUND		(0x1 << 31)
-#define PCIE_ATU_REGION_OUTBOUND	(0x0 << 31)
-#define PCIE_ATU_REGION_INDEX1		(0x1 << 0)
-#define PCIE_ATU_REGION_INDEX0		(0x0 << 0)
-#define PCIE_ATU_CR1			0x904
-#define PCIE_ATU_TYPE_MEM		(0x0 << 0)
-#define PCIE_ATU_TYPE_IO		(0x2 << 0)
-#define PCIE_ATU_TYPE_CFG0		(0x4 << 0)
-#define PCIE_ATU_TYPE_CFG1		(0x5 << 0)
-#define PCIE_ATU_CR2			0x908
-#define PCIE_ATU_ENABLE			(0x1 << 31)
-#define PCIE_ATU_BAR_MODE_ENABLE	(0x1 << 30)
-#define PCIE_ATU_LOWER_BASE		0x90C
-#define PCIE_ATU_UPPER_BASE		0x910
-#define PCIE_ATU_LIMIT			0x914
-#define PCIE_ATU_LOWER_TARGET		0x918
-#define PCIE_ATU_BUS(x)			(((x) & 0xff) << 24)
-#define PCIE_ATU_DEV(x)			(((x) & 0x1f) << 19)
-#define PCIE_ATU_FUNC(x)		(((x) & 0x7) << 16)
-#define PCIE_ATU_UPPER_TARGET		0x91C
-
-/* The following defines are used for EP mode only */
-#define MSI_REGION			0x72FB0000
-#define PCI_BASE_ADDR			0x72000000
-#define PCI_BASE_DBI			0x72FFC000
-#define MSI_REGION_NR			3
-#define NR_REGIONS			4
-#define PCI_REGION_MEM			0x00000000 /* PCI mem space */
-#define PCI_REGION_IO			0x00000001 /* PCI IO space */
-#define PCI_WIDTH_32b			0x00000000 /* 32-bit BAR */
-#define PCI_WIDTH_64b			0x00000004 /* 64-bit BAR */
-#define PCI_REGION_PREFETCH		0x00000008 /* prefetch PCI mem */
-#define PCI_REGION_NON_PREFETCH		0x00000000 /* non-prefetch PCI mem */
-#define PCIE_BAR0_SIZE			SZ_1M		/* 1MB */
-#define PCIE_BAR1_SIZE			0
-#define PCIE_BAR2_SIZE			SZ_1M		/* 1MB */
-#define PCIE_BAR3_SIZE			0
-#define PCIE_BAR4_SIZE			0
-#define PCIE_BAR5_SIZE			0
-#define PCIE_ROM_SIZE			0
-#define PCIE_BAR0_EN_DIS		1
-#define PCIE_BAR1_EN_DIS		0
-#define PCIE_BAR2_EN_DIS		1
-#define PCIE_BAR3_EN_DIS		1
-#define PCIE_BAR4_EN_DIS		1
-#define PCIE_BAR5_EN_DIS		1
-#define PCIE_ROM_EN_DIS			0
-#define PCIE_BAR0_INIT	(PCI_REGION_MEM | PCI_WIDTH_32b | \
-		PCI_REGION_NON_PREFETCH)
-#define PCIE_BAR1_INIT	(PCI_REGION_MEM | PCI_WIDTH_32b | \
-		PCI_REGION_NON_PREFETCH)
-#define PCIE_BAR2_INIT	(PCI_REGION_MEM | PCI_WIDTH_32b | \
-		PCI_REGION_NON_PREFETCH)
-#define PCIE_BAR3_INIT	(PCI_REGION_MEM | PCI_WIDTH_32b | \
-		PCI_REGION_NON_PREFETCH)
-#define PCIE_BAR4_INIT	0
-#define PCIE_BAR5_INIT	0
-#define PCIE_ROM_INIT	0
-
-/* To do proper EP support, we need to have interrupt driven handlers
- * to keep our EP configuration in proper shape.
- */
-#define PCIE_INTERRUPT_link_req_rst_not         135
-
-/* Global variables */
-static int ignoreERR009852;
-
-/*
- * PHY access functions
- */
- /* FIX: The RM does not document any of this. How should it be
-  * possible to understand any of the PHY handling if it is a hard
-  * requirement. Do we have to reinstate PHY docs in the manual?
-  * If so, what parts?
-  */
-static int pcie_phy_poll_ack(void __iomem *dbi_base, int exp_val)
-{
-	u32 val;
-	u32 max_iterations = 10;
-	u32 wait_counter = 0;
-
-	do {
-		val = readl(dbi_base + PCIE_PHY_STAT);
-		val = (val >> PCIE_PHY_STAT_ACK_LOC) & 0x1;
-		wait_counter++;
-
-		if (val == exp_val)
-			return 0;
-
-		udelay(1);
-	} while (wait_counter < max_iterations);
-
-	return -ETIMEDOUT;
-}
-
-static int pcie_phy_wait_ack(void __iomem *dbi_base, int addr)
-{
-	u32 val;
-	int ret;
-
-	val = addr << PCIE_PHY_CTRL_DATA_LOC;
-	writel(val, dbi_base + PCIE_PHY_CTRL);
-
-	val |= (0x1 << PCIE_PHY_CTRL_CAP_ADR_LOC);
-	writel(val, dbi_base + PCIE_PHY_CTRL);
-
-	ret = pcie_phy_poll_ack(dbi_base, 1);
-	if (ret)
-		return ret;
-
-	val = addr << PCIE_PHY_CTRL_DATA_LOC;
-	writel(val, dbi_base + PCIE_PHY_CTRL);
-
-	ret = pcie_phy_poll_ack(dbi_base, 0);
-	if (ret)
-		return ret;
-
-	return 0;
-}
-
-/* Read from the 16-bit PCIe PHY control registers (not memory-mapped) */
-static int pcie_phy_read(void __iomem *dbi_base, int addr, int *data)
-{
-	u32 val, phy_ctl;
-	int ret;
-
-	ret = pcie_phy_wait_ack(dbi_base, addr);
-	if (ret)
-		return ret;
-
-	/* assert Read signal */
-	phy_ctl = 0x1 << PCIE_PHY_CTRL_RD_LOC;
-	writel(phy_ctl, dbi_base + PCIE_PHY_CTRL);
-
-	ret = pcie_phy_poll_ack(dbi_base, 1);
-	if (ret)
-		return ret;
-
-	val = readl(dbi_base + PCIE_PHY_STAT);
-	*data = val & 0xffff;
-
-	/* deassert Read signal */
-	writel(0x00, dbi_base + PCIE_PHY_CTRL);
-
-	ret = pcie_phy_poll_ack(dbi_base, 0);
-	if (ret)
-		return ret;
-
-	return 0;
-}
-
-static int pcie_phy_write(void __iomem *dbi_base, int addr, int data)
-{
-	u32 var;
-	int ret;
-
-	/* write addr */
-	/* cap addr */
-	ret = pcie_phy_wait_ack(dbi_base, addr);
-	if (ret)
-		return ret;
-
-	var = data << PCIE_PHY_CTRL_DATA_LOC;
-	writel(var, dbi_base + PCIE_PHY_CTRL);
-
-	/* capture data */
-	var |= (0x1 << PCIE_PHY_CTRL_CAP_DAT_LOC);
-	writel(var, dbi_base + PCIE_PHY_CTRL);
-
-	ret = pcie_phy_poll_ack(dbi_base, 1);
-	if (ret)
-		return ret;
-
-	/* deassert cap data */
-	var = data << PCIE_PHY_CTRL_DATA_LOC;
-	writel(var, dbi_base + PCIE_PHY_CTRL);
-
-	/* wait for ack de-assertion */
-	ret = pcie_phy_poll_ack(dbi_base, 0);
-	if (ret)
-		return ret;
-
-	/* assert wr signal */
-	var = 0x1 << PCIE_PHY_CTRL_WR_LOC;
-	writel(var, dbi_base + PCIE_PHY_CTRL);
-
-	/* wait for ack */
-	ret = pcie_phy_poll_ack(dbi_base, 1);
-	if (ret)
-		return ret;
-
-	/* deassert wr signal */
-	var = data << PCIE_PHY_CTRL_DATA_LOC;
-	writel(var, dbi_base + PCIE_PHY_CTRL);
-
-	/* wait for ack de-assertion */
-	ret = pcie_phy_poll_ack(dbi_base, 0);
-	if (ret)
-		return ret;
-
-	writel(0x0, dbi_base + PCIE_PHY_CTRL);
-
-	return 0;
-}
-
-static int s32v234_pcie_link_up(void)
-{
-	u32 rc, ltssm;
-	int rx_valid, temp;
-
-	/* link is debug bit 36, debug register 1 starts at bit 32 */
-	rc = readl(S32V234_DBI_ADDR + PCIE_PHY_DEBUG_R1);
-	if ((rc & PCIE_PHY_DEBUG_R1_LINK_UP) &&
-	    !(rc & PCIE_PHY_DEBUG_R1_LINK_IN_TRAINING))
-		return -EAGAIN;
-
-	/*
-	 * From L0, initiate MAC entry to gen2 if EP/RC supports gen2.
-	 * Wait 2ms (LTSSM timeout is 24ms, PHY lock is ~5us in gen2).
-	 * If (MAC/LTSSM.state == Recovery.RcvrLock)
-	 * && (PHY/rx_valid==0) then pulse PHY/rx_reset. Transition
-	 * to gen2 is stuck
-	 */
-	pcie_phy_read((void *)S32V234_DBI_ADDR, PCIE_PHY_RX_ASIC_OUT,
-		      &rx_valid);
-	ltssm = readl(S32V234_DBI_ADDR + PCIE_PHY_DEBUG_R0) & 0x3F;
-
-	if (rx_valid & 0x01)
-		return 0;
-
-	if (ltssm != 0x0d)
-		return 0;
-
-	printf("transition to gen2 is stuck, reset PHY!\n");
-
-	pcie_phy_read((void *)S32V234_DBI_ADDR, PHY_RX_OVRD_IN_LO, &temp);
-	temp |= (PHY_RX_OVRD_IN_LO_RX_DATA_EN | PHY_RX_OVRD_IN_LO_RX_PLL_EN);
-	pcie_phy_write((void *)S32V234_DBI_ADDR, PHY_RX_OVRD_IN_LO, temp);
-
-	mdelay(3);
-
-	pcie_phy_read((void *)S32V234_DBI_ADDR, PHY_RX_OVRD_IN_LO, &temp);
-	temp &= ~(PHY_RX_OVRD_IN_LO_RX_DATA_EN | PHY_RX_OVRD_IN_LO_RX_PLL_EN);
-	pcie_phy_write((void *)S32V234_DBI_ADDR, PHY_RX_OVRD_IN_LO, temp);
-
-	return 0;
-}
-
-static void s32v234_pcie_set_bar(int baroffset, int enable,
-				 unsigned int size,
-				 unsigned int init)
-{
-	char __iomem *dbi_base = (char __iomem *)S32V234_DBI_ADDR;
-	uint32_t mask = (enable) ? ((size - 1) & ~1) : 0;
-
-	/* According to the RM, you have to enable the BAR before you
-	 * can modify the mask value. While it appears that this may
-	 * be ok in a single write anyway, we play it safe.
-	 */
-	writel(1, dbi_base + 0x1000 + baroffset);
-
-	writel(enable | mask, dbi_base + 0x1000 + baroffset);
-	writel(init, dbi_base + baroffset);
-}
-
-static void set_non_sticky_config_regs(void)
-{
-	const int socmask_info = readl(SIUL2_MIDR1) & 0x000000ff;
-	const struct src *src_regs = (struct src *)SRC_SOC_BASE_ADDR;
-	const int ep_mode = (readl(&src_regs->gpr5) & 0x0000001c) == 0;
-
-	/* We need this function because the PCIe IP loses some
-	 * configuration values when it loses the link.
-	 * THIS FUNCTION MUST BE INTERRUPT SAFE, so we don't use
-	 * external complex functions.
-	 */
-	if (!ep_mode) {
-		/* Set the CLASS_REV of RC CFG header to PCI_CLASS_BRIDGE_PCI */
-		setbits_le32(S32V234_DBI_ADDR + PCI_CLASS_REVISION,
-			     PCI_CLASS_BRIDGE_PCI << 16);
-
-		/* CMD reg:I/O space, MEM space, and Bus Master Enable */
-		setbits_le32(S32V234_DBI_ADDR | PCI_COMMAND,
-			     PCI_COMMAND_IO | PCI_COMMAND_MEMORY |
-			     PCI_COMMAND_MASTER);
-
-		/* Region #0 is used for Outbound CFG space access. */
-		writel(0, S32V234_DBI_ADDR + PCIE_ATU_VIEWPORT);
-		writel(S32V234_ROOT_ADDR,
-		       S32V234_DBI_ADDR + PCIE_ATU_LOWER_BASE);
-		writel(0, S32V234_DBI_ADDR + PCIE_ATU_UPPER_BASE);
-		writel(S32V234_ROOT_ADDR + S32V234_ROOT_SIZE,
-		       S32V234_DBI_ADDR + PCIE_ATU_LIMIT);
-		writel(0, S32V234_DBI_ADDR + PCIE_ATU_LOWER_TARGET);
-		writel(0, S32V234_DBI_ADDR + PCIE_ATU_UPPER_TARGET);
-		writel(PCIE_ATU_TYPE_CFG0, S32V234_DBI_ADDR + PCIE_ATU_CR1);
-		writel(PCIE_ATU_ENABLE, S32V234_DBI_ADDR + PCIE_ATU_CR2);
-	} else {
-		/* Set the CLASS_REV of RC CFG header to something that
-		 * makes sense for this SoC by itself. For a product,
-		 * the class setting should be board/product specific,
-		 * so we'd technically need a CONFIG_PCIE_CLASS as part
-		 * of the board configuration.
-		 */
-		setbits_le32(S32V234_DBI_ADDR + PCI_CLASS_REVISION,
-			     (PCI_BASE_CLASS_PROCESSOR << 24) |
-			     (0x80 /* other */ << 16));
-
-		/* Preconfigure the BAR registers, so that the RC can
-		 * enumerate us properly and assign address spaces.
-		 * Mask registers are W only!
-		 */
-		if (!ignoreERR009852 && (socmask_info == 0x00)) {
-			/* Erratum ERR009852 requires us to avoid
-			 * any memory access from the RC! We solve this
-			 * by disabling all BARs and ROM access
-			 */
-			s32v234_pcie_set_bar(PCI_BASE_ADDRESS_0,
-					     0, 0, 0);
-			s32v234_pcie_set_bar(PCI_BASE_ADDRESS_1,
-					     0, 0, 0);
-			s32v234_pcie_set_bar(PCI_BASE_ADDRESS_2,
-					     0, 0, 0);
-			s32v234_pcie_set_bar(PCI_BASE_ADDRESS_3,
-					     0, 0, 0);
-			s32v234_pcie_set_bar(PCI_BASE_ADDRESS_4,
-					     0, 0, 0);
-			s32v234_pcie_set_bar(PCI_BASE_ADDRESS_5,
-					     0, 0, 0);
-			s32v234_pcie_set_bar(PCI_ROM_ADDRESS,
-					     0, 0, 0);
-		} else {
-			s32v234_pcie_set_bar(PCI_BASE_ADDRESS_0,
-					     PCIE_BAR0_EN_DIS,
-					     PCIE_BAR0_SIZE,
-					     PCIE_BAR0_INIT);
-			s32v234_pcie_set_bar(PCI_BASE_ADDRESS_1,
-					     PCIE_BAR1_EN_DIS,
-					     PCIE_BAR1_SIZE,
-					     PCIE_BAR1_INIT);
-			s32v234_pcie_set_bar(PCI_BASE_ADDRESS_2,
-					     PCIE_BAR2_EN_DIS,
-					     PCIE_BAR2_SIZE,
-					     PCIE_BAR2_INIT);
-			s32v234_pcie_set_bar(PCI_BASE_ADDRESS_3,
-					     PCIE_BAR3_EN_DIS,
-					     PCIE_BAR3_SIZE,
-					     PCIE_BAR3_INIT);
-			s32v234_pcie_set_bar(PCI_BASE_ADDRESS_4,
-					     PCIE_BAR4_EN_DIS,
-					     PCIE_BAR4_SIZE,
-					     PCIE_BAR4_INIT);
-			s32v234_pcie_set_bar(PCI_BASE_ADDRESS_5,
-					     PCIE_BAR5_EN_DIS,
-					     PCIE_BAR5_SIZE,
-					     PCIE_BAR5_INIT);
-			s32v234_pcie_set_bar(PCI_ROM_ADDRESS,
-					     PCIE_ROM_EN_DIS,
-					     PCIE_ROM_SIZE,
-					     PCIE_ROM_INIT);
-
-			/* Region #0 is used for Inbound Mem space
-			access on BAR2. */
-			writel(0x80000000, S32V234_DBI_ADDR +
-			       PCIE_ATU_VIEWPORT);
-			writel(0xcff00000, S32V234_DBI_ADDR +
-			       PCIE_ATU_LOWER_TARGET);
-			writel(0, S32V234_DBI_ADDR +
-			       PCIE_ATU_UPPER_TARGET);
-			writel(PCIE_ATU_TYPE_MEM, S32V234_DBI_ADDR +
-			       PCIE_ATU_CR1);
-			writel(0xC0000200, S32V234_DBI_ADDR +
-			       PCIE_ATU_CR2);
-
-			/* CMD reg:I/O space, MEM space,
-			and Bus Master Enable */
-			setbits_le32(S32V234_DBI_ADDR | PCI_COMMAND,
-				    PCI_COMMAND_IO |
-				    PCI_COMMAND_MEMORY |
-				    PCI_COMMAND_MASTER);
-		}
-	}
-}
-
-static void inthandler_pcie_link_req_rst_not(struct pt_regs *pt_regs,
-					     unsigned int esr)
-{
-	const struct src *src_regs = (struct src *)SRC_SOC_BASE_ADDR;
-
-	/* Clear link_req_rst_not interrupt signal */
-	clrsetbits_le32(&src_regs->pcie_config0, 0x00000001, 0x00000001);
-
-	/* Once we get this interrupt, the link came down and all the
-	 * non sticky registers in our configuration space got reset.
-	 * We reestablish the register values now and finally
-	 * permit configuration transactions
-	 */
-	 set_non_sticky_config_regs();
-
-	/* Accept inbound configuration requests now */
-	clrsetbits_le32(&src_regs->gpr11, 0x00400000, 0x00400000);
-}
-
-/*
- * iATU region setup
- */
-static int s32v234_pcie_regions_setup(const int ep_mode)
-{
-	/*
-	 * S32V234 defines 16MB in the AXI address map for PCIe.
-	 *
-	 * That address space excepted the pcie registers is
-	 * split and defined into different regions by iATU,
-	 * with sizes and offsets as follows:
-	 *
-	 * 0x0100_0000 --- 0x010F_FFFF 1MB IORESOURCE_IO
-	 * 0x0110_0000 --- 0x01EF_FFFF 14MB IORESOURCE_MEM
-	 * 0x01F0_0000 --- 0x01FF_FFFF 1MB Cfg + Registers
-	 */
-
-	/* We set up the ID for all Rev 1.x chips */
-	if (get_siul2_midr1_major() == 0x00) {
-		/*
-		 * Vendor ID is Freescale (now NXP): 0x1957
-		 * Device ID is split as follows
-		 * Family 15:12, Device 11:6, Personality 5:0
-		 * S32V is in the automotive family: 0100
-		 * S32V is the first auto device with PCIe: 000000
-		 * S32V does not have export controlled cryptography: 00001
-		 */
-		printf("Setting PCIE Vendor and Device ID\n");
-		writel((0x4001 << 16) | 0x1957,
-		      S32V234_DBI_ADDR + PCI_VENDOR_ID);
-	}
-
-	#if defined(CONFIG_PCIE_SUBSYSTEM_VENDOR_ID) \
-		&& defined(CONFIG_PCIE_SUBSYSTEM_ID)
-	writel((CONFIG_PCIE_SUBSYSTEM_ID << 16) |
-			CONFIG_PCIE_SUBSYSTEM_VENDOR_ID,
-			S32V234_DBI_ADDR + PCI_SUBSYSTEM_VENDOR_ID);
-	#endif
-
-	if (env_get("ignoreERR009852"))
-		ignoreERR009852 = true;
-	else
-		ignoreERR009852 = false;
-
-	set_non_sticky_config_regs();
-
-	if (ep_mode) {
-
-		struct src *src_regs = (struct src *)SRC_SOC_BASE_ADDR;
-
-		if (ignoreERR009852)
-			printf("\n Ignoring errata ERR009852\n");
-
-		/* Ensure that if the link comes down we do not react
-		 * to config accesses anymore until we have reconfigured
-		 * ourselves properly! A link down event unfortunately
-		 * clears non-sticky registers.
-		 * Note that we permit automatic link training. This
-		 * puts the responsibility on us to reconfigure and
-		 * set PCIE_CFG_READY again if the link comes down.
-		 */
-		clrsetbits_le32(&src_regs->gpr10,
-				0x40000000, 0x40000000);
-
-		/* Assume the link is up and reset the link down event,
-		 * so that we can properly try to set PCIE_CFG_READY.
-		 */
-		clrsetbits_le32(&src_regs->pcie_config0,
-				0x00000001, 0x00000001);
-
-		/* Ensure that we can fix up our configuration again
-		 * if the link came down!
-		 */
-		gic_register_handler(PCIE_INTERRUPT_link_req_rst_not,
-				     inthandler_pcie_link_req_rst_not,
-				     0, "PCIE_INTERRUPT_link_req_rst_not");
-
-		/* Accept inbound configuration requests now */
-		clrsetbits_le32(&src_regs->gpr11,
-				0x00400000, 0x00400000);
-	}
-
-	return 0;
-}
-
-/*
- * PCI Express accessors
- */
-static uint8_t *get_bus_address(pci_dev_t d, int where)
-{
-	uint8_t *va_address;
-
-	/* Reconfigure Region #0 */
-	writel(0, S32V234_DBI_ADDR + PCIE_ATU_VIEWPORT);
-
-	if (PCI_BUS(d) < 2)
-		writel(PCIE_ATU_TYPE_CFG0, S32V234_DBI_ADDR + PCIE_ATU_CR1);
-	else
-		writel(PCIE_ATU_TYPE_CFG1, S32V234_DBI_ADDR + PCIE_ATU_CR1);
-
-	if (PCI_BUS(d) == 0) {
-		va_address = (uint8_t *)S32V234_DBI_ADDR;
-	} else {
-		writel(d << 8, S32V234_DBI_ADDR + PCIE_ATU_LOWER_TARGET);
-		va_address = (uint8_t *)(S32V234_IO_ADDR + SZ_16M - SZ_1M);
-	}
-
-	va_address += (where & ~0x3);
-
-	return va_address;
-}
-
-static int s32v234_pcie_addr_valid(pci_dev_t d)
-{
-	if ((PCI_BUS(d) == 0) && (PCI_DEV(d) > 1))
-		return -EINVAL;
-	if ((PCI_BUS(d) == 1) && (PCI_DEV(d) > 0))
-		return -EINVAL;
-	return 0;
-}
-
-static int s32v234_pcie_read_config(struct pci_controller *hose, pci_dev_t d,
-				int where, u32 *val)
-{
-	uint8_t *va_address;
-	int ret;
-
-	ret = s32v234_pcie_addr_valid(d);
-	if (ret) {
-		*val = 0xffffffff;
-		return ret;
-	}
-
-	va_address = get_bus_address(d, where);
-	writel(0xffffffff, val);
-	*val = readl(va_address);
-
-	return 0;
-}
-
-static int s32v234_pcie_write_config(struct pci_controller *hose, pci_dev_t d,
-			int where, u32 val)
-{
-	void *va_address = 0;
-	int ret;
-
-	ret = s32v234_pcie_addr_valid(d);
-	if (ret)
-		return ret;
-
-	va_address = get_bus_address(d, where);
-	writel(val, va_address);
-
-	return 0;
-}
-
-static int s32v234_pcie_init_phy(const int ep_mode)
-{
-	struct src *src_regs = (struct src *)SRC_SOC_BASE_ADDR;
-
-	clrbits_le32(&src_regs->gpr5, SRC_GPR5_PCIE_APP_LTSSM_ENABLE);
-
-	clrsetbits_le32(&src_regs->gpr5,
-			SRC_GPR5_PCIE_PHY_LOS_LEVEL_MASK,
-			SRC_GPR5_PCIE_PHY_LOS_LEVEL_9);
-	clrsetbits_le32(&src_regs->gpr5,
-			SRC_GPR5_PCIE_PHY_RX0_EQ_MASK,
-			SRC_GPR5_PCIE_PHY_RX0_EQ_2);
-
-	writel((0x0 << SRC_GPR6_PCIE_PCS_TX_DEEMPH_GEN1_OFFSET) |
-	       (0x0 << SRC_GPR6_PCIE_PCS_TX_DEEMPH_GEN2_3P5DB_OFFSET) |
-	       (20 << SRC_GPR6_PCIE_PCS_TX_DEEMPH_GEN2_6DB_OFFSET) |
-	       (127 << SRC_GPR6_PCIE_PCS_TX_SWING_FULL_OFFSET) |
-	       (127 << SRC_GPR6_PCIE_PCS_TX_SWING_LOW_OFFSET),
-	       &src_regs->gpr6);
-
-	return 0;
-}
-
-static int s32v234_pcie_deassert_core_reset(void)
-{
-	struct src *src_regs = (struct src *)SRC_SOC_BASE_ADDR;
-
-	/* Enable PCIe */
-	clrbits_le32(&src_regs->gpr5, SRC_GPR5_GPR_PCIE_BUTTON_RST_N);
-	mdelay(50);
-	return 0;
-}
-
-static int s32v_pcie_link_up(const int ep_mode)
-{
-	struct src *src_regs = (struct src *)SRC_SOC_BASE_ADDR;
-	uint32_t tmp;
-	int count = 0;
-
-	s32v234_pcie_init_phy(ep_mode);
-	s32v234_pcie_deassert_core_reset();
-	s32v234_pcie_regions_setup(ep_mode);
-
-	/*
-	 * FIXME: Force the PCIe RC to Gen1 operation
-	 * The RC must be forced into Gen1 mode before bringing the link
-	 * up, otherwise no downstream devices are detected. After the
-	 * link is up, a managed Gen1->Gen2 transition can be initiated.
-	 */
-	if (!ep_mode) {
-		printf("\nForcing PCIe to Gen1 operation\n");
-
-		tmp = readl(S32V234_DBI_ADDR + 0x7c);
-		tmp &= ~0xf;
-		tmp |= 0x1;
-		writel(tmp, S32V234_DBI_ADDR + 0x7c);
-	} else {
-		printf("\nPCIE: EP: Gen%d\n",
-		       readl(S32V234_DBI_ADDR + 0x7c) & 0xf);
-	}
-
-	/* LTSSM enable, starting link. */
-	setbits_le32(&src_regs->gpr5, SRC_GPR5_PCIE_APP_LTSSM_ENABLE);
-
-	while (!s32v234_pcie_link_up()) {
-		udelay(10);
-		count++;
-		if (count >= 2000) {
-			printf("phy link never came up\n");
-			printf("DEBUG_R0: 0x%08x, DEBUG_R1: 0x%08x\n",
-			      readl(S32V234_DBI_ADDR + PCIE_PHY_DEBUG_R0),
-			      readl(S32V234_DBI_ADDR + PCIE_PHY_DEBUG_R1));
-			return -EINVAL;
-		}
-	}
-
-	return 0;
-}
-
-void s32v234_pcie_init(const int ep_mode)
-{
-	/* Static instance of the controller. */
-	static struct pci_controller	pcc;
-	struct pci_controller		*hose = &pcc;
-	int ret;
-	struct src *src_regs = (struct src *)SRC_SOC_BASE_ADDR;
-
-	/* Set device type */
-	clrsetbits_le32(&src_regs->gpr5,
-			SRC_GPR5_PCIE_DEVICE_TYPE_MASK,
-			(ep_mode) ? SRC_GPR5_PCIE_DEVICE_TYPE_EP :
-				    SRC_GPR5_PCIE_DEVICE_TYPE_RC);
-
-	if (!ep_mode) {
-		memset(&pcc, 0, sizeof(pcc));
-
-		/* PCI I/O space */
-		pci_set_region(&hose->regions[0],
-			       S32V234_IO_ADDR, S32V234_IO_ADDR,
-			       S32V234_IO_SIZE, PCI_REGION_IO);
-
-		/* PCI memory space */
-		pci_set_region(&hose->regions[1],
-			       S32V234_MEM_ADDR, S32V234_MEM_ADDR,
-			       S32V234_MEM_SIZE, PCI_REGION_MEM);
-
-		/* System memory space */
-		pci_set_region(&hose->regions[2],
-			       MMDC0_ARB_BASE_ADDR, MMDC0_ARB_BASE_ADDR,
-			       0x3FFFFFFF, PCI_REGION_MEM |
-				   PCI_REGION_SYS_MEMORY);
-
-		hose->region_count = 3;
-
-		pci_set_ops(hose,
-			    pci_hose_read_config_byte_via_dword,
-			    pci_hose_read_config_word_via_dword,
-			    s32v234_pcie_read_config,
-			    pci_hose_write_config_byte_via_dword,
-			    pci_hose_write_config_word_via_dword,
-			    s32v234_pcie_write_config);
-	}
-
-	/* Start the controller. */
-	ret = s32v_pcie_link_up(ep_mode);
-
-	if (!ep_mode) {
-		if (!ret) {
-			pci_register_hose(hose);
-			hose->last_busno = pci_hose_scan(hose);
-		}
-	}
-}
-
-void pci_init_board(void)
-{
-	int epmode;
-	int clockexternal = 0;
-
-#ifdef CONFIG_PCIE_EP_MODE
-	epmode = 1;
-#else
-	epmode = 0;
-#endif
-
-#if defined CONFIG_MPXS32V234_R1 || defined CONFIG_MPXS32V234_R2
-#ifdef CONFIG_PCIE_EXT_CLOCK
-	/*
-	 * SBC-S32VEVB has external PCIe clocking.
-	 * Note that it is not an option to make this configuration available
-	 * via setting the environment variable 'hwconfig'. The reason is that
-	 * the variable 'hwconfig' could be deleted by mistake from the
-	 * persistent storage. In that case U-Boot would hang when
-	 * initializing the PCIe subsystem.
-	 */
-	clockexternal = 1;
-#else
-	clockexternal = 0;
-	/* For CUT2.0 we MUST use external clock, since there is no
-	 * internal clock available.
-	 * This must be done for backwards compatibility, so that
-	 * PCIe works the same way with the default settings on
-	 * all CUTs, old and new */
-	if (get_siul2_midr1_major() >= 1)
-		clockexternal = 1;
-	else
-		clockexternal = 0;
-#endif
-#endif
-	/* We have a build time default, but we allow a custom
-	 * override for configuration flexibility
-	 */
-	if (hwconfig_subarg_cmp("pcie", "mode", "rc")) {
-		epmode = 0;
-	}
-	if (hwconfig_subarg_cmp("pcie", "mode", "ep")) {
-		epmode = 1;
-	}
-
-	if (hwconfig_subarg_cmp("pcie", "clock", "ext")) {
-		clockexternal = 1;
-	}
-	if (hwconfig_subarg_cmp("pcie", "clock", "int")) {
-		clockexternal = 0;
-	}
-	
-	cpu_pci_clock_init(clockexternal);
-
-	s32v234_pcie_init(epmode);
-}
diff --git a/drivers/serial/serial_linflexuart.c b/drivers/serial/serial_linflexuart.c
index dae50a1056..407617cce5 100644
--- a/drivers/serial/serial_linflexuart.c
+++ b/drivers/serial/serial_linflexuart.c
@@ -16,10 +16,6 @@
 
 #define LINCR1_INIT			BIT(0)
 #define LINCR1_MME			BIT(4)
-/* This bit is marked as Reserved on S32GEN1 */
-#ifdef CONFIG_S32V234
-#define LINCR1_BF			BIT(7)
-#endif
 #define LINSR_LINS_INITMODE		(0x00001000)
 #define LINSR_LINS_MASK			(0x0000F000)
 #define UARTCR_UART			BIT(0)
@@ -101,9 +97,6 @@ static int _linflex_serial_init(struct linflex_fsl *base)
 	/* set the Linflex in master|init mode and activate by-pass filter
 	 * (where supported) */
 	ctrl = LINCR1_MME | LINCR1_INIT;
-#ifdef CONFIG_S32V234
-	ctrl |= LINCR1_BF;
-#endif
 	__raw_writel(ctrl, &base->lincr1);
 
 	/* waiting for init mode entry - TODO: add a timeout */
diff --git a/drivers/spi/fsl_dspi.c b/drivers/spi/fsl_dspi.c
index 7350ca8e69..4d95cb32de 100644
--- a/drivers/spi/fsl_dspi.c
+++ b/drivers/spi/fsl_dspi.c
@@ -7,7 +7,7 @@
  * TsiChung Liew (Tsi-Chung.Liew@freescale.com)
  * Chao Fu (B44548@freescale.com)
  * Haikun Wang (B53464@freescale.com)
- * Copyright 2017, 2019-2020 NXP
+ * Copyright 2017, 2019-2021 NXP
  */
 
 #include <common.h>
@@ -808,7 +808,6 @@ static const struct dm_spi_ops fsl_dspi_ops = {
 
 static const struct udevice_id fsl_dspi_ids[] = {
 	{ .compatible = "fsl,vf610-dspi" },
-	{ .compatible = "fsl,s32v234-dspi" },
 	{ }
 };
 
diff --git a/include/configs/s32.h b/include/configs/s32.h
index 235728d9f9..26448932d5 100644
--- a/include/configs/s32.h
+++ b/include/configs/s32.h
@@ -19,10 +19,6 @@
 
 #define CONFIG_REMAKE_ELF
 
-#if defined(CONFIG_S32V234)
-#define CONFIG_STANDALONE_LOAD_ADDR	0x80100000
-#endif /* CONFIG_S32V234/CONFIG_S32_GEN1 */
-
 #define CONFIG_MACH_TYPE		4146
 
 /* Config CACHE */
@@ -59,9 +55,6 @@
 #define CONFIG_FSL_CSE3_SETTINGS
 #endif /* CONFIG_FSL_CSE3 */
 
-/* DDR chips on S32V234 boards have 32 bits cells */
-#define RAM_CELL_SIZE		32
-
 #define CONFIG_SKIP_LOWLEVEL_INIT
 
 /* Enable passing of ATAGs */
@@ -120,7 +113,6 @@
 
 #endif
 
-#ifdef CONFIG_S32_GEN1
 #define S32_LOAD_FLASH_IMAGES_CMD\
 	"sf probe 6:0;"\
 	"sf read ${loadaddr} ${kernel_flashaddr} ${kernel_maxsize};"\
@@ -128,14 +120,6 @@
 	"sf read ${ramdisk_addr} ${ramdisk_flashaddr} "\
 	" ${ramdisk_maxsize};"
 
-#else
-#define S32_LOAD_FLASH_IMAGES_CMD\
-	"cp.b ${kernel_flashaddr} ${loadaddr} ${kernel_maxsize};"\
-	"cp.b ${fdt_flashaddr} ${fdt_addr} ${fdt_maxsize};"\
-	"cp.b ${ramdisk_flashaddr} ${ramdisk_addr} ${ramdisk_maxsize};"
-
-#endif
-
 /* Note: The *_FLASH_ADDR and *_FLASH_MAXSIZE macros are used
  * with the 'setexpr' command. Therefore ensure none of them expand
  * into operations with more than two operands and avoid unnecessary
@@ -148,15 +132,9 @@
 #define RAMDISK_FLASH_MAXSIZE		0x2000000
 #define UBOOT_FLASH_ADDR		(CONFIG_SYS_FSL_FLASH0_BASE + 0x0)
 
-#ifdef CONFIG_S32_GEN1
-#  define KERNEL_FLASH_ADDR	(CONFIG_SYS_FSL_FLASH0_BASE + 0x1f0000)
-#  define FDT_FLASH_ADDR	(CONFIG_SYS_FSL_FLASH0_BASE + 0xff0000)
-#  define RAMDISK_FLASH_ADDR	(CONFIG_SYS_FSL_FLASH0_BASE + 0x10f0000)
-#else
-#  define KERNEL_FLASH_ADDR	(CONFIG_SYS_FSL_FLASH0_BASE + 0x100000)
-#  define FDT_FLASH_ADDR	(CONFIG_SYS_FSL_FLASH0_BASE + 0xf00000)
-#  define RAMDISK_FLASH_ADDR	(CONFIG_SYS_FSL_FLASH0_BASE + 0x1000000)
-#endif
+#define KERNEL_FLASH_ADDR	(CONFIG_SYS_FSL_FLASH0_BASE + 0x1f0000)
+#define FDT_FLASH_ADDR	(CONFIG_SYS_FSL_FLASH0_BASE + 0xff0000)
+#define RAMDISK_FLASH_ADDR	(CONFIG_SYS_FSL_FLASH0_BASE + 0x10f0000)
 
 #if defined(CONFIG_ENV_IS_IN_FLASH) || defined(CONFIG_ENV_IS_IN_SPI_FLASH)
 
@@ -179,12 +157,8 @@
 #error "FDT and Ramdisk would overlap in flash memory"
 #endif
 
-#if defined(CONFIG_S32_GEN1)
 #define ENV_FDTCONTROLADDR \
 			"fdtcontroladdr=" __stringify(CONFIG_DTB_SRAM_ADDR) "\0"
-#else
-#define ENV_FDTCONTROLADDR ""
-#endif
 
 /* Generic Timer Definitions */
 #if defined(CONFIG_SYS_ARCH_TIMER)
@@ -197,9 +171,6 @@
  * FXOSC_CLK itself is board-specific.
  */
 #define COUNTER_FREQUENCY		(40 * 1000 * 1000)
-#elif defined(CONFIG_S32V234)
-#define COUNTER_FREQUENCY               (10000000)     /* 10MHz*/
-#define COUNTER_FREQUENCY_CUT1          (12000000)     /* 12MHz*/
 #elif defined(CONFIG_TARGET_TYPE_S32GEN1_EMULATOR)
 #define COUNTER_FREQUENCY				(1000)		    /* 1Khz */
 #endif
@@ -222,35 +193,6 @@
 
 #undef CONFIG_CMD_IMLS
 
-/* Regarding S32G, some of these are already controlled (read: duplicated)
- * in the defconfig; others are unused throughout the arch, board or
- * platform code; others yet are still unnecessary because we only plan to
- * enable them later (e.g CONFIG_FEC_MXC/MII or CONFIG_CMD_I2C)
- */
-#ifndef CONFIG_S32_GEN1
-
-#define CONFIG_SYS_FSL_ESDHC_ADDR	USDHC_BASE_ADDR
-#define CONFIG_SYS_FSL_ESDHC_NUM	1
-
-/* Ethernet config */
-#ifdef CONFIG_PHY_RGMII_DIRECT_CONNECTED
-#define CONFIG_FEC_MXC_PHYADDR (0x484a53)
-#define CONFIG_BCM_DUPLEX_MODE	DUPLEX_FULL
-#endif
-
-/* I2C Configs */
-#ifndef CONFIG_DM_I2C
-#define CONFIG_SYS_I2C
-#define CONFIG_SYS_I2C_MXC
-#define CONFIG_SYS_I2C_MXC_I2C1	/* enable I2C bus 1 */
-#define CONFIG_SYS_I2C_MXC_I2C2	/* enable I2C bus 2 */
-#define CONFIG_SYS_I2C_MXC_I2C3	/* enable I2C bus 3 */
-#define CONFIG_SYS_I2C_SPEED	100000
-#define CONFIG_SYS_SPD_BUS_NUM	0
-#endif
-
-#endif
-
 #define CONFIG_HWCONFIG
 
 #ifdef CONFIG_CMD_BOOTI
@@ -278,13 +220,6 @@
 #define CONFIG_DCU_EXTRA_ENV_SETTINGS	""
 #endif
 
-#ifdef CONFIG_FEC_MXC
-#define S32V234_FEC_DEFAULT_ADDR "00:1b:c3:12:34:22"
-#define FEC_EXTRA_ENV_SETTINGS	"ethaddr=" S32V234_FEC_DEFAULT_ADDR
-#else
-#define FEC_EXTRA_ENV_SETTINGS	""
-#endif
-
 #ifndef S32_DEFAULT_IP
 #define S32_DEFAULT_IP "10.0.0.100\0"
 #endif
@@ -498,7 +433,6 @@
 	PFE_EXTRA_ENV_SETTINGS \
 	PCIE_EXTRA_ENV_SETTINGS \
 	PCIE_MSIS_ENV_SETTINGS \
-	FEC_EXTRA_ENV_SETTINGS
 
 #undef CONFIG_BOOTCOMMAND
 
@@ -579,21 +513,7 @@
 
 #define CONFIG_BOOTP_BOOTFILESIZE
 
-#if !defined(CONFIG_S32_GEN1)
-/* TODO: update S32V234 defconfigs so that definitions below to not apply
- * to all S32's or find a smarter way to make S32G and S32V PCI coexist
- */
-#ifdef CONFIG_CMD_PCI
-#define CONFIG_GICSUPPORT
-#define CONFIG_CMD_IRQ
-#define CONFIG_PCIE_S32V234
-#define CONFIG_PCI
-#define CONFIG_PCI_PNP
-#define CONFIG_PCI_SCAN_SHOW
-#endif
-#else
 #define CONFIG_SYS_PCI_64BIT
-#endif  /* !CONFIG_S32_GEN1 */
 
 #define CONFIG_SYS_LDSCRIPT  "arch/arm/cpu/armv8/s32/u-boot.lds"
 
diff --git a/include/fsl_esdhc_imx.h b/include/fsl_esdhc_imx.h
index 874498db5b..442b519344 100644
--- a/include/fsl_esdhc_imx.h
+++ b/include/fsl_esdhc_imx.h
@@ -273,8 +273,7 @@ struct fsl_esdhc_cfg {
 #error "Endianess is not defined: please fix to continue"
 #endif
 
-#if defined(CONFIG_S32V234) || defined(CONFIG_IMX8) || \
-	defined(CONFIG_IMX8M)
+#if defined(CONFIG_IMX8) || defined(CONFIG_IMX8M)
 #define CORE_64BIT_PERIPHERALS_32BIT
 #endif
 
diff --git a/include/image.h b/include/image.h
index 098f091d96..1216ef8c4d 100644
--- a/include/image.h
+++ b/include/image.h
@@ -260,7 +260,6 @@ enum {
 	IH_TYPE_FLATDT,			/* Binary Flat Device Tree Blob	*/
 	IH_TYPE_KWBIMAGE,		/* Kirkwood Boot Image		*/
 	IH_TYPE_IMXIMAGE,		/* Freescale IMXBoot Image	*/
-	IH_TYPE_S32V234IMAGE,		/* NXP S32V234 Boot Image	*/
 	IH_TYPE_S32GEN1IMAGE,		/* NXP S32GEN1 Boot Image	*/
 	IH_TYPE_UBLIMAGE,		/* Davinci UBL Image		*/
 	IH_TYPE_OMAPIMAGE,		/* TI OMAP Config Header Image	*/
diff --git a/scripts/config_whitelist.txt b/scripts/config_whitelist.txt
index 8fa48f1395..fb73d6c2d3 100644
--- a/scripts/config_whitelist.txt
+++ b/scripts/config_whitelist.txt
@@ -570,7 +570,6 @@ CONFIG_FSL_CADMUS
 CONFIG_FSL_CORENET
 CONFIG_FSL_CPLD
 CONFIG_FSL_CSE3_SETTINGS
-CONFIG_FSL_DCU_FB
 CONFIG_FSL_DCU_SII9022A
 CONFIG_FSL_DEEP_SLEEP
 CONFIG_FSL_DEVICE_DISABLE
@@ -1137,7 +1136,6 @@ CONFIG_MPC85XX_FEC_NAME
 CONFIG_MPC85XX_PCI2
 CONFIG_MPC8xxx_DISABLE_BPTR
 CONFIG_MPLL_FREQ
-CONFIG_MPXS32V234_R2
 CONFIG_MSHC_FREQ
 CONFIG_MTD_CONCAT
 CONFIG_MTD_ECC_SOFT
@@ -1285,7 +1283,6 @@ CONFIG_PCIE_EXT_CLOCK
 CONFIG_PCIE_IMX
 CONFIG_PCIE_IMX_PERST_GPIO
 CONFIG_PCIE_IMX_POWER_GPIO
-CONFIG_PCIE_S32V234
 CONFIG_PCISLAVE
 CONFIG_PCIX_CHECK
 CONFIG_PCI_33M
@@ -1503,9 +1500,6 @@ CONFIG_RTC_PT7C4338
 CONFIG_RUN_FROM_IRAM_ONLY
 CONFIG_RX_DESCR_NUM
 CONFIG_S32
-CONFIG_S32V234
-CONFIG_S32V234_FLASH
-CONFIG_S32V234_USES_FLASH
 CONFIG_S5P
 CONFIG_S5PC100
 CONFIG_S5PC110
diff --git a/tools/Makefile b/tools/Makefile
index 48bcf33a55..c57fc2747a 100644
--- a/tools/Makefile
+++ b/tools/Makefile
@@ -62,7 +62,6 @@ FIT_SIG_OBJS-$(CONFIG_FIT_SIGNATURE) := common/image-sig.o
 FIT_CIPHER_OBJS-$(CONFIG_FIT_CIPHER) := common/image-cipher.o
 
 S32_COMMON-$(CONFIG_ARCH_S32) := s32_common.o
-S32V234IMAGE-$(CONFIG_S32V234) := s32v234image.o
 S32GEN1IMAGE-$(CONFIG_S32_GEN1) := s32gen1image.o
 ifdef CONFIG_S32_GEN1
 S32GEN1IMAGE-$(CONFIG_SPI_FLASH_MACRONIX) += s32gen1image_qspi_macronix.o
@@ -104,7 +103,6 @@ dumpimage-mkimage-objs := aisimage.o \
 			imagetool.o \
 			imximage.o \
 			$(S32_COMMON-y) \
-			$(S32V234IMAGE-y) \
 			$(S32GEN1IMAGE-y) \
 			imx8image.o \
 			imx8mimage.o \
diff --git a/tools/s32v234-cse/Makefile b/tools/s32v234-cse/Makefile
deleted file mode 100644
index b7f7b0294e..0000000000
--- a/tools/s32v234-cse/Makefile
+++ /dev/null
@@ -1,34 +0,0 @@
-# Creates Secure Callback Image. The Secure Callback function included
-# in the image will be executed by the BootROM code on the M4 Core.
-
-# Path to 32bit ARM cross-compiler
-COMP=TODO_PATH_TO_ARM_COMPILER
-# Secure callback image final address, located right after the u-boot image.
-# This value can be obtained during u-boot verbose (V=1) build when
-# SECURE_CALLBACK config is enabled. The address is the last value of the
-# "HAB Blocks:" compiling output line:
-# e.g. "HAB Blocks:   3e81f000 00000000 0003b000 3e85a000"
-BASE_ADDR=1048977408 # 0x3e862000
-# Secure callback function address
-SCADDR=$(($BASE+0x10))
-SCADDR=$((SCADDR | 1)) # thumb mode address
-# CMAC address
-MACADDR=$(($BASE+0x10+$SCSIZE))
-
-sci: sec_call genHeader.pl genCMAC.pl
-	# Generate header
-	perl genHeader.pl $(BASE_ADDR) $(shell stat -c%s sec_call) > sci.bin
-	# Add callback function
-	cat sec_call >> sci.bin
-	# Generate and append CMAC
-	#cat sci.bin | ruby genCMAC.rb > sciCMAC -- needs cmac-rb
-	cat sci.bin | perl genCMAC.pl > sciCMAC # -- needs Digest::CMAC
-	cat sciCMAC >> sci.bin
-
-sec_call: sec_call.c
-	$(COMP)gcc -mthumb -c sec_call.c -fpic -o sec_call.o
-	$(COMP)objcopy -j .text -O binary sec_call.o sec_call
-
-
-clean:
-	rm sec_call sec_call.o sciCMAC sci.bin
diff --git a/tools/s32v234-cse/genCMAC.pl b/tools/s32v234-cse/genCMAC.pl
deleted file mode 100644
index 6b04d92e1a..0000000000
--- a/tools/s32v234-cse/genCMAC.pl
+++ /dev/null
@@ -1,10 +0,0 @@
-use Digest::CMAC;
-
-#AVK Key
-my $key = "\xc5\xe8\xd1\x74\x1b\xa3\x39\xb9\x85\xeb\x03\x67\xf3\x2f\xf7\x7c";
-my $plaintext = <STDIN>;
-
-my $alg = Digest::CMAC->new($key);
-$alg->add($plaintext);
-my $result = $alg->digest;
-print $result
diff --git a/tools/s32v234-cse/genCMAC.rb b/tools/s32v234-cse/genCMAC.rb
deleted file mode 100644
index 22e90f76ac..0000000000
--- a/tools/s32v234-cse/genCMAC.rb
+++ /dev/null
@@ -1,9 +0,0 @@
-require 'cmac-rb'
-
-#AVK Key
-key="\xc5\xe8\xd1\x74\x1b\xa3\x39\xb9\x85\xeb\x03\x67\xf3\x2f\xf7\x7c"
-plaintext = gets
-
-digest = CMAC::Digest.new(key)
-result = digest.update(plaintext)
-print result
diff --git a/tools/s32v234-cse/genHeader.pl b/tools/s32v234-cse/genHeader.pl
deleted file mode 100644
index 3e4bfe1d7d..0000000000
--- a/tools/s32v234-cse/genHeader.pl
+++ /dev/null
@@ -1,22 +0,0 @@
-#! /usr/bin/perl -w
-use strict;
-# Generates Secure Callback Image header
-
-# Secure callback image final address
-my $base_addr=$ARGV[0];
-# Secure callback function size
-my $sc_len=$ARGV[1];
-#open(my $out, '>:raw', 'sci.bin') or die "Unable to open: $!";
-print pack("C", 0xDF); # Tag
-# Whole image size: Secure Callback + Header + CMAC
-# Write this value in u-boot config file under SECURE_CALLBACK config
-print pack("n", $sc_len+0x20);
-print pack("C", 0x50); # Version
-# Secure Callback function address - thumb mode
-print pack("V", ($base_addr+0x10)|1);
-# CMAC address
-print pack("V", $base_addr+0x10+$sc_len);
-# Authentication Length = Image Size - CMAC
-print pack("V", $sc_len+0x10);
-#close($out);
-
diff --git a/tools/s32v234-cse/sec_call.c b/tools/s32v234-cse/sec_call.c
deleted file mode 100644
index b62a59c72d..0000000000
--- a/tools/s32v234-cse/sec_call.c
+++ /dev/null
@@ -1,25 +0,0 @@
-#include <stdint.h>
-
-#define SRAM_ADDR			0x3e801000
-#define SIZE				0x4800UL
-#define SDHC_ADDR			0x25D020
-#define SCI_FAIL			0x33
-#define SCI_OK				0xF0
-#define KIA_ADDR			0x3e805000
-#define ROM_CARD_DATA_READ	((uint32_t *) 0x00003ebf)
-
-typedef uint32_t card_data_read_t(uint32_t *dest_ptr, uint32_t len,
-		uint32_t offset);
-
-
-int Locate_KeyImageFile(uint32_t *file1, uint32_t *file2)
-{
-	if (((card_data_read_t *)ROM_CARD_DATA_READ)((uint32_t *)SRAM_ADDR,
-				SIZE, SDHC_ADDR) == 0)
-		return SCI_FAIL;
-
-	*file1 = KIA_ADDR;
-	*file2 = KIA_ADDR;
-
-	return SCI_OK;
-}
diff --git a/tools/s32v234-cse/signmac.sh b/tools/s32v234-cse/signmac.sh
deleted file mode 100755
index 2a7803bcf9..0000000000
--- a/tools/s32v234-cse/signmac.sh
+++ /dev/null
@@ -1,28 +0,0 @@
-#!/bin/bash
-
-# Script used to sign a file with its generated MAC (the MAC will be appended
-# to the end of the file). To generate the MAC for a file, one can either use
-# an external AES-128 CMAC generator, or the CSE3 CMAC generation command that
-# we provide in u-boot. For more details regarding the second case, see Release
-# Notes.
-# Use the string (MAC in hex format) that is generated as the first argument of
-# this script.
-#
-# Usage ./<signmac.sh> <MAC> <unsigned file> <signed file>
-#
-# For example, to sign uImage, use a command like the example below:
-#
-# ./signmac.sh "6c63e25942d296c59a7d7448c0524a3a" <SRC_PATH>/uImage <DST_PATH>/uImage
-#
-# where the hex string given as the first parameter is the previously generated
-# MAC, <SRC_PATH> is the path to the unsigned uImage and <DST_PATH> is the
-# path to the signed uImage.
-
-if [ $# -ne 3 ]
-    then
-        echo "Usage ./$0  <MAC> <unsigned file> <signed file>"
-        exit 1
-fi
-
-cp $2 $3
-echo $1 | xxd -r -p >> $3
diff --git a/tools/s32v234-smp/.gitignore b/tools/s32v234-smp/.gitignore
deleted file mode 100644
index 909db4d727..0000000000
--- a/tools/s32v234-smp/.gitignore
+++ /dev/null
@@ -1,2 +0,0 @@
-u-boot.bin.smp
-u-boot.s32.smp
diff --git a/tools/s32v234-smp/makefile b/tools/s32v234-smp/makefile
deleted file mode 100644
index 5ab942034d..0000000000
--- a/tools/s32v234-smp/makefile
+++ /dev/null
@@ -1,30 +0,0 @@
-# The final U-boot image is expected to look like this 
-#
-#    0x3E802000    +----------------------------------+
-#                  |           Cortex-M4 binary       |
-#                  |              5368 bytes          |
-#    0x3E8034F8    +----------------------------------+
-#                  |            (Freee Area)          |
-#                  |            117512 bytes          |
-#    0x3E820000    +----------------------------------+
-#                  |            u-boot.bin            |
-#                  +----------------------------------+
-#
-# we use $+ instead of $^ so the order of files is kept
-
-all: u-boot.s32.smp
-
-nop.bin:
-	./nop_generator.sh
-
-u-boot.bin.smp: exec_m4.bin nop.bin  ../../u-boot.bin
-	cat $+ > $@
-
-u-boot.s32.smp: u-boot.bin.smp
-	../mkimage -n ../../board/freescale/s32v234evb/s32v234evb.cfg.cfgtmp -T imximage  -e 0x3e802000 -d $^ $@
-
-clean:
-	rm -f u-boot.bin.smp u-boot.s32.smp nop.bin
-
-
-.PHONY: clean
diff --git a/tools/s32v234-smp/nop_generator.sh b/tools/s32v234-smp/nop_generator.sh
deleted file mode 100755
index efdfffcaa8..0000000000
--- a/tools/s32v234-smp/nop_generator.sh
+++ /dev/null
@@ -1,9 +0,0 @@
-#!/bin/bash
-
-#remove previous nop file
-rm -f nop.bin
-
-for iter in {1..29378}
-do
-	echo -n -e '\x1F\x20\x03\xD5' >> nop.bin
-done
diff --git a/tools/s32v234-smp/readme.md b/tools/s32v234-smp/readme.md
deleted file mode 100644
index 64dc8fa1a6..0000000000
--- a/tools/s32v234-smp/readme.md
+++ /dev/null
@@ -1,22 +0,0 @@
-Cortex-M4 SDHC booting image generation
-=======================================
-
-In order to obtain an image suitable for SDHC booting from M4, you need
-an M4 binary that starts the A53 master core or if you need SMP support,
-the A53 slave cores (1, 2 and 3) should also be started.
-
-
-How to generate the SDHC image
-==============================
-After generating the Cortex-M4 elf, extract the binary. The current
-folder contains an M4 binary that starts all the A53 cores which start
-to execute the u-boot.
-
-Build u-boot as usual and afterwards from the current directory run:
-
-`make clean`
-`make all`
-`ls u-boot.s32.smp`
-
-The resulting image will be called `u-boot.s32.smp`.
-Write the image on SD as the Release Notes document specifies.
diff --git a/tools/s32v234image.c b/tools/s32v234image.c
deleted file mode 100644
index 4ea6359c8f..0000000000
--- a/tools/s32v234image.c
+++ /dev/null
@@ -1,250 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0+
-/* Copyright 2019-2020 NXP */
-
-#include <image.h>
-#include <generated/autoconf.h>
-#include <config.h>
-#include "imagetool.h"
-#include "s32_common.h"
-#include "s32v234image.h"
-#include <asm/arch/clock.h>
-#include <asm/arch-s32/s32v234/mc_cgm_regs.h>
-#include <asm/arch-s32/s32v234/mc_me_regs.h>
-
-#define BIT(nr)			(1UL << (nr))
-
-static struct program_image image_layout = {
-#ifdef CONFIG_FLASH_BOOT
-	.qspi_params = {
-		.offset = S32V234_QSPI_PARAMS_OFFSET,
-		.size = S32V234_QSPI_PARAMS_SIZE,
-	},
-#endif
-	.ivt = {
-#ifdef CONFIG_FLASH_BOOT
-		.offset = S32V234_IVT_OFFSET,
-#else
-		/* The offset is actually 0x1000, but we do not
-		 * want to integrate it in the generated image.
-		 * This allows writing the image at 0x1000 on
-		 * sdcard/qspi, which avoids overwriting the
-		 * partition table.
-		 */
-		.offset = 0x0,
-#endif
-		.size = sizeof(struct ivt),
-	},
-	.boot_data = {
-		.offset = S32_AUTO_OFFSET,
-		.alignment = 0x8U,
-		.size = sizeof(struct boot_data),
-	},
-	.dcd = {
-		.offset = S32_AUTO_OFFSET,
-		.alignment = 0x8U,
-		.size = DCD_MAXIMUM_SIZE,
-	},
-};
-
-static uint32_t dcd_data[] = {
-	DCD_HEADER,
-	DCD_WRITE_HEADER(4, PARAMS_BYTES(4)),
-	DCD_ADDR(FXOSC_CTL), DCD_MASK(FXOSC_CTL_FASTBOOT_VALUE),
-
-#ifdef CONFIG_S32V234_FAST_BOOT
-	DCD_ADDR(MC_ME_DRUN_MC),
-	DCD_MASK(DRUN_MC_RESETVAL | MC_ME_RUNMODE_MC_XOSCON |
-		 MC_ME_RUNMODE_MC_PLL(ARM_PLL) |
-		 MC_ME_RUNMODE_MC_PLL(ENET_PLL) |
-		 MC_ME_RUNMODE_MC_SYSCLK(SYSCLK_ARM_PLL_DFS_1)),
-#else
-	DCD_ADDR(MC_ME_DRUN_MC),
-	DCD_MASK(DRUN_MC_RESETVAL | MC_ME_RUNMODE_MC_XOSCON |
-		 MC_ME_RUNMODE_MC_SYSCLK(SYSCLK_FXOSC)),
-#endif
-
-	DCD_ADDR(MC_ME_MCTL),
-	DCD_MASK(MC_ME_MCTL_KEY | MC_ME_MCTL_DRUN),
-	DCD_ADDR(MC_ME_MCTL),
-	DCD_MASK(MC_ME_MCTL_INVERTEDKEY | MC_ME_MCTL_DRUN),
-};
-
-static struct ivt *get_ivt(struct program_image *image)
-{
-	return (struct ivt *)image->ivt.data;
-}
-
-static uint8_t *get_dcd(struct program_image *image)
-{
-	return image->dcd.data;
-}
-
-static struct boot_data *get_boot_data(struct program_image *image)
-{
-	return (struct boot_data *)image->boot_data.data;
-}
-
-#ifdef CONFIG_FLASH_BOOT
-static struct qspi_params *get_qspi_params(struct program_image *image)
-{
-	return (struct qspi_params *)image->qspi_params.data;
-}
-
-static void s32v234_set_qspi_params(struct qspi_params *qspi_params)
-{
-	memcpy(qspi_params, &s32v234_qspi_params, sizeof(*qspi_params));
-}
-#endif
-
-static void set_data_pointers(struct program_image *layout, void *header)
-{
-	uint8_t *data = (uint8_t *)header;
-
-	layout->ivt.data = data + layout->ivt.offset;
-#ifdef CONFIG_FLASH_BOOT
-	layout->qspi_params.data = data + layout->qspi_params.offset;
-#endif
-	layout->boot_data.data = data + layout->boot_data.offset;
-	layout->dcd.data = data + layout->dcd.offset;
-}
-
-static void s32v234_set_header(void *header, struct stat *sbuf, int unused,
-			       struct image_tool_params *tool_params)
-{
-	uint8_t *dcd;
-	struct ivt *ivt;
-	struct boot_data *boot_data;
-
-	set_data_pointers(&image_layout, header);
-
-	dcd = get_dcd(&image_layout);
-	if (sizeof(dcd_data) > DCD_MAXIMUM_SIZE) {
-		fprintf(stderr, "DCD exceeds the maximum size\n");
-		exit(EXIT_FAILURE);
-	}
-	memcpy(dcd, &dcd_data[0], sizeof(dcd_data));
-	*(uint16_t *)(dcd + DCD_HEADER_LENGTH_OFFSET) =
-						cpu_to_be16(sizeof(dcd_data));
-
-	ivt = get_ivt(&image_layout);
-	ivt->tag = IVT_TAG;
-	ivt->length = cpu_to_be16(sizeof(struct ivt));
-	ivt->version = IVT_VERSION;
-	ivt->entry = CONFIG_SYS_TEXT_BASE;
-	ivt->self = ivt->entry - S32V234_INITLOAD_SIZE + S32V234_IVT_OFFSET;
-	ivt->dcd_pointer = ivt->self + image_layout.dcd.offset -
-				image_layout.ivt.offset;
-	ivt->boot_data_pointer = ivt->self + image_layout.boot_data.offset -
-				image_layout.ivt.offset;
-
-	boot_data = get_boot_data(&image_layout);
-	boot_data->start = ivt->entry - S32V234_INITLOAD_SIZE;
-	boot_data->length = ROUND(sbuf->st_size + S32V234_INITLOAD_SIZE,
-				  0x1000);
-#ifdef CONFIG_FLASH_BOOT
-	s32v234_set_qspi_params(get_qspi_params(&image_layout));
-#endif
-	s32_check_env_overlap(sbuf->st_size);
-}
-
-static int s32v234_check_image_type(uint8_t type)
-{
-	if (type == IH_TYPE_S32V234IMAGE)
-		return EXIT_SUCCESS;
-	else
-		return EXIT_FAILURE;
-}
-
-static int s32v234_build_layout(struct program_image *program_image,
-				size_t *header_size, void **image)
-{
-	uint8_t *image_layout;
-	struct image_comp *parts[] = {&program_image->ivt,
-		&program_image->boot_data,
-		&program_image->dcd,
-#ifdef CONFIG_FLASH_BOOT
-		&program_image->qspi_params,
-#endif
-	};
-	size_t last_comp = ARRAY_SIZE(parts) - 1;
-
-	program_image->dcd.size = sizeof(dcd_data);
-
-	qsort(&parts[0], ARRAY_SIZE(parts), sizeof(parts[0]), image_parts_comp);
-
-	/* Compute auto-offsets */
-	s32_compute_dyn_offsets(parts, ARRAY_SIZE(parts));
-
-	*header_size = S32V234_HEADER_SIZE;
-	if (parts[last_comp]->offset + parts[last_comp]->size > *header_size) {
-		perror("S32V234 Header is too large");
-		exit(EXIT_FAILURE);
-	}
-
-	image_layout = calloc(*header_size, sizeof(*image_layout));
-	if (!image_layout) {
-		perror("Call to calloc() failed");
-		return -ENOMEM;
-	}
-
-	*image = image_layout;
-	return 0;
-}
-
-static int s32v234_vrec_header(struct image_tool_params *tool_params,
-			       struct image_type_params *type_params)
-{
-	size_t header_size;
-	void *image = NULL;
-
-	s32v234_build_layout(&image_layout, &header_size, &image);
-	type_params->header_size = header_size;
-	type_params->hdr = image;
-
-	return 0;
-}
-
-static void s32v234_print_header(const void *header)
-{
-	struct boot_data *boot_data;
-
-	boot_data = get_boot_data(&image_layout);
-
-	fprintf(stderr, "\nNote: The following offsets are absolute offsets "
-			"within the persistent storage\n");
-
-	fprintf(stderr, "\nIVT:\t\t\tOffset: 0x%x\t\tSize: 0x%x\n",
-		(unsigned int)(image_layout.ivt.offset + S32V234_IVT_OFFSET),
-		(unsigned int)image_layout.ivt.size);
-	fprintf(stderr, "Boot Data:\t\tOffset: 0x%x\t\tSize: 0x%x\n",
-		(unsigned int)(image_layout.boot_data.offset +
-							S32V234_IVT_OFFSET),
-		(unsigned int)image_layout.boot_data.size);
-	fprintf(stderr, "DCD:\t\t\tOffset: 0x%x\t\tSize: 0x%x\n",
-		(unsigned int)(image_layout.dcd.offset + S32V234_IVT_OFFSET),
-		(unsigned int)image_layout.dcd.size);
-	fprintf(stderr, "U-Boot:\t\t\tOffset: 0x%x\t\tSize: 0x%x\n",
-		(unsigned int)(S32V234_INITLOAD_SIZE),
-		(unsigned int)boot_data->length);
-#if defined(CONFIG_ENV_OFFSET) && defined(CONFIG_ENV_SIZE)
-	fprintf(stderr, "U-Boot Environment:\tOffset: 0x%x\tSize: 0x%x\n",
-		(unsigned int)CONFIG_ENV_OFFSET,
-		(unsigned int)CONFIG_ENV_SIZE);
-#endif
-	fprintf(stderr, "\n");
-}
-
-U_BOOT_IMAGE_TYPE(
-	s32v2image,
-	"NXP S32V234 Boot Image",
-	0,
-	NULL,
-	NULL,
-	NULL,
-	s32v234_print_header,
-	s32v234_set_header,
-	NULL,
-	s32v234_check_image_type,
-	NULL,
-	s32v234_vrec_header
-);
diff --git a/tools/s32v234image.h b/tools/s32v234image.h
deleted file mode 100644
index 587ea54721..0000000000
--- a/tools/s32v234image.h
+++ /dev/null
@@ -1,111 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0+ */
-/* Copyright 2019-2020 NXP */
-
-#ifndef S32V234IMAGE_H
-#define S32V234IMAGE_H
-
-#include <asm/types.h>
-#include <generated/autoconf.h>
-
-#define DCD_HEADER			(0x500000d2)
-#define IVT_VERSION			(0x50)
-
-#define S32V234_IVT_OFFSET		(0x1000U)
-#define S32V234_INITLOAD_SIZE		(0x2000U)
-
-#ifdef CONFIG_FLASH_BOOT
-#  define S32V234_COMMAND_SEQ_FILL_OFF 20
-#endif
-
-#ifdef CONFIG_FLASH_BOOT
-#  define S32V234_QSPI_PARAMS_OFFSET	0x200U
-#  define S32V234_QSPI_PARAMS_SIZE	0x200
-#endif
-
-#ifdef CONFIG_FLASH_BOOT
-#  define S32V234_HEADER_SIZE	0x2000U
-#else
-#  define S32V234_HEADER_SIZE	0x1000U
-#endif
-
-struct ivt {
-	__u8		tag;
-	__u16		length;
-	__u8		version;
-	__u32		entry;
-	__u32		reserved1;
-	__u32		dcd_pointer;
-	__u32		boot_data_pointer;
-	__u32		self;
-	__u32		reserved2;
-	__u32		self_test;
-	__u32		reserved3;
-	__u32		reserved4;
-} __attribute((packed));
-
-struct boot_data {
-	__u32		start;
-	__u32		length;
-	__u8		reserved2[4];
-} __packed;
-
-struct program_image {
-	struct image_comp ivt;
-#ifdef CONFIG_FLASH_BOOT
-	struct image_comp qspi_params;
-#endif
-	struct image_comp boot_data;
-	struct image_comp dcd;
-	__u8 *header;
-};
-
-#ifdef CONFIG_FLASH_BOOT
-struct qspi_params {
-	__u32 dqs;
-	__u8 hold_delay;
-	__u8 half_speed_phase_sel;
-	__u8 half_speed_delay_sel;
-	__u8 reserved1;
-	__u32 clock_conf;
-	__u32 soc_conf;
-	__u32 reserved2;
-	__u32 cs_hold;
-	__u32 cs_setup;
-	__u32 flash_a1_size;
-	__u32 flash_a2_size;
-	__u32 flash_b1_size;
-	__u32 flash_b2_size;
-	__u32 clock_freq;
-	__u32 reserved3;
-	__u8 mode;
-	__u8 flash_b_sel;
-	__u8 ddr_mode;
-	__u8 dss;
-	__u8 parallel_mode_en;
-	__u8 cs1_port_a;
-	__u8 cs1_port_b;
-	__u8 full_speed_phase_sel;
-	__u8 full_speed_delay_sel;
-	__u8 ddr_sampling_point;
-	__u8 luts[256];
-};
-
-static const struct qspi_params s32v234_qspi_params = {
-	.hold_delay = 0x1,
-	.flash_a1_size = 0x40000000,
-	.clock_freq = 0x3,
-	.ddr_mode = 0x1,
-	.dss = 0x1,
-	.luts = {
-		/*Flash specific LUT */
-		0xA0, 0x47, 0x18, 0x2B, 0x10, 0x4F, 0x0F, 0x0F, 0x80,
-		/* 128 bytes*/
-		0x3B, 0x00, 0x03,
-		/*STOP - 8pads*/
-		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-		0x00, 0x00, 0x00, 0x00
-	}
-};
-#endif //CONFIG_FLASH_BOOT
-
-#endif /* S32V234IMAGE_H */
-- 
2.17.1

