From f105806331c75f1358ef83f8512c26a0994c49ed Mon Sep 17 00:00:00 2001
From: Ghennadi Procopciuc <ghennadi.procopciuc@nxp.com>
Date: Tue, 23 Nov 2021 12:28:38 +0200
Subject: [PATCH 10/20] s32gen1: Correct SRAM initialization algorithm

This simplifies the way SRAM is initialized on all S32GEN1
SoC by moving the entire implementation from assembly into C.

Issue: ALB-8227
Upstream-Status: Pending 

Signed-off-by: Ghennadi Procopciuc <ghennadi.procopciuc@nxp.com>
Signed-off-by: Zhantao Tang <zhantao.tang@windriver.com>
---
 arch/arm/cpu/armv8/s32/s32-gen1/Makefile      |   4 +
 .../armv8/s32/s32-gen1/include/s32gen1_sram.h |  33 ++
 arch/arm/cpu/armv8/s32/s32-gen1/s32g3_sramc.c |  61 +++
 arch/arm/cpu/armv8/s32/s32-gen1/s32g_sramc.h  |  71 ----
 .../armv8/s32/s32-gen1/s32gen1_common_sramc.c |  44 ++
 .../cpu/armv8/s32/s32-gen1/s32gen1_sramc.c    | 126 ++++++
 arch/arm/cpu/armv8/s32/s32-gen1/sram.S        | 401 +++---------------
 7 files changed, 330 insertions(+), 410 deletions(-)
 create mode 100644 arch/arm/cpu/armv8/s32/s32-gen1/include/s32gen1_sram.h
 create mode 100644 arch/arm/cpu/armv8/s32/s32-gen1/s32g3_sramc.c
 delete mode 100644 arch/arm/cpu/armv8/s32/s32-gen1/s32g_sramc.h
 create mode 100644 arch/arm/cpu/armv8/s32/s32-gen1/s32gen1_common_sramc.c
 create mode 100644 arch/arm/cpu/armv8/s32/s32-gen1/s32gen1_sramc.c

diff --git a/arch/arm/cpu/armv8/s32/s32-gen1/Makefile b/arch/arm/cpu/armv8/s32/s32-gen1/Makefile
index 7bdacb0444..4c9ab34b6e 100644
--- a/arch/arm/cpu/armv8/s32/s32-gen1/Makefile
+++ b/arch/arm/cpu/armv8/s32/s32-gen1/Makefile
@@ -13,7 +13,11 @@ obj-y					+= ncore.o
 obj-y					+= soc.o
 obj-$(CONFIG_NXP_S32G2XX)		+= s32g274a.o
 obj-$(CONFIG_NXP_S32G3XX)		+= s32g3.o
+obj-$(CONFIG_NXP_S32G3XX)		+= s32g3_sramc.o
+obj-$(CONFIG_NXP_S32G2XX)		+= s32gen1_common_sramc.o
+obj-$(CONFIG_NXP_S32R45)		+= s32gen1_common_sramc.o
 obj-y					+= sram.o
+obj-y					+= s32gen1_sramc.o
 ifdef CONFIG_S32_GEN1
 obj-$(CONFIG_NETDEVICES)		+= sgmii/sgmii.o sgmii/serdes_xpcs.o
 endif
diff --git a/arch/arm/cpu/armv8/s32/s32-gen1/include/s32gen1_sram.h b/arch/arm/cpu/armv8/s32/s32-gen1/include/s32gen1_sram.h
new file mode 100644
index 0000000000..f4117e27a5
--- /dev/null
+++ b/arch/arm/cpu/armv8/s32/s32-gen1/include/s32gen1_sram.h
@@ -0,0 +1,33 @@
+/* SPDX-License-Identifier: BSD-3-Clause */
+/*
+ * Copyright 2021 NXP
+ */
+#ifndef S32GEN1_SRAMC_H
+#define S32GEN1_SRAMC_H
+
+#include <linux/types.h>
+
+#define SRAMC0_BASE_ADDR        0x4019C000
+#define SRAMC1_BASE_ADDR        0x401A0000
+#define SRAMC_SIZE              0x3000
+
+#ifndef __ASSEMBLER__
+
+struct sram_ctrl {
+	uintptr_t base_addr;
+	u32 min_sram_addr;
+	u32 max_sram_addr;
+	/**
+	 * Translate an A53 SRAM address to SRAM controller offset
+	 * associated to that memory region.
+	 * This algorithm is platform specific.
+	 */
+	uintptr_t (*a53_to_sramc_offset)(uintptr_t addr);
+};
+
+int s32_sram_clear(uintptr_t start, uintptr_t end);
+void s32_ssram_clear(void);
+void s32_get_sramc(struct sram_ctrl **ctrls, size_t *size);
+#endif
+#endif
+
diff --git a/arch/arm/cpu/armv8/s32/s32-gen1/s32g3_sramc.c b/arch/arm/cpu/armv8/s32/s32-gen1/s32g3_sramc.c
new file mode 100644
index 0000000000..6522177b98
--- /dev/null
+++ b/arch/arm/cpu/armv8/s32/s32-gen1/s32g3_sramc.c
@@ -0,0 +1,61 @@
+// SPDX-License-Identifier: BSD-3-Clause
+/*
+ * Copyright 2021 NXP
+ */
+#include <config.h>
+#include <linux/kernel.h>
+#include <s32gen1_sram.h>
+
+#define SRAMC2_BASE_ADDR        0x4055A000
+#define SRAMC3_BASE_ADDR        0x4055E000
+
+#define SRAM_BANK_SIZE          (S32_SRAM_SIZE / 4)
+
+#define SRAM_BANK_MIN(N)        (S32_SRAM_BASE + (N) * SRAM_BANK_SIZE)
+#define SRAM_BANK_MAX(N)        (S32_SRAM_BASE + ((N) + 1) * SRAM_BANK_SIZE - 1)
+
+static uintptr_t a53_to_sramc_offset(uintptr_t addr)
+{
+	/**
+	 * mem_addr[16:0] = { (bus_addr[24:20] modulo 5),
+	 *                    bus_addr[19:8], bus_addr[5:4]};
+	 */
+	addr = ((addr & 0x30) >> 4) |
+	    (((addr & 0xFFF00) >> 8) << 2) |
+	    (((addr & 0x1F00000) >> 20) % 5) << 14;
+
+	return addr;
+}
+
+void s32_get_sramc(struct sram_ctrl **ctrls, size_t *size)
+{
+	static struct sram_ctrl controllers[] = {
+		{
+			.base_addr = SRAMC0_BASE_ADDR,
+			.min_sram_addr = SRAM_BANK_MIN(0),
+			.max_sram_addr = SRAM_BANK_MAX(0),
+			.a53_to_sramc_offset = a53_to_sramc_offset,
+		},
+		{
+			.base_addr = SRAMC1_BASE_ADDR,
+			.min_sram_addr = SRAM_BANK_MIN(1),
+			.max_sram_addr = SRAM_BANK_MAX(1),
+			.a53_to_sramc_offset = a53_to_sramc_offset,
+		},
+		{
+			.base_addr = SRAMC2_BASE_ADDR,
+			.min_sram_addr = SRAM_BANK_MIN(2),
+			.max_sram_addr = SRAM_BANK_MAX(2),
+			.a53_to_sramc_offset = a53_to_sramc_offset,
+		},
+		{
+			.base_addr = SRAMC3_BASE_ADDR,
+			.min_sram_addr = SRAM_BANK_MIN(3),
+			.max_sram_addr = SRAM_BANK_MAX(3),
+			.a53_to_sramc_offset = a53_to_sramc_offset,
+		},
+	};
+
+	*ctrls = &controllers[0];
+	*size = ARRAY_SIZE(controllers);
+}
diff --git a/arch/arm/cpu/armv8/s32/s32-gen1/s32g_sramc.h b/arch/arm/cpu/armv8/s32/s32-gen1/s32g_sramc.h
deleted file mode 100644
index 394ed6f9cf..0000000000
--- a/arch/arm/cpu/armv8/s32/s32-gen1/s32g_sramc.h
+++ /dev/null
@@ -1,71 +0,0 @@
-/* SPDX-License-Identifier: BSD-3-Clause */
-/*
- * Copyright 2020-2021 NXP
- */
-#ifndef S32G_SRAMC_H
-#define S32G_SRAMC_H
-
-/* SRAM is actually at 0x3400_0000; we are just mirroring it in the
- * Virtual Code RAM
- */
-#define S32G_SRAM_BASE		0x34000000
-#define S32G_SRAM_SIZE		0x00800000
-#define S32G_SRAM_END		(S32G_SRAM_BASE + S32G_SRAM_SIZE)
-
-/* SRAM controller is able to erase 64 bits at once */
-#define SRAM_BLOCK		512
-#define SRAM_BLOCK_MASK		(SRAM_BLOCK - 1)
-#define SRAM_INV_BLOCK_MASK	(~(SRAM_BLOCK_MASK))
-
-#define SRAMC0_BASE_ADDR	0x4019C000
-#define SRAMC0_BASE_ADDR_H	(SRAMC0_BASE_ADDR >> 16)
-#define SRAMC0_BASE_ADDR_L	((SRAMC0_BASE_ADDR & 0xFFFF))
-#define SRAMC1_BASE_ADDR	0x401A0000
-#define SRAMC1_BASE_ADDR_H	(SRAMC1_BASE_ADDR >> 16)
-#define SRAMC1_BASE_ADDR_L	((SRAMC1_BASE_ADDR & 0xFFFF))
-#ifdef CONFIG_NXP_S32G3XX
-#define SRAMC2_BASE_ADDR	0x4055A000
-#define SRAMC2_BASE_ADDR_H	(SRAMC0_BASE_ADDR >> 16)
-#define SRAMC2_BASE_ADDR_L	((SRAMC0_BASE_ADDR & 0xFFFF))
-#define SRAMC3_BASE_ADDR	0x4055E000
-#define SRAMC3_BASE_ADDR_H	(SRAMC1_BASE_ADDR >> 16)
-#define SRAMC3_BASE_ADDR_L	((SRAMC1_BASE_ADDR & 0xFFFF))
-#endif
-#define SSRAMC_BASE_ADDR	0x44028000
-#define SRAMC_SIZE		0x3000
-
-/* Block ranges */
-
-#if defined(CONFIG_NXP_S32G2XX) || defined(CONFIG_NXP_S32R45)
-#define SRAMC0_MIN_ADDR		(0x0)
-#define SRAMC0_MAX_ADDR		(0x7FFF)
-#define SRAMC1_MIN_ADDR		(SRAMC0_MAX_ADDR + 1)
-#define SRAMC1_MAX_ADDR		(0x10000)
-#elif CONFIG_NXP_S32G3XX
-#define SRAMC0_MIN_ADDR		(0x0)
-#define SRAMC0_MAX_ADDR		(0x7FFF)
-#define SRAMC1_MIN_ADDR		(SRAMC0_MAX_ADDR + 1)
-#define SRAMC1_MAX_ADDR		(0xFFFF)
-#define SRAMC2_MIN_ADDR		(SRAMC1_MAX_ADDR + 1)
-#define SRAMC2_MAX_ADDR		(0x17FFF)
-#define SRAMC2_MAX_ADDR_H	(SRAMC2_MAX_ADDR >> 16)
-#define SRAMC2_MAX_ADDR_L	(SRAMC2_MAX_ADDR & 0xFFFF)
-#define SRAMC3_MIN_ADDR		(SRAMC2_MAX_ADDR + 1)
-#define SRAMC3_MIN_ADDR_H	(SRAMC3_MIN_ADDR >> 16)
-#define SRAMC3_MIN_ADDR_L	(SRAMC3_MIN_ADDR & 0xFFFF)
-#define SRAMC3_MAX_ADDR		(0x1FFFF)
-#define SRAMC3_MAX_ADDR_H	(SRAMC3_MAX_ADDR >> 16)
-#define SRAMC3_MAX_ADDR_L	(SRAMC3_MAX_ADDR & 0xFFFF)
-#endif
-
-#define SRAMC_PRAMCR_OFFSET	0x0
-#define SRAMC_PRAMCR_INITREQ	1
-#define SRAMC_PRAMIAS_OFFSET	0x4
-#define SRAMC_PRAMIAE_OFFSET	0x8
-#define SRAMC_PRAMSR_OFFSET	0xC
-#define SRAMC_PRAMSR_IDONE	1
-
-#define SSRAM_MAX_ADDR		0x7FF
-
-#endif
-
diff --git a/arch/arm/cpu/armv8/s32/s32-gen1/s32gen1_common_sramc.c b/arch/arm/cpu/armv8/s32/s32-gen1/s32gen1_common_sramc.c
new file mode 100644
index 0000000000..98293be5fb
--- /dev/null
+++ b/arch/arm/cpu/armv8/s32/s32-gen1/s32gen1_common_sramc.c
@@ -0,0 +1,44 @@
+// SPDX-License-Identifier: BSD-3-Clause
+/*
+ * Copyright 2021 NXP
+ */
+#include <config.h>
+#include <linux/kernel.h>
+#include <s32gen1_sram.h>
+
+#define SRAM_BANK_SIZE          (S32_SRAM_SIZE / 2)
+
+#define SRAM_BANK_MIN(N)        (S32_SRAM_BASE + (N) * SRAM_BANK_SIZE)
+#define SRAM_BANK_MAX(N)        (S32_SRAM_BASE + ((N) + 1) * SRAM_BANK_SIZE - 1)
+
+static uintptr_t a53_to_sramc_offset(uintptr_t addr)
+{
+	addr -= S32_SRAM_BASE;
+
+	/* mem_addr[16:0] = {bus_addr[23:9], bus_addr[5:4]} */
+	addr = ((addr >> 9) << 2) | ((addr >> 4) & 0x3);
+
+	return addr;
+}
+
+void s32_get_sramc(struct sram_ctrl **ctrls, size_t *size)
+{
+	static struct sram_ctrl controllers[] = {
+		{
+			.base_addr = SRAMC0_BASE_ADDR,
+			.min_sram_addr = SRAM_BANK_MIN(0),
+			.max_sram_addr = SRAM_BANK_MAX(0),
+			.a53_to_sramc_offset = a53_to_sramc_offset,
+		},
+		{
+			.base_addr = SRAMC1_BASE_ADDR,
+			.min_sram_addr = SRAM_BANK_MIN(1),
+			.max_sram_addr = SRAM_BANK_MAX(1),
+			.a53_to_sramc_offset = a53_to_sramc_offset,
+		},
+	};
+
+	*ctrls = &controllers[0];
+	*size = ARRAY_SIZE(controllers);
+}
+
diff --git a/arch/arm/cpu/armv8/s32/s32-gen1/s32gen1_sramc.c b/arch/arm/cpu/armv8/s32/s32-gen1/s32gen1_sramc.c
new file mode 100644
index 0000000000..29f270517f
--- /dev/null
+++ b/arch/arm/cpu/armv8/s32/s32-gen1/s32gen1_sramc.c
@@ -0,0 +1,126 @@
+// SPDX-License-Identifier: BSD-3-Clause
+/*
+ * Copyright 2021 NXP
+ */
+#include <asm/io.h>
+#include <cpu_func.h>
+#include <errno.h>
+#include <linux/kernel.h>
+#include <linux/string.h>
+#include <s32gen1_sram.h>
+
+#define S32G_SRAM_END		(S32_SRAM_BASE + S32_SRAM_SIZE)
+
+/* SRAM controller is able to erase 64 bits at once */
+#define SRAM_BLOCK              512
+#define SRAM_BLOCK_MASK         (SRAM_BLOCK - 1)
+
+#define SRAMC_PRAMCR_OFFSET     0x0
+#define SRAMC_PRAMCR_INITREQ    1
+#define SRAMC_PRAMIAS_OFFSET    0x4
+#define SRAMC_PRAMIAE_OFFSET    0x8
+#define SRAMC_PRAMSR_OFFSET     0xC
+#define SRAMC_PRAMSR_IDONE      1
+
+static void a53_sram_init(void *start, size_t len)
+{
+	memset(start, 0, len);
+	if (dcache_status())
+		flush_dcache_range((uintptr_t)start, len);
+}
+
+static void clear_unaligned_ends(uintptr_t *start, uintptr_t *end)
+{
+	uintptr_t leftover;
+
+	if (*start % SRAM_BLOCK) {
+		leftover = SRAM_BLOCK - (*start & SRAM_BLOCK_MASK);
+
+		a53_sram_init((void *)*start, round_up(leftover, 8));
+		*start += leftover;
+	}
+
+	if (*end % SRAM_BLOCK) {
+		leftover = *end & SRAM_BLOCK_MASK;
+
+		a53_sram_init((void *)(*end - leftover), round_up(leftover, 8));
+		*end -= leftover;
+	}
+}
+
+static bool in_overlap(uintptr_t s1, uintptr_t e1, uintptr_t s2, uintptr_t e2)
+{
+	return max(s1, s2) <= min(e1, e2);
+}
+
+static void clear_sramc_range(uintptr_t base, u32 start_offset,
+			      u32 end_offset)
+{
+	/* Disable the controller */
+	writel(0x0, base + SRAMC_PRAMCR_OFFSET);
+
+	/* Max range */
+	writel(start_offset, base + SRAMC_PRAMIAS_OFFSET);
+	writel(end_offset, base + SRAMC_PRAMIAE_OFFSET);
+
+	/* Initialization request */
+	writel(SRAMC_PRAMCR_INITREQ, base + SRAMC_PRAMCR_OFFSET);
+
+	while (!(readl(base + SRAMC_PRAMSR_OFFSET) & SRAMC_PRAMSR_IDONE))
+		;
+	writel(SRAMC_PRAMSR_IDONE, base + SRAMC_PRAMSR_OFFSET);
+}
+
+static void clear_sram_range(struct sram_ctrl *c, uintptr_t start_addr,
+			     uintptr_t end_addr)
+{
+	uintptr_t base = c->base_addr;
+	u32 start_offset, end_offset;
+
+	start_addr -= c->min_sram_addr;
+	end_addr -= c->min_sram_addr;
+
+	start_offset = c->a53_to_sramc_offset(start_addr);
+	end_offset = c->a53_to_sramc_offset(end_addr);
+
+	clear_sramc_range(base, start_offset, end_offset);
+}
+
+int s32_sram_clear(uintptr_t start, uintptr_t end)
+{
+	struct sram_ctrl *ctrls;
+	struct sram_ctrl *c;
+	size_t i, n_ctrls;
+	uintptr_t s, e;
+
+	if (start == end)
+		return 1;
+
+	if (end < start)
+		return 0;
+
+	if (start < S32_SRAM_BASE)
+		return 0;
+
+	if (end > S32G_SRAM_END)
+		return 0;
+
+	clear_unaligned_ends(&start, &end);
+
+	s32_get_sramc(&ctrls, &n_ctrls);
+
+	for (i = 0u; i < n_ctrls; i++) {
+		c = &ctrls[i];
+
+		if (!in_overlap(start, end, c->min_sram_addr, c->max_sram_addr))
+			continue;
+
+		/* Adapt the range to current controller */
+		s = max(start, (uintptr_t)c->min_sram_addr);
+		e = min(end, (uintptr_t)c->max_sram_addr);
+
+		clear_sram_range(c, s, e);
+	}
+
+	return 1;
+}
diff --git a/arch/arm/cpu/armv8/s32/s32-gen1/sram.S b/arch/arm/cpu/armv8/s32/s32-gen1/sram.S
index eaa1204b3b..fccf288f0f 100644
--- a/arch/arm/cpu/armv8/s32/s32-gen1/sram.S
+++ b/arch/arm/cpu/armv8/s32/s32-gen1/sram.S
@@ -1,354 +1,77 @@
 /* SPDX-License-Identifier:     GPL-2.0+ */
 /*
- * Copyright 2020-2021 NXP
- *
- * Extracted from armv8/start.S
+ * Copyright 2021 NXP
  */
 
-/* Allow inclusion assembly macros */
-#define __INCLUDE_ASSEMBLY_MACROS__
-
 #include <config.h>
 #include <linux/linkage.h>
-#include "s32g_sramc.h"
 
-/*
- * Translate a bus address in SRAM controller initialization address based on:
- * On S32G2 and S32R45
- * mem_addr[16:0] = {bus_addr[23:9], bus_addr[5:4]}
- *
- * addr := ((addr >> 9) << 2) | ((addr >> 4) & 0x3);
- *
- * On S32G3
- * mem_addr[16:0] = { (bus_addr[24:20] modulo 5), bus_addr[19:8], bus_addr[5:4]}
- *
- * addr := ((addr & 0x30) >> 4) |
- *         (((addr & 0xFFF00) >> 8) << 2) |
- *         (((addr & 0x1F00000) >> 20) % 5) << 14
- *
- * x0: SRAM bus address
- * ret: x0: Initialization address
- *
- * Clobber list: x0,x4,x5,x6
- */
-ENTRY(calc_sramc_addr)
-#if defined(CONFIG_NXP_S32G2XX) || defined(CONFIG_NXP_S32R45)
-	lsr	x4, x0, #9
-	lsl	x4, x4, #2
-	lsr	x5, x0, #4
-	and	x5, x5, #3
-	orr	x0, x4, x5
-#else /* CONFIG_NXP_S32G3XX */
-	ubfx	x5, x0, #20, #5
-	mov	w4, #0xcccd
-	movk	w4, #0xcccc, lsl #16
-	lsr	w6, w0, #6
-	and	w6, w6, #0x3ffc
-	ubfx	x0, x0, #4, #2
-	umull	x4, w5, w4
-	orr	w0, w0, w6
-	lsr	x4, x4, #32
-	lsr	w4, w4, #2
-	add	w4, w4, w4, lsl #2
-	sub	w4, w5, w4
-	orr	w0, w0, w4, lsl #14
-#endif
-	ret
-ENDPROC(calc_sramc_addr)
+#define S32_STACK_GUARD	0xDEAD
 
-/**
- * Check if two intervals are in overlap
- *
- * x0: start index of the first interval
- * x1: end index of the first interval
- * x2: start index of the second interval
- * x3: end index of the second interval
- *
- * x0: return 0 if the intervals do not overlap and 1 otherwise
- * Clobber list: x0,x1,x2,x3,x4,x5,x6
- */
-ENTRY(in_overlap)
-	/* x4 = max */
-	cmp	x1, x3
-	b.gt	1f
-	mov	x4, x3
-	b	2f
-1:
-	mov	x4, x1
-2:
-	/* x5 = min */
-	cmp	x0, x2
-	b.lt	3f
-	mov	x5, x2
-	b	4f
-3:
-	mov	x5, x0
-4:
-	/* x5 = max - min */
-	sub	x5, x4, x5
-	/* x4 = first interval size */
-	sub	x4, x1, x0
-	/* x6 = second interval size */
-	sub	x6, x3, x2
-	/* x4 = len1 + len2 */
-	add	x4, x4, x6
-	cmp	x4, x5
-	bgt	overlap
-	mov	x0, #0
-	ret
-overlap:
-	mov	x0, #1
-	ret
-ENDPROC(in_overlap)
-
-/**
- * Clear SRAM range using SRAM controller
- *
- * x0: SRAM controller address
- * x1: Initialization Start Address
- * x2: Initialization End Address
- *
- * Clobber list: x0,x1,x2,x3
- */
-ENTRY(clear_sramc_range)
-	/* Disable the module */
-	mov	x3, #0
-	str	w3, [x0, #SRAMC_PRAMCR_OFFSET]
-
-	/* Address range */
-	str	w1, [x0, #SRAMC_PRAMIAS_OFFSET]
-	str	w2, [x0, #SRAMC_PRAMIAE_OFFSET]
-
-	/* Request initialization */
-	mov	x3, #SRAMC_PRAMCR_INITREQ
-	str	w3, [x0, #SRAMC_PRAMCR_OFFSET]
-
-wait_init:
-	ldr	w3, [x0, #SRAMC_PRAMSR_OFFSET]
-	and	w3, w3, #SRAMC_PRAMSR_IDONE
-	cbz	w3, wait_init
-
-	/* Clear status */
-	mov	w3, #SRAMC_PRAMSR_IDONE
-	str	w3, [x0, #SRAMC_PRAMSR_OFFSET]
+#ifndef S32_CRASH_STACK_SIZE
+#define S32_CRASH_STACK_SIZE	0x400
+#endif
 
-	ret
-ENDPROC(clear_sramc_range)
+.section .data.s32_crash_reg_stash
+	.align 3
+	s32_crash_reg_stash: .quad 0, 0, 0, 0, 0
 
 /**
- * Clear SRAM range using (current) A53 core
- *
- * x0: start address of memory area to clear
- * x1: end address of memory area to clear
- *
- * Clobber list: x0,x1,x9,x10
+ * Use a local buffer as stack for Linflex crash callbacks and SRAM
+ * initialization
  */
-ENTRY(a53_sram_clr)
-	mov	x10, #0x0
-	cmp	x1, x0
-	bgt	pos_step
-	mov	x9, #-8
-	b	clr_loop
-pos_step:
-	mov	x9, #8
-clr_loop:
-	cmp	x1, x0
-	beq	finish
-	str	x10, [x0]
-	add	x0, x0, x9
-	b	clr_loop
-finish:
-	ret
-ENDPROC(a53_sram_clr)
+.section .data.s32_plat_data_stack
+	.balign 16
+	s32_plat_data_stack: .skip S32_CRASH_STACK_SIZE
 
 /**
- * Clear unaligned (to SRAMC granularity) SRAM range using current core
- *
- * x0: start address of memory area to clear
- * x1: end address of memory area to clear
+ * Save intra-procedure-call scratch, frame pointer and
+ * link registers (x16, x17, x29, x30)
  *
- * Clobber list: x0,x1,x9,x10,x11
+ * Clobbers: reg1, reg2
  */
-ENTRY(clear_unaligned_ends)
-	/* Save x30 */
-	mov	x12, x30
-	/*
-	 * Obtain SRAM addresses
-	 */
-	mov	x9, #S32G_SRAM_BASE
-	add	x11, x1, x9
-	add	x9, x0, x9
-
-	and	x1, x9, #SRAM_INV_BLOCK_MASK
-	cmp	x1, x9
-	beq	clear_end
-	add	x1, x1, SRAM_BLOCK
-	mov	x0, x9
-	bl	a53_sram_clr
-
-clear_end:
-	and	x0, x11, #SRAM_INV_BLOCK_MASK
-	cmp	x0, x11
-	beq	clr_exit
-	mov	x1, x11
-	bl	a53_sram_clr
-clr_exit:
-	mov	x30, x12
-	ret
-ENDPROC(clear_unaligned_ends)
+.macro	s32_save_regs reg1=x9, reg2=x10
+	mov	\reg1, sp
+	adrp	\reg2, s32_crash_reg_stash
+	add	\reg2, \reg2, :lo12:s32_crash_reg_stash
+	stp	x16, x17, [\reg2]
+	stp	x29, x30, [\reg2, #16]
+	str	x9, [\reg2, #32]
+.endm
 
 /**
- * Clear SRAM region using SRAMC & current core fo unaligned ends
- *
- * x0: start address of memory area to clear
- * x1: end address of memory area to clear
- * x0: return 0 on error or size of memory cleared on success
+ * Restore intra-procedure-call scratch, frame pointer
+ * and link registers (x16, x17, x29, x30)
  *
- * Clobber list: x0,x1,x2,x3,x4,x5,x6,x7,x9,x10,x11,x12,x13,x14,x15,x16
+ * Clobbers: reg1, reg2
  */
-ENTRY(_s32g_sram_clr)
-	mov	x16, x1
-	sub	x16, x16, x0
-	mov	x13, x0
-	mov	x14, x1
-	bl	clear_unaligned_ends
-	mov	x0, x13
-	mov	x1, x14
-
-	/* Align to SRAM blocks */
-	and	x9, x0, #SRAM_INV_BLOCK_MASK
-	cmp	x0, x9
-	beq	align_high_addr
-	add	x0, x9, SRAM_BLOCK
-
-align_high_addr:
-	and	x1, x1, #SRAM_INV_BLOCK_MASK
-	cbz	x1, sram_exit
-
-	sub	x1, x1, #1
-	/* Low address */
-	bl	calc_sramc_addr
-	mov	x7, x0
-	mov	x0, x1
-
-	/* High address */
-	bl	calc_sramc_addr
-
-	/**
-	 * x7 - Low initialization address
-	 * x10 - High initialization address
-	 */
-	mov	x10, x0
-	mov	x9, #SRAMC1_MAX_ADDR
-	cmp	x10, x9
-	bgt	error
-
-	mov	x0, #SRAMC0_MIN_ADDR
-	mov	x1, #SRAMC0_MAX_ADDR
-	mov	x2, x7
-	mov	x3, x10
-	bl	in_overlap
-	cbz	x0, check_sramc1
-
-init_sramc0:
-	mov	x0, #SRAMC0_BASE_ADDR_L
-	movk	x0, #SRAMC0_BASE_ADDR_H, lsl #16
-	mov	x1, x7
-	mov	x2, x10
-	mov	x9, #SRAMC0_MAX_ADDR
-	cmp	x2, x9
-	b.gt	1f
-	b	2f
-1:
-	mov	x2, #SRAMC0_MAX_ADDR
-2:
-	bl	clear_sramc_range
-
-check_sramc1:
-	mov	x0, #SRAMC1_MIN_ADDR
-	mov	x1, #SRAMC1_MAX_ADDR
-	mov	x2, x7
-	mov	x3, x10
-	bl	in_overlap
-#if defined(CONFIG_NXP_S32G2XX) || defined(CONFIG_NXP_S32R45)
-	cbz	x0, sram_exit
-#else /* CONFIG_NXP_S32G3XX */
-	cbz	x0, check_sramc2
-#endif
-
-init_sramc1:
-	mov	x0, #SRAMC1_BASE_ADDR
-	movk	x0, #SRAMC1_BASE_ADDR_H, lsl #16
-	cmp	x7, #SRAMC1_MIN_ADDR
-	b.lt	3f
-	sub	x1, x7, #SRAMC1_MIN_ADDR
-	b	4f
-3:
-	mov	x1, #0
-4:
-	sub	x2, x10, #SRAMC1_MIN_ADDR
-	bl	clear_sramc_range
-
-#ifdef CONFIG_NXP_S32G3XX
-check_sramc2:
-	mov	x0, #SRAMC2_MIN_ADDR
-	mov	x1, #SRAMC2_MAX_ADDR_L
-	movk	x1, #SRAMC2_MAX_ADDR_H, lsl #16
-	mov	x2, x7
-	mov	x3, x10
-	bl	in_overlap
-	cbz	x0, check_sramc3
-
-init_sramc2:
-	mov	x0, #SRAMC2_BASE_ADDR_L
-	movk	x0, #SRAMC2_BASE_ADDR_H, lsl #16
-	cmp	x7, #SRAMC2_MIN_ADDR
-	b.lt	5f
-	sub	x1, x7, #SRAMC2_MIN_ADDR
-	b	6f
-5:
-	mov	x1, #0
-6:
-	sub	x2, x10, #SRAMC2_MIN_ADDR
-	bl	clear_sramc_range
-
-check_sramc3:
-	mov	x0, #SRAMC3_MIN_ADDR
-	mov	x1, #SRAMC3_MAX_ADDR_L
-	movk	x1, #SRAMC3_MAX_ADDR_H, lsl #16
-	mov	x2, x7
-	mov	x3, x10
-	bl	in_overlap
-	cbz	x0, sram_exit
-
-init_sramc3:
-	mov	x0, #SRAMC2_BASE_ADDR_L
-	movk	x0, #SRAMC2_BASE_ADDR_H, lsl #16
-	cmp	x7, #SRAMC2_MIN_ADDR
-	b.lt	7f
-	sub	x1, x7, #SRAMC2_MIN_ADDR
-	b	8f
-7:
-	mov	x1, #0
-8:
-	sub	x2, x10, #SRAMC2_MIN_ADDR
-	bl	clear_sramc_range
-#endif
-
-	mov	x0, #0
-
-sram_exit:
-	/* Restore x30 */
-	mov	x30, x15
-	mov	x0, x16
-	ret
-
-error:
-	/* Restore x30 */
-	mov	x30, x15
-	mov	x0, #0
-	ret
-ENDPROC(_s32g_sram_clr)
+.macro	s32_restore_regs reg1=x9, reg2=x10
+	adrp	\reg2, s32_crash_reg_stash
+	add	\reg2, \reg2, :lo12:s32_crash_reg_stash
+	ldp	x16, x17, [\reg2]
+	ldp	x29, x30, [\reg2, #16]
+	ldr	x9, [\reg2, #32]
+	mov	sp, \reg1
+.endm
+
+.macro	s32_init_local_stack
+	mov	w10, #S32_STACK_GUARD
+	adrp	x9, s32_plat_data_stack
+	add	x9, x9, :lo12:s32_plat_data_stack
+	/* Color the end of the stack */
+	str	w10, [x9]
+	add	x9, x9, #S32_CRASH_STACK_SIZE
+	mov	sp, x9
+.endm
+
+.macro s32_check_stack_guard
+	mov	w10, #S32_STACK_GUARD
+	adrp	x9, s32_plat_data_stack
+	add	x9, x9, :lo12:s32_plat_data_stack
+	ldrh	w9, [x9]
+	cmp	w9, w10
+	b.ne	panic
+.endm
 
 /**
  * Clear SRAM region using SRAMC
@@ -357,16 +80,16 @@ ENDPROC(_s32g_sram_clr)
  * x1: size of the memory area to be cleared
  * x0: return the size of the cleared memory
  *
- * Clobber list: x0,x1,x2,x3,x4,x5,x6,x7,x9,x10,x11,x12,x13,x14,x15,x16
+ * Clobber list: x0,x1,x9,x10
  */
 ENTRY(sram_clr)
-	/* Save x30 */
-	mov	x15, x30
+	add x1, x0, x1
+	s32_save_regs
+	s32_init_local_stack
 
-	/* To bus addresses */
-	mov	x2, #S32G_SRAM_BASE
-	sub	x0, x0, x2
-	add	x1, x1, x0
+	bl s32_sram_clear
 
-	b	_s32g_sram_clr
+	s32_check_stack_guard
+	s32_restore_regs
+	ret
 ENDPROC(sram_clr)
-- 
2.17.1

