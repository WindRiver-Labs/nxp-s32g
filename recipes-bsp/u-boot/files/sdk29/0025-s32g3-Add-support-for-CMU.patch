From c93621295afc103cd6e08e04e395eb89b898803e Mon Sep 17 00:00:00 2001
From: Larisa Grigore <larisa.grigore@nxp.com>
Date: Mon, 29 Mar 2021 15:35:55 +0300
Subject: [PATCH 25/42] s32g3: Add support for CMU

The support was tested on emulator.

Upstream-Status: Pending

Issue: ALB-6496
Signed-off-by: Larisa Grigore <larisa.grigore@nxp.com>
Signed-off-by: Zhantao Tang <zhantao.tang@windriver.com>
---
 arch/arm/cpu/armv8/s32/Kconfig                |   2 +-
 arch/arm/cpu/armv8/s32/s32-gen1/Makefile      |   4 +
 arch/arm/cpu/armv8/s32/s32-gen1/cmu.c         | 181 +-----------------
 arch/arm/cpu/armv8/s32/s32-gen1/include/cmu.h | 110 +++++++++++
 arch/arm/cpu/armv8/s32/s32-gen1/s32g2_cmu.c   |  60 ++++++
 arch/arm/cpu/armv8/s32/s32-gen1/s32g3_cmu.c   |  49 +++++
 arch/arm/cpu/armv8/s32/s32-gen1/s32r45_cmu.c  |  50 +++++
 7 files changed, 280 insertions(+), 176 deletions(-)
 create mode 100644 arch/arm/cpu/armv8/s32/s32-gen1/include/cmu.h
 create mode 100644 arch/arm/cpu/armv8/s32/s32-gen1/s32g2_cmu.c
 create mode 100644 arch/arm/cpu/armv8/s32/s32-gen1/s32g3_cmu.c
 create mode 100644 arch/arm/cpu/armv8/s32/s32-gen1/s32r45_cmu.c

diff --git a/arch/arm/cpu/armv8/s32/Kconfig b/arch/arm/cpu/armv8/s32/Kconfig
index 945051f445..f7c8822677 100644
--- a/arch/arm/cpu/armv8/s32/Kconfig
+++ b/arch/arm/cpu/armv8/s32/Kconfig
@@ -197,7 +197,7 @@ config DDR_HANDSHAKE_AT_RESET
 
 config S32_CMU
 	bool "Enable Clock Monitoring Unit-Frequency Check"
-	default y if !CONFIG_TARGET_TYPE_S32GEN1_EMULATOR
+	default y
 	depends on S32_GEN1
 	help
 	  Checks if the frequency of a monitored clock (monitored_clock)
diff --git a/arch/arm/cpu/armv8/s32/s32-gen1/Makefile b/arch/arm/cpu/armv8/s32/s32-gen1/Makefile
index 35f942a93a..72a2e4b465 100644
--- a/arch/arm/cpu/armv8/s32/s32-gen1/Makefile
+++ b/arch/arm/cpu/armv8/s32/s32-gen1/Makefile
@@ -4,6 +4,9 @@
 #
 
 obj-$(CONFIG_S32_CMU)			+= cmu.o
+obj-$(CONFIG_NXP_S32G2XX)		+= s32g2_cmu.o
+obj-$(CONFIG_NXP_S32G3XX)		+= s32g3_cmu.o
+obj-$(CONFIG_NXP_S32R45)		+= s32r45_cmu.o
 obj-$(CONFIG_HSE_SECBOOT)		+= hse_adv_secboot.o
 obj-y					+= ncore.o
 obj-y					+= soc.o
@@ -12,5 +15,6 @@ ifneq ($(filter y,$(CONFIG_NXP_S32G2XX) $(CONFIG_NXP_S32R45)),)
 obj-$(CONFIG_NETDEVICES)		+= sgmii/sgmii.o sgmii/serdes_xpcs.o
 endif
 ccflags-y				+= -I./board/freescale/s32-gen1/
+ccflags-y				+= -I./arch/arm/cpu/armv8/s32/s32-gen1/include
 ccflags-y				+= -I./arch/arm/include/asm/arch-s32/s32-gen1/
 ccflags-y				+= -I./drivers/clk/s32/include/
diff --git a/arch/arm/cpu/armv8/s32/s32-gen1/cmu.c b/arch/arm/cpu/armv8/s32/s32-gen1/cmu.c
index eb9c7699c4..e8650581ce 100644
--- a/arch/arm/cpu/armv8/s32/s32-gen1/cmu.c
+++ b/arch/arm/cpu/armv8/s32/s32-gen1/cmu.c
@@ -3,27 +3,13 @@
  * Copyright 2020-2021 NXP
  */
 #include <asm/io.h>
-#include <asm/arch/siul.h>
+#include <cmu.h>
 #include <command.h>
 #include <common.h>
 #include <inttypes.h>
 #include <linux/kernel.h>
 
-#ifndef __STR
-#define __STR(x) #x
-#endif
-#ifndef STR
-#define STR(x) __STR(x)
-#endif
-
 /* Clocks variations in percentages */
-#define FIRC_VARIATION			6.0f
-#define FXOSC_VARIATION			0.5f
-#define PERIPH_VARIATION		0.5f
-
-#define FIRC_FREQ			((double)48)
-#define FXOSC_FREQ			((double)40)
-#define SIRC_FREQ			((double)0.032)
 #define MAX_PERIPH_FREQ			((double)2000)
 
 #define CMU_FC_GCR(BASE)		((BASE) + 0x0)
@@ -50,36 +36,6 @@
 #define CMU_FM_SR_FMTO			BIT(1)
 #define CMU_FM_SR_FMC			BIT(0)
 
-#define CMU(ID, REF_CLK, MON_CLK, REF_FRQ, MON_FRQ, REF_VAR, MON_VAR, FC) \
-{\
-	.addr = CMU_BASE_ADDR + 0x20 * (ID),\
-	.ref_clk = (REF_CLK),\
-	.mon_clk = (MON_CLK),\
-	.ref_name = STR(REF_CLK),\
-	.mon_name = STR(MON_CLK),\
-	.ref_freq = (REF_FRQ),\
-	.mon_freq = (MON_FRQ),\
-	.ref_var = (REF_VAR),\
-	.mon_var = (MON_VAR),\
-	.fc = (FC),\
-}
-
-#define FXOSC_PERIPH_CMU_FC(ID, MON, MON_FRQ) \
-	CMU(ID, FXOSC_CLK, MON, FXOSC_FREQ, MON_FRQ, \
-			FXOSC_VARIATION, PERIPH_VARIATION, true)
-
-#define FIRC_PERIPH_CMU_FC(ID, MON, MON_FRQ) \
-	CMU(ID, FIRC_CLK, MON, FIRC_FREQ, MON_FRQ, \
-			FIRC_VARIATION, PERIPH_VARIATION, true)
-
-#define FXOSC_PERIPH_CMU_FM(ID, MON, MON_FRQ) \
-	CMU(ID, FXOSC_CLK, MON, FXOSC_FREQ, MON_FRQ, \
-			0, 0, false)
-
-#define FIRC_PERIPH_CMU_FM(ID, MON, MON_FRQ) \
-	CMU(ID, FIRC_CLK, MON, FIRC_FREQ, MON_FRQ, \
-			0, 0, false)
-
 #define MAX_DEPTH 20
 
 struct cmu_params {
@@ -104,130 +60,6 @@ enum fc_result {
 	HIGHER = 0x2,
 };
 
-enum cmu_fc_clk {
-	FIRC_CLK,
-	FXOSC_CLK,
-	SIRC_CLK,
-	XBAR_CLK_M7_0,
-	XBAR_CLK_M7_1,
-	XBAR_CLK_M7_2,
-	XBAR_DIV3_CLK,
-	SERDES_REF_CLK,
-	PER_CLK,
-	CAN_PE_CLK,
-	LIN_CLK,
-	QSPI_1X_CLK,
-	SDHC_CLK,
-	DDR_CLK,
-	SPI_CLK,
-	A53_CORE_CLK,
-	ACCEL3_CLK,
-	ACCEL4_CLK_0,
-	ACCEL4_CLK_1,
-	MIPICSI2_0,
-	MIPICSI2_2,
-	GMAC_TS_CLK,
-	GMAC_0_TX_CLK,
-	GMAC_0_RX_CLK,
-	GMAC_1_TX_CLK,
-	GMAC_1_RX_CLK,
-	PFE_SYS_CLK,
-	PFE_MAC_0_TX_CLK,
-	PFE_MAC_0_RX_CLK,
-	PFE_MAC_1_TX_CLK,
-	PFE_MAC_1_RX_CLK,
-	PFE_MAC_2_TX_CLK,
-	PFE_MAC_2_RX_CLK,
-	FTM_0_REF_CLK,
-	FTM_1_REF_CLK,
-};
-
-struct cmu {
-	uintptr_t addr;
-	enum cmu_fc_clk ref_clk;
-	enum cmu_fc_clk mon_clk;
-	const char *ref_name;
-	const char *mon_name;
-	double ref_freq;
-	double mon_freq;
-	double ref_var;
-	double mon_var;
-	bool fc;
-};
-
-#if defined(CONFIG_NXP_S32R45)
-static struct cmu cmu_blocks[] = {
-	FIRC_PERIPH_CMU_FC(0, FXOSC_CLK, FXOSC_FREQ),
-	FXOSC_PERIPH_CMU_FM(1, FIRC_CLK, FIRC_FREQ),
-	FXOSC_PERIPH_CMU_FM(2, SIRC_CLK, SIRC_FREQ),
-	FXOSC_PERIPH_CMU_FM(3, FTM_0_REF_CLK, 40),
-	FXOSC_PERIPH_CMU_FM(4, FTM_1_REF_CLK, 40),
-	FIRC_PERIPH_CMU_FC(5, XBAR_DIV3_CLK, 133.33),
-	FIRC_PERIPH_CMU_FC(6, XBAR_CLK_M7_0, 400),
-	FXOSC_PERIPH_CMU_FC(7, XBAR_DIV3_CLK, 133.33),
-	FIRC_PERIPH_CMU_FC(8, XBAR_CLK_M7_1, 400),
-	FIRC_PERIPH_CMU_FC(9, XBAR_CLK_M7_2, 400),
-	FIRC_PERIPH_CMU_FC(10, PER_CLK, 80),
-	FXOSC_PERIPH_CMU_FC(11, SERDES_REF_CLK, 125),
-	FXOSC_PERIPH_CMU_FC(13, CAN_PE_CLK, 80),
-	FXOSC_PERIPH_CMU_FC(14, GMAC_0_TX_CLK, 125),
-	FXOSC_PERIPH_CMU_FC(15, GMAC_TS_CLK, 200),
-	FXOSC_PERIPH_CMU_FC(16, LIN_CLK, 125),
-	FXOSC_PERIPH_CMU_FC(17, QSPI_1X_CLK, 133.33),
-	FXOSC_PERIPH_CMU_FC(18, SDHC_CLK, 400),
-	FIRC_PERIPH_CMU_FC(20, DDR_CLK, 800),
-	FXOSC_PERIPH_CMU_FC(21, GMAC_0_RX_CLK, 125),
-	FXOSC_PERIPH_CMU_FC(22, SPI_CLK, 100),
-	FXOSC_PERIPH_CMU_FC(27, A53_CORE_CLK, 800),
-	FIRC_PERIPH_CMU_FC(28, A53_CORE_CLK, 800),
-	FXOSC_PERIPH_CMU_FC(38, ACCEL3_CLK, 600),
-	FXOSC_PERIPH_CMU_FC(39, ACCEL4_CLK_0, 400),
-	FXOSC_PERIPH_CMU_FC(40, ACCEL4_CLK_0, 400),
-	FXOSC_PERIPH_CMU_FC(46, GMAC_1_TX_CLK, 125),
-	FXOSC_PERIPH_CMU_FC(51, GMAC_1_RX_CLK, 125),
-	FXOSC_PERIPH_CMU_FC(52, MIPICSI2_0, 400),
-	FXOSC_PERIPH_CMU_FC(53, MIPICSI2_0, 400),
-	FXOSC_PERIPH_CMU_FC(54, SERDES_REF_CLK, 125),
-};
-#elif defined(CONFIG_NXP_S32G2XX) || defined(CONFIG_NXP_S32G3XX)
-static struct cmu cmu_blocks[] = {
-	FIRC_PERIPH_CMU_FC(0, FXOSC_CLK, FXOSC_FREQ),
-	FXOSC_PERIPH_CMU_FM(1, FIRC_CLK, FIRC_FREQ),
-	FXOSC_PERIPH_CMU_FM(2, SIRC_CLK, SIRC_FREQ),
-	FXOSC_PERIPH_CMU_FM(3, FTM_0_REF_CLK, 40),
-	FXOSC_PERIPH_CMU_FM(4, FTM_1_REF_CLK, 40),
-	FIRC_PERIPH_CMU_FC(0, FXOSC_CLK, FXOSC_FREQ),
-	FIRC_PERIPH_CMU_FC(5, XBAR_DIV3_CLK, 133.33),
-	FIRC_PERIPH_CMU_FC(6, XBAR_CLK_M7_0, 400),
-	FXOSC_PERIPH_CMU_FC(7, XBAR_DIV3_CLK, 133.33),
-	FIRC_PERIPH_CMU_FC(8, XBAR_CLK_M7_1, 400),
-	FIRC_PERIPH_CMU_FC(9, XBAR_CLK_M7_2, 400),
-	FIRC_PERIPH_CMU_FC(10, PER_CLK, 80),
-	FXOSC_PERIPH_CMU_FC(11, SERDES_REF_CLK, 125),
-	FXOSC_PERIPH_CMU_FC(13, CAN_PE_CLK, 80),
-	FXOSC_PERIPH_CMU_FC(14, GMAC_0_TX_CLK, 125),
-	FXOSC_PERIPH_CMU_FC(15, GMAC_TS_CLK, 200),
-	FXOSC_PERIPH_CMU_FC(16, LIN_CLK, 125),
-	FXOSC_PERIPH_CMU_FC(17, QSPI_1X_CLK, 200),
-	FXOSC_PERIPH_CMU_FC(18, SDHC_CLK, 400),
-	FIRC_PERIPH_CMU_FC(20, DDR_CLK, 666.66),
-	FXOSC_PERIPH_CMU_FC(21, GMAC_0_RX_CLK, 125),
-	FXOSC_PERIPH_CMU_FC(22, SPI_CLK, 100),
-	FXOSC_PERIPH_CMU_FC(27, A53_CORE_CLK, 1000),
-	FIRC_PERIPH_CMU_FC(28, A53_CORE_CLK, 1000),
-	FXOSC_PERIPH_CMU_FC(39, PFE_SYS_CLK, 300),
-	FXOSC_PERIPH_CMU_FC(46, PFE_MAC_0_TX_CLK, 312.5),
-	FXOSC_PERIPH_CMU_FC(47, PFE_MAC_0_RX_CLK, 312.5),
-	FXOSC_PERIPH_CMU_FC(48, PFE_MAC_1_TX_CLK, 125),
-	FXOSC_PERIPH_CMU_FC(49, PFE_MAC_1_RX_CLK, 125),
-	FXOSC_PERIPH_CMU_FC(50, PFE_MAC_2_TX_CLK, 125),
-	FXOSC_PERIPH_CMU_FC(51, PFE_MAC_2_RX_CLK, 125),
-
-};
-#else
-#error CMU_FC cannot be enabled for this board
-#endif
-
 static double get_min_freq(double clk, double variation)
 {
 	return clk * ((double)1 - variation / 100);
@@ -501,6 +333,8 @@ static int get_fm_mon_freq(struct cmu *inst, double *mon_freq)
 	return 0;
 }
 
+__weak void cmu_fixup(void) {}
+
 static int do_verify_clocks(cmd_tbl_t *cmdtp, int flag, int argc,
 			    char * const argv[])
 {
@@ -517,13 +351,10 @@ static int do_verify_clocks(cmd_tbl_t *cmdtp, int flag, int argc,
 	puts("-----------|------------------|-----------|----------");
 	puts("|--------------------\n");
 
-#if defined(CONFIG_TARGET_S32G274AEVB) || defined(CONFIG_TARGET_S32G274ARDB)
-	if (is_s32gen1_soc_rev1())
-		cmu_blocks[17].mon_freq = 133.33;
-#endif
+	cmu_fixup();
 
-	for (i = 0; i < ARRAY_SIZE(cmu_blocks); i++) {
-		inst = &cmu_blocks[i];
+	for (i = 0; i < get_cmu_blocks_number(); i++) {
+		inst = get_cmu_block(i);
 		if (inst->fc) {
 			if (get_fc_mon_freq(inst, &freq_int)) {
 				pr_err("Failed to determine CMU_FC parameters "
diff --git a/arch/arm/cpu/armv8/s32/s32-gen1/include/cmu.h b/arch/arm/cpu/armv8/s32/s32-gen1/include/cmu.h
new file mode 100644
index 0000000000..20229d8a44
--- /dev/null
+++ b/arch/arm/cpu/armv8/s32/s32-gen1/include/cmu.h
@@ -0,0 +1,110 @@
+/* SPDX-License-Identifier: GPL-2.0+ */
+/*
+ * Copyright 2021 NXP
+ */
+
+#ifndef __S32_CMU_H
+#define __S32_CMU_H
+
+#include <common.h>
+
+#ifndef __STR
+#define __STR(x) #x
+#endif
+#ifndef STR
+#define STR(x) __STR(x)
+#endif
+
+#define FIRC_VARIATION			6.0f
+#define FXOSC_VARIATION			0.5f
+#define PERIPH_VARIATION		0.5f
+
+#define FIRC_FREQ			((double)48)
+#define FXOSC_FREQ			((double)40)
+#define SIRC_FREQ			((double)0.032)
+
+#define CMU(ID, REF_CLK, MON_CLK, REF_FRQ, MON_FRQ, REF_VAR, MON_VAR, FC) \
+{\
+	.addr = CMU_BASE_ADDR + 0x20 * (ID),\
+	.ref_clk = (REF_CLK),\
+	.mon_clk = (MON_CLK),\
+	.ref_name = STR(REF_CLK),\
+	.mon_name = STR(MON_CLK),\
+	.ref_freq = (REF_FRQ),\
+	.mon_freq = (MON_FRQ),\
+	.ref_var = (REF_VAR),\
+	.mon_var = (MON_VAR),\
+	.fc = (FC),\
+}
+
+#define FXOSC_PERIPH_CMU_FC(ID, MON, MON_FRQ) \
+	CMU(ID, FXOSC_CLK, MON, FXOSC_FREQ, MON_FRQ, \
+			FXOSC_VARIATION, PERIPH_VARIATION, true)
+
+#define FIRC_PERIPH_CMU_FC(ID, MON, MON_FRQ) \
+	CMU(ID, FIRC_CLK, MON, FIRC_FREQ, MON_FRQ, \
+			FIRC_VARIATION, PERIPH_VARIATION, true)
+
+#define FXOSC_PERIPH_CMU_FM(ID, MON, MON_FRQ) \
+	CMU(ID, FXOSC_CLK, MON, FXOSC_FREQ, MON_FRQ, \
+			0, 0, false)
+
+#define FIRC_PERIPH_CMU_FM(ID, MON, MON_FRQ) \
+	CMU(ID, FIRC_CLK, MON, FIRC_FREQ, MON_FRQ, \
+			0, 0, false)
+
+enum cmu_fc_clk {
+	FIRC_CLK,
+	FXOSC_CLK,
+	SIRC_CLK,
+	XBAR_CLK_M7_0,
+	XBAR_CLK_M7_1,
+	XBAR_CLK_M7_2,
+	XBAR_DIV3_CLK,
+	SERDES_REF_CLK,
+	PER_CLK,
+	CAN_PE_CLK,
+	LIN_CLK,
+	QSPI_1X_CLK,
+	SDHC_CLK,
+	DDR_CLK,
+	SPI_CLK,
+	A53_CORE_CLK,
+	ACCEL3_CLK,
+	ACCEL4_CLK_0,
+	ACCEL4_CLK_1,
+	MIPICSI2_0,
+	MIPICSI2_2,
+	GMAC_TS_CLK,
+	GMAC_0_TX_CLK,
+	GMAC_0_RX_CLK,
+	GMAC_1_TX_CLK,
+	GMAC_1_RX_CLK,
+	PFE_SYS_CLK,
+	PFE_MAC_0_TX_CLK,
+	PFE_MAC_0_RX_CLK,
+	PFE_MAC_1_TX_CLK,
+	PFE_MAC_1_RX_CLK,
+	PFE_MAC_2_TX_CLK,
+	PFE_MAC_2_RX_CLK,
+	FTM_0_REF_CLK,
+	FTM_1_REF_CLK,
+};
+
+struct cmu {
+	uintptr_t addr;
+	enum cmu_fc_clk ref_clk;
+	enum cmu_fc_clk mon_clk;
+	const char *ref_name;
+	const char *mon_name;
+	double ref_freq;
+	double mon_freq;
+	double ref_var;
+	double mon_var;
+	bool fc;
+};
+
+void cmu_fixup(void);
+struct cmu *get_cmu_block(int index);
+int get_cmu_blocks_number(void);
+#endif
diff --git a/arch/arm/cpu/armv8/s32/s32-gen1/s32g2_cmu.c b/arch/arm/cpu/armv8/s32/s32-gen1/s32g2_cmu.c
new file mode 100644
index 0000000000..a9ef3a5cd9
--- /dev/null
+++ b/arch/arm/cpu/armv8/s32/s32-gen1/s32g2_cmu.c
@@ -0,0 +1,60 @@
+// SPDX-License-Identifier: GPL-2.0+
+/*
+ * Copyright 2020-2021 NXP
+ */
+
+#include <asm/arch/siul.h>
+#include <cmu.h>
+
+static struct cmu cmu_blocks[] = {
+	FIRC_PERIPH_CMU_FC(0, FXOSC_CLK, FXOSC_FREQ),
+	FXOSC_PERIPH_CMU_FM(1, FIRC_CLK, FIRC_FREQ),
+	FXOSC_PERIPH_CMU_FM(2, SIRC_CLK, SIRC_FREQ),
+	FXOSC_PERIPH_CMU_FM(3, FTM_0_REF_CLK, 40),
+	FXOSC_PERIPH_CMU_FM(4, FTM_1_REF_CLK, 40),
+	FIRC_PERIPH_CMU_FC(0, FXOSC_CLK, FXOSC_FREQ),
+	FIRC_PERIPH_CMU_FC(5, XBAR_DIV3_CLK, 133.33),
+	FIRC_PERIPH_CMU_FC(6, XBAR_CLK_M7_0, 400),
+	FXOSC_PERIPH_CMU_FC(7, XBAR_DIV3_CLK, 133.33),
+	FIRC_PERIPH_CMU_FC(8, XBAR_CLK_M7_1, 400),
+	FIRC_PERIPH_CMU_FC(9, XBAR_CLK_M7_2, 400),
+	FIRC_PERIPH_CMU_FC(10, PER_CLK, 80),
+	FXOSC_PERIPH_CMU_FC(11, SERDES_REF_CLK, 125),
+	FXOSC_PERIPH_CMU_FC(13, CAN_PE_CLK, 80),
+	FXOSC_PERIPH_CMU_FC(14, GMAC_0_TX_CLK, 125),
+	FXOSC_PERIPH_CMU_FC(15, GMAC_TS_CLK, 200),
+	FXOSC_PERIPH_CMU_FC(16, LIN_CLK, 125),
+	FXOSC_PERIPH_CMU_FC(17, QSPI_1X_CLK, 200),
+	FXOSC_PERIPH_CMU_FC(18, SDHC_CLK, 400),
+	FIRC_PERIPH_CMU_FC(20, DDR_CLK, 666.66),
+	FXOSC_PERIPH_CMU_FC(21, GMAC_0_RX_CLK, 125),
+	FXOSC_PERIPH_CMU_FC(22, SPI_CLK, 100),
+	FXOSC_PERIPH_CMU_FC(27, A53_CORE_CLK, 1000),
+	FIRC_PERIPH_CMU_FC(28, A53_CORE_CLK, 1000),
+	FXOSC_PERIPH_CMU_FC(39, PFE_SYS_CLK, 300),
+	FXOSC_PERIPH_CMU_FC(46, PFE_MAC_0_TX_CLK, 312.5),
+	FXOSC_PERIPH_CMU_FC(47, PFE_MAC_0_RX_CLK, 312.5),
+	FXOSC_PERIPH_CMU_FC(48, PFE_MAC_1_TX_CLK, 125),
+	FXOSC_PERIPH_CMU_FC(49, PFE_MAC_1_RX_CLK, 125),
+	FXOSC_PERIPH_CMU_FC(50, PFE_MAC_2_TX_CLK, 125),
+	FXOSC_PERIPH_CMU_FC(51, PFE_MAC_2_RX_CLK, 125),
+
+};
+
+void cmu_fixup(void)
+{
+#if defined(CONFIG_TARGET_S32G274AEVB) || defined(CONFIG_TARGET_S32G274ARDB)
+	if (is_s32gen1_soc_rev1())
+		cmu_blocks[17].mon_freq = 133.33;
+#endif
+}
+
+struct cmu *get_cmu_block(int index)
+{
+	return &cmu_blocks[index];
+}
+
+int get_cmu_blocks_number(void)
+{
+	return ARRAY_SIZE(cmu_blocks);
+}
diff --git a/arch/arm/cpu/armv8/s32/s32-gen1/s32g3_cmu.c b/arch/arm/cpu/armv8/s32/s32-gen1/s32g3_cmu.c
new file mode 100644
index 0000000000..cc7fbc5d02
--- /dev/null
+++ b/arch/arm/cpu/armv8/s32/s32-gen1/s32g3_cmu.c
@@ -0,0 +1,49 @@
+// SPDX-License-Identifier: GPL-2.0+
+/*
+ * Copyright 2021 NXP
+ */
+#include <cmu.h>
+
+static struct cmu cmu_blocks[] = {
+	FIRC_PERIPH_CMU_FC(0, FXOSC_CLK, FXOSC_FREQ),
+	FXOSC_PERIPH_CMU_FM(1, FIRC_CLK, FIRC_FREQ),
+	FXOSC_PERIPH_CMU_FM(2, SIRC_CLK, SIRC_FREQ),
+	FXOSC_PERIPH_CMU_FM(3, FTM_0_REF_CLK, 40),
+	FXOSC_PERIPH_CMU_FM(4, FTM_1_REF_CLK, 40),
+	FIRC_PERIPH_CMU_FC(0, FXOSC_CLK, FXOSC_FREQ),
+	FIRC_PERIPH_CMU_FC(6, XBAR_CLK_M7_0, 399.96),
+	FXOSC_PERIPH_CMU_FC(7, XBAR_DIV3_CLK, 133.32),
+	FIRC_PERIPH_CMU_FC(8, XBAR_CLK_M7_1, 399.96),
+	FIRC_PERIPH_CMU_FC(9, XBAR_CLK_M7_2, 399.96),
+	FIRC_PERIPH_CMU_FC(10, PER_CLK, 80),
+	FIRC_PERIPH_CMU_FC(5, XBAR_DIV3_CLK, 133.32),
+	FXOSC_PERIPH_CMU_FC(11, SERDES_REF_CLK, 125),
+	FXOSC_PERIPH_CMU_FC(13, CAN_PE_CLK, 80),
+	FXOSC_PERIPH_CMU_FC(14, GMAC_0_TX_CLK, 125),
+	FXOSC_PERIPH_CMU_FC(15, GMAC_TS_CLK, 200),
+	FXOSC_PERIPH_CMU_FC(16, LIN_CLK, 125),
+	FXOSC_PERIPH_CMU_FC(17, QSPI_1X_CLK, 200),
+	FXOSC_PERIPH_CMU_FC(18, SDHC_CLK, 400),
+	FIRC_PERIPH_CMU_FC(20, DDR_CLK, 800),
+	FXOSC_PERIPH_CMU_FC(21, GMAC_0_RX_CLK, 125),
+	FXOSC_PERIPH_CMU_FC(22, SPI_CLK, 100),
+	FXOSC_PERIPH_CMU_FC(27, A53_CORE_CLK, 1300),
+	FIRC_PERIPH_CMU_FC(28, A53_CORE_CLK, 1300),
+	FXOSC_PERIPH_CMU_FC(39, PFE_SYS_CLK, 300),
+	FXOSC_PERIPH_CMU_FC(46, PFE_MAC_0_TX_CLK, 312.5),
+	FXOSC_PERIPH_CMU_FC(47, PFE_MAC_0_RX_CLK, 312.5),
+	FXOSC_PERIPH_CMU_FC(48, PFE_MAC_1_TX_CLK, 125),
+	FXOSC_PERIPH_CMU_FC(49, PFE_MAC_1_RX_CLK, 125),
+	FXOSC_PERIPH_CMU_FC(50, PFE_MAC_2_TX_CLK, 125),
+	FXOSC_PERIPH_CMU_FC(51, PFE_MAC_2_RX_CLK, 125),
+};
+
+struct cmu *get_cmu_block(int index)
+{
+	return &cmu_blocks[index];
+}
+
+int get_cmu_blocks_number(void)
+{
+	return ARRAY_SIZE(cmu_blocks);
+}
diff --git a/arch/arm/cpu/armv8/s32/s32-gen1/s32r45_cmu.c b/arch/arm/cpu/armv8/s32/s32-gen1/s32r45_cmu.c
new file mode 100644
index 0000000000..9f282c9b2b
--- /dev/null
+++ b/arch/arm/cpu/armv8/s32/s32-gen1/s32r45_cmu.c
@@ -0,0 +1,50 @@
+// SPDX-License-Identifier: GPL-2.0+
+/*
+ * Copyright 2020-2021 NXP
+ */
+
+#include <cmu.h>
+
+static struct cmu cmu_blocks[] = {
+	FIRC_PERIPH_CMU_FC(0, FXOSC_CLK, FXOSC_FREQ),
+	FXOSC_PERIPH_CMU_FM(1, FIRC_CLK, FIRC_FREQ),
+	FXOSC_PERIPH_CMU_FM(2, SIRC_CLK, SIRC_FREQ),
+	FXOSC_PERIPH_CMU_FM(3, FTM_0_REF_CLK, 40),
+	FXOSC_PERIPH_CMU_FM(4, FTM_1_REF_CLK, 40),
+	FIRC_PERIPH_CMU_FC(5, XBAR_DIV3_CLK, 133.33),
+	FIRC_PERIPH_CMU_FC(6, XBAR_CLK_M7_0, 400),
+	FXOSC_PERIPH_CMU_FC(7, XBAR_DIV3_CLK, 133.33),
+	FIRC_PERIPH_CMU_FC(8, XBAR_CLK_M7_1, 400),
+	FIRC_PERIPH_CMU_FC(9, XBAR_CLK_M7_2, 400),
+	FIRC_PERIPH_CMU_FC(10, PER_CLK, 80),
+	FXOSC_PERIPH_CMU_FC(11, SERDES_REF_CLK, 125),
+	FXOSC_PERIPH_CMU_FC(13, CAN_PE_CLK, 80),
+	FXOSC_PERIPH_CMU_FC(14, GMAC_0_TX_CLK, 125),
+	FXOSC_PERIPH_CMU_FC(15, GMAC_TS_CLK, 200),
+	FXOSC_PERIPH_CMU_FC(16, LIN_CLK, 125),
+	FXOSC_PERIPH_CMU_FC(17, QSPI_1X_CLK, 133.33),
+	FXOSC_PERIPH_CMU_FC(18, SDHC_CLK, 400),
+	FIRC_PERIPH_CMU_FC(20, DDR_CLK, 800),
+	FXOSC_PERIPH_CMU_FC(21, GMAC_0_RX_CLK, 125),
+	FXOSC_PERIPH_CMU_FC(22, SPI_CLK, 100),
+	FXOSC_PERIPH_CMU_FC(27, A53_CORE_CLK, 800),
+	FIRC_PERIPH_CMU_FC(28, A53_CORE_CLK, 800),
+	FXOSC_PERIPH_CMU_FC(38, ACCEL3_CLK, 600),
+	FXOSC_PERIPH_CMU_FC(39, ACCEL4_CLK_0, 400),
+	FXOSC_PERIPH_CMU_FC(40, ACCEL4_CLK_0, 400),
+	FXOSC_PERIPH_CMU_FC(46, GMAC_1_TX_CLK, 125),
+	FXOSC_PERIPH_CMU_FC(51, GMAC_1_RX_CLK, 125),
+	FXOSC_PERIPH_CMU_FC(52, MIPICSI2_0, 400),
+	FXOSC_PERIPH_CMU_FC(53, MIPICSI2_0, 400),
+	FXOSC_PERIPH_CMU_FC(54, SERDES_REF_CLK, 125),
+};
+
+struct cmu *get_cmu_block(int index)
+{
+	return &cmu_blocks[index];
+}
+
+int get_cmu_blocks_number(void)
+{
+	return ARRAY_SIZE(cmu_blocks);
+}
-- 
2.25.1

