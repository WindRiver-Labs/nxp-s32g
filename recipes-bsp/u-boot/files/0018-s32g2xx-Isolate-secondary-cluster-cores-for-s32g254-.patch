From 38c5d74981cabc41f9e9425b1de9edb06d0cf19f Mon Sep 17 00:00:00 2001
From: Ghennadi Procopciuc <Ghennadi.Procopciuc@nxp.com>
Date: Thu, 10 Dec 2020 12:18:14 +0200
Subject: [PATCH 18/76] s32g2xx: Isolate secondary cluster cores for s32g254 &
 s32g233

Issue: ALB-6005, ALB-6004
Signed-off-by: Ghennadi Procopciuc <Ghennadi.Procopciuc@nxp.com>
---
 arch/arm/cpu/armv8/s32/fdt.c          | 38 +++++++++++++++++++++------
 arch/arm/cpu/armv8/s32/mp.c           |  9 ++++---
 arch/arm/cpu/armv8/s32/mp.h           |  3 +--
 arch/arm/cpu/armv8/s32/s32-gen1/soc.c | 25 ++++++++++++++++++
 arch/arm/cpu/armv8/s32/s32v234/soc.c  |  6 +++++
 5 files changed, 68 insertions(+), 13 deletions(-)

diff --git a/arch/arm/cpu/armv8/s32/fdt.c b/arch/arm/cpu/armv8/s32/fdt.c
index 3d5f639fa6..beacdb1319 100644
--- a/arch/arm/cpu/armv8/s32/fdt.c
+++ b/arch/arm/cpu/armv8/s32/fdt.c
@@ -14,6 +14,8 @@
 #include <linux/sizes.h>
 #include "mp.h"
 
+#define ID_TO_CORE(ID)	(((ID) & 3) | ((ID) >> 7))
+
 #if defined(CONFIG_TARGET_S32G274AEVB) || defined(CONFIG_TARGET_S32G274ARDB)
 #include <dt-bindings/clock/s32gen1-clock-freq.h>
 #endif
@@ -99,21 +101,41 @@ fdt_error:
 
 void ft_fixup_cpu(void *blob)
 {
-	int off;
-	u64 *reg;
+	int off, addr_cells;
+	u64 core_id;
+	fdt32_t *reg;
+	u32 mask = cpu_pos_mask();
+	int off_prev = -1;
+
+	off = fdt_path_offset(blob, "/cpus");
+	if (off < 0) {
+		puts("couldn't find /cpus node\n");
+		return;
+	}
+
+	fdt_support_default_count_cells(blob, off, &addr_cells, NULL);
 
-	off = fdt_node_offset_by_prop_value(blob, -1, "device_type", "cpu", 4);
+	off = fdt_node_offset_by_prop_value(blob, off_prev, "device_type",
+					    "cpu", 4);
 	while (off != -FDT_ERR_NOTFOUND) {
-		reg = (u64 *)fdt_getprop(blob, off, "reg", 0);
+		reg = (fdt32_t *)fdt_getprop(blob, off, "reg", 0);
 		if (!reg) {
-			puts("cpu NULL\n");
 			continue;
 		}
+
+		core_id = fdt_read_number(reg, addr_cells);
+		if (!test_bit(ID_TO_CORE(core_id), &mask)) {
+			fdt_del_node(blob, off);
+			off = off_prev;
+		} else {
 #if CONFIG_S32_ATF_BOOT_FLOW
-		ft_fixup_enable_method(blob, off, *reg);
+			ft_fixup_enable_method(blob, off, *reg);
 #endif
-		off = fdt_node_offset_by_prop_value(blob, off, "device_type",
-						    "cpu", 4);
+		}
+
+		off_prev = off;
+		off = fdt_node_offset_by_prop_value(blob, off_prev,
+						    "device_type", "cpu", 4);
 	}
 
 #if CONFIG_S32_ATF_BOOT_FLOW
diff --git a/arch/arm/cpu/armv8/s32/mp.c b/arch/arm/cpu/armv8/s32/mp.c
index cfa8904dc4..8049b83267 100644
--- a/arch/arm/cpu/armv8/s32/mp.c
+++ b/arch/arm/cpu/armv8/s32/mp.c
@@ -113,6 +113,8 @@ static void fsl_s32_wake_secondary_core(int prtn, int core)
 
 int fsl_s32_wake_secondary_cores(void)
 {
+	u32 i, mask = cpu_pos_mask();
+
 	/* Enable partition clock */
 	writel(MC_ME_PRTN_N_PCE,
 	       MC_ME_PRTN_N_PCONF(MC_ME_BASE_ADDR, MC_ME_CORES_PRTN));
@@ -129,9 +131,10 @@ int fsl_s32_wake_secondary_cores(void)
 	 * The procedure can be found in
 	 * "MC_ME application core enable", S32R RM Rev1 DraftC.
 	 */
-	fsl_s32_wake_secondary_core(1, 1);
-	fsl_s32_wake_secondary_core(1, 2);
-	fsl_s32_wake_secondary_core(1, 3);
+	for (i = 1; i <= fls(mask); i++) {
+		if (test_bit(i, &mask))
+			fsl_s32_wake_secondary_core(1, i);
+	}
 
 	smp_kick_all_cpus();
 
diff --git a/arch/arm/cpu/armv8/s32/mp.h b/arch/arm/cpu/armv8/s32/mp.h
index 22c68ca736..4459678a23 100644
--- a/arch/arm/cpu/armv8/s32/mp.h
+++ b/arch/arm/cpu/armv8/s32/mp.h
@@ -7,8 +7,6 @@
 #ifndef _S32_MP_H
 #define _S32_MP_H
 
-#define id_to_core(x)	((x & 3) | (x >> 8))
-
 #if defined (CONFIG_S32_GEN1)
 #define S32_A53_GPR_BASE_ADDR	0x4007c400ul
 #define S32_A53_GP06_OFF	0x18
@@ -25,6 +23,7 @@ int fsl_s32_wake_secondary_cores(void);
 void *get_spin_tbl_addr(void);
 phys_addr_t determine_mp_bootpg(void);
 void secondary_boot_func(void);
+u32 cpu_pos_mask(void);
 #endif
 
 #endif /* _S32_MP_H */
diff --git a/arch/arm/cpu/armv8/s32/s32-gen1/soc.c b/arch/arm/cpu/armv8/s32/s32-gen1/soc.c
index 8093166f43..c566ccad91 100644
--- a/arch/arm/cpu/armv8/s32/s32-gen1/soc.c
+++ b/arch/arm/cpu/armv8/s32/s32-gen1/soc.c
@@ -323,3 +323,28 @@ int mmap_dspi(unsigned short bus, struct dspi **base_addr)
 	return 0;
 }
 #endif
+
+#if CONFIG_NXP_S32G2XX
+u32 cpu_pos_mask(void)
+{
+	switch (get_s32g2_derivative()) {
+	case S32G274A_DERIV:
+		return BIT(0) | BIT(1) | BIT(2) | BIT(3);
+	case S32G254A_DERIV:
+	case S32G233A_DERIV:
+		return BIT(0) | BIT(2);
+	default:
+		return 0;
+	}
+
+	return 0;
+}
+#endif
+
+#ifdef CONFIG_NXP_S32R45
+u32 cpu_pos_mask(void)
+{
+	/* 4 cores */
+	return 0xFU;
+}
+#endif
diff --git a/arch/arm/cpu/armv8/s32/s32v234/soc.c b/arch/arm/cpu/armv8/s32/s32v234/soc.c
index 719e1be141..11f629e8e7 100644
--- a/arch/arm/cpu/armv8/s32/s32v234/soc.c
+++ b/arch/arm/cpu/armv8/s32/s32v234/soc.c
@@ -1134,3 +1134,9 @@ int mmap_dspi(unsigned short bus, struct dspi **base_addr)
 	return 0;
 }
 #endif
+
+u32 cpu_pos_mask(void)
+{
+	/* 4 cores */
+	return 0xFU;
+}
-- 
2.17.1

