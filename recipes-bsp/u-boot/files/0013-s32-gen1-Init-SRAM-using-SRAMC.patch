From 1fb1ff737390dbebbd3d2bff39c5ba6419ade318 Mon Sep 17 00:00:00 2001
From: Ghennadi Procopciuc <Ghennadi.Procopciuc@nxp.com>
Date: Wed, 16 Dec 2020 14:08:07 +0200
Subject: [PATCH 13/76] s32-gen1: Init SRAM using SRAMC

This reduces the time needed for SRAM initialization from 122ms to 0.894ms

Issue: ALB-6126
Signed-off-by: Ghennadi Procopciuc <Ghennadi.Procopciuc@nxp.com>
---
 arch/arm/cpu/armv8/s32/Makefile              |   1 +
 arch/arm/cpu/armv8/s32/cpu.c                 |   8 +-
 arch/arm/cpu/armv8/s32/cse.c                 |   4 +-
 arch/arm/cpu/armv8/s32/initsram.c            |   5 +-
 arch/arm/cpu/armv8/s32/lowlevel.S            | 101 +------
 arch/arm/cpu/armv8/s32/s32-gen1/Makefile     |   1 +
 arch/arm/cpu/armv8/s32/s32-gen1/s32g_sramc.h |  45 +++
 arch/arm/cpu/armv8/s32/s32-gen1/sram.S       | 296 +++++++++++++++++++
 arch/arm/cpu/armv8/s32/s32v234/Makefile      |   1 +
 arch/arm/cpu/armv8/s32/s32v234/sram.S        | 108 +++++++
 arch/arm/cpu/armv8/s32/{dma_mem.h => sram.h} |   6 +-
 11 files changed, 466 insertions(+), 110 deletions(-)
 create mode 100644 arch/arm/cpu/armv8/s32/s32-gen1/s32g_sramc.h
 create mode 100644 arch/arm/cpu/armv8/s32/s32-gen1/sram.S
 create mode 100644 arch/arm/cpu/armv8/s32/s32v234/sram.S
 rename arch/arm/cpu/armv8/s32/{dma_mem.h => sram.h} (81%)

diff --git a/arch/arm/cpu/armv8/s32/Makefile b/arch/arm/cpu/armv8/s32/Makefile
index 8389dcf163..08d10cc061 100644
--- a/arch/arm/cpu/armv8/s32/Makefile
+++ b/arch/arm/cpu/armv8/s32/Makefile
@@ -4,6 +4,7 @@
 # (C) Copyright 2016-2018, 2020 NXP
 #
 ccflags-y += -I./board/freescale/common/
+ccflags-y += -Iarch/arm/cpu/armv8/s32/
 
 obj-$(CONFIG_S32V234)		+= s32v234/
 obj-$(CONFIG_S32_GEN1)		+= s32-gen1/
diff --git a/arch/arm/cpu/armv8/s32/cpu.c b/arch/arm/cpu/armv8/s32/cpu.c
index 5fcce8a705..19bdbeeaea 100644
--- a/arch/arm/cpu/armv8/s32/cpu.c
+++ b/arch/arm/cpu/armv8/s32/cpu.c
@@ -13,7 +13,7 @@
 #include <asm/arch/siul.h>
 #include <asm-generic/sections.h>
 #include "mp.h"
-#include "dma_mem.h"
+#include "sram.h"
 #include "scmi_reset_agent.h"
 #include <asm/arch/soc.h>
 #include <asm/arch/s32-gen1/a53_cluster_gpr.h>
@@ -193,7 +193,7 @@ static inline void early_mmu_setup(void)
 	gd->arch.tlb_size = CONFIG_SYS_TEXT_BASE - S32_IRAM_MMU_TABLES_BASE;
 
 #if defined(CONFIG_S32_SKIP_RELOC) && !defined(CONFIG_S32_ATF_BOOT_FLOW)
-	dma_mem_clr(gd->arch.tlb_addr, gd->arch.tlb_size);
+	sram_clr(gd->arch.tlb_addr, gd->arch.tlb_size);
 #endif
 
 #ifdef CONFIG_S32V234
@@ -231,7 +231,7 @@ static inline void final_mmu_setup(void)
 	gd->arch.tlb_size = CONFIG_SYS_TEXT_BASE - S32_IRAM_MMU_TABLES_BASE;
 
 #if defined(CONFIG_S32_SKIP_RELOC) && !defined(CONFIG_S32_ATF_BOOT_FLOW)
-	dma_mem_clr(gd->arch.tlb_addr, gd->arch.tlb_size);
+	sram_clr(gd->arch.tlb_addr, gd->arch.tlb_size);
 #endif
 	setup_pgtables();
 
@@ -306,7 +306,7 @@ static inline int clear_after_bss(void)
 	 */
 	base = (uintptr_t)&__bss_end;
 	size = S32_SRAM_BASE + S32_SRAM_SIZE - base;
-	ret = dma_mem_clr(base, size);
+	ret = sram_clr(base, size);
 	if (!ret)
 		return ret;
 
diff --git a/arch/arm/cpu/armv8/s32/cse.c b/arch/arm/cpu/armv8/s32/cse.c
index d9053007a0..158781d879 100644
--- a/arch/arm/cpu/armv8/s32/cse.c
+++ b/arch/arm/cpu/armv8/s32/cse.c
@@ -12,6 +12,7 @@
 #include <linux/libfdt.h>
 #include <fs.h>
 #include <errno.h>
+#include <sram.h>
 
 #define CSE_TIMEOUT		1000000
 
@@ -64,7 +65,6 @@ static int mmc_load_cse_blob(void)
 	return 0;
 }
 
-extern void dma_mem_clr(void *, uint32_t);
 int cse_init(void)
 {
 	uint32_t firmware;
@@ -106,7 +106,7 @@ cse_firmware_loading:
 	/* check if CSE_BLOB_BASE is in SRAM and if it is, clear the area
 	 * between CSE_BLOB_BASE and CSE_BLOB_BASE + CSE_BLOB_SIZE */
 	if (is_addr_in_sram(CSE_BLOB_BASE))
-		dma_mem_clr((void *)CSE_BLOB_BASE, CSE_BLOB_SIZE);
+		sram_clr(CSE_BLOB_BASE, CSE_BLOB_SIZE);
 
 	if (mmc_load_cse_blob()) {
 		printf("CSE firmware loading failed\n");
diff --git a/arch/arm/cpu/armv8/s32/initsram.c b/arch/arm/cpu/armv8/s32/initsram.c
index 4907d1618c..6850722e1c 100644
--- a/arch/arm/cpu/armv8/s32/initsram.c
+++ b/arch/arm/cpu/armv8/s32/initsram.c
@@ -7,8 +7,7 @@
 #include <common.h>
 #include <cpu_func.h>
 #include <linux/kernel.h>
-
-int dma_mem_clr(int addr, int size);
+#include <sram.h>
 
 static int do_init_sram(cmd_tbl_t *cmdtp, int flag, int argc,
 			char * const argv[])
@@ -53,7 +52,7 @@ static int do_init_sram(cmd_tbl_t *cmdtp, int flag, int argc,
 	}
 
 	invalidate_dcache_range(addr, addr + size);
-	ret_size = dma_mem_clr(addr, size);
+	ret_size = sram_clr(addr, size);
 
 	if (!ret_size) {
 		printf("Init SRAM failed\n");
diff --git a/arch/arm/cpu/armv8/s32/lowlevel.S b/arch/arm/cpu/armv8/s32/lowlevel.S
index 1b03d7ecaa..6d4f788e73 100644
--- a/arch/arm/cpu/armv8/s32/lowlevel.S
+++ b/arch/arm/cpu/armv8/s32/lowlevel.S
@@ -18,96 +18,6 @@
 
 #define SWT_SR(SWTn_BASE_ADDR) (SWTn_BASE_ADDR + 0x10)
 
-/*************************************************************************
- *
- * void dma_mem_clr(start, size);
- *
- * Clear a memory region of size 'size' starting with address 'start'
- * (using DMA)
- *
- *************************************************************************/
-
-ENTRY(dma_mem_clr)
-	/*
-	 * x0: start address of memory to clear
-	 * x1: size of memory area to clear
-	 * x0: return 0 on error or size of memory cleared on success
-	 */
-
-	/* DMA_TCDn_SADDR */
-	ldr x9, =DMA_TCD_N_SADDR(DMA_CHANNEL_1)
-	ldr x10, =initvar
-	/* Point DMA source address to initialization data block */
-	str w10, [x9]
-
-	/* DMA_TCDn_SOFF */
-	/* DMA_TCDn_ATTR */
-	ldr x9, =DMA_TCD_N_SOFF(DMA_CHANNEL_1)
-	/* no offset reread same source address each interation */
-	/* 32 byte burst */
-	ldr x10, =0x05050000
-	str w10, [x9]
-
-	/* DMA_TCDn_NBYTES_MLNO */
-	ldr x9, =DMA_TCD_N_NBYTES_MLNO(DMA_CHANNEL_1)
-	/* load the size */
-	mov x10, x1
-	str x10, [x9]
-
-	/* DMA_TCDn_DADDR */
-	ldr x9, =DMA_TCD_N_DADDR(DMA_CHANNEL_1)
-	/* load the start address */
-	mov x10, x0
-	str x10, [x9]
-
-	/* DMA_TCDn_DOFF          */
-	/* DMA_TCDn_CITER_ELINKNO */
-	ldr x9, =DMA_TCD_N_DOFF(DMA_CHANNEL_1)
-	/* Increment destination address by 0x20 each interation */
-	/* ELINKNO CITER = 0X0001 single service request */
-	ldr w10, =0x00010020
-	str w10, [x9]
-
-	/* DMA_TCDn_BITER_ELINKNO */
-	/* ELINKNO BITER = 0X0001 single service request */
-	ldr x9, =DMA_TCD_N_BITER_ELINKNO(DMA_CHANNEL_1)
-	ldr w10, =0x1
-	strb w10, [x9]
-
-	/* Start transfer */
-	/* DMA_TCDn_CSR */
-	ldr x9, =DMA_TCD_N_CSR(DMA_CHANNEL_1)
-	ldr w10, =0x1
-	strb w10, [x9]
-
-	/* loop until write is done */
-ctrl_status:
-	/* DMA_ES */
-	ldr x9, =DMA_ES
-	ldr w10, [x9]
-	ldr x11, =0x80000000
-	/* Check error bit */
-	and w10, w10, #0x80000000
-	sub w10, w10, w11
-	cbz w10, ret_error
-	/* Check transfer done */
-	check_done_bit
-	cbnz w10, ctrl_status
-	/* clear DONE bit */
-	clear_done_bit
-	/* return bytes written */
-	mov x0, x1
-
-	ret
-
-ret_error:
-	/* error return zero bytes written */
-	ldr x0, =0x0
-	clear_channel_err
-	ret
-
-ENDPROC(dma_mem_clr)
-
 
 ENTRY(lowlevel_init)
 
@@ -140,7 +50,7 @@ sram_init:
 	/* Clear stack region */
 	ldr x0,  =(CONFIG_SYS_INIT_SP_ADDR - CONFIG_SYS_INIT_SP_OFFSET)
 	ldr x1,  =CONFIG_SYS_INIT_SP_OFFSET
-	bl dma_mem_clr
+	bl sram_clr
 
 	/* Start address of the SRAM memory to init */
 	ldr x0,  =__bss_start
@@ -155,7 +65,7 @@ sram_init:
 #endif
 	sub x1, x1, x0
 
-	bl dma_mem_clr
+	bl sram_clr
 
 	/* turn on a53 slave cores from a53 master */
 	/* deassert cores on reset */
@@ -289,9 +199,4 @@ ENDPROC(lowlevel_init)
 	.global __real_cntfrq
 __real_cntfrq:
 	.quad COUNTER_FREQUENCY
-	.data
-initvar:
-	.quad 0x0
-	.quad 0x0
-	.quad 0x0
-	.quad 0x0
+
diff --git a/arch/arm/cpu/armv8/s32/s32-gen1/Makefile b/arch/arm/cpu/armv8/s32/s32-gen1/Makefile
index e724aecb38..dccdbddee2 100644
--- a/arch/arm/cpu/armv8/s32/s32-gen1/Makefile
+++ b/arch/arm/cpu/armv8/s32/s32-gen1/Makefile
@@ -10,6 +10,7 @@ obj-$(CONFIG_TARGET_S32R45EVB)		+= cmu.o
 obj-$(CONFIG_HSE_SECBOOT)		+= hse_adv_secboot.o
 obj-y					+= ncore.o
 obj-y					+= soc.o
+obj-y					+= sram.o
 ifneq ($(filter y,$(CONFIG_TARGET_S32G274ARDB) $(CONFIG_TARGET_S32G274AEVB) $(CONFIG_TARGET_S32G274ABLUEBOX3) $(CONFIG_TARGET_S32R45EVB)),)
 obj-$(CONFIG_NETDEVICES)		+= sgmii/sgmii.o sgmii/serdes_xpcs.o
 endif
diff --git a/arch/arm/cpu/armv8/s32/s32-gen1/s32g_sramc.h b/arch/arm/cpu/armv8/s32/s32-gen1/s32g_sramc.h
new file mode 100644
index 0000000000..d1e8b71e16
--- /dev/null
+++ b/arch/arm/cpu/armv8/s32/s32-gen1/s32g_sramc.h
@@ -0,0 +1,45 @@
+/* SPDX-License-Identifier: BSD-3-Clause */
+/*
+ * Copyright 2020 NXP
+ */
+#ifndef S32G_SRAMC_H
+#define S32G_SRAMC_H
+
+/* SRAM is actually at 0x3400_0000; we are just mirroring it in the
+ * Virtual Code RAM
+ */
+#define S32G_SRAM_BASE		0x34000000
+#define S32G_SRAM_SIZE		0x00800000
+#define S32G_SRAM_END		(S32G_SRAM_BASE + S32G_SRAM_SIZE)
+
+/* SRAM controller is able to erase 64 bits at once */
+#define SRAM_BLOCK		512
+#define SRAM_BLOCK_MASK		(SRAM_BLOCK - 1)
+#define SRAM_INV_BLOCK_MASK	(~(SRAM_BLOCK_MASK))
+
+#define SRAMC0_BASE_ADDR	0x4019C000
+#define SRAMC0_BASE_ADDD_H	(SRAMC0_BASE_ADDR >> 16)
+#define SRAMC0_BASE_ADDD_L	((SRAMC0_BASE_ADDR & 0xFFFF))
+#define SRAMC1_BASE_ADDR	0x401A0000
+#define SRAMC1_BASE_ADDD_H	(SRAMC1_BASE_ADDR >> 16)
+#define SRAMC1_BASE_ADDD_L	((SRAMC1_BASE_ADDR & 0xFFFF))
+#define SSRAMC_BASE_ADDR	0x44028000
+#define SRAMC_SIZE		0x3000
+
+/* Block ranges */
+#define SRAMC0_MIN_ADDR		(0x0)
+#define SRAMC0_MAX_ADDR		(0x7FFF)
+#define SRAMC1_MIN_ADDR		(SRAMC0_MAX_ADDR + 1)
+#define SRAMC1_MAX_ADDR		(0x10000)
+
+#define SRAMC_PRAMCR_OFFSET	0x0
+#define SRAMC_PRAMCR_INITREQ	1
+#define SRAMC_PRAMIAS_OFFSET	0x4
+#define SRAMC_PRAMIAE_OFFSET	0x8
+#define SRAMC_PRAMSR_OFFSET	0xC
+#define SRAMC_PRAMSR_IDONE	1
+
+#define SSRAM_MAX_ADDR		0x7FF
+
+#endif
+
diff --git a/arch/arm/cpu/armv8/s32/s32-gen1/sram.S b/arch/arm/cpu/armv8/s32/s32-gen1/sram.S
new file mode 100644
index 0000000000..9737350c8f
--- /dev/null
+++ b/arch/arm/cpu/armv8/s32/s32-gen1/sram.S
@@ -0,0 +1,296 @@
+/* SPDX-License-Identifier:     GPL-2.0+ */
+/*
+ * Copyright 2020 NXP
+ *
+ * Extracted from armv8/start.S
+ */
+
+/* Allow inclusion assembly macros */
+#define __INCLUDE_ASSEMBLY_MACROS__
+
+#include <config.h>
+#include <linux/linkage.h>
+#include "s32g_sramc.h"
+
+/*
+ * Translate a bus address in SRAM controller initialization address based on:
+ * mem_addr[16:0] = {bus_addr[23:9], bus_addr[5:4]}
+ *
+ * addr := ((addr >> 9) << 2) | ((addr >> 4) & 0x3);
+ *
+ * x0: SRAM bus address
+ * ret: x0: Initialization address
+ *
+ * Clobber list: x0,x4,x5
+ */
+ENTRY(calc_sramc_addr)
+	lsr	x4, x0, #9
+	lsl	x4, x4, #2
+	lsr	x5, x0, #4
+	and	x5, x5, #3
+	orr	x0, x4, x5
+	ret
+ENDPROC(calc_sramc_addr)
+
+/**
+ * Check if two intervals are in overlap
+ *
+ * x0: start index of the first interval
+ * x1: end index of the first interval
+ * x2: start index of the second interval
+ * x3: end index of the second interval
+ *
+ * x0: return 0 if the intervals do not overlap and 1 otherwise
+ * Clobber list: x0,x1,x2,x3,x4,x5,x6
+ */
+ENTRY(in_overlap)
+	/* x4 = max */
+	cmp	x1, x3
+	b.gt	1f
+	mov	x4, x3
+	b	2f
+1:
+	mov	x4, x1
+2:
+	/* x5 = min */
+	cmp	x0, x2
+	b.lt	3f
+	mov	x5, x2
+	b	4f
+3:
+	mov	x5, x0
+4:
+	/* x5 = max - min */
+	sub	x5, x4, x5
+	/* x4 = first interval size */
+	sub	x4, x1, x0
+	/* x6 = second interval size */
+	sub	x6, x3, x2
+	/* x4 = len1 + len2 */
+	add	x4, x4, x6
+	cmp	x4, x5
+	bgt	overlap
+	mov	x0, #0
+	ret
+overlap:
+	mov	x0, #1
+	ret
+ENDPROC(in_overlap)
+
+/**
+ * Clear SRAM range using SRAM controller
+ *
+ * x0: SRAM controller address
+ * x1: Initialization Start Address
+ * x2: Initialization End Address
+ *
+ * Clobber list: x0,x1,x2,x3
+ */
+ENTRY(clear_sramc_range)
+	/* Disable the module */
+	mov	x3, #0
+	str	w3, [x0, #SRAMC_PRAMCR_OFFSET]
+
+	/* Address range */
+	str	w1, [x0, #SRAMC_PRAMIAS_OFFSET]
+	str	w2, [x0, #SRAMC_PRAMIAE_OFFSET]
+
+	/* Request initialization */
+	mov	x3, #SRAMC_PRAMCR_INITREQ
+	str	w3, [x0, #SRAMC_PRAMCR_OFFSET]
+
+wait_init:
+	ldr	w3, [x0, #SRAMC_PRAMSR_OFFSET]
+	and	w3, w3, #SRAMC_PRAMSR_IDONE
+	cbz	w3, wait_init
+
+	/* Clear status */
+	mov	w3, #SRAMC_PRAMSR_IDONE
+	str	w3, [x0, #SRAMC_PRAMSR_OFFSET]
+
+	ret
+ENDPROC(clear_sramc_range)
+
+/**
+ * Clear SRAM range using (current) A53 core
+ *
+ * x0: start address of memory area to clear
+ * x1: end address of memory area to clear
+ *
+ * Clobber list: x0,x1,x9,x10
+ */
+ENTRY(a53_sram_clr)
+	mov	x10, #0x0
+	cmp	x1, x0
+	bgt	pos_step
+	mov	x9, #-8
+	b	clr_loop
+pos_step:
+	mov	x9, #8
+clr_loop:
+	cmp	x1, x0
+	beq	finish
+	str	x10, [x0]
+	add	x0, x0, x9
+	b	clr_loop
+finish:
+	ret
+ENDPROC(a53_sram_clr)
+
+/**
+ * Clear unaligned (to SRAMC granularity) SRAM range using current core
+ *
+ * x0: start address of memory area to clear
+ * x1: end address of memory area to clear
+ *
+ * Clobber list: x0,x1,x9,x10,x11
+ */
+ENTRY(clear_unaligned_ends)
+	/* Save x30 */
+	mov	x12, x30
+	/*
+	 * Obtain SRAM addresses
+	 */
+	mov	x9, #S32G_SRAM_BASE
+	add	x11, x1, x9
+	add	x9, x0, x9
+
+	and	x1, x9, #SRAM_INV_BLOCK_MASK
+	cmp	x1, x9
+	beq	clear_end
+	add	x1, x1, SRAM_BLOCK
+	mov	x0, x9
+	bl	a53_sram_clr
+
+clear_end:
+	and	x0, x11, #SRAM_INV_BLOCK_MASK
+	cmp	x0, x11
+	beq	clr_exit
+	mov	x1, x11
+	bl	a53_sram_clr
+clr_exit:
+	mov	x30, x12
+	ret
+ENDPROC(clear_unaligned_ends)
+
+/**
+ * Clear SRAM region using SRAMC & current core fo unaligned ends
+ *
+ * x0: start address of memory area to clear
+ * x1: end address of memory area to clear
+ * x0: return 0 on error or size of memory cleared on success
+ *
+ * Clobber list: x0,x1,x2,x3,x4,x5,x6,x7,x9,x10,x11,x12,x13,x14,x15
+ */
+ENTRY(_s32g_sram_clr)
+	mov	x13, x0
+	mov	x14, x1
+	bl	clear_unaligned_ends
+	mov	x0, x13
+	mov	x1, x14
+
+	/* Align to SRAM blocks */
+	and	x9, x0, #SRAM_INV_BLOCK_MASK
+	cmp	x0, x9
+	beq	align_high_addr
+	add	x0, x9, SRAM_BLOCK
+
+align_high_addr:
+	and	x1, x1, #SRAM_INV_BLOCK_MASK
+
+	sub	x1, x1, #1
+	/* Low address */
+	bl	calc_sramc_addr
+	mov	x7, x0
+	mov	x0, x1
+
+	/* High address */
+	bl	calc_sramc_addr
+
+	/**
+	 * x7 - Low initialization address
+	 * x10 - High initialization address
+	 */
+	mov	x10, x0
+	mov	x9, #SRAMC1_MAX_ADDR
+	cmp	x10, x9
+	bgt	error
+
+	mov	x0, #SRAMC0_MIN_ADDR
+	mov	x1, #SRAMC0_MAX_ADDR
+	mov	x2, x7
+	mov	x3, x10
+	bl	in_overlap
+	cbnz	x0, init_sramc0
+
+check_sramc1:
+	mov	x0, #SRAMC1_MIN_ADDR
+	mov	x1, #SRAMC1_MAX_ADDR
+	mov	x2, x7
+	mov	x3, x10
+	bl	in_overlap
+	cbnz	x0, init_sramc1
+	b	sram_exit
+
+init_sramc0:
+	mov	x0, #SRAMC0_BASE_ADDD_L
+	movk	x0, #SRAMC0_BASE_ADDD_H, lsl #16
+	mov	x1, x7
+	mov	x2, x10
+	mov	x9, #SRAMC0_MAX_ADDR
+	cmp	x2, x9
+	b.gt	1f
+	b	2f
+1:
+	mov	x2, #SRAMC0_MAX_ADDR
+2:
+	bl	clear_sramc_range
+	b	check_sramc1
+
+init_sramc1:
+	mov	x0, #SRAMC1_BASE_ADDD_L
+	movk	x0, #SRAMC1_BASE_ADDD_H, lsl #16
+	cmp	x7, #SRAMC1_MIN_ADDR
+	b.lt	3f
+	sub	x1, x7, #SRAMC1_MIN_ADDR
+	b	4f
+3:
+	mov	x1, #0
+4:
+	sub	x2, x10, #SRAMC1_MIN_ADDR
+	bl	clear_sramc_range
+
+	mov	x0, #0
+
+sram_exit:
+	/* Restore x30 */
+	mov	x30, x15
+	ret
+
+error:
+	/* Restore x30 */
+	mov	x30, x15
+	mov	x0, #-1
+	ret
+ENDPROC(_s32g_sram_clr)
+
+/**
+ * Clear SRAM region using SRAMC
+ *
+ * x0: start address of memory area to clear
+ * x1: end address of memory area to clear
+ * x0: return 0 on error or size of memory cleared on success
+ *
+ * Clobber list: x0,x1,x2,x3,x4,x5,x6,x7,x9,x10,x11,x12,x13,x14,x15
+ */
+ENTRY(sram_clr)
+	/* Save x30 */
+	mov	x15, x30
+
+	/* To bus addresses */
+	mov	x2, #S32G_SRAM_BASE
+	sub	x0, x0, x2
+	add	x1, x1, x0
+
+	b	_s32g_sram_clr
+ENDPROC(sram_clr)
diff --git a/arch/arm/cpu/armv8/s32/s32v234/Makefile b/arch/arm/cpu/armv8/s32/s32v234/Makefile
index 167437a9bc..cd3e923afa 100644
--- a/arch/arm/cpu/armv8/s32/s32v234/Makefile
+++ b/arch/arm/cpu/armv8/s32/s32v234/Makefile
@@ -5,5 +5,6 @@
 
 obj-y					+= clock.o
 obj-y					+= soc.o
+obj-y					+= sram.o
 obj-$(CONFIG_S32V234_FLASH)		+= qspi_driver.o
 obj-$(CONFIG_S32V234_USES_FLASH)	+= qspi_iomux.o
diff --git a/arch/arm/cpu/armv8/s32/s32v234/sram.S b/arch/arm/cpu/armv8/s32/s32v234/sram.S
new file mode 100644
index 0000000000..7ecc679721
--- /dev/null
+++ b/arch/arm/cpu/armv8/s32/s32v234/sram.S
@@ -0,0 +1,108 @@
+/* SPDX-License-Identifier:     GPL-2.0+ */
+/*
+ * Copyright 2020 NXP
+ */
+
+/* Allow inclusion assembly macros */
+#define __INCLUDE_ASSEMBLY_MACROS__
+
+#include <config.h>
+#include <linux/linkage.h>
+
+/*************************************************************************
+ *
+ * void sram_clr(start, size);
+ *
+ * Clear a memory region of size 'size' starting with address 'start'
+ * (using DMA)
+ *
+ *************************************************************************/
+
+ENTRY(sram_clr)
+	/*
+	 * x0: start address of memory to clear
+	 * x1: size of memory area to clear
+	 * x0: return 0 on error or size of memory cleared on success
+	 */
+
+	/* DMA_TCDn_SADDR */
+	ldr x9, =DMA_TCD_N_SADDR(DMA_CHANNEL_1)
+	ldr x10, =initvar
+	/* Point DMA source address to initialization data block */
+	str w10, [x9]
+
+	/* DMA_TCDn_SOFF */
+	/* DMA_TCDn_ATTR */
+	ldr x9, =DMA_TCD_N_SOFF(DMA_CHANNEL_1)
+	/* no offset reread same source address each interation */
+	/* 32 byte burst */
+	ldr x10, =0x05050000
+	str w10, [x9]
+
+	/* DMA_TCDn_NBYTES_MLNO */
+	ldr x9, =DMA_TCD_N_NBYTES_MLNO(DMA_CHANNEL_1)
+	/* load the size */
+	mov x10, x1
+	str x10, [x9]
+
+	/* DMA_TCDn_DADDR */
+	ldr x9, =DMA_TCD_N_DADDR(DMA_CHANNEL_1)
+	/* load the start address */
+	mov x10, x0
+	str x10, [x9]
+
+	/* DMA_TCDn_DOFF          */
+	/* DMA_TCDn_CITER_ELINKNO */
+	ldr x9, =DMA_TCD_N_DOFF(DMA_CHANNEL_1)
+	/* Increment destination address by 0x20 each interation */
+	/* ELINKNO CITER = 0X0001 single service request */
+	ldr w10, =0x00010020
+	str w10, [x9]
+
+	/* DMA_TCDn_BITER_ELINKNO */
+	/* ELINKNO BITER = 0X0001 single service request */
+	ldr x9, =DMA_TCD_N_BITER_ELINKNO(DMA_CHANNEL_1)
+	ldr w10, =0x1
+	strb w10, [x9]
+
+	/* Start transfer */
+	/* DMA_TCDn_CSR */
+	ldr x9, =DMA_TCD_N_CSR(DMA_CHANNEL_1)
+	ldr w10, =0x1
+	strb w10, [x9]
+
+	/* loop until write is done */
+ctrl_status:
+	/* DMA_ES */
+	ldr x9, =DMA_ES
+	ldr w10, [x9]
+	ldr x11, =0x80000000
+	/* Check error bit */
+	and w10, w10, #0x80000000
+	sub w10, w10, w11
+	cbz w10, ret_error
+	/* Check transfer done */
+	check_done_bit
+	cbnz w10, ctrl_status
+	/* clear DONE bit */
+	clear_done_bit
+	/* return bytes written */
+	mov x0, x1
+
+	ret
+
+ret_error:
+	/* error return zero bytes written */
+	ldr x0, =0x0
+	clear_channel_err
+	ret
+
+ENDPROC(sram_clr)
+
+	.data
+initvar:
+	.quad 0x0
+	.quad 0x0
+	.quad 0x0
+	.quad 0x0
+
diff --git a/arch/arm/cpu/armv8/s32/dma_mem.h b/arch/arm/cpu/armv8/s32/sram.h
similarity index 81%
rename from arch/arm/cpu/armv8/s32/dma_mem.h
rename to arch/arm/cpu/armv8/s32/sram.h
index 1da56fb628..32332329a8 100644
--- a/arch/arm/cpu/armv8/s32/dma_mem.h
+++ b/arch/arm/cpu/armv8/s32/sram.h
@@ -2,8 +2,8 @@
 /*
  * Copyright 2020 NXP
  */
-#ifndef S32_DMA_MEM_H
-#define S32_DMA_MEM_H
+#ifndef S32G_SRAM_H
+#define S32G_SRAM_H
 
 /**
  * @brief Clear a memory region of size 'size' starting with address 'addr'
@@ -14,6 +14,6 @@
  *
  * @return  0 on error or size of memory cleared on success
  */
-int dma_mem_clr(int addr, int size);
+int sram_clr(int addr, int size);
 
 #endif
-- 
2.17.1

