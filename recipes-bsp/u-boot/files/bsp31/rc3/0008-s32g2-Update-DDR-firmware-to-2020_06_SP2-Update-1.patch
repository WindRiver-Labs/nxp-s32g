From 4028f9211fab31e17a3af60061d1879358402049 Mon Sep 17 00:00:00 2001
From: Andrei Cherechesu <andrei.cherechesu@nxp.com>
Date: Wed, 13 Oct 2021 18:29:42 +0300
Subject: [PATCH 08/14] s32g2: Update DDR firmware to 2020_06_SP2 Update 1

This commit updates the DDR driver for S32G274A Rev2 to
firmware 2020_06_SP2 generated with S32CT v1.4 Update 1.

Issue: ALB-7757
Upstream-Status: Pending 

Signed-off-by: Andrei Cherechesu <andrei.cherechesu@nxp.com>
Signed-off-by: Zhantao Tang <zhantao.tang@windriver.com>
---
 board/freescale/s32-gen1/ddr_init.c          |  56 +-
 board/freescale/s32-gen1/ddr_init.h          |  49 +-
 board/freescale/s32-gen1/ddr_utils.c         | 524 ++++++++++---------
 board/freescale/s32-gen1/ddr_utils.h         | 247 ++++++---
 board/freescale/s32-gen1/ddrss_cfg.c         |  42 +-
 board/freescale/s32-gen1/imem_cfg.c          |   8 +-
 board/freescale/s32-gen1/s32g274a/dmem_cfg.c |   8 +-
 7 files changed, 541 insertions(+), 393 deletions(-)

diff --git a/board/freescale/s32-gen1/ddr_init.c b/board/freescale/s32-gen1/ddr_init.c
index 49071cde67..4c0a852651 100644
--- a/board/freescale/s32-gen1/ddr_init.c
+++ b/board/freescale/s32-gen1/ddr_init.c
@@ -31,10 +31,10 @@
 
 #include "ddr_init.h"
 
-static u32 ddrc_init_cfg(struct ddrss_config *config);
-static u32 execute_training(struct ddrss_config *config);
+static u32 ddrc_init_cfg(const struct ddrss_config *config);
+static u32 execute_training(const struct ddrss_config *config);
 static u32 load_phy_image(u32 start_addr, size_t size,
-			       u16 image[]);
+			       const u16 image[]);
 
 /* Main method needed to initialize ddr subsystem. */
 u32 ddr_init(void)
@@ -61,7 +61,8 @@ u32 ddr_init(void)
 			return ret;
 
 		/* Execute post training setup */
-		ret = post_train_setup(STORE_CSR_MASK | INIT_MEM_MASK);
+		ret = post_train_setup((u8)(STORE_CSR_MASK |
+						 INIT_MEM_MASK));
 		if (ret != NO_ERR)
 			return ret;
 	}
@@ -69,25 +70,25 @@ u32 ddr_init(void)
 }
 
 /* Initialize ddr controller with given settings. */
-static u32 ddrc_init_cfg(struct ddrss_config *config)
+static u32 ddrc_init_cfg(const struct ddrss_config *config)
 {
 	u32 ret = NO_ERR;
 
-	ret = load_register_cfg(config->ddrc_cfg_size, config->ddrc_cfg);
+	ret = load_register_cfg(config->ddrc_size, config->ddrc);
 	return ret;
 }
 
 /* Execute phy training with given settings. 2D training stage is optional. */
-static u32 execute_training(struct ddrss_config *config)
+static u32 execute_training(const struct ddrss_config *config)
 {
 	u32 ret = NO_ERR;
 	/* Apply DQ swapping settings */
-	ret = load_dq_cfg(config->dq_swap_cfg_size, config->dq_swap_cfg);
+	ret = load_dq_cfg(config->dq_swap_size, config->dq_swap);
 	if (ret != NO_ERR)
 		return ret;
 
 	/* Initialize phy module */
-	ret = load_register_cfg_16(config->phy_cfg_size, config->phy_cfg);
+	ret = load_register_cfg_16(config->phy_size, config->phy);
 	if (ret != NO_ERR)
 		return ret;
 
@@ -111,9 +112,9 @@ static u32 execute_training(struct ddrss_config *config)
 	set_optimal_pll();
 
 	writel(LOCK_CSR_ACCESS, MICROCONT_MUX_SEL);
-	writel(0x00000009, APBONLY_MICRORESET);
-	writel(0x00000001, APBONLY_MICRORESET);
-	writel(0x00000000, APBONLY_MICRORESET);
+	writel(APBONLY_RESET_STALL_MASK, APBONLY_MICRORESET);
+	writel(APBONLY_STALL_TO_MICRO_MASK, APBONLY_MICRORESET);
+	writel(APBONLY_MICRORESET_CLR_MASK, APBONLY_MICRORESET);
 
 	ret = wait_firmware_execution();
 	writel(UNLOCK_CSR_ACCESS, MICROCONT_MUX_SEL);
@@ -124,7 +125,7 @@ static u32 execute_training(struct ddrss_config *config)
 	 * Check if 2d training images have been initialized before executing
 	 * the second training stage.
 	 */
-	if (config->imem_2d_size > 0 && config->dmem_2d_size > 0) {
+	if (config->imem_2d_size > 0U && config->dmem_2d_size > 0U) {
 		/* Load 2d imem image */
 		writel(UNLOCK_CSR_ACCESS, MICROCONT_MUX_SEL);
 		ret = load_phy_image(IMEM_START_ADDR, config->imem_2d_size,
@@ -145,9 +146,9 @@ static u32 execute_training(struct ddrss_config *config)
 		set_optimal_pll();
 
 		writel(LOCK_CSR_ACCESS, MICROCONT_MUX_SEL);
-		writel(0x00000009, APBONLY_MICRORESET);
-		writel(0x00000001, APBONLY_MICRORESET);
-		writel(0x00000000, APBONLY_MICRORESET);
+		writel(APBONLY_RESET_STALL_MASK, APBONLY_MICRORESET);
+		writel(APBONLY_STALL_TO_MICRO_MASK, APBONLY_MICRORESET);
+		writel(APBONLY_MICRORESET_CLR_MASK, APBONLY_MICRORESET);
 
 		ret = wait_firmware_execution();
 		if (ret != NO_ERR)
@@ -156,13 +157,13 @@ static u32 execute_training(struct ddrss_config *config)
 
 	writel(UNLOCK_CSR_ACCESS, MICROCONT_MUX_SEL);
 	/*  Load pie image after training has executed */
-	ret = load_register_cfg_16(config->pie_cfg_size, config->pie_cfg);
+	ret = load_register_cfg_16(config->pie_size, config->pie);
 	writel(LOCK_CSR_ACCESS, MICROCONT_MUX_SEL);
 	return ret;
 }
 
 /* Load register array into memory. */
-u32 load_register_cfg_16(size_t size, struct regconf_16 cfg[])
+u32 load_register_cfg_16(size_t size, const struct regconf_16 cfg[])
 {
 	size_t i;
 
@@ -173,7 +174,7 @@ u32 load_register_cfg_16(size_t size, struct regconf_16 cfg[])
 }
 
 /* Load register array into memory. */
-u32 load_register_cfg(size_t size, struct regconf cfg[])
+u32 load_register_cfg(size_t size, const struct regconf cfg[])
 {
 	size_t i;
 
@@ -184,7 +185,7 @@ u32 load_register_cfg(size_t size, struct regconf cfg[])
 }
 
 /* Load dq config array into memory. */
-u32 load_dq_cfg(size_t size, struct dqconf cfg[])
+u32 load_dq_cfg(size_t size, const struct dqconf cfg[])
 {
 	size_t i;
 
@@ -196,13 +197,14 @@ u32 load_dq_cfg(size_t size, struct dqconf cfg[])
 
 /* Load image into memory at consecutive addresses */
 static u32 load_phy_image(u32 start_addr, size_t size,
-			       u16 image[])
+			       const u16 image[])
 {
 	size_t i;
+	u32 current_addr = start_addr;
 
 	for (i = 0; i < size; i++) {
-		writel(image[i], (uintptr_t)start_addr);
-		start_addr += sizeof(u32);
+		writel(image[i], (uintptr_t)current_addr);
+		current_addr += sizeof(u32);
 	}
 	return NO_ERR;
 }
@@ -211,8 +213,8 @@ static u32 load_phy_image(u32 start_addr, size_t size,
 void set_optimal_pll(void)
 {
 	/* Configure phy pll for 3200MTS data rate */
-	writel(0x00000021, MASTER_PLLCTRL1);
-	writel(0x00000024, MASTER_PLLTESTMODE);
-	writel(0x0000017f, MASTER_PLLCTRL4);
-	writel(0x00000019, MASTER_PLLCTRL2);
+	writel(PLLCTRL1_VALUE, MASTER_PLLCTRL1);
+	writel(PLLTESTMODE_VALUE, MASTER_PLLTESTMODE);
+	writel(PLLCTRL4_VALUE, MASTER_PLLCTRL4);
+	writel(PLLCTRL2_VALUE, MASTER_PLLCTRL2);
 }
diff --git a/board/freescale/s32-gen1/ddr_init.h b/board/freescale/s32-gen1/ddr_init.h
index 691a61f0ae..b7245d55d7 100644
--- a/board/freescale/s32-gen1/ddr_init.h
+++ b/board/freescale/s32-gen1/ddr_init.h
@@ -45,6 +45,17 @@
 #define LOCK_CSR_ACCESS   0x00000001
 #define UNLOCK_CSR_ACCESS 0x00000000
 
+#define APBONLY_RESET_TO_MICRO_MASK		0x00000008U
+#define APBONLY_STALL_TO_MICRO_MASK		0x00000001U
+#define APBONLY_RESET_STALL_MASK	APBONLY_RESET_TO_MICRO_MASK | \
+	APBONLY_STALL_TO_MICRO_MASK
+#define APBONLY_MICRORESET_CLR_MASK	0x00000000
+
+#define PLLCTRL1_VALUE		0x00000021
+#define PLLTESTMODE_VALUE	0x00000024
+#define PLLCTRL4_VALUE		0x0000017F
+#define PLLCTRL2_VALUE		0x00000019
+
 #define FIRMWARE_VERSION "2020_06_SP2"
 
 /* Enum for DRAM Type */
@@ -70,12 +81,12 @@ struct dqconf {
 
 struct ddrss_config {
 	u8 memory_type;
-	struct regconf *ddrc_cfg;
-	size_t ddrc_cfg_size;
-	struct dqconf *dq_swap_cfg;
-	size_t dq_swap_cfg_size;
-	struct regconf_16 *phy_cfg;
-	size_t phy_cfg_size;
+	struct regconf *ddrc;
+	size_t ddrc_size;
+	struct dqconf *dq_swap;
+	size_t dq_swap_size;
+	struct regconf_16 *phy;
+	size_t phy_size;
 	u16 *imem_1d;
 	size_t imem_1d_size;
 	u16 *dmem_1d;
@@ -84,8 +95,8 @@ struct ddrss_config {
 	size_t imem_2d_size;
 	u16 *dmem_2d;
 	size_t dmem_2d_size;
-	struct regconf_16 *pie_cfg;
-	size_t pie_cfg_size;
+	struct regconf_16 *pie;
+	size_t pie_size;
 };
 
 extern struct regconf ddrc_cfg[];
@@ -94,14 +105,14 @@ extern struct dqconf dq_swap_cfg[];
 extern size_t dq_swap_cfg_size;
 extern struct regconf_16 phy_cfg[];
 extern size_t phy_cfg_size;
-extern u16 imem_1d[];
-extern size_t imem_1d_size;
-extern u16 dmem_1d[];
-extern size_t dmem_1d_size;
-extern u16 imem_2d[];
-extern size_t imem_2d_size;
-extern u16 dmem_2d[];
-extern size_t dmem_2d_size;
+extern u16 imem_1d_cfg[];
+extern size_t imem_1d_cfg_size;
+extern u16 dmem_1d_cfg[];
+extern size_t dmem_1d_cfg_size;
+extern u16 imem_2d_cfg[];
+extern size_t imem_2d_cfg_size;
+extern u16 dmem_2d_cfg[];
+extern size_t dmem_2d_cfg_size;
 extern struct regconf_16 pie_cfg[];
 extern size_t pie_cfg_size;
 extern struct ddrss_config configs[];
@@ -123,7 +134,7 @@ void init_image_sizes(void);
  * @param cfg - array of configuration elements
  * @return - error code, 0 if init succeeds, non-zero on error.
  */
-u32 load_register_cfg(size_t size, struct regconf cfg[]);
+u32 load_register_cfg(size_t size, const struct regconf cfg[]);
 
 /*
  * Writes the data associated for each address. Similar to
@@ -134,7 +145,7 @@ u32 load_register_cfg(size_t size, struct regconf cfg[]);
  * @param cfg - array of configuration elements
  * @return - error code, 0 if init succeeds, non-zero on error.
  */
-u32 load_register_cfg_16(size_t size, struct regconf_16 cfg[]);
+u32 load_register_cfg_16(size_t size, const struct regconf_16 cfg[]);
 
 /*
  * Writes the data associated for each address. Similar to
@@ -145,7 +156,7 @@ u32 load_register_cfg_16(size_t size, struct regconf_16 cfg[]);
  * @param cfg - array of configuration elements
  * @return - error code, 0 if init succeeds, non-zero on error.
  */
-u32 load_dq_cfg(size_t size, struct dqconf cfg[]);
+u32 load_dq_cfg(size_t size, const struct dqconf cfg[]);
 
 /* Updates PHY internal PLL settings. */
 void set_optimal_pll(void);
diff --git a/board/freescale/s32-gen1/ddr_utils.c b/board/freescale/s32-gen1/ddr_utils.c
index 64f0f8c2ca..32e416861e 100644
--- a/board/freescale/s32-gen1/ddr_utils.c
+++ b/board/freescale/s32-gen1/ddr_utils.c
@@ -34,19 +34,24 @@
 static u32 enable_axi_ports(void);
 static u32 get_mail(u32 *mail);
 static u32 ack_mail(void);
+static u32 init_memory_ecc_scrubber(void);
+static bool sel_clk_src(u32 clk_src);
 
 u8 polling_needed = 2;
 
 /* Modify bitfield value with delta, given bitfield position and mask */
 bool update_bf(u32 *v, u8 pos, u32 mask, int32_t delta)
 {
-	if (mask >= (((*v >> pos) & mask) + delta)) {
-		*v = (*v & ~(mask << pos)) | ((((*v >> pos)
-			& mask) + delta) << pos);
-		return true;
-	} else {
-		return false;
+	bool ret = false;
+	u32 bf_val = (*v >> pos) & mask;
+	int64_t new_val = (int64_t)(bf_val) + delta;
+
+	if (mask >= (u32)(new_val)) {
+		*v = (*v & ~(mask << pos)) | ((u32)(new_val) << pos);
+		ret = true;
 	}
+
+	return ret;
 }
 
 /*
@@ -54,45 +59,52 @@ bool update_bf(u32 *v, u8 pos, u32 mask, int32_t delta)
  * @param clk_src - requested clock source
  * @return - true whether clock source has been changed, false otherwise
  */
-bool sel_clk_src(u32 clk_src)
+static bool sel_clk_src(u32 clk_src)
 {
 	u32 tmp32;
+	bool ret = true;
 
 	/* Check if the clock source is already set to clk_src*/
 	tmp32 = readl(MC_CGM5_BASE_ADDR + OFFSET_MUX_0_CSS);
-	if (((tmp32 & 0x3fffffffU) >> 24) == clk_src)
-		return false;
-
-	/* To wait till clock switching is completed */
-	do {
-		tmp32 = readl(MC_CGM5_BASE_ADDR + OFFSET_MUX_0_CSS);
-	} while (((tmp32 >> 16) & 0x1U) != 0x0);
-
-	/* Set DDR_CLK source on src_clk */
-	tmp32 = readl(MC_CGM5_BASE_ADDR + OFFSET_MUX_0_CSC);
-	writel((0xc0ffffffU & tmp32) | (clk_src << 24),
-	       MC_CGM5_BASE_ADDR + OFFSET_MUX_0_CSC);
+	if (((tmp32 & CSS_SELSTAT_MASK) >> CSS_SELSTAT_POS) == clk_src) {
+		ret = false;
+	} else {
+		/* To wait till clock switching is completed */
+		do {
+			tmp32 = readl(MC_CGM5_BASE_ADDR + OFFSET_MUX_0_CSS);
+		} while (((tmp32 >> CSS_SWIP_POS) &
+			  CSS_SW_IN_PROGRESS) != CSS_SW_COMPLETED);
 
-	/* Request clock switch */
-	tmp32 = readl(MC_CGM5_BASE_ADDR + OFFSET_MUX_0_CSC);
-	writel((0x1u << 2) | tmp32, MC_CGM5_BASE_ADDR + OFFSET_MUX_0_CSC);
+		/* Set DDR_CLK source on src_clk */
+		tmp32 = readl(MC_CGM5_BASE_ADDR + OFFSET_MUX_0_CSC);
+		writel((CSC_SELCTL_MASK & tmp32) | (clk_src << CSC_SELCTL_POS),
+		       MC_CGM5_BASE_ADDR + OFFSET_MUX_0_CSC);
 
-	/* To wait till clock switching is completed */
-	do {
-		tmp32 = readl(MC_CGM5_BASE_ADDR + OFFSET_MUX_0_CSS);
-	} while (((tmp32 >> 16) & 0x1U) != 0x0);
+		/* Request clock switch */
+		tmp32 = readl(MC_CGM5_BASE_ADDR + OFFSET_MUX_0_CSC);
+		writel((CSC_CLK_SWITCH_REQUEST << CSC_CLK_SWITCH_POS) |
+		       tmp32, MC_CGM5_BASE_ADDR + OFFSET_MUX_0_CSC);
 
-	/* To wait till Switch after request is succeeded */
-	do {
-		tmp32 = readl(MC_CGM5_BASE_ADDR + OFFSET_MUX_0_CSS);
-	} while (((tmp32 >> 17) & 0x1U) != 0x1);
+		/* To wait till clock switching is completed */
+		do {
+			tmp32 = readl(MC_CGM5_BASE_ADDR + OFFSET_MUX_0_CSS);
+		} while (((tmp32 >> CSS_SWIP_POS) & CSS_SW_IN_PROGRESS) !=
+			 CSS_SW_COMPLETED);
 
-	/* Make sure correct clock source is selected */
-	do {
-		tmp32 = readl(MC_CGM5_BASE_ADDR + OFFSET_MUX_0_CSS);
-	} while (((tmp32 & 0x3fffffffU) >> 24) != clk_src);
+		/* To wait till Switch after request is succeeded */
+		do {
+			tmp32 = readl(MC_CGM5_BASE_ADDR + OFFSET_MUX_0_CSS);
+		} while (((tmp32 >> CSS_SW_TRIGGER_CAUSE_POS) &
+			  CSS_SW_AFTER_REQUEST_SUCCEDED) !=
+			 CSS_SW_AFTER_REQUEST_SUCCEDED);
 
-	return true;
+		/* Make sure correct clock source is selected */
+		do {
+			tmp32 = readl(MC_CGM5_BASE_ADDR + OFFSET_MUX_0_CSS);
+		} while (((tmp32 & CSS_SELSTAT_MASK) >> CSS_SELSTAT_POS)
+			 != clk_src);
+	}
+	return ret;
 }
 
 /* Sets default AXI parity. */
@@ -103,17 +115,17 @@ u32 set_axi_parity(void)
 
 	/* Enable Parity For All AXI Interfaces */
 	tmp32 = readl(DDR_SS_REG);
-	writel(tmp32 | 0x1ff0U, DDR_SS_REG);
+	writel(tmp32 | DDR_SS_AXI_PARITY_ENABLE_MASK, DDR_SS_REG);
 
 	/* Set AXI_PARITY_TYPE to 0x1ff;   0-even, 1-odd */
 	tmp32 = readl(DDR_SS_REG);
-	writel(tmp32 | 0x1ff0000U, DDR_SS_REG);
+	writel(tmp32 | DDR_SS_AXI_PARITY_TYPE_MASK, DDR_SS_REG);
 
 	/* For LPDDR4 Set DFI1_ENABLED to 0x1 */
 	tmp32 = readl(DDRC_BASE_ADDR);
 	if ((tmp32 & MSTR_LPDDR4_MASK) == MSTR_LPDDR4_VAL) {
 		tmp32 = readl(DDR_SS_REG);
-		writel(tmp32 | 0x1U, DDR_SS_REG);
+		writel(tmp32 | DDR_SS_DFI_1_ENABLED, DDR_SS_REG);
 	}
 
 	/*
@@ -124,52 +136,58 @@ u32 set_axi_parity(void)
 
 	/* De-assert Reset To Controller and AXI Ports */
 	tmp32 = readl(MC_RGM_PRST_0);
-	writel(~(0x1U << 3) & tmp32, MC_RGM_PRST_0);
+	writel(~(FORCED_RESET_ON_PERIPH << PRST_0_PERIPH_3_RST_POS) &
+	       tmp32, MC_RGM_PRST_0);
 
 	/* Check if the initial clock source was not on FIRC */
 	if (switched_to_firc)
 		switched_to_firc = sel_clk_src(DDR_PHI0_PLL);
 
 	/* Enable HIF, CAM Queueing */
-	writel(0x0, DDRC_BASE_ADDR + OFFSET_DDRC_DBG1);
+	writel(DBG1_DISABLE_DE_QUEUEING, DDRC_BASE_ADDR + OFFSET_DDRC_DBG1);
 
 	/* Disable auto-refresh: RFSHCTL3.dis_auto_refresh = 1 */
 	tmp32 = readl(DDRC_BASE_ADDR + OFFSET_DDRC_RFSHCTL3);
-	writel((0x1U | tmp32), DDRC_BASE_ADDR + OFFSET_DDRC_RFSHCTL3);
+	writel((RFSHCTL3_DISABLE_AUTO_REFRESH | tmp32),
+	       DDRC_BASE_ADDR + OFFSET_DDRC_RFSHCTL3);
 
 	/* Disable power down: PWRCTL.powerdown_en = 0 */
 	tmp32 = readl(DDRC_BASE_ADDR + OFFSET_DDRC_PWRCTL);
-	writel(((~0x00000002U) & tmp32), DDRC_BASE_ADDR + OFFSET_DDRC_PWRCTL);
+	writel(((~PWRCTL_POWER_DOWN_ENABLE_MASK) & tmp32),
+	       DDRC_BASE_ADDR + OFFSET_DDRC_PWRCTL);
 
 	/* Disable self-refresh: PWRCTL.selfref_en = 0 */
 	tmp32 = readl(DDRC_BASE_ADDR + OFFSET_DDRC_PWRCTL);
-	writel(((~0x00000001U) & tmp32), DDRC_BASE_ADDR + OFFSET_DDRC_PWRCTL);
+	writel(((~PWRCTL_SELF_REFRESH_ENABLE_MASK) & tmp32),
+	       DDRC_BASE_ADDR + OFFSET_DDRC_PWRCTL);
 
 	/*
 	 * Disable assertion of dfi_dram_clk_disable:
 	 * PWRTL.en_dfi_dram_clk_disable = 0
 	 */
 	tmp32 = readl(DDRC_BASE_ADDR + OFFSET_DDRC_PWRCTL);
-	writel(((~0x00000008U) & tmp32), DDRC_BASE_ADDR + OFFSET_DDRC_PWRCTL);
+	writel(((~PWRCTL_EN_DFI_DRAM_CLOCK_DIS_MASK) & tmp32),
+	       DDRC_BASE_ADDR + OFFSET_DDRC_PWRCTL);
 
 	/* Enable Quasi-Dynamic Programming */
-	writel(DDRC_SWCTL_SWDONE_ENABLE, DDRC_BASE_ADDR + OFFSET_DDRC_SWCTL);
+	writel(SWCTL_SWDONE_ENABLE, DDRC_BASE_ADDR + OFFSET_DDRC_SWCTL);
 
 	/* Confirm Register Programming Done Ack is Cleared */
 	do {
 		tmp32 = readl(DDRC_BASE_ADDR + OFFSET_DDRC_SWSTAT);
-	} while ((tmp32 & DDRC_SWSTAT_SWDONE_ACK_MASK) == 1);
+	} while ((tmp32 & SWSTAT_SWDONE_ACK_MASK) == SWSTAT_SW_DONE);
 
 	/* DFI_INIT_COMPLETE_EN set to 0 */
 	tmp32 = readl(DDRC_BASE_ADDR + OFFSET_DDRC_DFIMISC);
-	writel((~0x1U) & tmp32, DDRC_BASE_ADDR + OFFSET_DDRC_DFIMISC);
+	writel((~DFIMISC_DFI_INIT_COMPLETE_EN_MASK) & tmp32,
+	       DDRC_BASE_ADDR + OFFSET_DDRC_DFIMISC);
 
 	/* Set SWCTL.sw_done to 1 */
-	writel(DDRC_SWCTL_SWDONE_DONE, DDRC_BASE_ADDR + OFFSET_DDRC_SWCTL);
+	writel(SWCTL_SWDONE_DONE, DDRC_BASE_ADDR + OFFSET_DDRC_SWCTL);
 
 	do {
 		tmp32 = readl(DDRC_BASE_ADDR + OFFSET_DDRC_SWSTAT);
-	} while ((tmp32 & DDRC_SWSTAT_SWDONE_ACK_MASK) == 0);
+	} while ((tmp32 & SWSTAT_SWDONE_ACK_MASK) == SWSTAT_SW_NOT_DONE);
 
 	return NO_ERR;
 }
@@ -178,11 +196,14 @@ u32 set_axi_parity(void)
 static u32 enable_axi_ports(void)
 {
 	/* Port 0 Control Register */
-	writel(0x00000001, DDRC_UMCTL2_MP_BASE_ADDR + OFFSET_DDRC_PCTRL_0);
+	writel(ENABLE_AXI_PORT,
+	       DDRC_UMCTL2_MP_BASE_ADDR + OFFSET_DDRC_PCTRL_0);
 	/* Port 1 Control Register */
-	writel(0x00000001, DDRC_UMCTL2_MP_BASE_ADDR + OFFSET_DDRC_PCTRL_1);
+	writel(ENABLE_AXI_PORT,
+	       DDRC_UMCTL2_MP_BASE_ADDR + OFFSET_DDRC_PCTRL_1);
 	/* Port 2 Control Register */
-	writel(0x00000001, DDRC_UMCTL2_MP_BASE_ADDR + OFFSET_DDRC_PCTRL_2);
+	writel(ENABLE_AXI_PORT,
+	       DDRC_UMCTL2_MP_BASE_ADDR + OFFSET_DDRC_PCTRL_2);
 
 	return NO_ERR;
 }
@@ -204,96 +225,107 @@ u32 post_train_setup(u8 options)
 	 */
 	do {
 		tmp32 = readl(DDR_PHYA_MASTER0_CALBUSY);
-	} while ((tmp32 & 0x1U) != 0);
+	} while ((tmp32 & MASTER0_CAL_ACTIVE) != MASTER0_CAL_DONE);
 
 	/* Set SWCTL.sw_done to 0 */
-	writel(DDRC_SWCTL_SWDONE_ENABLE, DDRC_BASE_ADDR + OFFSET_DDRC_SWCTL);
+	writel(SWCTL_SWDONE_ENABLE, DDRC_BASE_ADDR + OFFSET_DDRC_SWCTL);
 	do {
 		tmp32 = readl(DDRC_BASE_ADDR + OFFSET_DDRC_SWSTAT);
-	} while ((tmp32 & DDRC_SWSTAT_SWDONE_ACK_MASK) != 0);
+	} while ((tmp32 & SWSTAT_SWDONE_ACK_MASK) != SWSTAT_SW_NOT_DONE);
 
 	/* Set DFIMISC.dfi_init_start to 1*/
 	tmp32 = readl(DDRC_BASE_ADDR + OFFSET_DDRC_DFIMISC);
-	writel((0x00000020U | tmp32), DDRC_BASE_ADDR + OFFSET_DDRC_DFIMISC);
+	writel((DFIMISC_DFI_INIT_START_MASK | tmp32),
+	       DDRC_BASE_ADDR + OFFSET_DDRC_DFIMISC);
 
 	/* Set SWCTL.sw_done to 1 */
-	writel(DDRC_SWCTL_SWDONE_DONE, DDRC_BASE_ADDR + OFFSET_DDRC_SWCTL);
+	writel(SWCTL_SWDONE_DONE, DDRC_BASE_ADDR + OFFSET_DDRC_SWCTL);
 	/* Wait SWSTAT.sw_done_ack to 1*/
 	do {
 		tmp32 = readl(DDRC_BASE_ADDR + OFFSET_DDRC_SWSTAT);
-	} while ((tmp32 & DDRC_SWSTAT_SWDONE_ACK_MASK) == 0);
+	} while ((tmp32 & SWSTAT_SWDONE_ACK_MASK) == SWSTAT_SW_NOT_DONE);
 
 	/* Wait DFISTAT.dfi_init_complete to 1 */
 	do {
 		tmp32 = readl(DDRC_BASE_ADDR + OFFSET_DDRC_DFISTAT);
-	} while ((tmp32 & 0x1U) == 0);
+	} while ((tmp32 & DFISTAT_DFI_INIT_DONE) ==
+		 DFISTAT_DFI_INIT_INCOMPLETE);
 
 	/* Set SWCTL.sw_done to 0 */
-	writel(DDRC_SWCTL_SWDONE_ENABLE, DDRC_BASE_ADDR + OFFSET_DDRC_SWCTL);
+	writel(SWCTL_SWDONE_ENABLE, DDRC_BASE_ADDR + OFFSET_DDRC_SWCTL);
 	do {
 		tmp32 = readl(DDRC_BASE_ADDR + OFFSET_DDRC_SWSTAT);
-	} while ((tmp32 & DDRC_SWSTAT_SWDONE_ACK_MASK) != 0);
+	} while ((tmp32 & SWSTAT_SWDONE_ACK_MASK) != SWSTAT_SW_NOT_DONE);
 
 	/* Set dfi_init_start to 0 */
 	tmp32 = readl(DDRC_BASE_ADDR + OFFSET_DDRC_DFIMISC);
-	writel((~0x00000020U) & tmp32, DDRC_BASE_ADDR + OFFSET_DDRC_DFIMISC);
+	writel((~DFIMISC_DFI_INIT_START_MASK) & tmp32,
+	       DDRC_BASE_ADDR + OFFSET_DDRC_DFIMISC);
 
 	/* Set dfi_complete_en to 1 */
 	tmp32 = readl(DDRC_BASE_ADDR + OFFSET_DDRC_DFIMISC);
-	writel(0x00000001U | tmp32, DDRC_BASE_ADDR + OFFSET_DDRC_DFIMISC);
+	writel(DFIMISC_DFI_INIT_COMPLETE_EN_MASK | tmp32,
+	       DDRC_BASE_ADDR + OFFSET_DDRC_DFIMISC);
 
 	/* Set PWRCTL.selfref_sw to 0 */
 	tmp32 = readl(DDRC_BASE_ADDR + OFFSET_DDRC_PWRCTL);
-	writel(((~0x00000020U) & tmp32), DDRC_BASE_ADDR + OFFSET_DDRC_PWRCTL);
+	writel(((~PWRCTL_SELFREF_SW_MASK) & tmp32),
+	       DDRC_BASE_ADDR + OFFSET_DDRC_PWRCTL);
 
 	/* Set SWCTL.sw_done to 1 */
-	writel(DDRC_SWCTL_SWDONE_DONE, DDRC_BASE_ADDR + OFFSET_DDRC_SWCTL);
+	writel(SWCTL_SWDONE_DONE, DDRC_BASE_ADDR + OFFSET_DDRC_SWCTL);
 	do {
 		tmp32 = readl(DDRC_BASE_ADDR + OFFSET_DDRC_SWSTAT);
-	} while ((tmp32 & DDRC_SWSTAT_SWDONE_ACK_MASK) == 0);
+	} while ((tmp32 & SWSTAT_SWDONE_ACK_MASK) == SWSTAT_SW_NOT_DONE);
 
 	/* Wait for DWC_ddr_umctl2 to move to normal operating mode */
 	do {
 		tmp32 = readl(DDRC_BASE_ADDR + OFFSET_DDRC_STAT);
-	} while ((tmp32 & 0x7U) == 0);
+	} while ((tmp32 & STAT_OPERATING_MODE_MASK) ==
+		 STAT_OPERATING_MODE_INIT);
 
 	/* Enable auto-refresh: RFSHCTL3.dis_auto_refresh = 0 */
 	tmp32 = readl(DDRC_BASE_ADDR + OFFSET_DDRC_RFSHCTL3);
-	writel((~0x00000001U) & tmp32, DDRC_BASE_ADDR + OFFSET_DDRC_RFSHCTL3);
+	writel((~RFSHCTL3_DIS_AUTO_REFRESH_MASK) & tmp32,
+	       DDRC_BASE_ADDR + OFFSET_DDRC_RFSHCTL3);
 
 	/*
 	 * If ECC feature is enabled (ECCCFG0[ecc_mode] > 0)
 	 * initialize memory with the ecc scrubber
 	 */
 	tmp32 = readl(DDRC_BASE_ADDR + OFFSET_DDRC_ECCCFG0);
-	if (((tmp32 & 0x7U) > 0) && ((options & INIT_MEM_MASK) != 0)) {
+	if (((tmp32 & ECCCFG0_ECC_MODE_MASK) > ECCCFG0_ECC_DISABLED) &&
+	    ((options & INIT_MEM_MASK) != INIT_MEM_DISABLED)) {
 		ret = init_memory_ecc_scrubber();
-		if (ret != NO_ERR)
-			return ret;
 	}
 
-	/* Enable power down: PWRCTL.powerdown_en = 1 */
-	tmp32 = readl(DDRC_BASE_ADDR + OFFSET_DDRC_PWRCTL);
-	writel(0x00000002U | tmp32, DDRC_BASE_ADDR + OFFSET_DDRC_PWRCTL);
+	if (ret == NO_ERR) {
+		/* Enable power down: PWRCTL.powerdown_en = 1 */
+		tmp32 = readl(DDRC_BASE_ADDR + OFFSET_DDRC_PWRCTL);
+		writel(PWRCTL_POWER_DOWN_ENABLE_MASK | tmp32,
+		       DDRC_BASE_ADDR + OFFSET_DDRC_PWRCTL);
 
-	/* Enable self-refresh: PWRCTL.selfref_en = 1*/
-	tmp32 = readl(DDRC_BASE_ADDR + OFFSET_DDRC_PWRCTL);
-	writel(0x00000001U | tmp32, DDRC_BASE_ADDR + OFFSET_DDRC_PWRCTL);
+		/* Enable self-refresh: PWRCTL.selfref_en = 1*/
+		tmp32 = readl(DDRC_BASE_ADDR + OFFSET_DDRC_PWRCTL);
+		writel(PWRCTL_SELF_REFRESH_ENABLE_MASK | tmp32,
+		       DDRC_BASE_ADDR + OFFSET_DDRC_PWRCTL);
 
-	/*
-	 * Enable assertion of dfi_dram_clk_disable:
-	 * PWRTL.en_dfi_dram_clk_disable = 1
-	 */
-	tmp32 = readl(DDRC_BASE_ADDR + OFFSET_DDRC_PWRCTL);
-	writel(0x00000008U | tmp32, DDRC_BASE_ADDR + OFFSET_DDRC_PWRCTL);
+		/*
+		 * Enable assertion of dfi_dram_clk_disable:
+		 * PWRTL.en_dfi_dram_clk_disable = 1
+		 */
+		tmp32 = readl(DDRC_BASE_ADDR + OFFSET_DDRC_PWRCTL);
+		writel(PWRCTL_EN_DFI_DRAM_CLOCK_DIS_MASK | tmp32,
+		       DDRC_BASE_ADDR + OFFSET_DDRC_PWRCTL);
 
-	ret |= enable_derating_temp_errata();
+		ret |= enable_derating_temp_errata();
 
-	/*
-	 * Each platform has a different number of AXI ports so this
-	 * method should be implemented in hardware specific source
-	 */
-	ret |= enable_axi_ports();
+		/*
+		 * Each platform has a different number of AXI ports so this
+		 * method should be implemented in hardware specific source
+		 */
+		ret |= enable_axi_ports();
+	}
 	return ret;
 }
 
@@ -302,22 +334,23 @@ u32 wait_firmware_execution(void)
 {
 	u32 mail = 0;
 	u32 ret;
+	bool exit_loop = false;
 
-	while (true) {
+	while (!exit_loop) {
 		/* Obtain message from PHY (major message) */
 		ret = get_mail(&mail);
 
-		if (ret != NO_ERR)
-			break;
-
-		/* 0x07 means OK, 0xFF means failure */
-		if (mail == 0x07)
-			break;
-
-		if (mail == 0xff) {
-			/* Training stage failed */
-			ret = TRAINING_FAILED;
-			break;
+		if (ret == NO_ERR) {
+			if (mail == TRAINING_OK_MSG) {
+				/* 0x07 means OK, 0xFF means failure */
+				exit_loop = true;
+			} else if (mail == TRAINING_FAILED_MSG) {
+				/* Training stage failed */
+				ret = TRAINING_FAILED;
+				exit_loop = true;
+			}
+		} else {
+			exit_loop = true;
 		}
 	}
 
@@ -329,18 +362,18 @@ static u32 ack_mail(void)
 {
 	u32 timeout = DEFAULT_TIMEOUT;
 	/* ACK message */
-	writel(0, DDR_PHYA_APBONLY_DCTWRITEPROT);
-	u32 tmp32 = readl(DDR_PHYA_APBONLY_UCTSHSADOWREGS);
+	writel(APBONLY_DCTWRITEPROT_ACK_EN, DDR_PHYA_DCTWRITEPROT);
+	u32 tmp32 = readl(DDR_PHYA_APBONLY_UCTSHADOWREGS);
 
 	/* Wait firmware to respond to ACK (UctWriteProtShadow to be set) */
-	while ((--timeout != 0) &&
-	       ((tmp32 & UCT_WRITE_PROT_SHADOW_MASK) == 0))
-		tmp32 = readl(DDR_PHYA_APBONLY_UCTSHSADOWREGS);
+	while ((--timeout != 0u) && ((tmp32 & UCT_WRITE_PROT_SHADOW_MASK) ==
+				     UCT_WRITE_PROT_SHADOW_ACK))
+		tmp32 = readl(DDR_PHYA_APBONLY_UCTSHADOWREGS);
 
-	if (timeout == 0)
+	if (timeout == 0u)
 		return TIMEOUT_ERR;
 
-	writel(1, DDR_PHYA_APBONLY_DCTWRITEPROT);
+	writel(APBONLY_DCTWRITEPROT_ACK_DIS, DDR_PHYA_DCTWRITEPROT);
 
 	return NO_ERR;
 }
@@ -349,13 +382,13 @@ static u32 ack_mail(void)
 static u32 get_mail(u32 *mail)
 {
 	u32 timeout = DEFAULT_TIMEOUT;
-	u32 tmp32 = readl(DDR_PHYA_APBONLY_UCTSHSADOWREGS);
+	u32 tmp32 = readl(DDR_PHYA_APBONLY_UCTSHADOWREGS);
 
-	while ((--timeout != 0) &&
-	       ((tmp32 & UCT_WRITE_PROT_SHADOW_MASK) != 0))
-		tmp32 = readl(DDR_PHYA_APBONLY_UCTSHSADOWREGS);
+	while ((--timeout != 0u) && ((tmp32 & UCT_WRITE_PROT_SHADOW_MASK) !=
+				     UCT_WRITE_PROT_SHADOW_ACK))
+		tmp32 = readl(DDR_PHYA_APBONLY_UCTSHADOWREGS);
 
-	if (timeout == 0)
+	if (timeout == 0u)
 		return TIMEOUT_ERR;
 
 	*mail = readl(DDR_PHYA_APBONLY_UCTWRITEONLYSHADOW);
@@ -365,37 +398,45 @@ static u32 get_mail(u32 *mail)
 }
 
 /* Initialize memory with the ecc scrubber */
-u32 init_memory_ecc_scrubber(void)
+static u32 init_memory_ecc_scrubber(void)
 {
 	u8 region_lock;
 	u32 tmp32, pattern = 0x00000000U;
 
 	/* Save previous ecc region parity locked state. */
-	region_lock = readl(DDRC_BASE_ADDR + OFFSET_DDRC_ECCCFG1) &
-				  (0x1UL << 4);
+	region_lock = (u8)(readl(DDRC_BASE_ADDR + OFFSET_DDRC_ECCCFG1) &
+				(ECCCFG1_REGION_PARITY_LOCKED <<
+				 ECCCFG1_REGION_PARITY_LOCK_POS));
 
 	/* Enable ecc region lock. */
 	tmp32 = readl(DDRC_BASE_ADDR + OFFSET_DDRC_ECCCFG1);
-	writel((0x01U << 4) | tmp32, DDRC_BASE_ADDR + OFFSET_DDRC_ECCCFG1);
+	writel((ECCCFG1_REGION_PARITY_LOCKED <<
+		ECCCFG1_REGION_PARITY_LOCK_POS) | tmp32,
+	       DDRC_BASE_ADDR + OFFSET_DDRC_ECCCFG1);
 
 	/* Set SBRCTL.scrub_mode = 1. */
 	tmp32 = readl(DDRC_BASE_ADDR + OFFSET_DDRC_SBRCTL);
-	writel((0x1U << 2) | tmp32, DDRC_BASE_ADDR + OFFSET_DDRC_SBRCTL);
+	writel((SBRCTL_SCRUB_MODE_WRITE << SBRCTL_SCRUB_MODE_POS) |
+	       tmp32, DDRC_BASE_ADDR + OFFSET_DDRC_SBRCTL);
 
 	/* Set SBRCTL.scrub_during_lowpower = 1. */
 	tmp32 = readl(DDRC_BASE_ADDR + OFFSET_DDRC_SBRCTL);
-	writel((0x1U << 1) | tmp32, DDRC_BASE_ADDR + OFFSET_DDRC_SBRCTL);
+	writel((SBRCTL_SCRUB_DURING_LOWPOWER_CONTINUED <<
+		SBRCTL_SCRUB_DURING_LOWPOWER_POS) | tmp32,
+	       DDRC_BASE_ADDR + OFFSET_DDRC_SBRCTL);
 
 	/* Set SBRCTL.scrub_interval = 0. */
 	tmp32 = readl(DDRC_BASE_ADDR + OFFSET_DDRC_SBRCTL);
-	writel(~(0x1fffU << 8) & tmp32, DDRC_BASE_ADDR + OFFSET_DDRC_SBRCTL);
+	writel(~(SBRCTL_SCRUB_INTERVAL_FIELD <<
+		 SBRCTL_SCRUB_INTERVAL_POS) & tmp32,
+	       DDRC_BASE_ADDR + OFFSET_DDRC_SBRCTL);
 
 	/* Set the desired pattern through SBRWDATA0 register. */
 	writel(pattern, DDRC_BASE_ADDR + OFFSET_DDRC_SBRWDATA0);
 
 	/* Enable the SBR by programming SBRCTL.scrub_en = 1. */
 	tmp32 = readl(DDRC_BASE_ADDR + OFFSET_DDRC_SBRCTL);
-	writel(0x1U | tmp32, DDRC_BASE_ADDR + OFFSET_DDRC_SBRCTL);
+	writel(SBRCTL_SCRUB_EN | tmp32, DDRC_BASE_ADDR + OFFSET_DDRC_SBRCTL);
 
 	/*
 	 * Poll until SBRSTAT.scrub_done = 1
@@ -403,7 +444,8 @@ u32 init_memory_ecc_scrubber(void)
 	 */
 	do {
 		tmp32 = readl(DDRC_BASE_ADDR + OFFSET_DDRC_SBRSTAT);
-	} while ((tmp32 & 0x2U) == 0);
+	} while ((tmp32 & SBRSTAT_SCRUB_DONE_MASK) ==
+		 SBRSTAT_SCRUBBER_NOT_DONE);
 
 	/*
 	 * Poll until SBRSTAT.scrub_busy = 0
@@ -411,28 +453,35 @@ u32 init_memory_ecc_scrubber(void)
 	 */
 	do {
 		tmp32 = readl(DDRC_BASE_ADDR + OFFSET_DDRC_SBRSTAT);
-	} while ((tmp32 & 0x1U) != 0);
+	} while ((tmp32 & SBRSTAT_SCRUBBER_BUSY_MASK) !=
+		 SBRSTAT_SCRUBBER_NOT_BUSY);
 
 	/* Disable SBR by programming SBRCTL.scrub_en = 0. */
 	tmp32 = readl(DDRC_BASE_ADDR + OFFSET_DDRC_SBRCTL);
-	writel(~(0x1U) & tmp32, DDRC_BASE_ADDR + OFFSET_DDRC_SBRCTL);
+	writel(~SBRCTL_SCRUB_EN & tmp32, DDRC_BASE_ADDR + OFFSET_DDRC_SBRCTL);
 
 	/* Enter normal scrub operation (Reads): SBRCTL.scrub_mode = 0. */
 	tmp32 = readl(DDRC_BASE_ADDR + OFFSET_DDRC_SBRCTL);
-	writel(~(0x1U << 2) & tmp32, DDRC_BASE_ADDR + OFFSET_DDRC_SBRCTL);
+	writel(~(SBRCTL_SCRUB_MODE_WRITE << SBRCTL_SCRUB_MODE_POS) &
+	       tmp32, DDRC_BASE_ADDR + OFFSET_DDRC_SBRCTL);
 
 	/* Set SBRCTL.scrub_interval = 1. */
 	tmp32 = readl(DDRC_BASE_ADDR + OFFSET_DDRC_SBRCTL);
-	tmp32 = ~(0x1fffU << 8) & tmp32;
-	writel((0x1UL << 8) | tmp32, DDRC_BASE_ADDR + OFFSET_DDRC_SBRCTL);
+	tmp32 = ~(SBRCTL_SCRUB_INTERVAL_FIELD <<
+		  SBRCTL_SCRUB_INTERVAL_POS) & tmp32;
+	writel((SBRCTL_SCRUB_INTERVAL_VALUE_1 <<
+		SBRCTL_SCRUB_INTERVAL_POS) | tmp32,
+	       DDRC_BASE_ADDR + OFFSET_DDRC_SBRCTL);
 
 	/* Enable the SBR by programming SBRCTL.scrub_en = 1. */
 	tmp32 = readl(DDRC_BASE_ADDR + OFFSET_DDRC_SBRCTL);
-	writel(0x1U | tmp32, DDRC_BASE_ADDR + OFFSET_DDRC_SBRCTL);
+	writel(SBRCTL_SCRUB_EN | tmp32, DDRC_BASE_ADDR + OFFSET_DDRC_SBRCTL);
 
 	/* Restore locked state of ecc region. */
 	tmp32 = readl(DDRC_BASE_ADDR + OFFSET_DDRC_ECCCFG1);
-	tmp32 = (tmp32 & ~(0x1UL << 4)) | (region_lock << 4);
+	tmp32 = (tmp32 & ~(ECCCFG1_REGION_PARITY_LOCKED <<
+			   ECCCFG1_REGION_PARITY_LOCK_POS)) |
+		(region_lock << ECCCFG1_REGION_PARITY_LOCK_POS);
 	writel(tmp32, DDRC_BASE_ADDR + OFFSET_DDRC_ECCCFG1);
 
 	return NO_ERR;
@@ -446,7 +495,8 @@ u32 read_lpddr4_mr(u8 mr_index)
 
 	/* Set MRR_DDR_SEL_REG to 0x1 to enable LPDDR4 mode */
 	tmp32 = readl(PERF_BASE_ADDR + OFFSET_MRR_0_DATA_REG_ADDR);
-	writel((tmp32 | 0x1U), PERF_BASE_ADDR + OFFSET_MRR_0_DATA_REG_ADDR);
+	writel((tmp32 | MRR_0_DDR_SEL_REG_MASK),
+	       PERF_BASE_ADDR + OFFSET_MRR_0_DATA_REG_ADDR);
 
 	/*
 	 * Ensure no MR transaction is in progress:
@@ -454,7 +504,7 @@ u32 read_lpddr4_mr(u8 mr_index)
 	 */
 	do {
 		tmp32 = readl(DDRC_BASE_ADDR + OFFSET_DDRC_MRSTAT);
-		if ((tmp32 & 0x1U) == 0)
+		if ((tmp32 & MRSTAT_MR_BUSY) == MRSTAT_MR_NOT_BUSY)
 			succesive_reads++;
 		else
 			succesive_reads = 0;
@@ -462,26 +512,31 @@ u32 read_lpddr4_mr(u8 mr_index)
 
 	/* Set MR_TYPE = 0x1 (Read) and MR_RANK = 0x1 (Rank 0) */
 	tmp32 = readl(DDRC_BASE_ADDR + OFFSET_DDRC_MRCTRL0);
-	tmp32 |= 0x1U;
-	tmp32 = (tmp32 & ~(0xfUL << 4)) | (0x1UL << 4);
+	tmp32 |= MRCTRL0_MR_TYPE_READ;
+	tmp32 = (tmp32 & ~(MRCTRL0_RANK_ACCESS_FIELD <<
+			   MRCTRL0_RANK_ACCESS_POS)) |
+		(MRCTRL0_RANK_0 << MRCTRL0_RANK_ACCESS_POS);
 	writel(tmp32, DDRC_BASE_ADDR + OFFSET_DDRC_MRCTRL0);
 
 	/* Configure MR address: MRCTRL1[8:15] */
 	tmp32 = readl(DDRC_BASE_ADDR + OFFSET_DDRC_MRCTRL1);
-	tmp32 = (tmp32 & ~(0xffUL << 8)) | ((u16)mr_index << 8);
+	tmp32 = (tmp32 & ~(MRCTRL1_MR_ADDRESS_FIELD <<
+			   MRCTRL1_MR_ADDRESS_POS)) |
+		((u16)mr_index << MRCTRL1_MR_ADDRESS_POS);
 	writel(tmp32, DDRC_BASE_ADDR + OFFSET_DDRC_MRCTRL1);
 
 	dsb();
 
 	/* Initiate MR transaction: MR_WR = 0x1 */
 	tmp32 = readl(DDRC_BASE_ADDR + OFFSET_DDRC_MRCTRL0);
-	writel(tmp32 | (0x1UL << 31), DDRC_BASE_ADDR + OFFSET_DDRC_MRCTRL0);
+	writel(tmp32 | (MRCTRL0_WR_ENGAGE << MRCTRL0_WR_ENGAGE_POS),
+	       DDRC_BASE_ADDR + OFFSET_DDRC_MRCTRL0);
 
 	/* Wait until MR transaction completed */
 	succesive_reads = 0;
 	do {
 		tmp32 = readl(DDRC_BASE_ADDR + OFFSET_DDRC_MRSTAT);
-		if ((tmp32 & 0x1U) == 0)
+		if ((tmp32 & MRSTAT_MR_BUSY) == MRSTAT_MR_NOT_BUSY)
 			succesive_reads++;
 		else
 			succesive_reads = 0;
@@ -498,7 +553,8 @@ u32 write_lpddr4_mr(u8 mr_index, u8 mr_data)
 
 	/* Set MRR_DDR_SEL_REG to 0x1 to enable LPDDR4 mode */
 	tmp32 = readl(PERF_BASE_ADDR + OFFSET_MRR_0_DATA_REG_ADDR);
-	writel(tmp32 | 0x1U, PERF_BASE_ADDR + OFFSET_MRR_0_DATA_REG_ADDR);
+	writel(tmp32 | MRCTRL0_MR_TYPE_READ,
+	       PERF_BASE_ADDR + OFFSET_MRR_0_DATA_REG_ADDR);
 
 	/*
 	 * Ensure no MR transaction is in progress:
@@ -506,7 +562,7 @@ u32 write_lpddr4_mr(u8 mr_index, u8 mr_data)
 	 */
 	do {
 		tmp32 = readl(DDRC_BASE_ADDR + OFFSET_DDRC_MRSTAT);
-		if ((tmp32 & 0x1U) == 0)
+		if ((tmp32 & MRSTAT_MR_BUSY) == MRSTAT_MR_NOT_BUSY)
 			succesive_reads++;
 		else
 			succesive_reads = 0;
@@ -514,27 +570,31 @@ u32 write_lpddr4_mr(u8 mr_index, u8 mr_data)
 
 	/* Set MR_TYPE = 0x0 (Write) and MR_RANK = 0x1 (Rank 0) */
 	tmp32 = readl(DDRC_BASE_ADDR + OFFSET_DDRC_MRCTRL0);
-	tmp32 &= ~(0x1U);
-	tmp32 = (tmp32 & ~(0xfUL << 4)) | (0x1UL << 4);
+	tmp32 &= ~(MRCTRL0_MR_TYPE_READ);
+	tmp32 = (tmp32 & ~(MRCTRL0_RANK_ACCESS_FIELD <<
+			   MRCTRL0_RANK_ACCESS_POS)) |
+		(MRCTRL0_RANK_0 << MRCTRL0_RANK_ACCESS_POS);
 	writel(tmp32, DDRC_BASE_ADDR + OFFSET_DDRC_MRCTRL0);
 
 	/* Configure MR address: MRCTRL1[8:15] and MR data: MRCTRL1[0:7]*/
 	tmp32 = readl(DDRC_BASE_ADDR + OFFSET_DDRC_MRCTRL1);
-	tmp32 = (tmp32 & (0xffffUL << 16)) | ((u16)mr_index << 8) |
-		mr_data;
+	tmp32 = (tmp32 & (MRCTRL1_MR_DATA_ADDRESS_FIELD <<
+			  MRCTRL1_MR_DATA_ADDRESS_POS)) |
+		((u16)mr_index << MRCTRL1_MR_ADDRESS_POS) | mr_data;
 	writel(tmp32, DDRC_BASE_ADDR + OFFSET_DDRC_MRCTRL1);
 
 	dsb();
 
 	/* Initiate MR transaction: MR_WR = 0x1 */
 	tmp32 = readl(DDRC_BASE_ADDR + OFFSET_DDRC_MRCTRL0);
-	writel(tmp32 | (0x1UL << 31), DDRC_BASE_ADDR + OFFSET_DDRC_MRCTRL0);
+	writel(tmp32 | (MRCTRL0_WR_ENGAGE << MRCTRL0_WR_ENGAGE_POS),
+	       DDRC_BASE_ADDR + OFFSET_DDRC_MRCTRL0);
 
 	/* Wait until MR transaction completed */
 	succesive_reads = 0;
 	do {
 		tmp32 = readl(DDRC_BASE_ADDR + OFFSET_DDRC_MRSTAT);
-		if ((tmp32 & 0x1U) == 0)
+		if ((tmp32 & MRSTAT_MR_BUSY) == MRSTAT_MR_NOT_BUSY)
 			succesive_reads++;
 		else
 			succesive_reads = 0;
@@ -550,8 +610,8 @@ u8 read_tuf(void)
 	u8 mr4_die_1, mr4_die_2;
 
 	mr4_val = read_lpddr4_mr(MR4_IDX);
-	mr4_die_1 = mr4_val & 0x7U;
-	mr4_die_2 = (mr4_val >> 16) & 0x7U;
+	mr4_die_1 = (u8)(mr4_val & MR4_MASK);
+	mr4_die_2 = (u8)((mr4_val >> MR4_SHIFT) & MR4_MASK);
 
 	return (mr4_die_1 > mr4_die_2) ? mr4_die_1 : mr4_die_2;
 }
@@ -568,110 +628,106 @@ u32 enable_derating_temp_errata(void)
 {
 	u32 tmp32, bf_val;
 
-	if (read_tuf() > TUF_THRESHOLD) {
-		/* Disable timing parameter derating: DERATEEN.DERATE_EN = 0 */
+	if (read_tuf() < TUF_THRESHOLD) {
+		/* Enable timing parameter derating: DERATEEN.DERATE_EN = 1 */
 		tmp32 = readl(DDRC_BASE_ADDR + OFFSET_DDRC_DERATEEN);
-		writel(tmp32 & ~DDRC_DERATEEN_MASK_DISABLE,
+		writel(tmp32 | DERATEEN_ENABLE,
 		       DDRC_BASE_ADDR + OFFSET_DDRC_DERATEEN);
 
-		/*
-		 * Update average time interval between refreshes per rank:
-		 * RFSHTMG.T_RFC_NOM_X1_X32 = RFSHTMG.T_RFC_NOM_X1_X32 / 4
-		 */
-		tmp32 = readl(DDRC_BASE_ADDR + OFFSET_DDRC_RFSHTMG);
-		bf_val = (tmp32 >> DDRC_RFSHTMG_VAL_SHIFT) & DDRC_RFSHTMG_VAL;
-		bf_val = bf_val >> 2;
-		tmp32 = (tmp32 & ~DDRC_RFSHTMG_MASK) |
-			(bf_val << DDRC_RFSHTMG_VAL_SHIFT);
-		writel(tmp32, DDRC_BASE_ADDR + OFFSET_DDRC_RFSHTMG);
+		polling_needed = 0;
+		return NO_ERR;
+	}
 
-		/*
-		 * Toggle RFSHCTL3.REFRESH_UPDATE_LEVEL to indicate that
-		 * refresh registers have been updated
-		 */
-		tmp32 = readl(DDRC_BASE_ADDR + OFFSET_DDRC_RFSHCTL3);
-		bf_val = (tmp32 >> DDRC_RFSHCTL3_UPDATE_SHIFT) &
-			 DDRC_RFSHCTL3_AUTO_REFRESH_VAL;
-		bf_val = bf_val ^ 0x1U;
-		tmp32 = (tmp32 & ~DDRC_RFSHCTL3_MASK) |
-			(bf_val << DDRC_RFSHCTL3_UPDATE_SHIFT);
-		writel(tmp32, DDRC_BASE_ADDR + OFFSET_DDRC_RFSHCTL3);
-
-		/* Set SWCTL.sw_done to 0 */
-		writel(DDRC_SWCTL_SWDONE_ENABLE, DDRC_BASE_ADDR +
-		       OFFSET_DDRC_SWCTL);
-		do {
-			tmp32 = readl(DDRC_BASE_ADDR + OFFSET_DDRC_SWSTAT);
-		} while ((tmp32 & DDRC_SWSTAT_SWDONE_ACK_MASK) != 0);
+	/* Disable timing parameter derating: DERATEEN.DERATE_EN = 0 */
+	tmp32 = readl(DDRC_BASE_ADDR + OFFSET_DDRC_DERATEEN);
+	writel(tmp32 & ~DERATEEN_MASK_DIS,
+	       DDRC_BASE_ADDR + OFFSET_DDRC_DERATEEN);
 
-		tmp32 = readl(DDRC_BASE_ADDR + OFFSET_DDRC_DRAMTMG4);
-		/*
-		 * Set minimum time from activate to read/write command to same
-		 * bank: DRAMTMG4.T_RCD += 2
-		 */
-		if (!update_bf(&tmp32, DDRC_DRAMTMG4_TRCD_POS,
-			       DDRC_DRAMTMG5_TRCD_MASK, 2))
-			return BITFIELD_EXCEEDED;
+	/*
+	 * Update average time interval between refreshes per rank:
+	 * RFSHTMG.T_RFC_NOM_X1_X32 = RFSHTMG.T_RFC_NOM_X1_X32 / 4
+	 */
+	tmp32 = readl(DDRC_BASE_ADDR + OFFSET_DDRC_RFSHTMG);
+	bf_val = (tmp32 >> RFSHTMG_VAL_SHIFT) & RFSHTMG_VAL;
+	bf_val = bf_val >> RFSHTMG_UPDATE_SHIFT;
+	tmp32 = (tmp32 & ~RFSHTMG_MASK) | (u32)(bf_val << RFSHTMG_VAL_SHIFT);
+	writel(tmp32, DDRC_BASE_ADDR + OFFSET_DDRC_RFSHTMG);
 
-		/*
-		 * Set minimum time between activates from bank "a" to bank "b"
-		 * DRAMTMG4.T_RRD += 2
-		 */
-		if (!update_bf(&tmp32, DDRC_DRAMTMG4_TRRD_POS,
-			       DDRC_DRAMTMG5_TRRD_MASK, 2))
-			return BITFIELD_EXCEEDED;
+	/*
+	 * Toggle RFSHCTL3.REFRESH_UPDATE_LEVEL to indicate that
+	 * refresh registers have been updated
+	 */
+	tmp32 = readl(DDRC_BASE_ADDR + OFFSET_DDRC_RFSHCTL3);
+	bf_val = (tmp32 >> RFSHCTL3_UPDATE_SHIFT) & RFSHCTL3_AUTO_REFRESH_VAL;
+	bf_val = bf_val ^ RFSHCTL3_UPDATE_LEVEL_TOGGLE;
+	tmp32 = (tmp32 & ~RFSHCTL3_MASK) | (bf_val << RFSHCTL3_UPDATE_SHIFT);
+	writel(tmp32, DDRC_BASE_ADDR + OFFSET_DDRC_RFSHCTL3);
 
-		writel(tmp32, DDRC_BASE_ADDR + OFFSET_DDRC_DRAMTMG4);
+	/* Set SWCTL.sw_done to 0 */
+	writel(SWCTL_SWDONE_ENABLE, DDRC_BASE_ADDR + OFFSET_DDRC_SWCTL);
+	do {
+		tmp32 = readl(DDRC_BASE_ADDR + OFFSET_DDRC_SWSTAT);
+	} while ((tmp32 & SWSTAT_SWDONE_ACK_MASK) != SWSTAT_SW_NOT_DONE);
 
-		/*
-		 * Set minimum time between activate and precharge to same bank
-		 * DRAMTMG0.T_RAS_MIN += 2
-		 */
-		tmp32 = readl(DDRC_BASE_ADDR + OFFSET_DDRC_DRAMTMG0);
-		if (!update_bf(&tmp32, DDRC_DRAMTMG0_TRAS_POS,
-			       DDRC_DRAMTMG0_TRAS_MASK, 2))
-			return BITFIELD_EXCEEDED;
+	tmp32 = readl(DDRC_BASE_ADDR + OFFSET_DDRC_DRAMTMG4);
+	/*
+	 * Set minimum time from activate to read/write command to same
+	 * bank: DRAMTMG4.T_RCD += 2
+	 */
+	if (!update_bf(&tmp32, DRAMTMG4_TRCD_POS, DRAMTMG4_TRCD_MASK,
+		       DRAMTMG4_TRCD_DELTA_TIME))
+		return BITFIELD_EXCEEDED;
 
-		writel(tmp32, DDRC_BASE_ADDR + OFFSET_DDRC_DRAMTMG0);
+	/*
+	 * Set minimum time between activates from bank "a" to bank "b"
+	 * DRAMTMG4.T_RRD += 2
+	 */
+	if (!update_bf(&tmp32, DRAMTMG4_TRRD_POS, DRAMTMG4_TRRD_MASK,
+		       DRAMTMG4_TRRD_DELTA_TIME))
+		return BITFIELD_EXCEEDED;
 
-		/*
-		 * Set minimum time from single-bank precharge to activate of
-		 * same bank: DRAMTMG4.T_RP += 2
-		 */
-		tmp32 = readl(DDRC_BASE_ADDR + OFFSET_DDRC_DRAMTMG4);
-		if (!update_bf(&tmp32, DDRC_DRAMTMG4_TRP_POS,
-			       DDRC_DRAMTMG4_TRP_MASK, 2))
-			return BITFIELD_EXCEEDED;
+	writel(tmp32, DDRC_BASE_ADDR + OFFSET_DDRC_DRAMTMG4);
 
-		writel(tmp32, DDRC_BASE_ADDR + OFFSET_DDRC_DRAMTMG4);
+	/*
+	 * Set minimum time between activate and precharge to same bank
+	 * DRAMTMG0.T_RAS_MIN += 2
+	 */
+	tmp32 = readl(DDRC_BASE_ADDR + OFFSET_DDRC_DRAMTMG0);
+	if (!update_bf(&tmp32, DRAMTMG0_TRAS_POS,
+		       DRAMTMG0_TRAS_MASK, DRAMTMG0_TRAS_DELTA_TIME))
+		return BITFIELD_EXCEEDED;
 
-		/*
-		 * Set minimum time between activates to same bank:
-		 * DRAMTMG1.T_RC += 3
-		 */
-		tmp32 = readl(DDRC_BASE_ADDR + OFFSET_DDRC_DRAMTMG1);
-		if (!update_bf(&tmp32, DDRC_DRAMTMG1_TRC_POS,
-			       DDRC_DRAMTMG1_TRC_MASK, 3))
-			return BITFIELD_EXCEEDED;
+	writel(tmp32, DDRC_BASE_ADDR + OFFSET_DDRC_DRAMTMG0);
 
-		writel(tmp32, DDRC_BASE_ADDR + OFFSET_DDRC_DRAMTMG1);
+	/*
+	 * Set minimum time from single-bank precharge to activate of
+	 * same bank: DRAMTMG4.T_RP += 2
+	 */
+	tmp32 = readl(DDRC_BASE_ADDR + OFFSET_DDRC_DRAMTMG4);
+	if (!update_bf(&tmp32, DRAMTMG4_TRP_POS,
+		       DRAMTMG4_TRP_MASK, DRAMTMG4_TRP_DELTA_TIME))
+		return BITFIELD_EXCEEDED;
 
-		/* Set SWCTL.sw_done to 1 */
-		writel(DDRC_SWCTL_SWDONE_DONE, DDRC_BASE_ADDR +
-		       OFFSET_DDRC_SWCTL);
-		do {
-			tmp32 = readl(DDRC_BASE_ADDR + OFFSET_DDRC_SWSTAT);
-		} while ((tmp32 & DDRC_SWSTAT_SWDONE_ACK_MASK) == 0);
+	writel(tmp32, DDRC_BASE_ADDR + OFFSET_DDRC_DRAMTMG4);
 
-		polling_needed = 1;
+	/*
+	 * Set minimum time between activates to same bank:
+	 * DRAMTMG1.T_RC += 3
+	 */
+	tmp32 = readl(DDRC_BASE_ADDR + OFFSET_DDRC_DRAMTMG1);
+	if (!update_bf(&tmp32, DRAMTMG1_TRC_POS,
+		       DRAMTMG1_TRC_MASK, DRAMTMG1_TRC_DELTA_TIME))
+		return BITFIELD_EXCEEDED;
 
-	} else {
-		/* Enable timing parameter derating: DERATEEN.DERATE_EN = 1 */
-		tmp32 = readl(DDRC_BASE_ADDR + OFFSET_DDRC_DERATEEN);
-		writel(tmp32 | DDRC_DERATEEN_ENABLE,
-		       DDRC_BASE_ADDR + OFFSET_DDRC_DERATEEN);
+	writel(tmp32, DDRC_BASE_ADDR + OFFSET_DDRC_DRAMTMG1);
+
+	/* Set SWCTL.sw_done to 1 */
+	writel(SWCTL_SWDONE_DONE, DDRC_BASE_ADDR + OFFSET_DDRC_SWCTL);
+	do {
+		tmp32 = readl(DDRC_BASE_ADDR + OFFSET_DDRC_SWSTAT);
+	} while ((tmp32 & SWSTAT_SWDONE_ACK_MASK) == SWSTAT_SW_NOT_DONE);
+
+	polling_needed = 1;
 
-		polling_needed = 0;
-	}
 	return NO_ERR;
 }
diff --git a/board/freescale/s32-gen1/ddr_utils.h b/board/freescale/s32-gen1/ddr_utils.h
index 7c10acdcf0..f8c7b21720 100644
--- a/board/freescale/s32-gen1/ddr_utils.h
+++ b/board/freescale/s32-gen1/ddr_utils.h
@@ -41,86 +41,173 @@
 #include <stdbool.h>
 
 /* Possible errors */
-#define NO_ERR              0x00000000
-#define TIMEOUT_ERR         0x00000002
-#define TRAINING_FAILED     0x00000003
-#define BITFIELD_EXCEEDED   0x00000004
+#define NO_ERR              0x00000000U
+#define TIMEOUT_ERR         0x00000002U
+#define TRAINING_FAILED     0x00000003U
+#define BITFIELD_EXCEEDED   0x00000004U
 
 /* DDRC related */
-#define DDRC_BASE_ADDR                   0x403C0000
-#define OFFSET_DDRC_SWCTL                0x320
-#define OFFSET_DDRC_DFIMISC              0x1b0
-#define OFFSET_DDRC_DFISTAT              0x1bc
-#define OFFSET_DDRC_PWRCTL               0x30
-#define OFFSET_DDRC_SWSTAT               0x324
-#define OFFSET_DDRC_STAT                 0x04
-#define OFFSET_DDRC_DBG1                 0x304
-#define OFFSET_DDRC_ECCCFG0              0x70
-#define OFFSET_DDRC_ECCCFG1              0x74
-#define OFFSET_DDRC_SBRCTL               0xf24
-#define OFFSET_DDRC_SBRSTAT              0xf28
-#define OFFSET_DDRC_SBRWDATA0            0xf2c
-#define OFFSET_DDRC_MRSTAT               0x18
-#define OFFSET_DDRC_MRCTRL0              0x10
-#define OFFSET_DDRC_MRCTRL1              0x14
-#define OFFSET_DDRC_DERATEEN             0x20
-#define OFFSET_DDRC_RFSHTMG              0x64
-#define OFFSET_DDRC_DRAMTMG0             0x100
-#define OFFSET_DDRC_DRAMTMG1             0x104
-#define OFFSET_DDRC_DRAMTMG4             0x110
+#define DDRC_BASE_ADDR                   0x403C0000U
+#define OFFSET_DDRC_SWCTL                0x320U
+#define OFFSET_DDRC_DFIMISC              0x1b0U
+#define OFFSET_DDRC_DFISTAT              0x1bcU
+#define OFFSET_DDRC_PWRCTL               0x30U
+#define OFFSET_DDRC_SWSTAT               0x324U
+#define OFFSET_DDRC_STAT                 0x04U
+#define OFFSET_DDRC_DBG1                 0x304U
+#define OFFSET_DDRC_ECCCFG0              0x70U
+#define OFFSET_DDRC_ECCCFG1              0x74U
+#define OFFSET_DDRC_SBRCTL               0xf24U
+#define OFFSET_DDRC_SBRSTAT              0xf28U
+#define OFFSET_DDRC_SBRWDATA0            0xf2cU
+#define OFFSET_DDRC_MRSTAT               0x18U
+#define OFFSET_DDRC_MRCTRL0              0x10U
+#define OFFSET_DDRC_MRCTRL1              0x14U
+#define OFFSET_DDRC_DERATEEN             0x20U
+#define OFFSET_DDRC_RFSHTMG              0x64U
+#define OFFSET_DDRC_DRAMTMG0             0x100U
+#define OFFSET_DDRC_DRAMTMG1             0x104U
+#define OFFSET_DDRC_DRAMTMG4             0x110U
 
 /* DDRC masks and values */
-#define DDRC_RFSHTMG_VAL_SHIFT           16
-#define DDRC_RFSHTMG_VAL                 0xfffU
-#define DDRC_RFSHTMG_MASK                (DDRC_RFSHTMG_VAL << \
-	DDRC_RFSHTMG_VAL_SHIFT)
-#define DDRC_RFSHCTL3_UPDATE_SHIFT       1
-#define DDRC_RFSHCTL3_AUTO_REFRESH_VAL   0x1U
-#define DDRC_RFSHCTL3_MASK               (DDRC_RFSHCTL3_AUTO_REFRESH_VAL \
-	<< DDRC_RFSHCTL3_UPDATE_SHIFT)
-#define DDRC_DERATEEN_ENABLE             0x1U
-#define DDRC_SWCTL_SWDONE_ENABLE         0x0
-#define DDRC_SWSTAT_SWDONE_ACK_MASK      0x1U
-#define DDRC_DRAMTMG4_TRCD_POS           24
-#define DDRC_DRAMTMG5_TRCD_MASK          0x1f
-#define DDRC_DRAMTMG4_TRRD_POS           8
-#define DDRC_DRAMTMG5_TRRD_MASK          0xf
-#define DDRC_DRAMTMG0_TRAS_POS           0
-#define DDRC_DRAMTMG0_TRAS_MASK          0x3f
-#define DDRC_DRAMTMG4_TRP_POS            0
-#define DDRC_DRAMTMG4_TRP_MASK           0x1f
-#define DDRC_DRAMTMG1_TRC_POS            0
-#define DDRC_DRAMTMG1_TRC_MASK           0x7f
-#define DDRC_SWCTL_SWDONE_DONE           0x1
-#define SUCCESSIVE_READ                  2
-#define DDRC_DERATEEN_MASK_DISABLE       0x1U
-#define MSTR_LPDDR4_MASK                 0x20U
-#define MSTR_LPDDR4_VAL                  0x20U
+#define MSTR_LPDDR4_MASK	0x20U
+#define MSTR_LPDDR4_VAL		0x20U
+#define SWSTAT_SW_DONE		1U
+#define SWSTAT_SW_NOT_DONE	0U
+#define SWCTL_SWDONE_DONE	0x1
+#define SWCTL_SWDONE_ENABLE	0x0
+#define SWSTAT_SWDONE_ACK_MASK	0x1U
+#define RFSHTMG_VAL_SHIFT           16
+#define RFSHTMG_VAL                 0xfffUL
+#define RFSHTMG_MASK                (RFSHTMG_VAL << \
+	RFSHTMG_VAL_SHIFT)
+#define RFSHCTL3_UPDATE_SHIFT       1
+#define RFSHCTL3_AUTO_REFRESH_VAL   0x1U
+#define RFSHCTL3_MASK               (RFSHCTL3_AUTO_REFRESH_VAL \
+	<< RFSHCTL3_UPDATE_SHIFT)
+#define DERATEEN_ENABLE		0x1U
+#define DRAMTMG4_TRCD_POS	24
+#define DRAMTMG4_TRCD_MASK	0x1f
+#define DRAMTMG4_TRRD_POS	8
+#define DRAMTMG4_TRRD_MASK	0xf
+#define DRAMTMG0_TRAS_POS	0
+#define DRAMTMG0_TRAS_MASK	0x3f
+#define DRAMTMG4_TRP_POS	0
+#define DRAMTMG4_TRP_MASK	0x1f
+#define DRAMTMG1_TRC_POS	0
+#define DRAMTMG1_TRC_MASK	0x7f
+#define SUCCESSIVE_READ		0x2U
+#define	DERATEEN_MASK_DIS	0x1U
+
+#define RFSHTMG_UPDATE_SHIFT		2
+#define RFSHCTL3_UPDATE_LEVEL_TOGGLE	0x1U
+#define DRAMTMG4_TRCD_DELTA_TIME	2
+#define DRAMTMG4_TRRD_DELTA_TIME	2
+#define DRAMTMG0_TRAS_DELTA_TIME	2
+#define DRAMTMG4_TRP_DELTA_TIME		2
+#define DRAMTMG1_TRC_DELTA_TIME		3
+#define ERRATA_CHANGES_REVERTED		1
+#define ERRATA_CHANGES_UNMODIFIED	0
+
+#define CSS_SELSTAT_MASK		0x3f000000U
+#define	CSS_SELSTAT_POS			24
+#define	CSS_SWIP_POS			16
+#define	CSS_SW_IN_PROGRESS		0x1U
+#define	CSS_SW_COMPLETED		0x0U
+#define	CSC_SELCTL_MASK			0xC0FFFFFFU
+#define CSC_SELCTL_POS			24
+#define	CSC_CLK_SWITCH_REQUEST		0x1U
+#define	CSC_CLK_SWITCH_POS		2
+#define	CSS_SW_AFTER_REQUEST_SUCCEDED	0x1U
+#define	CSS_SW_TRIGGER_CAUSE_POS	17
+
+#define DDR_SS_AXI_PARITY_ENABLE_MASK	0x00001FF0U
+#define DDR_SS_AXI_PARITY_TYPE_MASK	0x01FF0000U
+#define DDR_SS_DFI_1_ENABLED		0x1U
+#define FORCED_RESET_ON_PERIPH		0x1U
+#define PRST_0_PERIPH_3_RST_POS		3
+#define DBG1_DISABLE_DE_QUEUEING	0x0U
+#define RFSHCTL3_DISABLE_AUTO_REFRESH	0x1U
+#define ENABLE_AXI_PORT			0x000000001
+
+#define PWRCTL_POWER_DOWN_ENABLE_MASK		0x00000002U
+#define PWRCTL_SELF_REFRESH_ENABLE_MASK		0x00000001U
+#define PWRCTL_EN_DFI_DRAM_CLOCK_DIS_MASK	0x00000008U
+#define DFIMISC_DFI_INIT_COMPLETE_EN_MASK	0x000000001U
+
+#define MASTER0_CAL_ACTIVE		0x1U
+#define MASTER0_CAL_DONE		0x0U
+#define	DFIMISC_DFI_INIT_START_MASK	0x00000020U
+#define	DFISTAT_DFI_INIT_DONE		0x1U
+#define	DFISTAT_DFI_INIT_INCOMPLETE	0x0U
+#define	PWRCTL_SELFREF_SW_MASK		0x00000020U
+#define	STAT_OPERATING_MODE_MASK		0x7U
+#define	STAT_OPERATING_MODE_INIT		0x0U
+#define	RFSHCTL3_DIS_AUTO_REFRESH_MASK	0x00000001U
+#define	ECCCFG0_ECC_MODE_MASK		0x7U
+#define	ECCCFG0_ECC_DISABLED		0x0U
+#define	TRAINING_OK_MSG			0x07U
+#define	TRAINING_FAILED_MSG		0xFFU
+#define	ECCCFG1_REGION_PARITY_LOCKED	0x1UL
+#define	ECCCFG1_REGION_PARITY_LOCK_POS	4
+#define	SBRCTL_SCRUB_MODE_WRITE		0x1UL
+#define	SBRCTL_SCRUB_MODE_POS		2
+
+#define	APBONLY_DCTWRITEPROT_ACK_EN	0
+#define	APBONLY_DCTWRITEPROT_ACK_DIS	1
+#define	SBRCTL_SCRUB_DURING_LOWPOWER_CONTINUED	0x1UL
+#define	SBRCTL_SCRUB_DURING_LOWPOWER_POS		1
+
+#define	SBRCTL_SCRUB_INTERVAL_FIELD	0x1FFFU
+#define	SBRCTL_SCRUB_INTERVAL_POS		8
+#define	SBRCTL_SCRUB_EN		0x1U
+#define	SBRSTAT_SCRUB_DONE_MASK		0x2U
+#define	SBRSTAT_SCRUBBER_NOT_DONE		0x0U
+#define	SBRSTAT_SCRUBBER_BUSY_MASK		0x1U
+#define	SBRSTAT_SCRUBBER_NOT_BUSY		0x0U
+#define	SBRCTL_SCRUB_INTERVAL_VALUE_1	0x1UL
+#define	MRR_0_DDR_SEL_REG_MASK	0x1U
+
+#define	MRSTAT_MR_BUSY			0x1U
+#define	MRSTAT_MR_NOT_BUSY			0x0U
+#define	MRCTRL0_MR_TYPE_READ		0x1U
+#define	MRCTRL0_RANK_ACCESS_POS		4
+#define	MRCTRL0_RANK_ACCESS_FIELD		0xfUL
+#define	MRCTRL0_RANK_0			0x1UL
+#define	MRCTRL1_MR_ADDRESS_FIELD		0xffUL
+#define	MRCTRL1_MR_ADDRESS_POS		8
+#define	MRCTRL0_WR_ENGAGE			0x1UL
+#define	MRCTRL0_WR_ENGAGE_POS		31
+#define	MRCTRL1_MR_DATA_ADDRESS_FIELD	0xffffUL
+#define	MRCTRL1_MR_DATA_ADDRESS_POS	16
+#define STORE_CSR_DISABLED			0x0U
+#define INIT_MEM_DISABLED			0x0U
 
 /* Performance monitoring registers */
-#define PERF_BASE_ADDR                   0x403E0000
-#define OFFSET_MRR_0_DATA_REG_ADDR       0x40
-#define OFFSET_MRR_1_DATA_REG_ADDR       0x44
+#define PERF_BASE_ADDR                   0x403E0000U
+#define OFFSET_MRR_0_DATA_REG_ADDR       0x40U
+#define OFFSET_MRR_1_DATA_REG_ADDR       0x44U
 
 /* uMCTL2 Multi-Port Registers */
-#define DDRC_UMCTL2_MP_BASE_ADDR         0x403C03F8
-#define OFFSET_DDRC_PCTRL_0              0x98
-#define OFFSET_DDRC_PCTRL_1              0x148
-#define OFFSET_DDRC_PCTRL_2              0x1f8
+#define DDRC_UMCTL2_MP_BASE_ADDR         0x403C03F8U
+#define OFFSET_DDRC_PCTRL_0              0x98U
+#define OFFSET_DDRC_PCTRL_1              0x148U
+#define OFFSET_DDRC_PCTRL_2              0x1f8U
 
 /* PHY related */
-#define DDR_PHYA_MASTER0_CALBUSY                 0x4038165C
-#define DDR_PHYA_APBONLY_UCTSHSADOWREGS          0x40380404U
-#define UCT_WRITE_PROT_SHADOW_MASK               0x1U
-#define DDR_PHYA_APBONLY_DCTWRITEPROT            0x4038040C
-#define DDR_PHYA_APBONLY_UCTWRITEONLYSHADOW      0x40380410
-#define OFFSET_DDRC_RFSHCTL3                     0x60
-#define DDR_PHYA_UCCLKHCLKENABLES                0x40380BEC
+#define DDR_PHYA_MASTER0_CALBUSY		0x4038165C
+#define DDR_PHYA_APBONLY_UCTSHADOWREGS		0x40380404U
+#define UCT_WRITE_PROT_SHADOW_MASK              0x1U
+#define DDR_PHYA_DCTWRITEPROT			0x4038040C
+#define DDR_PHYA_APBONLY_UCTWRITEONLYSHADOW	0x40380410
+#define OFFSET_DDRC_RFSHCTL3			0x60U
+#define DDR_PHYA_UCCLKHCLKENABLES		0x40380BEC
+#define UCT_WRITE_PROT_SHADOW_ACK		0x0U
 
 #define SHIFT_BIT(nr)             ((1UL) << (nr))
 #define UCCLKEN_MASK              SHIFT_BIT(0)
 #define HCLKEN_MASK               SHIFT_BIT(1)
-#define OFFSET_DDRC_INIT0         0xd0
+#define OFFSET_DDRC_INIT0         0xd0U
 
 #define STORE_CSR_MASK            SHIFT_BIT(0)
 #define INIT_MEM_MASK             SHIFT_BIT(1)
@@ -145,12 +232,12 @@
 /* Reset Generation Module */
 #define MC_RGM_PRST_0             0x40078040
 #ifndef MC_CGM5_BASE_ADDR
-#define MC_CGM5_BASE_ADDR         0x40068000
+#define MC_CGM5_BASE_ADDR         0x40068000U
 #endif
-#define OFFSET_MUX_0_CSS          0x304
-#define OFFSET_MUX_0_CSC          0x300
-#define FIRC_CLK_SRC              0x0
-#define DDR_PHI0_PLL              0x24
+#define OFFSET_MUX_0_CSS          0x304U
+#define OFFSET_MUX_0_CSC          0x300U
+#define FIRC_CLK_SRC              0x0U
+#define DDR_PHI0_PLL              0x24U
 
 /* Default timeout for DDR PHY operations */
 #define DEFAULT_TIMEOUT 1000000
@@ -161,11 +248,13 @@
 
 /* ERR050543 related defines */
 #define MR4_IDX 4
-#define TUF_THRESHOLD 3
-#define REQUIRED_OK_CHECKS 3
+#define MR4_MASK	0x7U
+#define MR4_SHIFT	16
+#define TUF_THRESHOLD 0x3U
+#define REQUIRED_OK_CHECKS 0x3U
 
 /* ERR050760 related defines */
-#define REQUIRED_MRSTAT_READS 2
+#define REQUIRED_MRSTAT_READS 0x2U
 
 extern u8 polling_needed;
 
@@ -183,16 +272,6 @@ u32 post_train_setup(u8 options);
 /* Wait until firmware finishes execution and return training result */
 u32 wait_firmware_execution(void);
 
-/* Initialize memory with the ecc scrubber */
-u32 init_memory_ecc_scrubber(void);
-
-/*
- * Set the ddr clock source, FIRC or DDR_PLL_PHI0.
- * @param clk_src - requested clock source
- * @return - true whether clock source has been changed, false otherwise
- */
-bool sel_clk_src(u32 clk_src);
-
 /* Read lpddr4 mode register.
  * @param mr_index - index of mode register to be read
  */
diff --git a/board/freescale/s32-gen1/ddrss_cfg.c b/board/freescale/s32-gen1/ddrss_cfg.c
index e4ec89b7d6..2f20b30018 100644
--- a/board/freescale/s32-gen1/ddrss_cfg.c
+++ b/board/freescale/s32-gen1/ddrss_cfg.c
@@ -33,23 +33,23 @@
 
 struct ddrss_config configs[] = {
 	{
-		.memory_type = LPDDR4,
-		.ddrc_cfg = &ddrc_cfg[0],
-		.ddrc_cfg_size = 0,
-		.dq_swap_cfg = &dq_swap_cfg[0],
-		.dq_swap_cfg_size = 0,
-		.phy_cfg = &phy_cfg[0],
-		.phy_cfg_size = 0,
-		.imem_1d = &imem_1d[0],
+		.memory_type = (u8)LPDDR4,
+		.ddrc = &ddrc_cfg[0],
+		.ddrc_size = 0,
+		.dq_swap = &dq_swap_cfg[0],
+		.dq_swap_size = 0,
+		.phy = &phy_cfg[0],
+		.phy_size = 0,
+		.imem_1d = &imem_1d_cfg[0],
 		.imem_1d_size = 0,
-		.dmem_1d = &dmem_1d[0],
+		.dmem_1d = &dmem_1d_cfg[0],
 		.dmem_1d_size = 0,
-		.imem_2d = &imem_2d[0],
+		.imem_2d = &imem_2d_cfg[0],
 		.imem_2d_size = 0,
-		.dmem_2d = &dmem_2d[0],
+		.dmem_2d = &dmem_2d_cfg[0],
 		.dmem_2d_size = 0,
-		.pie_cfg = &pie_cfg[0],
-		.pie_cfg_size = 0,
+		.pie = &pie_cfg[0],
+		.pie_size = 0,
 	}
 };
 
@@ -58,14 +58,14 @@ void init_image_sizes(void)
 	size_t i;
 
 	for (i = 0; i < ddrss_config_size; i++) {
-		configs[i].ddrc_cfg_size = ddrc_cfg_size;
-		configs[i].dq_swap_cfg_size = dq_swap_cfg_size;
-		configs[i].phy_cfg_size = phy_cfg_size;
-		configs[i].imem_1d_size = imem_1d_size;
-		configs[i].dmem_1d_size = dmem_1d_size;
-		configs[i].imem_2d_size = imem_2d_size;
-		configs[i].dmem_2d_size = dmem_2d_size;
-		configs[i].pie_cfg_size = pie_cfg_size;
+		configs[i].ddrc_size = ddrc_cfg_size;
+		configs[i].dq_swap_size = dq_swap_cfg_size;
+		configs[i].phy_size = phy_cfg_size;
+		configs[i].imem_1d_size = imem_1d_cfg_size;
+		configs[i].dmem_1d_size = dmem_1d_cfg_size;
+		configs[i].imem_2d_size = imem_2d_cfg_size;
+		configs[i].dmem_2d_size = dmem_2d_cfg_size;
+		configs[i].pie_size = pie_cfg_size;
 	}
 }
 
diff --git a/board/freescale/s32-gen1/imem_cfg.c b/board/freescale/s32-gen1/imem_cfg.c
index 4c2dc73333..a38f6b85a8 100644
--- a/board/freescale/s32-gen1/imem_cfg.c
+++ b/board/freescale/s32-gen1/imem_cfg.c
@@ -31,7 +31,7 @@
 
 #include "ddr_init.h"
 
-u16 imem_1d[] = {
+u16 imem_1d_cfg[] = {
 	0x0114,
 	0x0000,
 	0x0050,
@@ -16418,9 +16418,9 @@ u16 imem_1d[] = {
 	0x0000,
 };
 
-size_t imem_1d_size = ARRAY_SIZE(imem_1d);
+size_t imem_1d_cfg_size = ARRAY_SIZE(imem_1d_cfg);
 
-u16 imem_2d[] = {
+u16 imem_2d_cfg[] = {
 	0x0204,
 	0x0000,
 	0x0050,
@@ -32807,4 +32807,4 @@ u16 imem_2d[] = {
 	0x0000,
 };
 
-size_t imem_2d_size = ARRAY_SIZE(imem_2d);
+size_t imem_2d_cfg_size = ARRAY_SIZE(imem_2d_cfg);
diff --git a/board/freescale/s32-gen1/s32g274a/dmem_cfg.c b/board/freescale/s32-gen1/s32g274a/dmem_cfg.c
index cf664a2301..55e391d2a5 100644
--- a/board/freescale/s32-gen1/s32g274a/dmem_cfg.c
+++ b/board/freescale/s32-gen1/s32g274a/dmem_cfg.c
@@ -31,7 +31,7 @@
 
 #include "ddr_init.h"
 
-u16 dmem_1d[] = {
+u16 dmem_1d_cfg[] = {
 	0x0000,
 	0x0000,
 	0x0000,
@@ -864,9 +864,9 @@ u16 dmem_1d[] = {
 	0x0000,
 };
 
-size_t dmem_1d_size = ARRAY_SIZE(dmem_1d);
+size_t dmem_1d_cfg_size = ARRAY_SIZE(dmem_1d_cfg);
 
-u16 dmem_2d[] = {
+u16 dmem_2d_cfg[] = {
 	0x0000,
 	0x0000,
 	0x0000,
@@ -1571,4 +1571,4 @@ u16 dmem_2d[] = {
 	0x0000,
 };
 
-size_t dmem_2d_size = ARRAY_SIZE(dmem_2d);
+size_t dmem_2d_cfg_size = ARRAY_SIZE(dmem_2d_cfg);
-- 
2.17.1

