From 7d08f51a45fc47e61ccb2e4979428fe8b339bd76 Mon Sep 17 00:00:00 2001
From: Ondrej Spacek <ondrej.spacek@nxp.com>
Date: Thu, 18 Mar 2021 08:39:12 +0100
Subject: [PATCH 11/19] s32-gen1/eth: This commit should add some required
 changes and also prepare for tango. Source serdes_xpcs.c is fully reworked
 and should work better for more exotic configurations.

List of improvements/fixes:
-Electrical parameters are updated to latest reference manual
-Changed initialization sequence that allows vitesse phy to work
-2.5G mode is now possible with 100Mhz clock
-It is now possible to start 2.5G on one lane and 1G on second lane
-New u-boot command "xpcs" was added to allow some customization/testing
-It is possible to enable SGMII AN via xpcs command
-It is possible to switch between 1G serdes and 2.5G serdes via xpcs
 command(Note: for this both plls have to be started)
-It is possible to switch speed select via xpcs command

Issue: ALB-6679
Upstream-Status: Pending 

Signed-off-by: Ondrej Spacek <ondrej.spacek@nxp.com>
Signed-off-by: Zhantao Tang <zhantao.tang@windriver.com>
---
 .../armv8/s32/s32-gen1/sgmii/serdes_xpcs.c    | 1009 +++++++++--------
 arch/arm/cpu/armv8/s32/s32-gen1/sgmii/sgmii.c |  517 +++++----
 .../asm/arch-s32/s32-gen1/serdes_hwconfig.h   |   13 +-
 .../asm/arch-s32/s32-gen1/serdes_regs.h       |    4 +-
 .../asm/arch-s32/s32-gen1/serdes_xpcs_regs.h  |  190 +++-
 drivers/net/dwc_eth_qos_s32cc.c               |   12 +-
 drivers/net/pfeng/pfeng_cmd.c                 |   40 +-
 drivers/pci/serdes_s32gen1.c                  |   47 +-
 drivers/pci/serdes_s32gen1.h                  |    3 +-
 9 files changed, 1033 insertions(+), 802 deletions(-)

diff --git a/arch/arm/cpu/armv8/s32/s32-gen1/sgmii/serdes_xpcs.c b/arch/arm/cpu/armv8/s32/s32-gen1/sgmii/serdes_xpcs.c
index cdcc0130b3..078e5982cc 100644
--- a/arch/arm/cpu/armv8/s32/s32-gen1/sgmii/serdes_xpcs.c
+++ b/arch/arm/cpu/armv8/s32/s32-gen1/sgmii/serdes_xpcs.c
@@ -1,6 +1,6 @@
 // SPDX-License-Identifier: GPL-2.0
 /*
- * Copyright 2019-2020 NXP
+ * Copyright 2019-2021 NXP
  *
  * The SerDes module source file.
  */
@@ -13,168 +13,124 @@
 #include <linux/ethtool.h>
 #include <asm/io.h>
 
-/**
- * @brief	Variables for XPCS indirect access
- */
-typedef struct __serdes_xpcs_access_vars_tag {
-	u32 ofsleft;
-	u32 ofsright;
-	u32 addr1;
-	u32 data1;
-	u32 addr2;
-	u32 data2;
-} serdes_xpcs_access_vars_t;
-
-/**
- * @brief		Get variables needed for indirect XPCS access
- */
-static int serdes_get_xpcs_access_vars(u32 xpcs, u32 reg,
-					   serdes_xpcs_access_vars_t *vars)
-{
-	vars->ofsleft = (reg >> 8) & 0xffffU;
-	vars->ofsright = (reg & 0xffU);
-	vars->data1 = vars->ofsleft;
-
-	if (SERDES_XPCS_0_BASE == xpcs) {
-		vars->addr1 = SERDES_XPCS_0_ADDR1;
-		vars->addr2 = SERDES_XPCS_0_ADDR2 + (vars->ofsright * 4U);
-	} else if (SERDES_XPCS_1_BASE == xpcs) {
-		vars->addr1 = SERDES_XPCS_1_ADDR1;
-		vars->addr2 = SERDES_XPCS_1_ADDR2 + (vars->ofsright * 4U);
-	} else {
-		return -EINVAL;
-	}
+#define XPCS_BASE(xpcs) (((xpcs) == 0)  ? (SERDES_XPCS_0_ADDR2) : \
+					  (SERDES_XPCS_1_ADDR2))
 
-	return 0;
+u16 serdes_xpcs_read_gen2(void *base, u32 xpcs, u32 reg)
+{
+	u32 ofsleft = (reg >> 8) & 0xffffU;
+	u32 ofsright = (reg & 0xffU);
+	u32 pcs_off = XPCS_BASE(xpcs);
+
+	writel(ofsleft, base + pcs_off + 0x3fc);
+	return readl(base + pcs_off + 4 * ofsright) & 0xffffU;
 }
 
-/**
- * @brief			Read XPCS register
- * @param[in]		base SerDes base address
- * @param[in]		xpcs XPCS offset within SerDes memory space
- * @param[in]		reg XPCS register address
- * @param[in,out]	val The XPCS register value
- * @return		0 if success, error code otherwise
- */
-static void serdes_xpcs_reg_read(void *base, u32 xpcs, u32 reg,
-				 volatile u16 *val)
+void serdes_xpcs_write_gen2(void *base, u32 xpcs, u32 reg, u16 val)
 {
-	int ret;
-	serdes_xpcs_access_vars_t vars = {0U};
+	u32 ofsleft = (reg >> 8) & 0xffffU;
+	u32 ofsright = (reg & 0xffU);
+	u32 pcs_off = XPCS_BASE(xpcs);
 
-	ret = serdes_get_xpcs_access_vars(xpcs, reg, &vars);
-	if (ret)
-		pr_warn("Can't read XPCS register (0x%x)\n", reg);
+	writel(ofsleft, base + pcs_off + 0x3fc);
+	writel(val, base + pcs_off + 4 * ofsright);
+}
 
-	writel(vars.data1, (phys_addr_t)base + vars.addr1);
-	*val = readl((phys_addr_t)base + vars.addr2) & 0xffffU;
+void serdes_xpcs_clr_setb_gen2(void *base, u32 xpcs, u32 reg,
+			       u16 clr_mask, u16 mask)
+{
+	u16 tmp_rd =  0;
+
+	if (!base)
+		return;
+
+	if (mask || clr_mask)
+		tmp_rd = serdes_xpcs_read_gen2(base, xpcs, reg);
+
+	serdes_xpcs_write_gen2(base, xpcs, reg, (tmp_rd & ~clr_mask) | mask);
 }
 
-/**
- * @brief	Write XPCS register
- * @param[in]	base SerDes base address
- * @param[in]	xpcs XPCS offset within SerDes memory space
- * @param[in]	reg XPCS register address
- * @param[in]	val The XPCS register value
- * @return	0 if success, error code otherwise
- */
-static void serdes_xpcs_reg_write(void *base, u32 xpcs, u32 reg, u16 val)
+#define PCSW16(serdes_base, pcs, reg, val) ({\
+	serdes_xpcs_write_gen2(serdes_base, pcs, reg, val);\
+})
+
+#define PCSR16(serdes_base, pcs, reg) ({\
+	serdes_xpcs_read_gen2(serdes_base, pcs, reg);\
+})
+
+#define PCSBCLR(serdes_base, pcs, reg, mask) \
+	serdes_xpcs_clr_setb_gen2(serdes_base, pcs, reg, mask, 0)
+
+#define PCSBSET(serdes_base, pcs, reg, mask) \
+	serdes_xpcs_clr_setb_gen2(serdes_base, pcs, reg, 0, mask)
+
+#define PCSBCLRSET(serdes_base, pcs, reg, clr_mask, mask) \
+	serdes_xpcs_clr_setb_gen2(serdes_base, pcs, reg, clr_mask, mask)
+
+static int serdes_pcs_wait_bits(void *base, u32 xpcs, u32 reg, u16 mask,
+				u16 val, u16 us, u16 cnt)
 {
-	int ret;
-	serdes_xpcs_access_vars_t vars = {0U};
+	u32 tmp = cnt; /* Take care so this is not optimized out */
 
-	ret = serdes_get_xpcs_access_vars(xpcs, reg, &vars);
-	if (ret)
-		pr_warn("Can't write XPCS register (0x%x)\n", reg);
+	while ((((serdes_xpcs_read_gen2(base, xpcs, reg) & mask) != val) &&
+		(tmp > 0))) {
+		udelay(us);
+		tmp--;
+	}
 
-	writel(vars.data1, (phys_addr_t)base + vars.addr1);
-	writel(val, (phys_addr_t)base + vars.addr2);
+	return ((tmp > 0)) ? (0) : (-ETIMEDOUT);
 }
 
-/**
- * @brief	Wait until XPCS power-up sequence state "Power_Good"
- * @param[in]	base SerDes base address
- * @param[in]	xpcs XPCS offset within SerDes memory space
- * @return	0 Power-up sequence state is "Power_Good"
- */
-int serdes_xpcs_wait_for_power_good(void *base, u32 xpcs)
+void serdes_pcs_loopback_enable(void *base, u32 xpcs)
 {
-	u16 reg16;
-	u8 pseq;
-	int timeout = 1000U;
+	PCSBSET(base, xpcs, VR_MII_DIG_CTRL1, R2TLBE);
+}
 
-	do {
-		serdes_xpcs_reg_read(base, xpcs, VR_MII_DIG_STS, &reg16);
-		pseq = (reg16 >> 2) & 0x7U;
-		if (pseq == 0x4U)
-			break;
-		timeout--;
-		udelay(1000U);
-	} while (timeout > 0);
+void serdes_pcs_loopback_disable(void *base, u32 xpcs)
+{
+	PCSBCLR(base, xpcs, VR_MII_DIG_CTRL1, R2TLBE);
+}
 
-	if (timeout > 0U)
-		return 0;
+int serdes_pcs_wait_for_power_good(void *base, u32 xpcs)
+{
+	return serdes_pcs_wait_bits(base, xpcs, VR_MII_DIG_STS,
+				    0x7U << 2, 0x4U << 2, 1000U, 1000U);
+}
 
-	return -ETIMEDOUT;
+void serdes_pcs_issue_vreset(void *base, u32 xpcs)
+{
+	PCSBSET(base, xpcs, VR_MII_DIG_CTRL1, VR_RST);
 }
 
-/**
- * @brief	Wait until XPCS reset is cleared
- * @param[in]	base SerDes base address
- * @param[in]	xpcs XPCS offset within SerDes memory space
- * @return	0 Power-up sequence state is "Power_Good"
- */
-static int serdes_xpcs_wait_for_reset(void *base, u32 xpcs)
-{
-	volatile u16 reg16;
-	u8 pseq;
-	u32 timeout = 1000U;
-
-	do {
-		serdes_xpcs_reg_read(base, xpcs, VR_MII_DIG_CTRL1, &reg16);
-		pseq = reg16 & VR_RST;
-		if (pseq == 0x0U)
-			break;
-		timeout--;
-		udelay(1000U);
-	} while (timeout > 0U);
-
-	if (timeout > 0U)
-		return 0;
-
-	return -ETIMEDOUT;
-}
-
-/**
- * @brief		Set SGMII speed
- * @param[in]	base SerDes base address
- * @param[in]	xpcs XPCS offset within SerDes memory space
- * @param[in]	mbps Speed in [Mbps]
- * @param[in]	fduplex Full duplex = TRUE, Half duplex = FALSE
- * @return	0 if success, error code otherwise
- */
-int serdes_xpcs_set_sgmii_speed(void *base, u32 xpcs, u32 mbps,
-				bool fduplex)
+int serdes_pcs_wait_for_vreset(void *base, u32 xpcs)
 {
-	u16 reg16;
+	return serdes_pcs_wait_bits(base, xpcs, VR_MII_DIG_CTRL1,
+				    VR_RST, 0, 1000U, 1000U);
+}
 
-	if ((SERDES_XPCS_0_BASE != xpcs) && (SERDES_XPCS_1_BASE != xpcs))
-		return -EINVAL;
+static void serdes_pcs_set_2500M_mode(void *base, u32 xpcs)
+{
+	PCSBSET(base, xpcs, VR_MII_DIG_CTRL1, EN_2_5G_MODE);
+}
+
+static void serdes_pcs_set_1000M_mode(void *base, u32 xpcs)
+{
+	PCSBCLR(base, xpcs, VR_MII_DIG_CTRL1, EN_2_5G_MODE);
+}
 
-	/*	Update control register (+ disable AN) */
-	serdes_xpcs_reg_read(base, xpcs, SR_MII_CTRL, &reg16);
-	reg16 &= ~(MII_CTRL_SS13 | MII_CTRL_SS6 | MII_CTRL_DUPLEX_MODE
-		   | MII_CTRL_AN_ENABLE);
+int serdes_pcs_speed_select(void *base, u32 xpcs, u32 div)
+{
+	u16 reg16 = 0;
 
-	switch (mbps) {
-	case SPEED_10:
+	switch (div) {
+	case 100:
 		break;
 
-	case SPEED_100:
+	case 10:
 		reg16 |= MII_CTRL_SS13;
 		break;
 
-	case SPEED_1000:
+	case 1:
 		reg16 |= MII_CTRL_SS6;
 		break;
 
@@ -183,397 +139,532 @@ int serdes_xpcs_set_sgmii_speed(void *base, u32 xpcs, u32 mbps,
 		return -EINVAL;
 	}
 
-	if (fduplex)
-		reg16 |= MII_CTRL_DUPLEX_MODE;
-
-	/*	Write the control register */
-	serdes_xpcs_reg_write(base, xpcs, SR_MII_CTRL, reg16);
+	PCSBCLRSET(base, xpcs, SR_MII_CTRL,
+		   MII_CTRL_SS13 | MII_CTRL_SS6,
+		   reg16);
 
 	return 0;
 }
 
-/**
- * @brief	Get SGMII speed
- * @param[in]	base SerDes base address
- * @param[in]	xpcs XPCS offset within SerDes memory space
- *		SERDES_XPCS_0_BASE or SERDES_XPCS_1_BASE
- * @param[in]	mbps Speed in [Mbps]
- * @param[in]	duplex Full duplex = TRUE, Half duplex = FALSE
- * @param[in]	an Auto-neg enabled = TRUE, Auto-neg disabled = FALSE
- * @return	0 if success, error code otherwise
- */
-int serdes_xpcs_get_sgmii_speed(void *base, u32 xpcs, int *mbps,
-				bool *fduplex, bool *an)
+void serdes_pcs_set_fd(void *base, u32 xpcs)
 {
-	u16 reg16;
-
-	if (xpcs != SERDES_XPCS_0_BASE && xpcs != SERDES_XPCS_1_BASE)
-		return -EINVAL;
+	PCSBSET(base, xpcs, SR_MII_CTRL, MII_CTRL_DUPLEX_MODE);
+}
 
-	serdes_xpcs_reg_read(base, xpcs, SR_MII_CTRL, &reg16);
+void serdes_pcs_set_hd(void *base, u32 xpcs)
+{
+	PCSBCLR(base, xpcs, SR_MII_CTRL, MII_CTRL_DUPLEX_MODE);
+}
 
-	*mbps = SPEED_10;
-	*fduplex = false;
-	*an = false;
+/* Call in case MII bus is in all speeds 8bit */
+void serdes_pcs_mii_bus_control_disable(void *base, u32 xpcs)
+{
+	PCSBSET(base, xpcs, VR_MII_AN_CTRL, MII_AN_CTRL_MII_CTRL);
+}
 
-	if (reg16 & MII_CTRL_SS13)
-		*mbps = SPEED_100;
+/* Call in case MII bus is in 1G 8bit and other speeds 4bit */
+void serdes_pcs_mii_bus_control_enable(void *base, u32 xpcs)
+{
+	PCSBCLR(base, xpcs, VR_MII_AN_CTRL, MII_AN_CTRL_MII_CTRL);
+}
 
-	if (reg16 & MII_CTRL_SS6)
-		*mbps = SPEED_1000;
+void serdes_pcs_an_enable(void *base, u32 xpcs)
+{
+	/* Select SGMII type AN, enable interrupt */
+	PCSBCLRSET(base, xpcs, VR_MII_AN_CTRL,
+		   MII_AN_CTRL_PCS_MODE(0x3),
+		   MII_AN_CTRL_PCS_MODE(PCS_MODE_SGMII) |
+		   MII_AN_INTR_EN);
+	/* Enable SGMII AN */
+	PCSBSET(base, xpcs, SR_MII_CTRL, MII_CTRL_AN_ENABLE);
+}
 
-	if ((reg16 & MII_CTRL_SS6) && (reg16 & MII_CTRL_SS13))
-		return -EINVAL;
+void serdes_pcs_an_disable(void *base, u32 xpcs)
+{
+	PCSBCLR(base, xpcs, SR_MII_CTRL, MII_CTRL_AN_ENABLE);
+	/* Disable interrupt */
+	PCSBCLR(base, xpcs, VR_MII_AN_CTRL, MII_AN_INTR_EN);
+}
 
-	if (reg16 & MII_CTRL_DUPLEX_MODE)
-		*fduplex = true;
+void serdes_pcs_an_restart(void *base, u32 xpcs)
+{
+	PCSBSET(base, xpcs, SR_MII_CTRL, MII_CTRL_RESTART_AN);
+}
 
-	if (reg16 & MII_CTRL_AN_ENABLE)
-		*an = true;
+void serdes_pcs_an_auto_sw_enable(void *base, u32 xpcs)
+{
+	PCSBSET(base, xpcs, VR_MII_DIG_CTRL1, MAC_AUTO_SW);
+}
 
-	serdes_xpcs_reg_read(base, xpcs, VR_MII_DIG_CTRL1, &reg16);
-	if (reg16 & EN_2_5G_MODE) {
-		*mbps = SPEED_2500;
-		/* Auto-neg not supported in 2.5G mode */
-		*an = false;
-	}
+void serdes_pcs_an_auto_sw_disable(void *base, u32 xpcs)
+{
+	PCSBCLR(base, xpcs, VR_MII_DIG_CTRL1, MAC_AUTO_SW);
+}
 
-	return 0;
+void serdes_pcs_an_set_link_timer(void *base, u32 xpcs, u16 link_timer)
+{
+	PCSW16(base, xpcs, VR_MII_LINK_TIMER_CTRL, link_timer);
+	PCSBCLR(base, xpcs, VR_MII_DIG_CTRL1, CL37_TMR_OVR_RIDE);
+	PCSBSET(base, xpcs, VR_MII_DIG_CTRL1, CL37_TMR_OVR_RIDE);
 }
 
-int serdes_xpcs_set_loopback(void *base, u32 xpcs, bool enable)
+/* This is intended to be called from AN interrupt to resolve the AN result */
+int serdes_pcs_an_decode(void *base, u32 xpcs, bool *link,
+			 bool *fduplex, u16 *speed)
 {
-	u16 reg16;
+	u16 reg16 = PCSR16(base, xpcs, VR_MII_AN_INTR_STS);
 
-	if ((SERDES_XPCS_0_BASE != xpcs) && (SERDES_XPCS_1_BASE != xpcs))
+	if (reg16 & CL37_ANSGM_STS_LINK) {
+		*link = true;
+	} else {
+		*link = false;
+		/* Remote link is down Auto-negotiation didn't work*/
+		pr_warn("Auto-negotiation wasn't successful\n");
 		return -EINVAL;
+	}
+	*fduplex = false;
+	if (reg16 & CL37_ANSGM_STS_FD)
+		*fduplex = true;
 
-	serdes_xpcs_reg_read(base, xpcs, SR_MII_CTRL, &reg16);
+	switch (CL37_ANSGM_STS_GET_SPEED(reg16)) {
+	case CL37_ANSGM_STS_SPEED_10M:
+		*speed = 10;
+		break;
+	case CL37_ANSGM_STS_SPEED_100M:
+		*speed = 100;
+		break;
+	case CL37_ANSGM_STS_SPEED_1000M:
+		*speed = 1000;
+		break;
+	default:
+		*speed = 0;
+		return -EINVAL;
+	}
 
-	/*	Update control register (+ manage LBE) */
-	if (enable)
-		reg16 |= R2TLBE;
-	else
-		reg16 &= ~R2TLBE;
+	return 0;
+}
 
-	/*	Write the control register */
-	serdes_xpcs_reg_write(base, xpcs, SR_MII_CTRL, reg16);
+int serdes_pma_wait_link(void *base, u32 xpcs, u8 sec)
+{
+	return serdes_pcs_wait_bits(base, xpcs, SR_MII_STS,
+				    MII_STS_LINK_STS, MII_STS_LINK_STS,
+				    1000U, 1000U * sec);
+}
 
-	return 0;
+void serdes_pma_issue_rx_reset(void *base, u32 xpcs)
+{
+	PCSBSET(base, xpcs, VR_MII_GEN5_12G_16G_RX_GENCTRL1, RX_RST_0);
+	PCSBCLR(base, xpcs, VR_MII_GEN5_12G_16G_RX_GENCTRL1, RX_RST_0);
 }
 
-/**
- * @brief	Wait for PCS link
- * @param[in]	base SerDes base address
- * @param[in]	xpcs XPCS offset within SerDes memory space
- * @param[in]	timeout Timeout in [s]
- * @return	0 link is up, error code otherwise
- */
-int serdes_wait_for_link(void *base, u32 xpcs, u8 timeout)
+void serdes_pma_lane_disable(void *base, u32 xpcs)
 {
-	/*	Number of 100ms periods */
-	u32 tout = (1000U * timeout) / 100U;
-	u16 reg16;
+	PCSBSET(base, xpcs, VR_MII_GEN5_12G_16G_TX_POWER_STATE_CTRL,
+		TX_DISABLE_0);
+	PCSBSET(base, xpcs, VR_MII_GEN5_12G_16G_RX_POWER_STATE_CTRL,
+		RX_DISABLE_0);
+}
 
-	do {
-		serdes_xpcs_reg_read(base, xpcs, SR_MII_STS, &reg16);
-		if (0U != (reg16 & MII_STS_LINK_STS))
-			break;
-		tout--;
-		udelay(100000U);
-	} while (tout > 0U);
+void serdes_pma_lane_enable(void *base, u32 xpcs)
+{
+	PCSBCLR(base, xpcs, VR_MII_GEN5_12G_16G_TX_POWER_STATE_CTRL,
+		TX_DISABLE_0);
+	PCSBCLR(base, xpcs, VR_MII_GEN5_12G_16G_RX_POWER_STATE_CTRL,
+		RX_DISABLE_0);
+}
 
-	if (0U == tout)
-		return -ETIMEDOUT;
+void serdes_pma_loopback_enable(void *base, u32 xpcs)
+{
+	PCSBSET(base, xpcs, SR_MII_CTRL, LBE);
+}
 
-	return 0;
+void serdes_pma_loopback_disable(void *base, u32 xpcs)
+{
+	PCSBCLR(base, xpcs, SR_MII_CTRL, LBE);
 }
 
+static void serdes_pma_configure_tx_ctr(void *base, u32 xpcs)
+{
+	PCSBCLRSET(base, xpcs, VR_MII_GEN5_12G_16G_TX_EQ_CTRL0,
+		   0x3fU << 8U,
+		   0xCU << 8U);
+	PCSBCLRSET(base, xpcs, VR_MII_CONSUMER_10G_TX_TERM_CTRL,
+		   0x7U,
+		   0x4U);
+}
 
-/**
- * @brief	Configure XPCS to 1G mode with respect to reference clock
- * @param[in]	base SerDes base address
- * @param[in]	xpcs XPCS offset within SerDes memory space
- * @param[in]	ext_ref If reference clock is taken via pads then this shall be
- *		TRUE. If internal reference clock is used then use FALSE.
- * @param[in]	ref_mhz Reference clock frequency in [MHz]. 100 or 125.
- * @param[in]	bypass If true bypass initialization checks in case of ext_ref
- * @return	0 if success, error code otherwise
- */
-int serdes_xpcs_set_1000_mode(void *base, u32 xpcs,
-			      enum serdes_clock clktype,
-			      enum serdes_clock_fmhz fmhz,
-			      bool bypass)
+static void serdes_pma_1250Mhz_prepare(void *base, u32 xpcs,
+				       enum serdes_clock_fmhz fmhz)
 {
-	int retval = 0;
-	u16 reg16, use_pad = 0U;
+	u16 vco_cal_ld, vco_cal_ref;
 
-	if ((SERDES_XPCS_0_BASE != xpcs) && (SERDES_XPCS_1_BASE != xpcs))
-		return -EINVAL;
+	if (fmhz == CLK_100MHZ) {
+		vco_cal_ld = 1350U;
+		vco_cal_ref = 27U;
+	} else {
+		vco_cal_ld = 1360U;
+		vco_cal_ref = 17U;
+	}
+	/* RX VCO calibration value */
+	PCSBCLRSET(base, xpcs, VR_MII_GEN5_12G_16G_VCO_CAL_LD0,
+		   0x1fff,
+		   vco_cal_ld);
+
+	/* VCO calibration reference */
+	PCSBCLRSET(base, xpcs, VR_MII_GEN5_12G_VCO_CAL_REF0,
+		   0x3f,
+		   vco_cal_ref);
+
+	/* TX rate baud/4 (baud 1250Mhz) */
+	PCSBCLRSET(base, xpcs, VR_MII_GEN5_12G_16G_TX_RATE_CTRL,
+		   0x7,
+		   0x2U); /* b010 */
+
+	/* Rx rate baud/8 (baud 1250Mhz) */
+	PCSBCLRSET(base, xpcs, VR_MII_GEN5_12G_16G_RX_RATE_CTRL,
+		   0x3U,
+		   0x3U); /* b11 */
+
+	/* Clear low-frequency operating band */
+	PCSBCLR(base, xpcs, VR_MII_GEN5_12G_16G_CDR_CTRL, VCO_LOW_FREQ_0);
+}
 
-	if (clktype == CLK_EXT) {
-		/*	Using external clock reference */
-		use_pad = REF_CLK_CTRL_REF_USE_PAD;
+/* Call only with 125mhz ref clk */
+static void serdes_pma_3125Mhz_prepare(void *base, u32 xpcs,
+				       enum serdes_clock_fmhz fmhz)
+{
+	u16 vco_cal_ld, vco_cal_ref;
+
+	if (fmhz == CLK_100MHZ) {
+		vco_cal_ld = 1344U;
+		vco_cal_ref = 43U;
+	} else {
+		vco_cal_ld = 1350U;
+		vco_cal_ref = 27U;
 	}
+	/* RX VCO calibration value */
+	PCSBCLRSET(base, xpcs, VR_MII_GEN5_12G_16G_VCO_CAL_LD0,
+		   0x1fff,
+		   vco_cal_ld);
+
+	/* VCO calibration reference */
+	PCSBCLRSET(base, xpcs, VR_MII_GEN5_12G_VCO_CAL_REF0,
+		   0x3f,
+		   vco_cal_ref);
+
+	/* TX rate baud  */
+	PCSBCLRSET(base, xpcs, VR_MII_GEN5_12G_16G_TX_RATE_CTRL,
+		   0x7,
+		   0x0U);
+
+	/* Rx rate baud/2 */
+	PCSBCLRSET(base, xpcs, VR_MII_GEN5_12G_16G_RX_RATE_CTRL,
+		   0x3U,
+		   0x1U);
+
+	/* Set low-frequency operating band */
+	PCSBSET(base, xpcs, VR_MII_GEN5_12G_16G_CDR_CTRL, VCO_LOW_FREQ_0);
+}
 
-	/* Set bypass flag in case of internal clocks */
-	if (clktype == CLK_INT)
-		serdes_xpcs_reg_write(base, xpcs, VR_MII_DIG_CTRL1,
-				      EN_VSMMD1 | BYP_PWRUP);
-
-/* Currently this can't be enabled due to issue in bifurcation modes */
-#ifdef S32G_XPCS_ENABLE_PRECHECKS
-	if (!(bypass && clktype == CLK_EXT)) {
-		/*	Wait for XPCS power up */
-		retval = serdes_xpcs_wait_for_power_good(base,
-							 xpcs);
-		if (retval)
-			/*	XPCS power-up failed */
-			return retval;
-
-		/*	Compatibility check */
-		serdes_xpcs_reg_read(base, xpcs, SR_MII_DEV_ID1,
-				     &reg16);
-		if (reg16 != 0x7996U)
-			/*	Unexpected XPCS ID */
-			return -EINVAL;
-
-		serdes_xpcs_reg_read(base, xpcs, SR_MII_DEV_ID2,
-				     &reg16);
-		if (reg16 != 0xced0U)
-			/*	Unexpected XPCS ID */
-			return -EINVAL;
+static void serdes_pma_mplla_start_cal(void *base, u32 xpcs,
+				       enum serdes_clock_fmhz fmhz)
+{
+	if (fmhz == CLK_100MHZ) {
+		PCSBCLRSET(base, xpcs, VR_MII_GEN5_12G_16G_REF_CLK_CTRL,
+			   REF_RANGE(0x7U) | REF_CLK_DIV2 | REF_MPLLA_DIV2,
+			   REF_RANGE(0x3U) | REF_CLK_EN);
+
+		/* Clear multiplier and set it to 25 and enable PPL cal */
+		PCSBCLRSET(base, xpcs, VR_MII_GEN5_12G_16G_MPLLA_CTRL0,
+			   MPLLA_MULTIPLIER_VALUE(0xff) |
+			   MPLLA_CAL_DISABLE,
+			   MPLLA_MULTIPLIER_VALUE(25U));
+
+	} else {
+		PCSBCLRSET(base, xpcs, VR_MII_GEN5_12G_16G_REF_CLK_CTRL,
+			   REF_RANGE(0x7U),
+			   REF_RANGE(0x2U) | REF_CLK_DIV2 |
+			   REF_MPLLA_DIV2 | REF_CLK_EN);
+
+		/* Clear multiplier and set it to 80 and enable PPL cal */
+		PCSBCLRSET(base, xpcs, VR_MII_GEN5_12G_16G_MPLLA_CTRL0,
+			   MPLLA_MULTIPLIER_VALUE(0xff) | MPLLA_CAL_DISABLE,
+			   MPLLA_MULTIPLIER_VALUE(80U));
 	}
-#endif
 
-	/*	(Switch to 1G mode: #1) */
-	if (clktype == CLK_INT)
-		serdes_xpcs_reg_write(base, xpcs, VR_MII_DIG_CTRL1,
-				      EN_VSMMD1 | BYP_PWRUP);
+	PCSBCLR(base, xpcs, VR_MII_GEN5_12G_MPLLA_CTRL1, 0xffe0U);
+
+	PCSBCLRSET(base, xpcs, VR_MII_GEN5_12G_16G_MPLLA_CTRL2,
+		   MPLLA_TX_CLK_DIV(0x7U),
+		   MPLLA_TX_CLK_DIV(1U) | MPLLA_DIV10_CLK_EN);
+
+	if (fmhz == CLK_100MHZ)
+		PCSW16(base, xpcs, VR_MII_GEN5_12G_MPLLA_CTRL3, 357U);
 	else
-		serdes_xpcs_reg_write(base, xpcs, VR_MII_DIG_CTRL1,
-				      EN_VSMMD1);
-	/*	(Switch to 1G mode: #2) */
-	serdes_xpcs_reg_write(base, xpcs, VR_MII_DBG_CTRL, 0U);
-	/*	(Switch to 1G mode: #3) */
-	serdes_xpcs_reg_write(base, xpcs, VR_MII_GEN5_12G_16G_MPLL_CMN_CTRL,
-			      MPLL_CMN_CTRL_MPLL_EN_0);
+		PCSW16(base, xpcs, VR_MII_GEN5_12G_MPLLA_CTRL3, 43U);
+}
 
+/* Configure PLLB and start calibration
+ * Note: Enable this only with 125Mhz ref !!
+ */
+static void serdes_pma_mpllb_start_cal(void *base, u32 xpcs,
+				       enum serdes_clock_fmhz fmhz)
+{
 	if (fmhz == CLK_100MHZ) {
-		/*	RefClk = 100MHz */
-		/*	(Switch to 1G mode: #4) */
-		serdes_xpcs_reg_write(base, xpcs,
-				      VR_MII_GEN5_12G_16G_REF_CLK_CTRL,
-				      REF_CLK_CTRL_REF_RANGE(3U)
-				      | use_pad
-				      | REF_CLK_CTRL_REF_CLK_EN);
-		/*	(Switch to 1G mode: #5) */
-		serdes_xpcs_reg_write(base, xpcs,
-				      VR_MII_GEN5_12G_16G_MPLLA_CTRL0,
-				      MPLLA_MULTIPLIER_VALUE(25U));
+		PCSBCLRSET(base, xpcs, VR_MII_GEN5_12G_16G_REF_CLK_CTRL,
+			   REF_RANGE(0x7U) | REF_CLK_DIV2 | REF_MPLLB_DIV2,
+			   REF_RANGE(0x3U) | REF_CLK_EN);
+
+		/* Clear multiplier and set it to 25 and enable PPL cal */
+		PCSBCLRSET(base, xpcs, VR_MII_GEN5_12G_16G_MPLLB_CTRL0,
+			   MPLLB_MULTIPLIER(0xffU) | MPPLB_CAL_DISABLE,
+			   MPLLB_MULTIPLIER(0x27U));
+
 	} else {
-		/*	RefClk = 125MHz */
-		/*	(Switch to 1G mode: #4) */
-		serdes_xpcs_reg_write(base, xpcs,
-				      VR_MII_GEN5_12G_16G_REF_CLK_CTRL,
-				      REF_CLK_CTRL_REF_RANGE(2U)
-				      | use_pad
-				      | REF_CLK_CTRL_REF_MPLLA_DIV2
-				      | REF_CLK_CTRL_REF_CLK_DIV2
-				      | REF_CLK_CTRL_REF_CLK_EN);
-		/*	(Switch to 1G mode: #5) */
-		serdes_xpcs_reg_write(base, xpcs,
-				      VR_MII_GEN5_12G_16G_MPLLA_CTRL0,
-				      MPLLA_MULTIPLIER_VALUE(80U));
+		PCSBCLRSET(base, xpcs, VR_MII_GEN5_12G_16G_REF_CLK_CTRL,
+			   REF_RANGE(0x7U),
+			   REF_RANGE(0x2U) | REF_MPLLB_DIV2 |
+			   REF_CLK_DIV2 | REF_CLK_EN);
+
+		/* Clear multiplier and set it to 125 and enable PPL cal */
+		PCSBCLRSET(base, xpcs, VR_MII_GEN5_12G_16G_MPLLB_CTRL0,
+			   MPLLB_MULTIPLIER(0xffU) | MPPLB_CAL_DISABLE,
+			   MPLLB_MULTIPLIER(125U));
 	}
 
-	/*	(Switch to 1G mode: #6) */
-	serdes_xpcs_reg_write(base, xpcs, VR_MII_GEN5_12G_MPLLA_CTRL1, 0U);
+	/* Clear the fraction divider */
+	PCSBCLR(base, xpcs, VR_MII_GEN5_12G_MPLLB_CTRL1, 0xffe0U);
 
-	/*	(Switch to 1G mode: #7) */
-	serdes_xpcs_reg_write(base, xpcs, VR_MII_GEN5_12G_16G_MPLLA_CTRL2,
-			      MPLLA_TX_CLK_DIV(1U) | MPLLA_DIV10_CLK_EN);
+	PCSBCLRSET(base, xpcs, VR_MII_GEN5_12G_16G_MPLLB_CTRL2,
+		   MPLLB_TX_CLK_DIV(0x7U),
+		   MPLLB_TX_CLK_DIV(0x5U) | MPLLB_DIV10_CLK_EN);
 
 	if (fmhz == CLK_100MHZ) {
-		/*	RefClk = 100MHz */
-		/*	(Switch to 1G mode: #8) */
-		serdes_xpcs_reg_write(base, xpcs, VR_MII_GEN5_12G_MPLLA_CTRL3,
-				      357U);
-		/*	(Switch to 1G mode: #9) */
-		serdes_xpcs_reg_write(base, xpcs,
-				      VR_MII_GEN5_12G_16G_VCO_CAL_LD0, 1350U);
-		/*	(Switch to 1G mode: #10) */
-		serdes_xpcs_reg_write(base, xpcs, VR_MII_GEN5_12G_VCO_CAL_REF0,
-				      27U);
+		/* Set fraction divider */
+		PCSBSET(base, xpcs, VR_MII_GEN5_12G_MPLLB_CTRL1, 0x414U << 5U);
+
+		/* PLL bandwidth */
+		PCSW16(base, xpcs, VR_MII_GEN5_12G_MPLLB_CTRL3, 0x66U);
 	} else {
-		/*	RefClk = 125MHz */
-		/*	(Switch to 1G mode: #8) */
-		serdes_xpcs_reg_write(base, xpcs, VR_MII_GEN5_12G_MPLLA_CTRL3,
-				      43U);
-		/*	(Switch to 1G mode: #9) */
-		serdes_xpcs_reg_write(base, xpcs,
-				      VR_MII_GEN5_12G_16G_VCO_CAL_LD0, 1360U);
-		/*	(Switch to 1G mode: #10) */
-		serdes_xpcs_reg_write(base, xpcs, VR_MII_GEN5_12G_VCO_CAL_REF0,
-				      17U);
+		/* PLL bandwidth */
+		PCSW16(base, xpcs, VR_MII_GEN5_12G_MPLLB_CTRL3, 68U);
 	}
+}
 
-	/*	(Switch to 1G mode: #11) */
-	serdes_xpcs_reg_write(base, xpcs, VR_MII_GEN5_12G_16G_TX_RATE_CTRL,
-			      0x2U); /* b010 */
-	/*	(Switch to 1G mode: #12) */
-	serdes_xpcs_reg_write(base, xpcs, VR_MII_GEN5_12G_16G_RX_RATE_CTRL,
-			      0x3U); /* b11 */
-	/*	(Switch to 1G mode: #13) */
-	serdes_xpcs_reg_write(base, xpcs, VR_MII_GEN5_12G_16G_CDR_CTRL,
-			      0x1U); /* VCO_LOW_FREQ_0=0 + CDR_TRACK_ENA=1 */
-	/*	(Switch to 1G mode: #14) */
-	serdes_xpcs_reg_write(base, xpcs, VR_MII_GEN5_12G_16G_MPLLB_CTRL0,
-			      MPPLB_CAL_DISABLE|0x7dU);
-			      /* CAL_DISABLE=1, MPPLB_MULTIPLIER=default */
-
-	/*	(Switch to 1G mode: #15) */
-	serdes_xpcs_reg_read(base, xpcs, VR_MII_DIG_CTRL1, &reg16);
+static void serdes_pma_mplla_stop_cal(void *base, u32 xpcs)
+{
+	/* Disable PLLB calibration */
+	PCSBSET(base, xpcs, VR_MII_GEN5_12G_16G_MPLLA_CTRL0, MPLLA_CAL_DISABLE);
+}
 
-	/* Clear bypass flag in case of internal clocks */
-	if (clktype == CLK_INT) {
-		reg16 &= ~BYP_PWRUP;
-		serdes_xpcs_reg_write(base, xpcs, VR_MII_DIG_CTRL1, reg16);
-	}
-	serdes_xpcs_reg_write(base, xpcs, VR_MII_DIG_CTRL1, reg16 | VR_RST);
-
-	/* Issue reset */
-	/*	(Switch to 1G mode: #16) */
-	if (serdes_xpcs_wait_for_reset(base, xpcs))
-		pr_err("XPCS pre power-up soft reset failed\n");
-
-	/*	Wait for XPCS power up */
-	pr_debug("Waiting for XPCS power-up\n");
-	if (serdes_xpcs_wait_for_power_good(base, xpcs)) {
-		pr_err("XPCS power-up failed\n");
-		return -EXIT_FAILURE;
+static void serdes_pma_mpllb_stop_cal(void *base, u32 xpcs)
+{
+	/* Disable PLLB calibration */
+	PCSBSET(base, xpcs, VR_MII_GEN5_12G_16G_MPLLB_CTRL0, MPPLB_CAL_DISABLE);
+}
+
+void serdes_pma_select_plla_ref(void *base, u32 xpcs)
+{
+	/* Select PLLA */
+	PCSBCLR(base, xpcs, VR_MII_GEN5_12G_16G_MPLL_CMN_CTRL, MPLLB_SEL_0);
+	/* Enable PLL */
+	PCSBSET(base, xpcs, VR_MII_GEN5_12G_16G_MPLL_CMN_CTRL, MPLL_EN_0);
+}
+
+void serdes_pma_select_pllb_ref(void *base, u32 xpcs)
+{
+	/* Select PLLB */
+	PCSBSET(base, xpcs, VR_MII_GEN5_12G_16G_MPLL_CMN_CTRL, MPLLB_SEL_0);
+	/* Enable PLL */
+	PCSBSET(base, xpcs, VR_MII_GEN5_12G_16G_MPLL_CMN_CTRL, MPLL_EN_0);
+}
+
+int serdes_bifurcation_pll_transit(void *base, u32 xpcs, bool plla)
+{
+	int ret = 0;
+
+	/* Signal that clock are not available */
+	PCSBCLR(base, xpcs, VR_MII_GEN5_12G_16G_TX_GENCTRL1, TX_CLK_RDY_0);
+
+	if (plla) {
+		/* Request PLLA */
+		serdes_pma_select_plla_ref(base, xpcs);
+	} else {
+		/* Request PLLB */
+		serdes_pma_select_pllb_ref(base, xpcs);
 	}
 
-	return retval;
+	/* Initiate transmitter TX reconfiguration request */
+	PCSBSET(base, xpcs, VR_MII_GEN5_12G_16G_TX_GENCTRL2, TX_REQ_0);
+
+	/* Wait for transmitter to reconfigure */
+	ret = serdes_pcs_wait_bits(base, xpcs, VR_MII_GEN5_12G_16G_TX_GENCTRL2,
+				   TX_REQ_0, 0,
+				   100U, 100U);
+	if (ret)
+		pr_err("TX_REQ_0 failed\n");
+
+	/* Initiate transmitter RX reconfiguration request */
+	PCSBSET(base, xpcs, VR_MII_GEN5_12G_16G_RX_GENCTRL2, RX_REQ_0);
+
+	/* Wait for transmitter to reconfigure */
+	ret = serdes_pcs_wait_bits(base, xpcs, VR_MII_GEN5_12G_16G_RX_GENCTRL2,
+				   RX_REQ_0, 0,
+				   100U, 100U);
+	if (ret)
+		pr_err("RX_REQ_0 failed\n");
+
+	/* Signal that clock are available */
+	PCSBSET(base, xpcs, VR_MII_GEN5_12G_16G_TX_GENCTRL1, TX_CLK_RDY_0);
+
+	/* Flush internal logic */
+	PCSBSET(base, xpcs, VR_MII_DIG_CTRL1, INIT);
+
+	/* Wait for init */
+	ret = serdes_pcs_wait_bits(base, xpcs, VR_MII_DIG_CTRL1,
+				   INIT, 0,
+				   100U, 100U);
+	if (ret)
+		pr_err("INIT failed\n");
+
+	return ret;
 }
 
-/**
- * @brief	Configure XPCS to 2.5G mode with respect to reference clock
- * @param[in]	base SerDes base address
- * @param[in]	xpcs XPCS offset within SerDes memory space
- * @param[in]	clktype If reference clock external/internal
- * @param[in]	fmhz Reference clock frequency
- * @return	0 if success, error code otherwise
- */
-int serdes_xpcs_set_2500_mode(void *base, u32 xpcs,
-			      enum serdes_clock clktype,
-			      enum serdes_clock_fmhz fmhz)
+/* Transit to PLLB */
+int serdes_bifurcation_pll_transit_to_3125Mhz(void *base, u32 xpcs,
+					      enum serdes_clock_fmhz fmhz)
 {
-	int retval;
-	u16 reg16, use_pad = 0U;
+	/* Switch PCS logic to 2.5G */
+	serdes_pcs_set_2500M_mode(base, xpcs);
 
-	if ((SERDES_XPCS_0_BASE != xpcs) && (SERDES_XPCS_1_BASE != xpcs))
-		return -EINVAL;
+	/* Switch PMA logic to 3.125Ghz */
+	serdes_pma_3125Mhz_prepare(base, xpcs, fmhz);
 
-	if (fmhz != CLK_125MHZ)
-		return -EINVAL;
+	/* Do the transit to PLLB */
+	return serdes_bifurcation_pll_transit(base, xpcs, false);
+}
+
+/* Transit to PLLA */
+int serdes_bifurcation_pll_transit_to_1250Mhz(void *base, u32 xpcs,
+					      enum serdes_clock_fmhz fmhz)
+{
+	/* Switch PCS logic to 1G */
+	serdes_pcs_set_1000M_mode(base, xpcs);
+
+	/* Switch PMA logic to 1.250Ghz */
+	serdes_pma_1250Mhz_prepare(base, xpcs, fmhz);
 
-	if (clktype == CLK_EXT) {
-		/*	Using external clock reference */
-		use_pad = REF_CLK_CTRL_REF_USE_PAD;
+	/* Do the transit PLLA */
+	return serdes_bifurcation_pll_transit(base, xpcs, true);
+}
+
+void serdes_pcs_pma_init_gen2(void *base, enum serdes_clock_fmhz fmhz,
+			      u32 init_flags)
+{
+	u32 xpcs_phy_ctr = 0;
+
+	if ((init_flags & PHY_CTRL_XPCS_OWNED) != 0) {
+		if ((init_flags & PHY_CTRL_XPCS0_OWNED) != 0)
+			xpcs_phy_ctr = 0;
+		else if ((init_flags & PHY_CTRL_XPCS1_OWNED) != 0)
+			xpcs_phy_ctr = 1;
 	}
 
 	/* Set bypass flag in case of internal clocks */
-	if (clktype == CLK_INT)
-		serdes_xpcs_reg_write(base, xpcs,
-				      VR_MII_DIG_CTRL1, EN_VSMMD1 | BYP_PWRUP);
-
-	/*	Wait for XPCS power up */
-	retval = serdes_xpcs_wait_for_power_good(base, xpcs);
-	if (retval)
-		/*	XPCS power-up failed */
-		return retval;
-
-	/*	Compatibility check */
-	serdes_xpcs_reg_read(base, xpcs, SR_MII_DEV_ID1, &reg16);
-	if (0x7996U != reg16)
-		/*	Unexpected XPCS ID */
-		return -EINVAL;
+	if (((init_flags & PHY_CLK_INT) != 0) &&
+	    ((init_flags & (XPCS0_OWNED)) != 0)) {
+		PCSBSET(base, 0, VR_MII_DIG_CTRL1, EN_VSMMD1 | BYP_PWRUP);
+	} else if ((init_flags & (XPCS0_OWNED)) != 0) {
+		PCSBCLRSET(base, 0, VR_MII_DIG_CTRL1, BYP_PWRUP, EN_VSMMD1);
+	}
 
-	serdes_xpcs_reg_read(base, xpcs, SR_MII_DEV_ID2, &reg16);
-	if (0xced0U != reg16)
-		/*	Unexpected XPCS ID */
-		return -EINVAL;
+	if (((init_flags & PHY_CLK_INT) != 0) &&
+	    ((init_flags & (XPCS1_OWNED)) != 0)) {
+		PCSBSET(base, 1, VR_MII_DIG_CTRL1, EN_VSMMD1 | BYP_PWRUP);
+	} else if ((init_flags & (XPCS1_OWNED)) != 0) {
+		PCSBCLRSET(base, 1, VR_MII_DIG_CTRL1, BYP_PWRUP, EN_VSMMD1);
+	}
 
-	/*	(Switch to 2.5G mode: #1) */
-	if (clktype == CLK_INT)
-		serdes_xpcs_reg_write(base, xpcs, VR_MII_DIG_CTRL1,
-				      EN_VSMMD1 | EN_2_5G_MODE | BYP_PWRUP);
-	else
-		serdes_xpcs_reg_write(base, xpcs, VR_MII_DIG_CTRL1,
-				      EN_VSMMD1 | EN_2_5G_MODE);
-	/*	(Switch to 2.5G mode: #2) */
-	serdes_xpcs_reg_write(base, xpcs, VR_MII_DBG_CTRL, 0U);
-	/*	(Switch to 2.5G mode: #3) */
-	serdes_xpcs_reg_write(base, xpcs, VR_MII_GEN5_12G_16G_MPLL_CMN_CTRL,
-			      MPLL_CMN_CTRL_MPLL_EN_0
-			      | MPLL_CMN_CTRL_MPLLB_SEL_0);
-	/*	(Switch to 2.5G mode: #4) */
-	serdes_xpcs_reg_write(base, xpcs, VR_MII_GEN5_12G_16G_REF_CLK_CTRL,
-			      REF_CLK_CTRL_REF_MPLLB_DIV2
-			      | use_pad
-			      | REF_CLK_CTRL_REF_RANGE(2U)
-			      | REF_CLK_CTRL_REF_CLK_DIV2);
-	/*	(Switch to 2.5G mode: #5) */
-	serdes_xpcs_reg_write(base, xpcs, VR_MII_GEN5_12G_16G_MPLLB_CTRL0,
-			      MPLLB_MULTIPLIER(125U));
-	/*	(Switch to 2.5G mode: #6) */
-	serdes_xpcs_reg_write(base, xpcs, VR_MII_GEN5_12G_MPLLB_CTRL1, 0U);
-	/*	(Switch to 2.5G mode: #7) */
-	serdes_xpcs_reg_write(base, xpcs, VR_MII_GEN5_12G_16G_MPLLB_CTRL2,
-			      MPLLB_CTRL2_MPLLB_TX_CLK_DIV(5U)
-			      | MPLLB_CTRL2_MPLLB_DIV10_CLK_EN);
-	/*	(Switch to 2.5G mode: #8) */
-	serdes_xpcs_reg_write(base, xpcs, VR_MII_GEN5_12G_MPLLB_CTRL3, 68U);
-	/*	(Switch to 2.5G mode: #9) */
-	serdes_xpcs_reg_write(base, xpcs, VR_MII_GEN5_12G_16G_VCO_CAL_LD0,
-			      1350U);
-	/*	(Switch to 2.5G mode: #10) */
-	serdes_xpcs_reg_write(base, xpcs, VR_MII_GEN5_12G_VCO_CAL_REF0, 27U);
-	/*	(Switch to 2.5G mode: #11) */
-	serdes_xpcs_reg_write(base, xpcs, VR_MII_GEN5_12G_16G_TX_RATE_CTRL, 0U);
-	/*	(Switch to 2.5G mode: #12) */
-	serdes_xpcs_reg_write(base, xpcs, VR_MII_GEN5_12G_16G_RX_RATE_CTRL,
-			      0x1U); /* b01 */
-	/*	(Switch to 2.5G mode: #13) */
-	serdes_xpcs_reg_write(base, xpcs, VR_MII_GEN5_12G_16G_CDR_CTRL,
-			      CDR_CTRL_VCO_LOW_FREQ_0 | 0x1U);
-			      /* +CDR_TRACKING_ENABLE=1 */
-	/*	(Switch to 2.5G mode: #14) */
-	serdes_xpcs_reg_write(base, xpcs, VR_MII_GEN5_12G_16G_MPLLA_CTRL0,
-			      MPLLA_CAL_DISABLE | 0x50U);
-			      /* MPPLA_MULTIPLIER=default */
-	/*	(Switch to 2.5G mode: #15) */
-	serdes_xpcs_reg_read(base, xpcs, VR_MII_DIG_CTRL1, &reg16);
+	if ((init_flags & XPCS0_2500M) != 0) {
+		serdes_pma_configure_tx_ctr(base, 0U);
+		serdes_pcs_set_2500M_mode(base, 0);
+		serdes_pma_select_pllb_ref(base, 0);
+	} else if ((init_flags & XPCS0_1000M) != 0) {
+		serdes_pma_configure_tx_ctr(base, 0U);
+		serdes_pcs_set_1000M_mode(base, 0);
+		serdes_pma_select_plla_ref(base, 0);
+	}
 
-	/* Clear bypass flag in case of internal clocks */
-	if (clktype == CLK_INT) {
-		reg16 &= ~BYP_PWRUP;
-		serdes_xpcs_reg_write(base, xpcs, VR_MII_DIG_CTRL1, reg16);
+	if ((init_flags & XPCS1_2500M) != 0) {
+		serdes_pma_configure_tx_ctr(base, 1);
+		serdes_pcs_set_2500M_mode(base, 1);
+		serdes_pma_select_pllb_ref(base, 1);
+	} else if ((init_flags & XPCS1_1000M) != 0) {
+		serdes_pma_configure_tx_ctr(base, 1);
+		serdes_pcs_set_1000M_mode(base, 1);
+		serdes_pma_select_plla_ref(base, 1);
 	}
-	serdes_xpcs_reg_write(base, xpcs, VR_MII_DIG_CTRL1, reg16 | VR_RST);
-		/* Issue reset */
-
-	/*	(Switch to 2.5G mode: #16) */
-	if (serdes_xpcs_wait_for_reset(base, xpcs))
-		pr_err("XPCS pre power-up soft reset failed\n");
-
-	/*	Wait for XPCS power up */
-	pr_debug("Waiting for XPCS power-up\n");
-	if (serdes_xpcs_wait_for_power_good(base, xpcs)) {
-		pr_err("XPCS power-up failed\n");
-		return -EXIT_FAILURE;
+
+	/* Using external clock reference */
+	if (((init_flags & PHY_CTRL_XPCS_OWNED) != 0) &&
+	    (init_flags & PHY_CLK_INT) == 0)
+		PCSBSET(base, xpcs_phy_ctr, VR_MII_GEN5_12G_16G_REF_CLK_CTRL,
+			REF_USE_PAD);
+	else if ((init_flags & PHY_CTRL_XPCS_OWNED) != 0)
+		PCSBCLR(base, xpcs_phy_ctr, VR_MII_GEN5_12G_16G_REF_CLK_CTRL,
+			REF_USE_PAD);
+
+	/* Start PLLA cal */
+	if (((init_flags & PHY_CTRL_XPCS_OWNED) != 0) &&
+	    (init_flags & PLLA_CAL_EN) != 0) {
+		/* Configure PLLA and start calibration */
+		serdes_pma_mplla_start_cal(base, xpcs_phy_ctr, fmhz);
 	}
 
-	return 0;
+	/* Start PLLB cal */
+	if (((init_flags & PHY_CTRL_XPCS_OWNED) != 0) &&
+	    (init_flags & PLLB_CAL_EN) != 0) {
+		serdes_pma_mpllb_start_cal(base, xpcs_phy_ctr, fmhz);
+	}
+
+	/* Disable PLLA, if requested */
+	if (((init_flags & PHY_CTRL_XPCS_OWNED) != 0) &&
+	    (init_flags & PLLA_CAL_DIS) != 0) {
+		serdes_pma_mplla_stop_cal(base, xpcs_phy_ctr);
+	}
+
+	/* Disable PLLB, if requested */
+	if (((init_flags & PHY_CTRL_XPCS_OWNED) != 0) &&
+	    (init_flags & PLLB_CAL_DIS) != 0) {
+		serdes_pma_mpllb_stop_cal(base, xpcs_phy_ctr);
+	}
+
+	if ((init_flags & XPCS0_2500M) != 0)
+		serdes_pma_3125Mhz_prepare(base, 0, fmhz);
+	else if ((init_flags & XPCS0_1000M) != 0)
+		serdes_pma_1250Mhz_prepare(base, 0, fmhz);
+
+	if ((init_flags & XPCS1_2500M) != 0)
+		serdes_pma_3125Mhz_prepare(base, 1, fmhz);
+	else if ((init_flags & XPCS1_1000M) != 0)
+		serdes_pma_1250Mhz_prepare(base, 1, fmhz);
+
+	if ((init_flags & XPCS0_DIS) != 0)
+		serdes_pma_lane_disable(base, 0);
+
+	if ((init_flags & XPCS1_DIS) != 0)
+		serdes_pma_lane_disable(base, 1);
+
+	/* Clear bypass flag in case of internal clocks */
+	if (((init_flags & PHY_CLK_INT) != 0U) &&
+	    ((init_flags & (XPCS0_OWNED)) != 0U) &&
+	    ((init_flags & XPCS0_DIS) == 0U)) {
+		PCSBCLR(base, 0U, VR_MII_DIG_CTRL1, BYP_PWRUP);
+	}
+
+	if (((init_flags & PHY_CLK_INT) != 0U) &&
+	    ((init_flags & (XPCS1_OWNED)) != 0U) &&
+	    ((init_flags & XPCS1_DIS) == 0U)) {
+		PCSBCLR(base, 1U, VR_MII_DIG_CTRL1, BYP_PWRUP);
+	}
 }
diff --git a/arch/arm/cpu/armv8/s32/s32-gen1/sgmii/sgmii.c b/arch/arm/cpu/armv8/s32/s32-gen1/sgmii/sgmii.c
index f5b8f1190d..f3d0ab894d 100644
--- a/arch/arm/cpu/armv8/s32/s32-gen1/sgmii/sgmii.c
+++ b/arch/arm/cpu/armv8/s32/s32-gen1/sgmii/sgmii.c
@@ -25,9 +25,9 @@
 #define S32G_SERDES_1_BASE			0x44100000U
 #define S32G_SERDES_BASE_LEN			0x100000
 #define S32G_SERDES_COUNT			2
+#define S32G_SERDES_XPCS_COUNT			2
 
 /*
- * Auto-negotiation is currently not supported.
  *
  * Only limited number of configurations were tested (Only on SerDes1).
  * You should take care and check, if everything works in your configuration.
@@ -50,138 +50,42 @@
  */
 
 struct s32_xpcs_cfg {
+	void __iomem *base;
 	enum serdes_xpcs_mode xpcs_mode;
+	enum serdes_xpcs_mode_gen2 mode[2];
+	enum serdes_mode ss_mode;
+	enum serdes_clock clktype;
+	enum serdes_clock_fmhz fmhz;
 	bool is_init;
 };
 
-static struct s32_xpcs_cfg xpcs_cfg[S32G_SERDES_COUNT] = { {.is_init = false},
+static struct s32_xpcs_cfg serdes_cfg[S32G_SERDES_COUNT] = { {.is_init = false},
 							   {.is_init = false} };
 
-static inline void *s32_get_serdes_base(int id)
+static struct s32_xpcs_cfg *s32_get_serdes_priv(int platform_serdes_id)
 {
-	if (id == 0)
-		return (void *)(phys_addr_t)S32G_SERDES_0_BASE;
-	else if (id == 1)
-		return (void *)(phys_addr_t)S32G_SERDES_1_BASE;
+	if (platform_serdes_id < S32G_SERDES_COUNT)
+		return &serdes_cfg[platform_serdes_id];
 	else
 		return NULL;
 }
 
-static inline u32 s32_get_xpcs_base(int id)
+int s32_sgmii_wait_link(int serdes_id, int xpcs)
 {
-	if (id == 0)
-		return SERDES_XPCS_0_BASE;
-	else if (id == 1)
-		return SERDES_XPCS_1_BASE;
-	else
-		return 0;
-}
-
-int s32_sgmii_wait_link(int serdes, int xpcs)
-{
-	void *serdes_base;
-	u32 xpcs_base;
+	struct s32_xpcs_cfg *serdes = s32_get_serdes_priv(serdes_id);
 	int ret;
 
-	serdes_base = s32_get_serdes_base(serdes);
-	if (!serdes_base)
+	if (!serdes || xpcs >= S32G_SERDES_XPCS_COUNT)
 		return -EINVAL;
 
-	xpcs_base = s32_get_xpcs_base(xpcs);
-	if (!xpcs_base)
-		return -EINVAL;
 
-	debug("Waiting for link (SerDes%d XPCS%i)...\n", serdes, xpcs);
-	ret = serdes_wait_for_link(serdes_base, xpcs_base, 1U);
+	debug("Waiting for link (SerDes%d XPCS%i)...\n", serdes_id, xpcs);
+	ret = serdes_pma_wait_link(serdes->base, xpcs, 1U);
 
 	if (ret)
-		printf("SerDes%d XPCS%i link timed-out\n", serdes, xpcs);
+		printf("SerDes%d XPCS%i link timed-out\n", serdes_id, xpcs);
 	else
-		debug("SerDes%d XPCS%i link is up\n", serdes, xpcs);
-
-	return ret;
-}
-
-#ifdef SGMII_VERIFY_LINK_ON_STARTUP
-static int s32_serdes_verify_link(int serdes, int xpcs)
-{
-	void *serdes_base;
-	u32 xpcs_base;
-	int ret = 0;
-
-	serdes_base = s32_get_serdes_base(serdes);
-	if (!serdes_base)
-		return -EINVAL;
-
-	xpcs_base = s32_get_xpcs_base(xpcs);
-	if (!xpcs_base)
-		return -EINVAL;
-
-	if (serdes_xpcs_set_loopback(serdes_base, xpcs_base, true)) {
-		ret = -EINVAL;
-		goto link_error;
-	}
-
-	if (s32_sgmii_wait_link(serdes, xpcs))
-		ret = -ETIMEDOUT;
-
-link_error:
-	serdes_xpcs_set_loopback(serdes_base, xpcs, false);
-	return ret;
-}
-#endif /* SGMII_VERIFY_LINK_ON_STARTUP */
-
-/* WARNING: This function is only experimental and it is not tested*/
-/* Get SGMII speed/duplex/auto-neg */
-int s32_sgmii_get_speed(int serdes, int xpcs, int *mbps, bool *fd, bool *an)
-{
-	void *serdes_base;
-	u32 xpcs_base;
-	int ret;
-
-	serdes_base = s32_get_serdes_base(serdes);
-	if (!serdes_base)
-		return -EINVAL;
-
-	xpcs_base = s32_get_xpcs_base(xpcs);
-	if (!xpcs_base)
-		return -EINVAL;
-
-	ret = serdes_xpcs_get_sgmii_speed(serdes_base, xpcs_base,
-					  mbps, fd, an);
-	debug("SerDes%d XPCS%d is configured to %dMbs (AN %s, %s)",
-	      serdes, xpcs, *mbps,
-	      an ? "ON" : "OFF",
-	      fd ? "FD" : "HD");
-
-	return ret;
-}
-
-/* WARNING: This function is only experimental and it is not tested*/
-/* Set SGMII speed/duplex/auto-neg */
-int s32_sgmii_set_speed(int serdes, int xpcs, int mbps, bool fd, bool an)
-{
-	void *serdes_base;
-	u32 xpcs_base;
-	int ret;
-
-	/* SGMII auto-negotiation is currently not supported  */
-	(void)an;
-
-	serdes_base = s32_get_serdes_base(serdes);
-	if (!serdes_base)
-		return -EINVAL;
-
-	xpcs_base = s32_get_xpcs_base(xpcs);
-	if (!xpcs_base)
-		return -EINVAL;
-
-	ret = serdes_xpcs_set_sgmii_speed(serdes_base, xpcs_base,
-					  mbps, fd);
-	debug("SerDes%d XPCS%d config was updated to %dMbs (AN %s, %s)",
-	      serdes, xpcs, mbps,
-	      an ? "ON" : "OFF",
-	      fd ? "FD" : "HD");
+		debug("SerDes%d XPCS%i link is up\n", serdes_id, xpcs);
 
 	return ret;
 }
@@ -206,152 +110,323 @@ static void s32_serdes_no_pcie_init(void)
 }
 #endif
 
-enum serdes_xpcs_mode s32_get_xpcs_mode(int serdes)
+enum serdes_xpcs_mode_gen2 s32_get_xpcs_mode(int serd, int xpcs)
 {
-	if (serdes > S32G_SERDES_COUNT) {
-		printf("Invalid SerDes ID %d\n", serdes);
-		return SGMII_INAVALID;
-	}
+	struct s32_xpcs_cfg *serdes = s32_get_serdes_priv(serd);
+
+	if (!serdes || xpcs >= S32G_SERDES_XPCS_COUNT)
+		return SGMII_XPCS_PCIE;
 
 /* In case PCIe is disabled probe serdes drivers */
 #if	!CONFIG_IS_ENABLED(PCI) && CONFIG_IS_ENABLED(SERDES_S32GEN1)
-	if (!xpcs_cfg[serdes].is_init)
+	if (!serdes->is_init)
 		s32_serdes_no_pcie_init();
 #elif !CONFIG_IS_ENABLED(SERDES_S32GEN1)
 	printf("SGMII is not supported in this configuration");
 #endif
 
-	if (!xpcs_cfg[serdes].is_init ||
-	    xpcs_cfg[serdes].xpcs_mode == SGMII_INAVALID) {
-		printf("SerDes %d was not initialized\n", serdes);
-		return SGMII_INAVALID;
+	if (!serdes->is_init || serdes->xpcs_mode == SGMII_INAVALID) {
+		printf("SerDes %d was not initialized\n", serd);
+		return SGMII_XPCS_PCIE;
+	}
+
+	return serdes->mode[xpcs];
+}
+
+static void s32_serdes_issue_reset(struct s32_xpcs_cfg *serdes)
+{
+	switch (serdes->ss_mode) {
+	case SERDES_MODE_PCIE_SGMII0:
+		serdes_pcs_issue_vreset(serdes->base, 0);
+		break;
+	case SERDES_MODE_PCIE_SGMII1:
+		serdes_pcs_issue_vreset(serdes->base, 1);
+		break;
+	case SERDES_MODE_SGMII_SGMII:
+		serdes_pcs_issue_vreset(serdes->base, 1);
+		serdes_pcs_issue_vreset(serdes->base, 0);
+		break;
+	case SERDES_MODE_SGMII_SGMII_ALT:
+		serdes_pcs_issue_vreset(serdes->base, 0);
+		serdes_pcs_issue_vreset(serdes->base, 1);
+		break;
+	default:
+		break;
+	}
+}
+
+static void s32_serdes_init_flags(struct s32_xpcs_cfg *serdes,
+				  enum serdes_xpcs_mode_gen2 xpcs_mode,
+				  u32 *init_flags, u32 f1g, u32 f25g, u32 fdis)
+{
+	if (xpcs_mode == SGMII_XPCS_2G5_OP)
+		*init_flags |= PLLA_CAL_EN | PLLB_CAL_EN | f25g;
+
+	if (xpcs_mode == SGMII_XPCS_1G_OP)
+		*init_flags |= PLLA_CAL_EN | f1g;
+
+	if (xpcs_mode == SGMII_XPCS_1G_OP)
+		*init_flags |= PLLA_CAL_EN | f1g;
+
+	if (xpcs_mode == SGMII_XPCS_DISABLED)
+		*init_flags |= fdis;
+
+	switch (serdes->ss_mode) {
+	case SERDES_MODE_SGMII_SGMII:
+		*init_flags |= PHY_CTRL_XPCS0_OWNED;
+		break;
+	case SERDES_MODE_SGMII_SGMII_ALT:
+		*init_flags |= PHY_CTRL_XPCS1_OWNED;
+		break;
+	default:
+		break;
 	}
-	return xpcs_cfg[serdes].xpcs_mode;
 }
 
-int s32_eth_xpcs_init(void __iomem *serdes_base, int id,
-		      bool combo,
+static void s32_serdes_post_init(struct s32_xpcs_cfg *serdes, u32 xpcs)
+{
+	if (serdes_pcs_wait_for_vreset(serdes->base, xpcs))
+		pr_err("XPCS%d pre power-up soft reset failed\n", xpcs);
+
+	if (serdes_pcs_wait_for_power_good(serdes->base, xpcs))
+		pr_err("XPCS%d power-up failed\n", xpcs);
+
+	serdes_pma_issue_rx_reset(serdes->base, xpcs);
+
+	/* Disable automatic MII width change */
+	serdes_pcs_mii_bus_control_disable(serdes->base, xpcs);
+	/* Disable AN */
+	serdes_pcs_an_disable(serdes->base, xpcs);
+	/* Full duplex */
+	serdes_pcs_set_fd(serdes->base, xpcs);
+	/* Speed select */
+	serdes_pcs_speed_select(serdes->base, xpcs, 1);
+}
+
+int s32_eth_xpcs_init(void __iomem *serdes_base, int platform_serdes_id,
+		      enum serdes_mode ss_mode,
 		      enum serdes_xpcs_mode xpcs_mode,
 		      enum serdes_clock clktype,
 		      enum serdes_clock_fmhz fmhz)
 {
-	int retval = 0;
-	u32 xpcs0_base;
-	u32 xpcs1_base;
-	bool xpcs0 = false;
-	bool xpcs1 = false;
-
-	xpcs0_base = s32_get_xpcs_base(0);
-	if (!xpcs0_base)
-		return -EINVAL;
+#ifdef SGMII_MIN_SOC_REV_SUPPORTED
+	u32 raw_rev = 0;
 
-	xpcs1_base = s32_get_xpcs_base(1);
-	if (!xpcs1_base)
-		return -EINVAL;
-
-	if (id > S32G_SERDES_COUNT) {
-		printf("Invalid XPCS ID %d\n", id);
-		return false;
+	/* construct a revision number based on major, minor and subminor,
+	 * each part using one hex digit
+	 */
+	raw_rev = (get_siul2_midr1_major() << 8) |
+		  (get_siul2_midr1_minor() << 4) |
+		  (get_siul2_midr2_subminor());
+
+	if (raw_rev < SGMII_MIN_SOC_REV_SUPPORTED) {
+		printf("SGMII not supported on rev.");
+		printf("%d.%d.%d\n", get_siul2_midr1_major() + 1,
+		       get_siul2_midr1_minor(),
+		       get_siul2_midr2_subminor());
+		return -ENXIO;
 	}
+#endif /* SGMII_MIN_SOC_REV_SUPPORTED */
 
-	xpcs_cfg[id].xpcs_mode = SGMII_INAVALID;
+	struct s32_xpcs_cfg *serdes = s32_get_serdes_priv(platform_serdes_id);
+	int ret = 0;
+	u32 init_flags = 0;
+	bool shared = false;
 
-	/* Decode XPCS */
-	if (xpcs_mode == SGMII_XPCS0 || xpcs_mode == SGMII_XPCS0_2G5) {
-		xpcs0 = true;
-		xpcs1 = false;
-	} else if (xpcs_mode == SGMII_XPCS1) {
-#if CONFIG_TARGET_S32R45EVB
-		printf("Configuration not supported");
-		printf(" on this platform for SerDes %d\n", id);
-		return -EINVAL;
-#endif
-		xpcs0 = false;
-		xpcs1 = true;
-	} else if (xpcs_mode == SGMII_XPCS0_XPCS1) {
-#if CONFIG_TARGET_S32R45EVB
-		printf("Configuration not supported");
-		printf(" on this platform for SerDes %d\n", id);
-		return -EINVAL;
-#endif
-		xpcs0 = true;
-		xpcs1 = true;
-	} else {
-		printf("Invalid XPCS mode on SerDes %d\n", id);
+	if (!serdes) {
+		printf("Invalid Serdes ID %d\n", platform_serdes_id);
 		return -EINVAL;
 	}
 
-	if (xpcs1) {
-		debug("SerDes %d XPCS_1 init to 1G mode started\n", id);
-		retval = serdes_xpcs_set_1000_mode(serdes_base,
-						   xpcs1_base,
-						   clktype, fmhz, combo);
-		if (retval) {
-			printf("SerDes %d XPCS_1 init failed\n", id);
-			return retval;
-		}
-		debug("SerDes %d XPCS_1 init to 1G mode successful\n", id);
+	serdes->base = serdes_base;
+	serdes->xpcs_mode = SGMII_INAVALID;
+	serdes->clktype = clktype;
+	serdes->ss_mode = ss_mode;
+	serdes->fmhz = fmhz;
+
+	if (serdes->ss_mode == SERDES_MODE_PCIE_SGMII0 ||
+	    serdes->ss_mode == SERDES_MODE_PCIE_SGMII1)
+		shared = true;
+
+	/* Note: this is temporary until upper layers are reworked */
+	switch (xpcs_mode) {
+	case SGMII_XPCS0_2G5:
+		serdes->mode[0] = SGMII_XPCS_2G5_OP;
+		serdes->mode[1] = SGMII_XPCS_1G_OP;
+		break;
+	case SGMII_XPCS0_XPCS1:
+		serdes->mode[0] = SGMII_XPCS_1G_OP;
+		serdes->mode[1] = SGMII_XPCS_1G_OP;
+		break;
+	case SGMII_XPCS0:
+		serdes->mode[0] = SGMII_XPCS_1G_OP;
+		if (shared)
+			serdes->mode[1] = SGMII_XPCS_PCIE;
+		else
+			serdes->mode[1] = SGMII_XPCS_DISABLED;
+		break;
+	case SGMII_XPCS1:
+		serdes->mode[1] = SGMII_XPCS_1G_OP;
+		if (shared)
+			serdes->mode[0] = SGMII_XPCS_PCIE;
+		else
+			serdes->mode[0] = SGMII_XPCS_DISABLED;
+		break;
+	default:
+		serdes->mode[0] = SGMII_XPCS_PCIE;
+		serdes->mode[1] = SGMII_XPCS_PCIE;
 	}
 
-	if (xpcs0) {
-		debug("SerDes %d XPCS_0 init to 1G mode started\n", id);
-		retval = serdes_xpcs_set_1000_mode(serdes_base,
-						   xpcs0_base,
-						   clktype, fmhz, combo);
-		if (retval) {
-			printf("SerDes %d XPCS_0 init failed\n", id);
-			return retval;
+	if (serdes->mode[0] != SGMII_XPCS_PCIE) {
+		/* Bypass power up in case of pcie combo or internal clock*/
+		if (serdes->clktype != CLK_INT && shared != true) {
+			ret = serdes_pcs_wait_for_power_good(serdes->base, 0);
+			if (!ret)
+				pr_info("XPCS0 power-up good success\n");
+			else
+				pr_err("XPCS0 power-up good failed\n");
 		}
-		debug("SerDes %d XPCS_0 init to 1G mode successful\n", id);
-	}
-
-	if (xpcs0) {
-		/*	Configure XPCS_0 speed (1000Mpbs, Full duplex) */
-		retval = serdes_xpcs_set_sgmii_speed(serdes_base,
-						     xpcs0_base,
-						     SPEED_1000, true);
-		if (retval)
-			return retval;
-	}
 
-	if (xpcs1) {
-		/*	Configure XPCS_1 speed (1000Mpbs, Full duplex) */
-		retval = serdes_xpcs_set_sgmii_speed(serdes_base,
-						     xpcs1_base,
-						     SPEED_1000, true);
-		if (retval)
-			return retval;
+		s32_serdes_init_flags(serdes, serdes->mode[0], &init_flags,
+				      XPCS0_1000M, XPCS0_2500M, XPCS0_DIS);
 	}
 
-	if (xpcs_mode == SGMII_XPCS0_2G5) {
-		retval = serdes_xpcs_set_2500_mode(serdes_base,
-						   xpcs0_base,
-						   clktype, fmhz);
-		if (retval) {
-			printf("XPCS_0 init failed\n");
-			return retval;
+	if (serdes->mode[1] != SGMII_XPCS_PCIE) {
+		/* Bypass power up in case of pcie combo or internal clock*/
+		if (serdes->clktype != CLK_INT && shared != true) {
+			ret = serdes_pcs_wait_for_power_good(serdes->base, 1);
+			if (!ret)
+				pr_info("XPCS1 power-up good success\n");
+			else
+				pr_err("XPCS1 power-up good failed\n");
 		}
-		debug("XPCS_0 in 2.5G mode\n");
+
+		s32_serdes_init_flags(serdes, serdes->mode[1], &init_flags,
+				      XPCS1_1000M, XPCS1_2500M, XPCS1_DIS);
 	}
 
+	/* Check, if we should init something */
+	if (!init_flags)
+		return 0;
+
+	if (serdes->clktype == CLK_INT)
+		init_flags |= PHY_CLK_INT;
+
+	serdes_pcs_pma_init_gen2(serdes->base, fmhz,  init_flags);
+
+	/* Issue ss mode dependent reset */
+	s32_serdes_issue_reset(serdes);
+
+	/* Wait reset + Post init */
+	if (((init_flags & (XPCS0_OWNED)) != 0))
+		s32_serdes_post_init(serdes, 0);
+
+	if (((init_flags & (XPCS1_OWNED)) != 0))
+		s32_serdes_post_init(serdes, 1);
+
 	debug("SerDes Init Done.\n");
 
-	xpcs_cfg[id].xpcs_mode = xpcs_mode;
-	xpcs_cfg[id].is_init = true;
-
-#ifdef SGMII_VERIFY_LINK_ON_STARTUP
-	/* disabled by default */
-	if (xpcs0)
-		if (s32_serdes_verify_link(id, 0))
-			printf("SerDes%d XPCS_%d link up failed\n", id, 0);
-	if (xpcs1)
-		if (s32_serdes_verify_link(id, 1))
-			printf("SerDes%d XPCS_%d link up failed\n", id, 1);
-#endif
+	serdes->xpcs_mode = xpcs_mode;
+	serdes->is_init = true;
 
 	return 0;
 }
 
+enum xpcs_cmd {
+	S32_XPCS_INVALID,
+	S32_XPCS_TRANSIT_TO_1000M,
+	S32_XPCS_TRANSIT_TO_2500M,
+	S32_XPCS_AN_AUTO_SW_ENABLE,
+	S32_XPCS_AN_ENABLE,
+	S32_XPCS_AN_DISABLE
+};
+
+static int do_xpcs_cmd(cmd_tbl_t *cmdtp, int flag,
+		       int argc, char * const argv[])
+{
+	struct s32_xpcs_cfg *serdes;
+	u8 serdes_id, pcs_id;
+	enum xpcs_cmd cmd = S32_XPCS_INVALID;
+	u8 cmd_ss = 0;
+
+	if (argc < 5)
+		return CMD_RET_USAGE;
+
+	serdes_id = simple_strtoul(argv[1], NULL, 10);
+	pcs_id = simple_strtoul(argv[2], NULL, 10);
+	serdes = s32_get_serdes_priv(serdes_id);
+
+	if (!serdes || !serdes->is_init ||
+	    pcs_id >= S32G_SERDES_XPCS_COUNT)
+		return CMD_RET_USAGE;
+
+	if (!strcmp(argv[3], "transit")) {
+		if (!strcmp(argv[4], "1000M"))
+			cmd = S32_XPCS_TRANSIT_TO_1000M;
+		else if (!strcmp(argv[4], "2500M"))
+			cmd = S32_XPCS_TRANSIT_TO_2500M;
+	} else if (!strcmp(argv[3], "ss")) {
+		if (!strcmp(argv[4], "10M")) {
+			cmd = S32_XPCS_TRANSIT_TO_1000M;
+			cmd_ss = 100;
+		} else if (!strcmp(argv[4], "100M")) {
+			cmd = S32_XPCS_TRANSIT_TO_1000M;
+			cmd_ss = 10;
+		} else if (!strcmp(argv[4], "1000M")) {
+			cmd_ss = 1;
+			cmd = S32_XPCS_TRANSIT_TO_1000M;
+		} else if (!strcmp(argv[4], "2500M")) {
+			cmd = S32_XPCS_TRANSIT_TO_2500M;
+		}
+	} else if (!strcmp(argv[3], "an") || !strcmp(argv[3], "an_auto")) {
+		if (!strcmp(argv[4], "enable") && !strcmp(argv[3], "an_auto"))
+			cmd = S32_XPCS_AN_AUTO_SW_ENABLE;
+		else if (!strcmp(argv[4], "enable"))
+			cmd = S32_XPCS_AN_ENABLE;
+		else if (!strcmp(argv[4], "disable"))
+			cmd = S32_XPCS_AN_DISABLE;
+	} else {
+		return CMD_RET_USAGE;
+	}
+
+	switch (cmd) {
+	case S32_XPCS_TRANSIT_TO_1000M:
+		serdes_bifurcation_pll_transit_to_1250Mhz(serdes->base,
+							  pcs_id, serdes->fmhz);
+		if (cmd_ss != 0)
+			serdes_pcs_speed_select(serdes->base, pcs_id, cmd_ss);
+		break;
+	case S32_XPCS_TRANSIT_TO_2500M:
+		serdes_bifurcation_pll_transit_to_3125Mhz(serdes->base,
+							  pcs_id, serdes->fmhz);
+		serdes_pcs_speed_select(serdes->base, pcs_id, 1);
+		break;
+	case S32_XPCS_AN_AUTO_SW_ENABLE:
+		serdes_pcs_an_auto_sw_enable(serdes->base, pcs_id);
+		/*fall through*/
+	case S32_XPCS_AN_ENABLE:
+		serdes_pcs_an_set_link_timer(serdes->base, pcs_id, 0x2faf);
+		serdes_pcs_an_enable(serdes->base, pcs_id);
+		break;
+	case S32_XPCS_AN_DISABLE:
+		serdes_pcs_an_auto_sw_disable(serdes->base, pcs_id);
+		serdes_pcs_an_disable(serdes->base, pcs_id);
+		break;
+	default:
+		return CMD_RET_USAGE;
+	}
+
+	return 0;
+}
+
+U_BOOT_CMD(xpcs, 6, 0, do_xpcs_cmd,
+	   "Utility command for SGMMI control",
+	   "xpcs <serdes> <xpcs> transit <1000M|2500M> - change serdes mode\n"
+	   "xpcs <serdes> <xpcs> ss <10M|100M|1000M|2500M> - change speed and serdes mode when required\n"
+	   "xpcs <serdes> <xpcs> an <enable|disable> - auto-negotiation control\n"
+	   "xpcs <serdes> <xpcs> an_auto <enable|disable> - auto-negotiation control with automatic speed change"
+);
+
 /* Provide UCLASS DRV so SerDes driver can bind to it*/
 #if	!CONFIG_IS_ENABLED(PCI) && CONFIG_IS_ENABLED(SERDES_S32GEN1)
 UCLASS_DRIVER(pci_uc_gen) = {
diff --git a/arch/arm/include/asm/arch-s32/s32-gen1/serdes_hwconfig.h b/arch/arm/include/asm/arch-s32/s32-gen1/serdes_hwconfig.h
index 7705154a84..20e9a6e570 100644
--- a/arch/arm/include/asm/arch-s32/s32-gen1/serdes_hwconfig.h
+++ b/arch/arm/include/asm/arch-s32/s32-gen1/serdes_hwconfig.h
@@ -37,6 +37,15 @@ enum serdes_dev_type {
 	 */
 };
 
+/* New enum */
+enum serdes_xpcs_mode_gen2 {
+	SGMII_XPCS_PCIE = 0,
+	SGMII_XPCS_DISABLED,
+	SGMII_XPCS_1G_OP,
+	SGMII_XPCS_2G5_OP,
+};
+
+/* Old enum TODO remove*/
 enum serdes_xpcs_mode {
 	SGMII_INAVALID = 0,
 	SGMII_XPCS0,		/* Combo mode PCIex1/SGMII(XPCS0) */
@@ -98,7 +107,9 @@ enum serdes_mode {
 	SERDES_MODE_PCIE_SGMII1 = 2,
 	/*	Lane0=SGMII(1G/2.5G), Lane1=SGMII(1G/2.5G) */
 	SERDES_MODE_SGMII_SGMII = 3,
-	SERDES_MODE_MAX = SERDES_MODE_SGMII_SGMII
+	/*	Lane0=SGMII(1G/2.5G), Lane1=SGMII(1G/2.5G) */
+	SERDES_MODE_SGMII_SGMII_ALT = 4,
+	SERDES_MODE_MAX = SERDES_MODE_SGMII_SGMII_ALT
 };
 
 enum serdes_dev_type s32_serdes_get_mode_from_hwconfig(int id);
diff --git a/arch/arm/include/asm/arch-s32/s32-gen1/serdes_regs.h b/arch/arm/include/asm/arch-s32/s32-gen1/serdes_regs.h
index ebb9339383..019b0af270 100644
--- a/arch/arm/include/asm/arch-s32/s32-gen1/serdes_regs.h
+++ b/arch/arm/include/asm/arch-s32/s32-gen1/serdes_regs.h
@@ -155,9 +155,9 @@
 
 #define MPLLB_CTRL2_MPLLB_DIV_MULT(n)		(((n) & 0xffU) << 0)
 #define MPLLB_CTRL2_MPLLB_DIV8_CLK_EN		(1U << 8)
-#define MPLLB_CTRL2_MPLLB_DIV10_CLK_EN		(1U << 9)
+#define MPLLB_DIV10_CLK_EN			BIT(9)
 #define MPLLB_CTRL2_MPLLB_DIV_CLK_EN		(1U << 10)
-#define MPLLB_CTRL2_MPLLB_TX_CLK_DIV(n)		(((n) & 0x7U) << 11)
+#define MPLLB_TX_CLK_DIV(n)		(((n) & 0x7U) << 11)
 
 #define MPLL_STATE_BIT         (30)
 #define MPLL_STATE             BIT(MPLL_STATE_BIT)
diff --git a/arch/arm/include/asm/arch-s32/s32-gen1/serdes_xpcs_regs.h b/arch/arm/include/asm/arch-s32/s32-gen1/serdes_xpcs_regs.h
index b729f46c46..1cc758e3f3 100644
--- a/arch/arm/include/asm/arch-s32/s32-gen1/serdes_xpcs_regs.h
+++ b/arch/arm/include/asm/arch-s32/s32-gen1/serdes_xpcs_regs.h
@@ -1,6 +1,6 @@
 /* SPDX-License-Identifier: GPL-2.0 */
 /*
- * Copyright 2019-2020 NXP
+ * Copyright 2019-2021 NXP
  *
  * The SerDes module header file.
  */
@@ -31,6 +31,14 @@
 #define VR_MII_DBG_CTRL				0x1f8005U
 #define VR_MII_LINK_TIMER_CTRL			0x1f800aU
 #define VR_MII_DIG_STS				0x1f8010U
+#define VR_MII_GEN5_12G_16G_TX_POWER_STATE_CTRL 0x1f8035U
+#define VR_MII_GEN5_12G_16G_RX_POWER_STATE_CTRL 0x1F8055U
+#define VR_MII_GEN5_12G_16G_TX_EQ_CTRL0		0x1F8036U
+#define VR_MII_CONSUMER_10G_TX_TERM_CTRL	0x1F803CU
+#define VR_MII_GEN5_12G_16G_RX_GENCTRL1		0x1F8051U
+#define VR_MII_GEN5_12G_16G_TX_GENCTRL1		0x1F8031U
+#define VR_MII_GEN5_12G_16G_TX_GENCTRL2		0x1F8032U
+#define VR_MII_GEN5_12G_16G_RX_GENCTRL2		0x1F8052U
 #define VR_MII_GEN5_12G_16G_MPLL_CMN_CTRL	0x1f8070U
 #define VR_MII_GEN5_12G_16G_MPLLA_CTRL0		0x1f8071U
 #define VR_MII_GEN5_12G_MPLLA_CTRL1		0x1f8072U
@@ -51,74 +59,146 @@
 #define SR_MII_DEV_ID1				0x1f0002U
 #define SR_MII_DEV_ID2				0x1f0003U
 
+/* VR_MII_Gen5_12G_16G_RX_GENCTRL1 */
+#define RX_RST_0				BIT(4U)
+
+/* VR_MII_Gen5_12G_16G_TX_GENCTRL1 */
+#define TX_CLK_RDY_0				BIT(12)
+
+/* VR_MII_Gen5_12G_16G_TX_GENCTRL2 */
+#define TX_REQ_0				BIT(0)
+
+/* VR_MII_Gen5_12G_16G_RX_GENCTRL2 */
+#define RX_REQ_0				BIT(0)
+
+/* VR_MII_Gen5_12G_16G_RX_POWER_STATE_CTRL */
+#define RX_DISABLE_0				BIT(8)
+
+/* VR_MII_Gen5_12G_16G_TX_POWER_STATE_CTRL */
+#define TX_DISABLE_0				BIT(8)
+
+/* VR_MII_Gen5_12G_16G_RX_CDR_CTRL */
+#define VCO_LOW_FREQ_0				BIT(8)
+
 #define PCS_MODE_1000_BASE_X			0U
-#define PCS_MODE_SGMII				1U
-#define PCS_MODE_QSGMII				2U
-#define PCS_MODE_XPCS				3U
+#define PCS_MODE_SGMII				2U
 #define MII_AN_CTRL_PCS_MODE(x)			(((x) & 0x3U) << 1)
-#define MII_AN_CTRL_MII_CTRL			(1U << 8)
-#define MII_AN_CTRL_TX_CONFIG			(1U << 3)
-#define MII_AN_INTR_STS_CL37_ANCMPLT_INTR	(1U << 0)
+#define MII_AN_CTRL_MII_CTRL			BIT(8)
+#define MII_AN_CTRL_TX_CONFIG			BIT(3)
+#define MII_AN_INTR_STS_CL37_ANCMPLT_INTR	BIT(0)
 
-#define MII_CTRL_SS6				(1U << 6)
-#define MII_CTRL_DUPLEX_MODE			(1U << 8)
-#define MII_CTRL_RESTART_AN			(1U << 9)
-#define MII_CTRL_AN_ENABLE			(1U << 12)
-#define MII_CTRL_SS13				(1U << 13)
+/* SR_MII_CTRL */
+#define LBE					BIT(14)
+#define MII_CTRL_SS6				BIT(6)
+#define MII_CTRL_DUPLEX_MODE			BIT(8)
+#define MII_CTRL_RESTART_AN			BIT(9)
+#define MII_CTRL_AN_ENABLE			BIT(12)
+#define MII_CTRL_SS13				BIT(13)
 
-#define MII_STS_LINK_STS			(1U << 2)
+#define MII_STS_LINK_STS			BIT(2)
 
-#define MPLL_CMN_CTRL_MPLL_EN_0			(1U << 0)
-#define MPLL_CMN_CTRL_MPLLB_SEL_0		(1U << 4)
+#define MPLL_EN_0				BIT(0)
+#define MPLLB_SEL_0				BIT(4)
 
 #define MPLLA_MULTIPLIER_VALUE(x)		(((x) & 0xffU) << 0)
 
-#define MII_DBG_CTRL_SUPPRESS_LOS_DET		(1U << 4)
-#define MII_DBG_CTRL_RX_DT_EN_CTL		(1U << 6)
+#define MII_DBG_CTRL_SUPPRESS_LOS_DET		BIT(4)
+#define MII_DBG_CTRL_RX_DT_EN_CTL		BIT(6)
 
 /* Field definitions for VR MII MMD Digital Control1 Register */
 
 #define BYP_PWRUP				BIT(1)
-#define EN_2_5G_MODE				(1U << 2)
-#define MAC_AUTO_SW				(1U << 9)
-#define CS_EN					(1U << 10)
-#define PWRSV					(1U << 11)
-#define EN_VSMMD1				(1U << 13)
-#define R2TLBE					(1U << 14)
-#define VR_RST					(1U << 15)
+#define EN_2_5G_MODE				BIT(2)
+#define CL37_TMR_OVR_RIDE			BIT(3)
+#define INIT					BIT(8)
+#define MAC_AUTO_SW				BIT(9)
+#define CS_EN					BIT(10)
+#define PWRSV					BIT(11)
+#define EN_VSMMD1				BIT(13)
+#define R2TLBE					BIT(14)
+#define VR_RST					BIT(15)
 
 /* Field definitions for VR_MII_Gen5_12G_16G_REF_CLK_CTRL Register */
-
-#define REF_CLK_CTRL_REF_CLK_EN			(1U << 0)
-#define REF_CLK_CTRL_REF_USE_PAD		(1U << 1)
-#define REF_CLK_CTRL_REF_CLK_DIV2		(1U << 2)
-#define REF_CLK_CTRL_REF_RANGE(x)		(((x) & 0x7U) << 3)
-#define REF_CLK_CTRL_REF_MPLLA_DIV2		(1U << 6)
-#define REF_CLK_CTRL_REF_MPLLB_DIV2		(1U << 7)
-#define REF_CLK_CTRL_REF_RPT_CLK_EN		(1U << 8)
-
-#define CDR_CTRL_VCO_LOW_FREQ_0			(1U << 8)
-
-
-int serdes_xpcs_wait_for_power_good(void *base, uint32_t xpcs);
-int serdes_xpcs_set_sgmii_speed(void *base, uint32_t xpcs,
-				u32 mbps, bool fduplex);
-int serdes_xpcs_get_sgmii_speed(void *base, u32 xpcs, int *mbps,
-				bool *fduplex, bool *an);
-int serdes_xpcs_set_1000_mode(void *base, u32 xpcs,
-			      enum serdes_clock clktype,
-			      enum serdes_clock_fmhz fmhz,
-			      bool bypass);
-int serdes_xpcs_set_2500_mode(void *base, u32 xpcs,
-			      enum serdes_clock clktype,
-			      enum serdes_clock_fmhz fmhz);
-int serdes_xpcs_set_loopback(void *base, uint32_t xpcs, bool enable);
-int serdes_wait_for_link(void *base, uint32_t xpcs, uint8_t timeout);
-enum serdes_xpcs_mode s32_get_xpcs_mode(int serdes);
-
+#define REF_CLK_EN				BIT(0)
+#define REF_USE_PAD				BIT(1)
+#define REF_CLK_DIV2				BIT(2)
+#define REF_RANGE(x)				(((x) & 0x7U) << 3)
+#define REF_MPLLA_DIV2				BIT(6)
+#define REF_MPLLB_DIV2				BIT(7)
+#define REF_RPT_CLK_EN				BIT(8)
+
+#define CDR_CTRL_VCO_LOW_FREQ_0			BIT(8)
+
+#define MII_AN_CTRL_TX_CONFIG			BIT(3)
+#define MII_AN_INTR_EN				BIT(0)
+#define CL37_ANSGM_STS_GET_SPEED(x)		BIT(((x) & 0xc) >> 2)
+#define CL37_ANSGM_STS_SPEED_10M		0U
+#define CL37_ANSGM_STS_SPEED_100M		1U
+#define CL37_ANSGM_STS_SPEED_1000M		2U
+#define CL37_ANSGM_STS_LINK			BIT(4)
+#define CL37_ANSGM_STS_FD			BIT(1)
+
+#define PLLA_CAL_EN		BIT(0)
+#define PLLA_CAL_DIS		BIT(1)
+
+#define PLLB_CAL_EN		BIT(2)
+#define PLLB_CAL_DIS		BIT(3)
+
+#define XPCS0_1000M		BIT(8)
+#define XPCS0_2500M		BIT(9)
+#define XPCS0_DIS		BIT(10)
+#define XPCS0_OWNED		(XPCS0_1000M | XPCS0_2500M | XPCS0_DIS)
+
+#define XPCS1_1000M		BIT(16)
+#define XPCS1_2500M		BIT(17)
+#define XPCS1_DIS		BIT(18)
+#define XPCS1_OWNED		(XPCS1_1000M | XPCS1_2500M | XPCS1_DIS)
+
+#define PHY_CLK_INT		BIT(20)
+#define PHY_CTRL_XPCS0_OWNED	BIT(21)
+#define PHY_CTRL_XPCS1_OWNED	BIT(22)
+#define PHY_CTRL_XPCS_OWNED	(PHY_CTRL_XPCS0_OWNED | PHY_CTRL_XPCS1_OWNED)
+
+/* Init */
+void serdes_pcs_pma_init_gen2(void *base, enum serdes_clock_fmhz fmhz,
+			      u32 init_flags);
+void serdes_pcs_issue_vreset(void *base, u32 xpcs);
+int serdes_pcs_wait_for_vreset(void *base, u32 xpcs);
+int serdes_pcs_reset_seqence(void *serdes_base, u32 xpcs0_base, u32 xpcs1_base);
+int serdes_pcs_wait_for_power_good(void *base, u32 xpcs);
+
+/* Bifurcation PMA control */
+int serdes_bifurcation_pll_transit_to_3125Mhz(void *base, u32 xpcs,
+					      enum serdes_clock_fmhz fmhz);
+int serdes_bifurcation_pll_transit_to_1250Mhz(void *base, u32 xpcs,
+					      enum serdes_clock_fmhz fmhz);
+
+/* PMA control */
+void serdes_pma_lane_disable(void *base, u32 xpcs);
+void serdes_pma_lane_enable(void *base, u32 xpcs);
+void serdes_pma_issue_rx_reset(void *base, u32 xpcs);
+void serdes_pma_loopback_enable(void *base, u32 xpcs);
+void serdes_pma_loopback_disable(void *base, u32 xpcs);
+int  serdes_pma_wait_link(void *base, u32 xpcs, u8 sec);
+
+/* PCS control */
+int  serdes_pcs_speed_select(void *base, u32 xpcs, u32 div);
+void serdes_pcs_mii_bus_control_disable(void *base, u32 xpcs);
+void serdes_pcs_mii_bus_control_enable(void *base, u32 xpcs);
+void serdes_pcs_an_enable(void *base, u32 xpcs);
+void serdes_pcs_an_disable(void *base, u32 xpcs);
+void serdes_pcs_an_restart(void *base, u32 xpcs);
+void serdes_pcs_an_auto_sw_enable(void *base, u32 xpcs);
+void serdes_pcs_an_auto_sw_disable(void *base, u32 xpcs);
+void serdes_pcs_an_set_link_timer(void *base, u32 xpcs, u16 link_timer);
+int  serdes_pcs_an_decode(void *base, u32 xpcs, bool *link, bool *fduplex,
+			  u16 *speed);
+void serdes_pcs_set_fd(void *base, u32 xpcs);
+void serdes_pcs_set_hd(void *base, u32 xpcs);
+void serdes_pcs_loopback_enable(void *base, u32 xpcs);
+void serdes_pcs_loopback_disable(void *base, u32 xpcs);
+
+enum serdes_xpcs_mode_gen2 s32_get_xpcs_mode(int serd, int xpcs);
 int s32_sgmii_wait_link(int serdes, int xpcs);
-int s32_sgmii_get_speed(int serdes, int xpcs, int *mbps, bool *fd, bool *an);
-int s32_sgmii_set_speed(int serdes, int xpcs, int mbps, bool fd, bool an);
-
 #endif
 
diff --git a/drivers/net/dwc_eth_qos_s32cc.c b/drivers/net/dwc_eth_qos_s32cc.c
index 172b4177ca..73e02ea0c0 100644
--- a/drivers/net/dwc_eth_qos_s32cc.c
+++ b/drivers/net/dwc_eth_qos_s32cc.c
@@ -254,7 +254,7 @@ static int check_sgmii_cfg(int gmac_no)
 {
 	int serdes = gmac_no;
 	int xpcs = 0;
-	enum serdes_xpcs_mode mode, desired_mode1, desired_mode2;
+	enum serdes_xpcs_mode_gen2 mode, desired_mode1, desired_mode2;
 
 #if defined(CONFIG_TARGET_S32G2XXAEVB) || \
 	defined(CONFIG_TARGET_S32G3XXAEVB) || \
@@ -263,21 +263,21 @@ static int check_sgmii_cfg(int gmac_no)
 	defined(CONFIG_TARGET_S32G274ASIM) || \
 	defined(CONFIG_TARGET_S32G398AEMU)
 
-	desired_mode1 = SGMII_XPCS0;
-	desired_mode2 = SGMII_XPCS0_XPCS1;
+	desired_mode1 = SGMII_XPCS_1G_OP;
+	desired_mode2 = SGMII_XPCS_1G_OP;
 
 #elif defined(CONFIG_TARGET_S32R45EVB) || \
 	defined(CONFIG_TARGET_S32R45SIM) || \
 	defined(CONFIG_TARGET_S32R45EMU)
 
-	desired_mode1 = SGMII_XPCS0;
-	desired_mode2 = SGMII_XPCS0_2G5;
+	desired_mode1 = SGMII_XPCS_1G_OP;
+	desired_mode2 = SGMII_XPCS_2G5_OP;
 
 #else
 #error "Board not supported"
 #endif
 
-	mode = s32_get_xpcs_mode(serdes);
+	mode = s32_get_xpcs_mode(serdes, 0);
 
 	if (mode != desired_mode1 && mode != desired_mode2) {
 		printf("Invalid SGMII configuration for GMAC%d", gmac_no);
diff --git a/drivers/net/pfeng/pfeng_cmd.c b/drivers/net/pfeng/pfeng_cmd.c
index 48ffe6846c..5e004f96d6 100644
--- a/drivers/net/pfeng/pfeng_cmd.c
+++ b/drivers/net/pfeng/pfeng_cmd.c
@@ -149,46 +149,32 @@ static void disable_partition_2(void)
 int pfeng_map_emac_to_serdes_xpcs(int emac, int *serdes, int *xpcs)
 {
 	int emac_to_serdes[] = {1, 1, 0};
-	enum serdes_xpcs_mode mode;
-	int mac_serdes;
+	int emac_to_pcs[] = {0, 1, 1};
+	enum serdes_xpcs_mode_gen2 mode;
 
 	if (emac >= ARRAY_SIZE(emac_intf)) {
 		pr_err("invalid emac index %d\n", emac);
 		return -ENXIO;
 	}
 
-	mac_serdes = emac_to_serdes[emac];
-	mode = s32_get_xpcs_mode(mac_serdes);
+	mode = s32_get_xpcs_mode(emac_to_serdes[emac], emac_to_pcs[emac]);
 
-	if (mode == SGMII_INAVALID) {
+	if (mode == SGMII_XPCS_PCIE) {
 		pr_err("Emac %d not initialized\n", emac);
 		return -ENXIO;
 	}
 
-	if ((mac_serdes == 0 && emac == 2) ||
-	    (mac_serdes == 1 && emac == 1)) {
-		switch (mode) {
-		case SGMII_XPCS1:
-		case SGMII_XPCS0_XPCS1:
-			*xpcs = 1;
-			break;
-		default:
-			return -ENXIO;
-		}
-	} else if (mac_serdes == 1 && emac == 0) {
-		switch (mode) {
-		case SGMII_XPCS0:
-		case SGMII_XPCS0_XPCS1:
-		case SGMII_XPCS0_2G5:
-			*xpcs = 0;
-			break;
-		default:
-			return -ENXIO;
-		}
-	} else {
+	if (mode == SGMII_XPCS_DISABLED) {
+		pr_err("PCS for emac %d was disabled\n", emac);
 		return -ENXIO;
 	}
-	*serdes = mac_serdes;
+
+	if (!((emac == 0 && mode == SGMII_XPCS_2G5_OP) ||
+	      mode == SGMII_XPCS_1G_OP))
+		return -ENXIO;
+
+	*serdes = emac_to_serdes[emac];
+	*xpcs = emac_to_pcs[emac];
 
 	return 0;
 }
diff --git a/drivers/pci/serdes_s32gen1.c b/drivers/pci/serdes_s32gen1.c
index 79a586ee45..57b17f8e63 100644
--- a/drivers/pci/serdes_s32gen1.c
+++ b/drivers/pci/serdes_s32gen1.c
@@ -303,6 +303,7 @@ void s32_serdes_phy_init(struct s32_serdes *pcie)
 	s32_serdes_phy_reg_write(pcie,
 				 RAWLANE0_DIG_PCS_XF_RX_EQ_DELTA_IQ_OVRD_IN,
 				 0x13, 0xff);
+
 	/* RX_EQ_DELTA_IQ_OVRD enable and override value for PCIe0 lane 1 */
 	s32_serdes_phy_reg_write(pcie,
 				 RAWLANE1_DIG_PCS_XF_RX_EQ_DELTA_IQ_OVRD_IN,
@@ -314,6 +315,9 @@ void s32_serdes_phy_init(struct s32_serdes *pcie)
 
 bool s32_serdes_init(struct s32_serdes *pcie)
 {
+	/* Fall back to mode compatible with PCIe */
+	pcie->ss_mode = SERDES_MODE_PCIE_SGMII0;
+
 	/* Reset the Serdes module */
 	s32_assert_serdes_reset(pcie);
 
@@ -335,37 +339,28 @@ bool s32_serdes_init(struct s32_serdes *pcie)
 					SERDES_MODE_PCIE_PCIE))
 			return false;
 	} else if (IS_SERDES_PCIE(pcie->devtype) &&
-				IS_SERDES_SGMII(pcie->devtype)) {
+		   IS_SERDES_SGMII(pcie->devtype)) {
 		if (pcie->xpcs_mode != SGMII_XPCS0 &&
 		    pcie->xpcs_mode != SGMII_XPCS1) {
 			printf("ERROR: Invalid XPCS config on PCIe%d\n",
 			       pcie->id);
-
-			/* Fall back to mode compatible with PCIe */
-			if (s32_serdes_set_mode(pcie->dbi, pcie->id,
-						SERDES_MODE_PCIE_SGMII0))
-				return false;
 		}
 
 		/* Configure SS mode based on XPCS */
 		if (pcie->xpcs_mode == SGMII_XPCS0)
-			if (s32_serdes_set_mode(pcie->dbi, pcie->id,
-						SERDES_MODE_PCIE_SGMII0))
-				return false;
+			pcie->ss_mode = SERDES_MODE_PCIE_SGMII0;
 		if (pcie->xpcs_mode == SGMII_XPCS1)
-			if (s32_serdes_set_mode(pcie->dbi, pcie->id,
-						SERDES_MODE_PCIE_SGMII1))
-				return false;
+			pcie->ss_mode = SERDES_MODE_PCIE_SGMII1;
+
 	} else if (!IS_SERDES_PCIE(pcie->devtype) &&
-				IS_SERDES_SGMII(pcie->devtype)) {
+		    IS_SERDES_SGMII(pcie->devtype)) {
 		/*	Set pipeP_pclk */
 		W32(pcie->dbi + SS_PHY_GEN_CTRL, EXT_PCLK_REQ);
-		if (s32_serdes_set_mode(pcie->dbi, pcie->id,
-					 SERDES_MODE_SGMII_SGMII))
-			return false;
+		pcie->ss_mode = SERDES_MODE_SGMII_SGMII;
 	}
 
-	s32_deassert_serdes_reset(pcie);
+	if (s32_serdes_set_mode(pcie->dbi, pcie->id, pcie->ss_mode))
+		return false;
 
 	/* Set the clock for the Serdes module */
 	if (pcie->clktype == CLK_INT) {
@@ -380,6 +375,9 @@ bool s32_serdes_init(struct s32_serdes *pcie)
 		BCLR32(pcie->dbi + SS_SS_RW_REG_0, 1 << 23);
 	}
 
+	/* Deassert SerDes reset */
+	s32_deassert_serdes_reset(pcie);
+
 	/* Enable PHY's SRIS mode in PCIe mode*/
 	if (pcie->phy_mode == SRIS)
 		BSET32(pcie->dbi + SS_PHY_GEN_CTRL,
@@ -423,7 +421,7 @@ __weak bool s32_pcie_set_link_width(void __iomem *dbi,
 }
 
 __weak int s32_eth_xpcs_init(void __iomem *dbi, int id,
-			     bool combo,
+			     enum serdes_mode ss_mode,
 			     enum serdes_xpcs_mode xpcs_mode,
 			     enum serdes_clock clktype,
 			     enum serdes_clock_fmhz fmhz)
@@ -594,14 +592,6 @@ static bool s32_serdes_is_xpcs_cfg_valid(struct s32_serdes *pcie)
 		ret = false;
 	}
 
-	if (pcie->xpcs_mode == SGMII_XPCS0_2G5 &&
-	    pcie->fmhz == CLK_100MHZ) {
-		printf("Invalid \"hwconfig\": In SGMII 2.5G frequency");
-		printf("has to be 125MHz\n");
-		/* We just fail in this case user has to reconfigure */
-		ret = false;
-	}
-
 	return ret;
 }
 
@@ -661,7 +651,6 @@ static int s32_serdes_probe(struct udevice *dev)
 	char mode[SERDES_MODE_SIZE];
 	const char *pcie_phy_mode;
 	int ret = 0;
-	bool combo_mode;
 
 	debug("%s: probing %s\n", __func__, dev->name);
 	if (!pcie) {
@@ -734,10 +723,8 @@ static int s32_serdes_probe(struct udevice *dev)
 
 	if (IS_SERDES_SGMII(pcie->devtype) &&
 	    pcie->xpcs_mode != SGMII_INAVALID) {
-		combo_mode = (IS_SERDES_SGMII(pcie->devtype) &&
-			      IS_SERDES_PCIE(pcie->devtype));
 		ret = s32_eth_xpcs_init(pcie->dbi, pcie->id,
-					combo_mode,
+					pcie->ss_mode,
 					pcie->xpcs_mode,
 					pcie->clktype,
 					pcie->fmhz);
diff --git a/drivers/pci/serdes_s32gen1.h b/drivers/pci/serdes_s32gen1.h
index bc30cb1838..c9df1ac137 100644
--- a/drivers/pci/serdes_s32gen1.h
+++ b/drivers/pci/serdes_s32gen1.h
@@ -55,6 +55,7 @@ struct s32_serdes {
 	struct udevice *bus;
 	struct fdt_resource dbi_res;
 	void __iomem *dbi;
+	enum serdes_mode ss_mode;
 
 	int id;
 	enum serdes_dev_type devtype;
@@ -74,7 +75,7 @@ bool s32_pcie_init(void __iomem *dbi, int id, bool rc_mode,
 		enum serdes_link_width linkwidth);
 
 int s32_eth_xpcs_init(void __iomem *serdes_base, int id,
-		      bool combo,
+		      enum serdes_mode ss_mode,
 		      enum serdes_xpcs_mode xpcs_mode,
 		      enum serdes_clock clktype,
 		      enum serdes_clock_fmhz fmhz);
-- 
2.17.1

