From 3c36e7f8e59bff9c7278d13034f9ad44634e5a4a Mon Sep 17 00:00:00 2001
From: Ghennadi Procopciuc <Ghennadi.Procopciuc@nxp.com>
Date: Mon, 4 Jan 2021 16:14:48 +0200
Subject: [PATCH 43/78] llce-can: Use NAPI on RX

Issue: ALB-5610
Signed-off-by: Ghennadi Procopciuc <Ghennadi.Procopciuc@nxp.com>
---
 drivers/mailbox/llce-mailbox.c                | 170 +++++++++++++-----
 drivers/net/can/llce_can.c                    | 142 +++++++++++++--
 include/linux/mailbox/nxp-llce/llce_mailbox.h |  32 +++-
 3 files changed, 279 insertions(+), 65 deletions(-)

diff --git a/drivers/mailbox/llce-mailbox.c b/drivers/mailbox/llce-mailbox.c
index c3bc722aa7e8..0677b09b69ee 100644
--- a/drivers/mailbox/llce-mailbox.c
+++ b/drivers/mailbox/llce-mailbox.c
@@ -1,6 +1,6 @@
 // SPDX-License-Identifier: GPL-2.0+ OR BSD-3-Clause
 /*
- * Copyright 2020 NXP
+ * Copyright 2020-2021 NXP
  */
 #include <dt-bindings/mailbox/nxp-llce-mb.h>
 #include <linux/can/dev.h>
@@ -99,6 +99,7 @@ static int llce_rx_startup(struct mbox_chan *chan);
 static int llce_tx_startup(struct mbox_chan *chan);
 static void llce_rx_shutdown(struct mbox_chan *chan);
 static void llce_tx_shutdown(struct mbox_chan *chan);
+static int process_rx_cmd(struct mbox_chan *chan, struct llce_rx_msg *msg);
 
 const char *llce_errors[] = {
 	LLCE_ERROR_ENTRY(LLCE_ERROR_TXACK_FIFO_FULL),
@@ -354,6 +355,16 @@ static bool is_config_chan(unsigned int chan_type)
 		chan_type == S32G274_LLCE_HIF_CONF_MB;
 }
 
+static bool is_rx_chan(unsigned int chan_type)
+{
+	return chan_type == S32G274_LLCE_CAN_RX_MB;
+}
+
+static bool is_tx_chan(unsigned int chan_type)
+{
+	return chan_type == S32G274_LLCE_CAN_TX_MB;
+}
+
 static int init_chan_priv(struct mbox_chan *chan, struct llce_mb *mb,
 			  unsigned int type, unsigned int index)
 {
@@ -374,7 +385,11 @@ static int init_chan_priv(struct mbox_chan *chan, struct llce_mb *mb,
 		chan->txdone_method = TXDONE_BY_POLL;
 		priv->state = LLCE_REGISTERED_CHAN;
 	} else {
-		chan->txdone_method = TXDONE_BY_IRQ;
+		if (is_rx_chan(type))
+			chan->txdone_method = TXDONE_BY_ACK;
+		else
+			chan->txdone_method = TXDONE_BY_IRQ;
+
 		priv->state = LLCE_UNREGISTERED_CHAN;
 	}
 
@@ -559,25 +574,44 @@ static int llce_mb_send_data(struct mbox_chan *chan, void *data)
 {
 	struct llce_chan_priv *priv = chan->con_priv;
 	struct llce_mb *mb = priv->mb;
-	int ret = -EINVAL;
 
 	/* Client should not flush new tasks if suspended. */
 	WARN_ON(mb->suspended);
 
 	if (is_config_chan(priv->type))
-		ret = execute_config_cmd(chan, data);
+		return execute_config_cmd(chan, data);
 
-	if (priv->type == S32G274_LLCE_CAN_TX_MB)
-		ret = send_can_msg(chan, data);
+	if (is_tx_chan(priv->type))
+		return send_can_msg(chan, data);
 
-	return ret;
+	if (is_rx_chan(priv->type))
+		return process_rx_cmd(chan, data);
+
+	return -EINVAL;
 }
 
-static int llce_rx_startup(struct mbox_chan *chan)
+static void disable_rx_irq(struct mbox_chan *chan)
+{
+	void __iomem *rxout = get_rxout_fifo(chan);
+	void __iomem *ier = LLCE_FIFO_IER(rxout);
+
+	writel(0, ier);
+}
+
+static void enable_rx_irq(struct mbox_chan *chan)
 {
 	void __iomem *rxout = get_rxout_fifo(chan);
 	void __iomem *status0 = LLCE_FIFO_STATUS0(rxout);
 	void __iomem *ier = LLCE_FIFO_IER(rxout);
+
+	/* Clear interrupt status flags. */
+	writel(readl(status0), status0);
+	/* Enable interrupt */
+	writel(LLCE_FIFO_FNEMTY, ier);
+}
+
+static int llce_rx_startup(struct mbox_chan *chan)
+{
 	struct llce_chan_priv *priv = chan->con_priv;
 	unsigned long flags;
 
@@ -585,11 +619,7 @@ static int llce_rx_startup(struct mbox_chan *chan)
 	spin_lock_irqsave(&priv->lock, flags);
 
 	priv->state = LLCE_REGISTERED_CHAN;
-
-	/* Clear interrupt status flags. */
-	writel(readl(status0), status0);
-	/* Enable interrupt */
-	writel(LLCE_FIFO_FNEMTY, ier);
+	enable_rx_irq(chan);
 
 	spin_unlock_irqrestore(&priv->lock, flags);
 	return 0;
@@ -597,16 +627,14 @@ static int llce_rx_startup(struct mbox_chan *chan)
 
 static void llce_rx_shutdown(struct mbox_chan *chan)
 {
-	void __iomem *rxout = get_rxout_fifo(chan);
-	void __iomem *ier = LLCE_FIFO_IER(rxout);
 	struct llce_chan_priv *priv = chan->con_priv;
 	unsigned long flags;
 
 	spin_lock_irqsave(&priv->lock, flags);
+
 	priv->state = LLCE_UNREGISTERED_CHAN;
+	disable_rx_irq(chan);
 
-	/* Disable interrupts */
-	writel(0, ier);
 	spin_unlock_irqrestore(&priv->lock, flags);
 }
 
@@ -848,7 +876,7 @@ static void llce_process_tx_ack(struct llce_mb *mb, uint8_t index)
 	struct mbox_controller *ctrl = &mb->controller;
 	struct llce_can_shared_memory *sh_mem = mb->sh_mem;
 	struct llce_can_tx2host_ack_info *info;
-	struct llce_notif notif;
+	struct llce_tx_notif notif;
 	uint32_t ack_id;
 	unsigned int chan_index;
 
@@ -876,7 +904,8 @@ static void process_chan_err(struct llce_mb *mb, uint32_t chan_type,
 {
 	unsigned int chan_index;
 	struct mbox_controller *ctrl = &mb->controller;
-	struct llce_notif notif = {
+	struct llce_rx_msg notif = {
+		.cmd = LLCE_ERROR,
 		.error = error->error_info.error_code,
 	};
 
@@ -884,7 +913,7 @@ static void process_chan_err(struct llce_mb *mb, uint32_t chan_type,
 	notif.error = error->error_info.error_code;
 
 	/* Release the channel if an error occurred */
-	if (chan_type == S32G274_LLCE_CAN_TX_MB)
+	if (is_tx_chan(chan_type))
 		mbox_chan_txdone(&ctrl->chans[chan_index], 0);
 
 	llce_mbox_chan_received_data(&ctrl->chans[chan_index], &notif);
@@ -958,43 +987,96 @@ static void llce_process_rxin(struct llce_mb *mb, uint8_t index)
 	writel(LLCE_FIFO_FNEMTY, status1);
 }
 
-static void read_rxout_message(struct llce_mb *mb, uint32_t rx_mb,
-			       uint8_t rx_index)
+static int process_is_rx_empty(struct mbox_chan *chan, struct llce_rx_msg *msg)
 {
-	struct mbox_controller *ctrl = &mb->controller;
+	void __iomem *rxout = get_rxout_fifo(chan);
+	void __iomem *status1 = LLCE_FIFO_STATUS1(rxout);
+
+	msg->is_rx_empty = !!(readl(status1) & LLCE_FIFO_FEMTYD);
+	return 0;
+}
+
+static int process_pop_rxout(struct mbox_chan *chan, struct llce_rx_msg *msg)
+{
+	struct llce_chan_priv *priv = chan->con_priv;
+	struct llce_mb *mb = priv->mb;
+	void __iomem *rxout = get_rxout_fifo(chan);
+	void __iomem *pop0 = LLCE_FIFO_POP0(rxout);
+	uint32_t rx_mb;
+
 	struct llce_can_shared_memory *sh_mem = mb->sh_mem;
-	struct llce_notif notif = {
-		.error = 0,
-	};
 	uint32_t frame_id;
 	unsigned int chan_index;
 
+
+	/* Get RX mailbox */
+	rx_mb = readl(pop0) & LLCE_CAN_CONFIG_FIFO_FIXED_MASK;
+
 	frame_id = sh_mem->can_rx_mb_desc[rx_mb].mb_frame_idx;
-	chan_index = get_channel_offset(S32G274_LLCE_CAN_RX_MB, rx_index);
-	notif.can_mb = &sh_mem->can_mb[frame_id];
-	llce_mbox_chan_received_data(&ctrl->chans[chan_index], &notif);
+	chan_index = get_channel_offset(S32G274_LLCE_CAN_RX_MB, priv->index);
+	msg->rx_pop.can_mb = &sh_mem->can_mb[frame_id];
+	msg->rx_pop.index = rx_mb;
+
+	return 0;
 }
 
-static void llce_process_rxout(struct llce_mb *mb, uint8_t index)
+static int process_release_index(struct mbox_chan *chan,
+				 struct llce_rx_msg *msg)
 {
+	struct llce_chan_priv *priv = chan->con_priv;
+	struct llce_mb *mb = priv->mb;
 	void __iomem *host_rxin = get_host_rxin(mb, LLCE_CAN_HIF0);
-	void __iomem *rxout = get_rxout_by_index(mb, index);
-	void __iomem *status1 = LLCE_FIFO_STATUS1(rxout);
-	void __iomem *pop0 = LLCE_FIFO_POP0(rxout);
 	void __iomem *host_push0 = LLCE_FIFO_PUSH0(host_rxin);
-	uint32_t rx_mb;
 
-	while (!(readl(status1) & LLCE_FIFO_FEMTYD)) {
-		/* Get RX mailbox */
-		rx_mb = readl(pop0) & LLCE_CAN_CONFIG_FIFO_FIXED_MASK;
-		/* Process RX message */
-		read_rxout_message(mb, rx_mb, index);
-		/* Make the index available for another reception flow */
-		writel(rx_mb, host_push0);
-	}
+	writel(msg->rx_release.index, host_push0);
+	return 0;
+}
 
-	/* Clear the interrupt status flag. */
-	writel(LLCE_FIFO_FNEMTY, status1);
+static int process_disable_rx_notif(struct mbox_chan *chan,
+				    struct llce_rx_msg __always_unused *msg)
+{
+	disable_rx_irq(chan);
+
+	return 0;
+}
+
+static int process_enable_rx_notif(struct mbox_chan *chan,
+				   struct llce_rx_msg __always_unused *msg)
+{
+	enable_rx_irq(chan);
+
+	return 0;
+}
+
+static int process_rx_cmd(struct mbox_chan *chan, struct llce_rx_msg *msg)
+{
+	if (msg->cmd == LLCE_DISABLE_RX_NOTIF)
+		return process_disable_rx_notif(chan, msg);
+	if (msg->cmd == LLCE_ENABLE_RX_NOTIF)
+		return process_enable_rx_notif(chan, msg);
+	if (msg->cmd == LLCE_IS_RX_EMPTY)
+		return process_is_rx_empty(chan, msg);
+	if (msg->cmd == LLCE_POP_RX)
+		return process_pop_rxout(chan, msg);
+	if (msg->cmd == LLCE_RELESE_RX_INDEX)
+		return process_release_index(chan, msg);
+
+	return 0;
+}
+
+static void llce_process_rxout(struct llce_mb *mb, uint8_t index)
+{
+	struct mbox_controller *ctrl = &mb->controller;
+	unsigned int chan_index;
+	struct llce_rx_msg msg = {
+		.error = 0,
+		.cmd = LLCE_RX_NOTIF,
+	};
+
+	chan_index = get_channel_offset(S32G274_LLCE_CAN_RX_MB, index);
+	disable_rx_irq(&ctrl->chans[chan_index]);
+
+	llce_mbox_chan_received_data(&ctrl->chans[chan_index], &msg);
 }
 
 typedef void (*icsr_consumer_t)(struct llce_mb *, uint8_t);
diff --git a/drivers/net/can/llce_can.c b/drivers/net/can/llce_can.c
index b40e070c8c4b..5fb173298b41 100644
--- a/drivers/net/can/llce_can.c
+++ b/drivers/net/can/llce_can.c
@@ -31,8 +31,9 @@ struct llce_xceiver {
 };
 
 struct llce_can {
-	struct can_priv can;
+	struct can_priv can; /* Must be the first member */
 	struct llce_xceiver xceiver;
+	struct napi_struct napi;
 
 	struct completion config_done;
 
@@ -338,6 +339,8 @@ static int llce_can_open(struct net_device *dev)
 		goto release_rx_chan;
 	}
 
+	napi_enable(&llce->napi);
+
 	ret = start_llce_can(llce);
 	if (ret)
 		goto release_tx_chan;
@@ -347,8 +350,10 @@ static int llce_can_open(struct net_device *dev)
 	return 0;
 
 release_tx_chan:
-	if (ret)
+	if (ret) {
+		napi_disable(&llce->napi);
 		mbox_free_channel(llce->tx);
+	}
 release_rx_chan:
 	if (ret)
 		mbox_free_channel(llce->rx);
@@ -378,6 +383,7 @@ static int llce_can_close(struct net_device *dev)
 	if (ret)
 		netdev_err(dev, "Failed to stop\n");
 
+	napi_disable(&llce->napi);
 	mbox_free_channel(llce->tx);
 	mbox_free_channel(llce->rx);
 
@@ -441,7 +447,7 @@ static void llce_process_error(struct llce_can *llce, enum llce_can_error error,
 
 static void llce_tx_notif_callback(struct mbox_client *cl, void *msg)
 {
-	struct llce_notif *notif = msg;
+	struct llce_tx_notif *notif = msg;
 	struct llce_can *llce = container_of(cl, struct llce_can,
 					     tx_client);
 	struct net_device_stats *net_stats = &llce->can.dev->stats;
@@ -482,26 +488,76 @@ static void unpack_word1(u32 word1, bool *fdf, u8 *len, bool *brs,
 	*fdf = !!(word1 & LLCE_CAN_MB_FDF);
 }
 
-static void llce_rx_notif_callback(struct mbox_client *cl, void *msg)
+static int send_rx_msg(struct llce_can *llce, struct llce_rx_msg *msg)
+{
+	int ret = mbox_send_message(llce->rx, msg);
+
+	if (ret < 0)
+		return ret;
+
+	mbox_client_txdone(llce->rx, 0);
+
+	return 0;
+}
+
+static int enable_rx_notif(struct llce_can *llce)
+{
+	struct llce_rx_msg msg = {
+		.cmd = LLCE_ENABLE_RX_NOTIF,
+	};
+
+	return send_rx_msg(llce, &msg);
+}
+
+static bool is_rx_empty(struct llce_can *llce)
+{
+	struct llce_rx_msg msg = {
+		.cmd = LLCE_IS_RX_EMPTY,
+	};
+
+	if (send_rx_msg(llce, &msg))
+		return false;
+
+	return msg.is_rx_empty;
+}
+
+static int pop_rx_fifo(struct llce_can *llce, uint32_t *index,
+		       struct llce_can_mb **can_mb)
+{
+	int ret;
+	struct llce_rx_msg msg = {
+		.cmd = LLCE_POP_RX,
+	};
+
+	ret = send_rx_msg(llce, &msg);
+
+	*can_mb = msg.rx_pop.can_mb;
+	*index = msg.rx_pop.index;
+	return ret;
+}
+
+static int release_rx_index(struct llce_can *llce, uint32_t index)
+{
+	struct llce_rx_msg msg = {
+		.cmd = LLCE_RELESE_RX_INDEX,
+		.rx_release = {
+			.index = index,
+		},
+	};
+
+	return send_rx_msg(llce, &msg);
+}
+
+static void process_rx_msg(struct llce_can *llce, struct llce_can_mb *can_mb)
 {
-	struct llce_notif *notif = msg;
-	struct llce_can *llce = container_of(cl, struct llce_can,
-					     rx_client);
 	struct net_device *dev = llce->can.dev;
 	struct net_device_stats *net_stats = &llce->can.dev->stats;
-	struct llce_can_mb *can_mb = notif->can_mb;
 	struct sk_buff *skb;
 	struct canfd_frame *cf;
 	u32 std_id, ext_id;
 	bool rtr, ide, brs, esi, fdf;
 	u8 len;
 
-	/* This is executed in IRQ context */
-	if (notif->error) {
-		llce_process_error(llce, notif->error, LLCE_RX);
-		return;
-	}
-
 	unpack_word0(can_mb->word0, &rtr, &ide, &std_id, &ext_id);
 	unpack_word1(can_mb->word1, &fdf, &len, &brs, &esi);
 
@@ -547,6 +603,60 @@ static void llce_rx_notif_callback(struct mbox_client *cl, void *msg)
 	return;
 }
 
+static int llce_rx_poll(struct napi_struct *napi, int quota)
+{
+	struct llce_can *llce = container_of(napi, struct llce_can, napi);
+	struct net_device *dev = llce->can.dev;
+	int num_pkts = 0;
+	struct llce_can_mb *can_mb;
+	u32 index;
+	int ret;
+
+	while (!is_rx_empty(llce) && num_pkts < quota) {
+		ret = pop_rx_fifo(llce, &index, &can_mb);
+		if (ret) {
+			netdev_err(dev, "Failed to peak RX FIFO\n");
+			return num_pkts;
+		}
+
+		process_rx_msg(llce, can_mb);
+
+		num_pkts++;
+
+		ret = release_rx_index(llce, index);
+		if (ret)
+			netdev_err(dev, "Failed to release RX FIFO index\n");
+	}
+
+	/* All packets processed */
+	if (num_pkts < quota) {
+		napi_complete_done(napi, num_pkts);
+
+		/* Enable RX notification / IRQ */
+		if (enable_rx_notif(llce))
+			netdev_err(dev, "Failed to enable RX notifications\n");
+	}
+
+	return num_pkts;
+}
+
+static void llce_rx_notif_callback(struct mbox_client *cl, void *msg)
+{
+	struct llce_rx_msg *rx_msg = msg;
+	struct llce_can *llce = container_of(cl, struct llce_can, rx_client);
+
+	/* This is executed in IRQ context */
+	if (rx_msg->error)
+		llce_process_error(llce, rx_msg->error, LLCE_RX);
+
+	if (rx_msg->cmd == LLCE_RX_NOTIF) {
+		if (!napi_schedule_prep(&llce->napi))
+			return;
+
+		__napi_schedule(&llce->napi);
+	}
+}
+
 static netdev_tx_t llce_can_start_xmit(struct sk_buff *skb,
 				       struct net_device *dev)
 {
@@ -652,7 +762,7 @@ static int init_llce_chans(struct llce_can *llce, struct device *dev)
 	llce->tx_client.tx_block = false;
 	llce->tx_client.rx_callback = llce_tx_notif_callback;
 	llce->rx_client.dev = dev;
-	llce->rx_client.tx_block = true;
+	llce->rx_client.tx_block = false;
 	llce->rx_client.rx_callback = llce_rx_notif_callback;
 
 	llce->config = mbox_request_channel_byname(&llce->config_client,
@@ -739,6 +849,7 @@ static int llce_can_probe(struct platform_device *pdev)
 	if (ret)
 		goto free_mem;
 
+	netif_napi_add(netdev, &llce->napi, llce_rx_poll, LLCE_CAN_MAX_RX_MB);
 	ret = register_candev(netdev);
 	if (ret) {
 		dev_err(dev, "Failed to register %s\n", dev_name);
@@ -758,6 +869,7 @@ static int llce_can_remove(struct platform_device *pdev)
 	struct llce_can *llce = netdev_priv(netdev);
 
 	unregister_candev(netdev);
+	netif_napi_del(&llce->napi);
 
 	clk_disable_unprepare(llce->clk);
 	mbox_free_channel(llce->config);
diff --git a/include/linux/mailbox/nxp-llce/llce_mailbox.h b/include/linux/mailbox/nxp-llce/llce_mailbox.h
index f96846b2b6db..95215b62d94e 100644
--- a/include/linux/mailbox/nxp-llce/llce_mailbox.h
+++ b/include/linux/mailbox/nxp-llce/llce_mailbox.h
@@ -1,5 +1,5 @@
 /* SPDX-License-Identifier: GPL-2.0+ */
-/* Copyright 2020 NXP */
+/* Copyright 2020-2021 NXP */
 #ifndef LLCE_MAILBOX_H
 #define LLCE_MAILBOX_H
 
@@ -29,13 +29,33 @@ struct llce_tx_msg {
 	struct canfd_frame *cf;
 };
 
-struct llce_notif {
+struct llce_tx_notif {
+	enum llce_can_error error;
+	uint32_t tx_timestamp;
+};
+
+enum llce_rx_cmd {
+	LLCE_RX_NOTIF,
+	LLCE_DISABLE_RX_NOTIF,
+	LLCE_ENABLE_RX_NOTIF,
+	LLCE_IS_RX_EMPTY,
+	LLCE_POP_RX,
+	LLCE_RELESE_RX_INDEX,
+	LLCE_ERROR,
+};
+
+struct llce_rx_msg {
+	enum llce_rx_cmd cmd;
 	enum llce_can_error error;
 	union {
-		/* TX notification */
-		uint32_t tx_timestamp;
-		/* RX notiication */
-		struct llce_can_mb *can_mb;
+		bool is_rx_empty;
+		struct {
+			uint32_t index;
+			struct llce_can_mb *can_mb;
+		} rx_pop;
+		struct {
+			uint32_t index;
+		} rx_release;
 	};
 };
 
-- 
2.25.1

