From 43f93cf1f59f62f22fdcc6487462e40ee61a91ee Mon Sep 17 00:00:00 2001
From: Ghennadi Procopciuc <Ghennadi.Procopciuc@nxp.com>
Date: Tue, 24 Nov 2020 10:43:20 +0200
Subject: [PATCH 21/78] drivers: mailbox: Add LLCE CAN mailbox

This mailbox is use to send notification or messages between
LLCE accelerator and A53 cores.

Issue: ALB-5829
Signed-off-by: Ghennadi Procopciuc <Ghennadi.Procopciuc@nxp.com>
---
 drivers/mailbox/Kconfig                       |    9 +
 drivers/mailbox/Makefile                      |    2 +
 drivers/mailbox/llce-mailbox.c                | 1464 +++++++++++++++++
 include/linux/mailbox/nxp-llce/llce_can.h     | 1364 +++++++++++++++
 .../linux/mailbox/nxp-llce/llce_fw_version.h  |   32 +
 .../mailbox/nxp-llce/llce_interface_config.h  |  169 ++
 .../mailbox/nxp-llce/llce_interface_fifo.h    |   74 +
 include/linux/mailbox/nxp-llce/llce_mailbox.h |   42 +
 8 files changed, 3156 insertions(+)
 create mode 100644 drivers/mailbox/llce-mailbox.c
 create mode 100644 include/linux/mailbox/nxp-llce/llce_can.h
 create mode 100644 include/linux/mailbox/nxp-llce/llce_fw_version.h
 create mode 100644 include/linux/mailbox/nxp-llce/llce_interface_config.h
 create mode 100644 include/linux/mailbox/nxp-llce/llce_interface_fifo.h
 create mode 100644 include/linux/mailbox/nxp-llce/llce_mailbox.h

diff --git a/drivers/mailbox/Kconfig b/drivers/mailbox/Kconfig
index 7707ee26251a..9745b02abb12 100644
--- a/drivers/mailbox/Kconfig
+++ b/drivers/mailbox/Kconfig
@@ -234,4 +234,13 @@ config ZYNQMP_IPI_MBOX
 	  message to the IPI buffer and will access the IPI control
 	  registers to kick the other processor or enquire status.
 
+config NXP_LLCE_MBOX
+	tristate "NXP LLCE Mailbox"
+	depends on OF && m
+	help
+	  Say yes here to add support for LLCE mailbox driver.
+	  This mailbox driver is used to send notification or messages
+	  between the LLCE accelerator and A53 cores. It will exchange
+	  messages using a shared memory.
+
 endif
diff --git a/drivers/mailbox/Makefile b/drivers/mailbox/Makefile
index 93918a84c91b..ad72f3f188d7 100644
--- a/drivers/mailbox/Makefile
+++ b/drivers/mailbox/Makefile
@@ -50,3 +50,5 @@ obj-$(CONFIG_STM32_IPCC) 	+= stm32-ipcc.o
 obj-$(CONFIG_MTK_CMDQ_MBOX)	+= mtk-cmdq-mailbox.o
 
 obj-$(CONFIG_ZYNQMP_IPI_MBOX)	+= zynqmp-ipi-mailbox.o
+
+obj-$(CONFIG_NXP_LLCE_MBOX)	+= llce-mailbox.o
diff --git a/drivers/mailbox/llce-mailbox.c b/drivers/mailbox/llce-mailbox.c
new file mode 100644
index 000000000000..8e519dcf54fb
--- /dev/null
+++ b/drivers/mailbox/llce-mailbox.c
@@ -0,0 +1,1464 @@
+// SPDX-License-Identifier: GPL-2.0+ OR BSD-3-Clause
+/*
+ * Copyright 2020 NXP
+ */
+#include <dt-bindings/mailbox/nxp-llce-mb.h>
+#include <linux/can/dev.h>
+#include <linux/clk.h>
+#include <linux/ctype.h>
+#include <linux/genalloc.h>
+#include <linux/interrupt.h>
+#include <linux/io.h>
+#include <linux/kernel.h>
+#include <linux/mailbox/nxp-llce/llce_can.h>
+#include <linux/mailbox/nxp-llce/llce_interface_fifo.h>
+#include <linux/mailbox/nxp-llce/llce_mailbox.h>
+#include <linux/mailbox_controller.h>
+#include <linux/module.h>
+#include <linux/of_platform.h>
+#include <linux/platform_device.h>
+#include <linux/processor.h>
+#include <linux/slab.h>
+#include <uapi/linux/can.h>
+
+#include "mailbox.h"
+
+#define LLCE_FIFO_SIZE			0x400
+
+#define LLCE_NFIFO_WITH_IRQ		16
+#define LLCE_RXIN_N_FIFO		20
+
+#define LLCE_NTXACK_FIFOS		21
+#define LLCE_NRXOUT_FIFOS		21
+
+#define LLCE_CAN_RXIN_ICSR_0_7		14
+#define LLCE_CAN_RXIN_ICSR_8_15		15
+#define LLCE_CAN_RXOUT_ICSR_0_7		16
+#define LLCE_CAN_RXOUT_ICSR_8_15	17
+#define LLCE_CAN_TXACK_ICSR_0_7		22
+#define LLCE_CAN_TXACK_ICSR_8_15	23
+#define LLCE_CAN_ICSR_N_ACK		8
+
+#define LLCE_CAN_ICSR_RXIN_INDEX	0
+#define LLCE_CAN_ICSR_RXOUT_INDEX	1
+#define LLCE_CAN_ICSR_TXACK_INDEX	2
+
+#define LLCE_CAN_COMPATIBLE "nxp,s32g274a-llce-can"
+
+#define LLCE_ARR_ENTRY(BASE_INDEX, ENTRY) \
+	[ENTRY - BASE_INDEX] = __stringify_1(ENTRY)
+
+#define LLCE_ERROR_ENTRY(ERROR) \
+	LLCE_ARR_ENTRY(LLCE_ERROR_TXACK_FIFO_FULL, ERROR)
+
+#define LLCE_MODULE_ENTRY(MODULE) \
+	LLCE_ARR_ENTRY(LLCE_TX, MODULE)
+
+struct llce_icsr {
+	uint8_t icsr0_num;
+	uint8_t icsr8_num;
+};
+
+struct llce_fifoirq {
+	int irq0;
+	int irq8;
+};
+
+struct llce_mb {
+	struct mbox_controller controller;
+	struct llce_fifoirq rxin_irqs;
+	struct llce_fifoirq rxout_irqs;
+	struct llce_fifoirq txack_irqs;
+	struct mutex txack_lock;
+	struct llce_can_shared_memory *sh_mem;
+	void __iomem *rxout_fifo;
+	void __iomem *rxin_fifo;
+	void __iomem *txack_fifo;
+	void __iomem *blrout_fifo;
+	void __iomem *blrin_fifo;
+	void __iomem *icsr;
+	struct clk *clk;
+};
+
+struct sram_pool {
+	struct gen_pool *pool;
+	size_t size;
+	unsigned long vaddr;
+	const char *name;
+};
+
+struct llce_mb_desc {
+	unsigned int nchan;
+	int (*startup)(struct mbox_chan *chan);
+	void (*shutdown)(struct mbox_chan *chan);
+};
+
+static int llce_rx_startup(struct mbox_chan *chan);
+static int llce_tx_startup(struct mbox_chan *chan);
+static void llce_rx_shutdown(struct mbox_chan *chan);
+static void llce_tx_shutdown(struct mbox_chan *chan);
+
+const char *llce_errors[] = {
+	LLCE_ERROR_ENTRY(LLCE_ERROR_TXACK_FIFO_FULL),
+	LLCE_ERROR_ENTRY(LLCE_ERROR_RXOUT_FIFO_FULL),
+	LLCE_ERROR_ENTRY(LLCE_ERROR_MB_NOTAVAILABLE),
+	LLCE_ERROR_ENTRY(LLCE_ERROR_BCAN_FRZ_EXIT),
+	LLCE_ERROR_ENTRY(LLCE_ERROR_BCAN_SYNC),
+	LLCE_ERROR_ENTRY(LLCE_ERROR_BCAN_FRZ_ENTER),
+	LLCE_ERROR_ENTRY(LLCE_ERROR_BCAN_LPM_EXIT),
+	LLCE_ERROR_ENTRY(LLCE_ERROR_BCAN_SRT_ENTER),
+	LLCE_ERROR_ENTRY(LLCE_ERROR_BCAN_ACKERR),
+	LLCE_ERROR_ENTRY(LLCE_ERROR_BCAN_CRCERR),
+	LLCE_ERROR_ENTRY(LLCE_ERROR_BCAN_BIT0ERR),
+	LLCE_ERROR_ENTRY(LLCE_ERROR_BCAN_BIT1ERR),
+	LLCE_ERROR_ENTRY(LLCE_ERROR_BCAN_FRMERR),
+	LLCE_ERROR_ENTRY(LLCE_ERROR_BCAN_STFERR),
+	LLCE_ERROR_ENTRY(LLCE_ERROR_DATA_LOST),
+	LLCE_ERROR_ENTRY(LLCE_ERROR_TXLUT_FULL),
+	LLCE_ERROR_ENTRY(LLCE_ERROR_CMD_PROCESSING),
+	LLCE_ERROR_ENTRY(LLCE_ERROR_RXLUT_SLOW_SEARCH),
+	LLCE_ERROR_ENTRY(LLCE_ERROR_RXLUT_ACCESS_MODE),
+	LLCE_ERROR_ENTRY(LLCE_ERROR_RXLUT_SEARCH_MODE),
+	LLCE_ERROR_ENTRY(LLCE_ERROR_RXLUT_SLOW_OPERATION),
+	LLCE_ERROR_ENTRY(LLCE_ERROR_RXLUT_INCOMPLETE_OP),
+	LLCE_ERROR_ENTRY(LLCE_ERROR_RXLUT_OPERATING_MODE),
+	LLCE_ERROR_ENTRY(LLCE_ERROR_RXLUT_INIT_SLOW_OP),
+	LLCE_ERROR_ENTRY(LLCE_ERROR_RXLUT_DEINIT_SLOW_OP),
+	LLCE_ERROR_ENTRY(LLCE_ERROR_RXLUT_INIT_OPERATING_MODE),
+	LLCE_ERROR_ENTRY(LLCE_ERROR_RXLUT_DEINIT_OPERATING_MODE1),
+	LLCE_ERROR_ENTRY(LLCE_ERROR_RXLUT_DEINIT_OPERATING_MODE2),
+	LLCE_ERROR_ENTRY(LLCE_ERROR_HARDWARE_BUSOFF),
+	LLCE_ERROR_ENTRY(LLCE_ERROR_CTRL_NOT_READY),
+	LLCE_ERROR_ENTRY(LLCE_ERROR_BUSOFF),
+	LLCE_ERROR_ENTRY(LLCE_ERROR_FIFO_LOG_FULL),
+	LLCE_ERROR_ENTRY(LLCE_ERROR_CAN2CAN),
+	LLCE_ERROR_ENTRY(LLCE_ERROR_COMMAND_PARAM),
+	LLCE_ERROR_ENTRY(LLCE_ERROR_COMMAND_DEINIT_NOTSTOP),
+	LLCE_ERROR_ENTRY(LLCE_ERROR_RXTOKENS_UNRETURNED),
+	LLCE_ERROR_ENTRY(LLCE_ERROR_TXACK_NOT_READ),
+	LLCE_ERROR_ENTRY(LLCE_ERROR_COMMAND_NOTSUPPORTED),
+	LLCE_ERROR_ENTRY(LLCE_ERROR_COMMAND_NOTVALIDATED),
+	LLCE_ERROR_ENTRY(LLCE_ERROR_COMMAND_NOTACCEPTED),
+	LLCE_ERROR_ENTRY(LLCE_ERROR_COMMAND_INVALID_PARAMS),
+	LLCE_ERROR_ENTRY(LLCE_ERROR_CTRL_NOT_STARTED),
+	LLCE_ERROR_ENTRY(LLCE_ERROR_FRAME_NOT_DELIVERED),
+	LLCE_ERROR_ENTRY(LLCE_ERROR_FRAME_NOT_DELIVERED_TO_AF),
+	LLCE_ERROR_ENTRY(LLCE_ERROR_FRAME_NOT_DELIVERED_TO_HOST),
+	LLCE_ERROR_ENTRY(LLCE_ERROR_LOST_INDEXES),
+	LLCE_ERROR_ENTRY(LLCE_ERROR_FILTERS_FULL),
+	LLCE_ERROR_ENTRY(LLCE_ERROR_FILTERS_NOTEXIST),
+	LLCE_ERROR_ENTRY(LLCE_ERROR_FILTERS_MASK_EMPTY),
+	LLCE_ERROR_ENTRY(LLCE_ERROR_FILTERS_RANGE_EMPTY),
+	LLCE_ERROR_ENTRY(LLCE_ERROR_FILTERS_EM_EMPTY),
+	LLCE_ERROR_ENTRY(LLCE_ERROR_IDX_NOT_VALID_HOST),
+	LLCE_ERROR_ENTRY(LLCE_ERROR_IDX_NOT_VALID_LOG),
+	LLCE_ERROR_ENTRY(LLCE_ERROR_INVALID_HOST_CORE),
+	LLCE_ERROR_ENTRY(LLCE_ERROR_RXFRAME_NOT_DELIVERED_TO_HSE),
+	LLCE_ERROR_ENTRY(LLCE_ERROR_TXFRAME_NOT_DELIVERED_TO_HSE),
+	LLCE_ERROR_ENTRY(LLCE_ERROR_RXFRAME_AUTH_ERROR),
+	LLCE_ERROR_ENTRY(LLCE_ERROR_INVALID_REQUEST_FROM_TX),
+	LLCE_ERROR_ENTRY(LLCE_ERROR_INVALID_REQUEST_FROM_RX),
+	LLCE_ERROR_ENTRY(LLCE_ERROR_RX_SW_FIFO_EMPTY),
+};
+
+const char *llce_modules[] = {
+	LLCE_MODULE_ENTRY(LLCE_TX),
+	LLCE_MODULE_ENTRY(LLCE_RX),
+	LLCE_MODULE_ENTRY(LLCE_DTE),
+	LLCE_MODULE_ENTRY(LLCE_FRPE),
+};
+
+static const struct llce_mb_desc mb_map[] = {
+	[S32G274_LLCE_HIF_CONF_MB] = {
+		.nchan = 2,
+	},
+	[S32G274_LLCE_CAN_CONF_MB] = {
+		.nchan = 16,
+	},
+	[S32G274_LLCE_CAN_RX_MB] = {
+		.nchan = 16,
+		.startup = llce_rx_startup,
+		.shutdown = llce_rx_shutdown,
+	},
+	[S32G274_LLCE_CAN_TX_MB] = {
+		.nchan = 16,
+		.startup = llce_tx_startup,
+		.shutdown = llce_tx_shutdown,
+	},
+};
+
+static const struct llce_icsr icsrs[] = {
+	[LLCE_CAN_ICSR_RXIN_INDEX] = {
+		.icsr0_num = LLCE_CAN_RXIN_ICSR_0_7,
+		.icsr8_num = LLCE_CAN_RXIN_ICSR_8_15,
+	},
+	[LLCE_CAN_ICSR_RXOUT_INDEX] = {
+		.icsr0_num = LLCE_CAN_RXOUT_ICSR_0_7,
+		.icsr8_num = LLCE_CAN_RXOUT_ICSR_8_15,
+	},
+	[LLCE_CAN_ICSR_TXACK_INDEX] = {
+		.icsr0_num = LLCE_CAN_TXACK_ICSR_0_7,
+		.icsr8_num = LLCE_CAN_TXACK_ICSR_8_15,
+	},
+};
+
+static const char *get_error_name(enum llce_can_error err)
+{
+	uint32_t index = err - LLCE_ERROR_TXACK_FIFO_FULL;
+
+	if (index > ARRAY_SIZE(llce_errors))
+		return "Undefined error";
+
+	return llce_errors[index];
+}
+
+static const char *get_module_name(enum llce_can_module module)
+{
+	uint32_t index = module - LLCE_TX;
+
+	if (index > ARRAY_SIZE(llce_modules))
+		return "Unknown module";
+
+	return llce_modules[index];
+}
+
+static unsigned int get_num_chans(void)
+{
+	size_t i;
+	unsigned int num = 0;
+
+	for (i = 0; i < ARRAY_SIZE(mb_map); i++)
+		num += mb_map[i].nchan;
+
+	return num;
+}
+
+static unsigned int get_channels_for_type(unsigned int type)
+{
+	return mb_map[type].nchan;
+}
+
+static unsigned int get_channel_offset(unsigned int type, unsigned int index)
+{
+	size_t i;
+	unsigned int off = index;
+
+	for (i = 0; i < ARRAY_SIZE(mb_map); i++) {
+		if (type == i)
+			return off;
+
+		off += mb_map[i].nchan;
+	}
+
+	return off;
+}
+
+static bool is_tx_fifo_empty(void __iomem *tx_fifo)
+{
+	void __iomem *status = LLCE_FIFO_STATUS0(tx_fifo);
+
+	return !(readl(status) & LLCE_FIFO_FNEMTY);
+}
+
+static void __iomem *get_fifo_by_index(void __iomem *fifo_base,
+				       unsigned int max_index,
+				       unsigned int index)
+{
+	if (index < max_index)
+		return fifo_base + (LLCE_FIFO_SIZE * index);
+
+	return NULL;
+}
+
+static void __iomem *get_rxin_by_index(struct llce_mb *mb, unsigned int index)
+{
+	return get_fifo_by_index(mb->rxin_fifo, LLCE_RXIN_N_FIFO, index);
+}
+
+static void __iomem *get_txack_by_index(struct llce_mb *mb, unsigned int index)
+{
+	return get_fifo_by_index(mb->txack_fifo, LLCE_NTXACK_FIFOS, index);
+}
+
+static void __iomem *get_rxout_by_index(struct llce_mb *mb, unsigned int index)
+{
+	return get_fifo_by_index(mb->rxout_fifo, LLCE_NRXOUT_FIFOS, index);
+}
+
+static void __iomem *get_host_rxin(struct llce_mb *mb, unsigned int host_index)
+{
+	if (host_index == LLCE_CAN_HIF0)
+		return get_rxin_by_index(mb, 16);
+
+	return get_rxin_by_index(mb, 18);
+}
+
+static void __iomem *get_host_notif(struct llce_mb *mb, unsigned int host_index)
+{
+	if (host_index == LLCE_CAN_HIF0)
+		return get_rxin_by_index(mb, 0);
+
+	return get_rxin_by_index(mb, 8);
+}
+
+static void __iomem *get_host_txack(struct llce_mb *mb, unsigned int host_index)
+{
+	if (host_index == LLCE_CAN_HIF0)
+		return get_txack_by_index(mb, 17);
+
+	return get_txack_by_index(mb, 18);
+}
+
+static void __iomem *get_txack_fifo(struct mbox_chan *chan)
+{
+	struct llce_chan_priv *priv = chan->con_priv;
+	struct llce_mb *mb = priv->mb;
+
+	if (priv->type == S32G274_LLCE_HIF_CONF_MB)
+		return get_host_txack(mb, LLCE_CAN_HIF0);
+
+	return get_txack_by_index(mb, priv->index);
+}
+
+static void __iomem *get_rxout_fifo(struct mbox_chan *chan)
+{
+	struct llce_chan_priv *priv = chan->con_priv;
+	struct llce_mb *mb = priv->mb;
+
+	return get_rxout_by_index(mb, priv->index);
+}
+
+static void __iomem *get_blrout_fifo(struct mbox_chan *chan)
+{
+	struct llce_chan_priv *priv = chan->con_priv;
+	struct llce_mb *mb = priv->mb;
+
+	return get_fifo_by_index(mb->blrout_fifo, LLCE_NFIFO_WITH_IRQ,
+				 priv->index);
+}
+
+static void __iomem *get_blrin_fifo(struct mbox_chan *chan)
+{
+	struct llce_chan_priv *priv = chan->con_priv;
+	struct llce_mb *mb = priv->mb;
+
+	return get_fifo_by_index(mb->blrin_fifo, LLCE_NFIFO_WITH_IRQ,
+				 priv->index);
+}
+
+static bool is_config_chan(unsigned int chan_type)
+{
+	return chan_type == S32G274_LLCE_CAN_CONF_MB ||
+		chan_type == S32G274_LLCE_HIF_CONF_MB;
+}
+
+static int init_chan_priv(struct mbox_chan *chan, struct llce_mb *mb,
+			  unsigned int type, unsigned int index)
+{
+	struct llce_chan_priv *priv;
+
+	priv = kmalloc(sizeof(*priv), GFP_KERNEL);
+	if (!priv)
+		return -ENOMEM;
+
+	priv->mb = mb;
+	priv->type = type;
+	priv->index = index;
+
+	chan->con_priv = priv;
+
+	/* Polling for firmware configuration */
+	if (is_config_chan(type)) {
+		chan->txdone_method = TXDONE_BY_POLL;
+		priv->state = LLCE_REGISTERED_CHAN;
+	} else {
+		chan->txdone_method = TXDONE_BY_IRQ;
+		priv->state = LLCE_UNREGISTERED_CHAN;
+	}
+
+	spin_lock_init(&priv->lock);
+
+	return 0;
+}
+
+static void deinit_chan_priv(struct mbox_chan *chan)
+{
+	kfree(chan->con_priv);
+}
+
+static struct mbox_chan *llce_mb_xlate(struct mbox_controller *mbox,
+				       const struct of_phandle_args *args)
+{
+	struct llce_mb *mb = container_of(mbox, struct llce_mb, controller);
+	struct device *dev = mbox->dev;
+	struct mbox_chan *chan;
+	unsigned int type = args->args[0];
+	unsigned int index = args->args[1];
+	unsigned int off;
+	int ret;
+
+	if (type >= ARRAY_SIZE(mb_map)) {
+		dev_err(dev, "%u is not a valid channel type\n", type);
+		return ERR_PTR(-EINVAL);
+	}
+
+	if (index >= get_channels_for_type(type)) {
+		dev_err(dev, "%u exceeds the number of allocated channels for type : %d\n",
+			index, type);
+		return ERR_PTR(-EINVAL);
+	}
+
+	off = get_channel_offset(type, index);
+	if (off >= mbox->num_chans) {
+		dev_err(dev, "Out of bounds access\n");
+		return ERR_PTR(-EINVAL);
+	}
+
+	chan = &mbox->chans[off];
+	ret = init_chan_priv(chan, mb, type, index);
+	if (ret)
+		return ERR_PTR(ret);
+
+	return chan;
+}
+
+static int execute_config_cmd(struct mbox_chan *chan,
+			      struct llce_can_command *cmd)
+{
+	struct llce_chan_priv *priv = chan->con_priv;
+	struct llce_mb *mb = priv->mb;
+	unsigned int idx = priv->index;
+	struct llce_can_command *sh_cmd;
+	void __iomem *txack, *push0;
+	int ret = 0;
+
+	mutex_lock_io(&mb->txack_lock);
+
+	txack = get_host_txack(mb, LLCE_CAN_HIF0);
+
+	sh_cmd = &mb->sh_mem->can_cmd[idx];
+	push0 = LLCE_FIFO_PUSH0(txack);
+
+	if (!is_tx_fifo_empty(txack)) {
+		ret = -EBUSY;
+		goto release_lock;
+	}
+
+	priv->last_msg = cmd;
+	memcpy(sh_cmd, cmd, sizeof(*cmd));
+	sh_cmd->return_value = LLCE_CAN_NOTRUN;
+
+	/* Trigger an interrupt to the LLCE */
+	writel(idx, push0);
+
+release_lock:
+	mutex_unlock(&mb->txack_lock);
+	return ret;
+}
+
+static bool is_blrin_full(struct mbox_chan *chan)
+{
+	void __iomem *blrin = get_blrin_fifo(chan);
+	void __iomem *status1 = LLCE_FIFO_STATUS1(blrin);
+
+	return !!(readl(status1) & LLCE_FIFO_FFULLD);
+}
+
+static uint32_t build_word0(bool rtr, bool ide, uint32_t std_id,
+			    uint32_t ext_id)
+{
+	uint32_t word0;
+
+	if (ide) {
+		word0 = ext_id << CAN_SFF_ID_BITS | std_id | LLCE_CAN_MB_IDE;
+	} else {
+		word0 = (std_id << LLCE_CAN_MB_IDSTD_SHIFT);
+
+		/* No retransmission with CAN FD */
+		if (rtr)
+			word0 |= LLCE_CAN_MB_RTR;
+	}
+
+	return word0;
+}
+
+static int send_can_msg(struct mbox_chan *chan, struct llce_tx_msg *msg)
+{
+	struct llce_chan_priv *priv = chan->con_priv;
+	struct llce_mb *mb = priv->mb;
+	void __iomem *blrout = get_blrout_fifo(chan);
+	void __iomem *pop0 = LLCE_FIFO_POP0(blrout);
+	void __iomem *blrin = get_blrin_fifo(chan);
+	void __iomem *push0 = LLCE_FIFO_PUSH0(blrin);
+	struct llce_can_shared_memory *sh_cmd = mb->sh_mem;
+	unsigned int idx = priv->index;
+	struct canfd_frame *cf = msg->cf;
+	uint32_t mb_index;
+	uint16_t frame_index;
+	uint32_t word0, std_id, ext_id;
+	u8 dlc, *payload;
+	uint32_t mb_config;
+
+	/* Get a free message buffer from BLROUT queue */
+	mb_index = readl(pop0);
+
+	if (mb_index == LLCE_FIFO_NULL_VALUE) {
+		pr_err("All LLCE buffers are in use\n");
+		return -EAGAIN;
+	}
+
+	mb_index &= LLCE_CAN_CONFIG_FIFO_FIXED_MASK;
+
+	std_id = cf->can_id & CAN_SFF_MASK;
+	ext_id = (cf->can_id & CAN_EFF_MASK) >> CAN_SFF_ID_BITS;
+
+	word0 = build_word0(!!(cf->can_id & CAN_RTR_FLAG),
+			    !!(cf->can_id & CAN_EFF_FLAG),
+			    std_id, ext_id);
+
+	/* Get the index of the frame reserved by the firmware */
+	frame_index = sh_cmd->can_tx_mb_desc[mb_index].mb_frame_idx;
+	/* Set CAN ID */
+	sh_cmd->can_mb[frame_index].word0 = word0;
+	/* Attach a token (channel ID) to be used in ACK handler */
+	sh_cmd->can_tx_mb_desc[mb_index].frame_tag1 = idx;
+	sh_cmd->can_tx_mb_desc[mb_index].enable_tx_frame_mac = false;
+	/* Set the notification interface */
+	sh_cmd->can_tx_mb_desc[mb_index].ack_interface = idx;
+	payload = &sh_cmd->can_mb[frame_index].payload[0];
+
+	memcpy(payload, cf->data, cf->len);
+	dlc = can_len2dlc(cf->len);
+
+	mb_config = dlc;
+	if (msg->fd) {
+		/* Configure the tx mb as a CAN FD frame. */
+		mb_config |= LLCE_CAN_MB_FDF;
+
+		/* Enable BRS feature to allow receiveing of CAN FD frames */
+		if (cf->flags & CANFD_BRS)
+			mb_config |= LLCE_CAN_MB_BRS;
+
+		if (cf->flags & CANFD_ESI)
+			mb_config |= LLCE_CAN_MB_ESI;
+	}
+
+	sh_cmd->can_mb[frame_index].word1 = mb_config;
+
+	spin_until_cond(!is_blrin_full(chan));
+
+	/* Submit the buffer in BLRIN queue */
+	writel(mb_index, push0);
+
+	return 0;
+}
+
+static int llce_mb_send_data(struct mbox_chan *chan, void *data)
+{
+	struct llce_chan_priv *priv = chan->con_priv;
+	int ret = -EINVAL;
+
+	if (is_config_chan(priv->type))
+		ret = execute_config_cmd(chan, data);
+
+	if (priv->type == S32G274_LLCE_CAN_TX_MB)
+		ret = send_can_msg(chan, data);
+
+	return ret;
+}
+
+static int llce_rx_startup(struct mbox_chan *chan)
+{
+	void __iomem *rxout = get_rxout_fifo(chan);
+	void __iomem *status0 = LLCE_FIFO_STATUS0(rxout);
+	void __iomem *ier = LLCE_FIFO_IER(rxout);
+	struct llce_chan_priv *priv = chan->con_priv;
+	unsigned long flags;
+
+	/* State change must go under the lock protection */
+	spin_lock_irqsave(&priv->lock, flags);
+
+	priv->state = LLCE_REGISTERED_CHAN;
+
+	/* Clear interrupt status flags. */
+	writel(readl(status0), status0);
+	/* Enable interrupt */
+	writel(LLCE_FIFO_FNEMTY, ier);
+
+	spin_unlock_irqrestore(&priv->lock, flags);
+	return 0;
+}
+
+static void llce_rx_shutdown(struct mbox_chan *chan)
+{
+	void __iomem *rxout = get_rxout_fifo(chan);
+	void __iomem *ier = LLCE_FIFO_IER(rxout);
+	struct llce_chan_priv *priv = chan->con_priv;
+	unsigned long flags;
+
+	spin_lock_irqsave(&priv->lock, flags);
+	priv->state = LLCE_UNREGISTERED_CHAN;
+
+	/* Disable interrupts */
+	writel(0, ier);
+	spin_unlock_irqrestore(&priv->lock, flags);
+}
+
+static void enable_bus_off_irq(struct llce_mb *mb)
+{
+	void __iomem *rxin = get_host_notif(mb, LLCE_CAN_HIF0);
+	void __iomem *ier = LLCE_FIFO_IER(rxin);
+	uint32_t ier_val;
+
+	/* Enable BusOff for host 0 only */
+	ier_val = readl(ier) | LLCE_FIFO_FNEMTY;
+	writel(ier_val, ier);
+}
+
+static int llce_tx_startup(struct mbox_chan *chan)
+{
+	void __iomem *txack = get_txack_fifo(chan);
+	void __iomem *status1 = LLCE_FIFO_STATUS1(txack);
+	void __iomem *ier = LLCE_FIFO_IER(txack);
+	struct llce_chan_priv *priv = chan->con_priv;
+	struct llce_mb *mb = priv->mb;
+	unsigned long flags;
+
+	spin_lock_irqsave(&priv->lock, flags);
+	priv->state = LLCE_REGISTERED_CHAN;
+
+	/* Clear interrupt status flags. */
+	writel(readl(status1), status1);
+	/* Enable interrupt */
+	writel(LLCE_FIFO_FNEMTY, ier);
+	enable_bus_off_irq(mb);
+
+	spin_unlock_irqrestore(&priv->lock, flags);
+
+	return 0;
+}
+
+static void llce_tx_shutdown(struct mbox_chan *chan)
+{
+	struct llce_chan_priv *priv = chan->con_priv;
+	void __iomem *txack = get_txack_fifo(chan);
+	void __iomem *ier = LLCE_FIFO_IER(txack);
+	unsigned long flags;
+
+	spin_lock_irqsave(&priv->lock, flags);
+	priv->state = LLCE_UNREGISTERED_CHAN;
+
+	/* Disable interrupts */
+	writel(0, ier);
+
+	spin_unlock_irqrestore(&priv->lock, flags);
+}
+
+static int llce_mb_startup(struct mbox_chan *chan)
+{
+	struct llce_chan_priv *priv = chan->con_priv;
+
+	if (mb_map[priv->type].startup)
+		return mb_map[priv->type].startup(chan);
+
+	return 0;
+}
+
+static void llce_mbox_chan_received_data(struct mbox_chan *chan, void *mssg)
+{
+	struct llce_chan_priv *priv = chan->con_priv;
+	unsigned long flags;
+
+	spin_lock_irqsave(&priv->lock, flags);
+
+	if (priv->state == LLCE_REGISTERED_CHAN)
+		mbox_chan_received_data(chan, mssg);
+
+	spin_unlock_irqrestore(&priv->lock, flags);
+}
+
+static bool llce_mb_last_tx_done(struct mbox_chan *chan)
+{
+	struct llce_chan_priv *priv = chan->con_priv;
+	unsigned int idx = priv->index;
+	void __iomem *txack;
+	struct llce_mb *mb = priv->mb;
+	struct llce_can_command *cmd;
+	struct llce_can_command *sh_cmd;
+
+	if (!is_config_chan(priv->type))
+		return false;
+
+	mutex_lock_io(&mb->txack_lock);
+
+	txack = get_host_txack(mb, LLCE_CAN_HIF0);
+
+	/* Wait an answer from LLCE FW */
+	spin_until_cond(is_tx_fifo_empty(txack));
+
+	cmd = priv->last_msg;
+	sh_cmd = &mb->sh_mem->can_cmd[idx];
+
+	memcpy(cmd, sh_cmd, sizeof(*cmd));
+
+	mutex_unlock(&mb->txack_lock);
+
+	if (priv->type != S32G274_LLCE_HIF_CONF_MB)
+		llce_mbox_chan_received_data(chan, cmd);
+
+	return true;
+}
+
+static void llce_mb_shutdown(struct mbox_chan *chan)
+{
+	struct llce_chan_priv *priv = chan->con_priv;
+
+	if (mb_map[priv->type].shutdown)
+		mb_map[priv->type].shutdown(chan);
+
+	deinit_chan_priv(chan);
+}
+
+static const struct mbox_chan_ops llce_mb_ops = {
+	.send_data = llce_mb_send_data,
+	.startup = llce_mb_startup,
+	.shutdown = llce_mb_shutdown,
+	.last_tx_done = llce_mb_last_tx_done,
+};
+
+static void devm_sram_pool_release(struct device *dev, void *res)
+{
+	struct sram_pool *spool = res;
+
+	gen_pool_free(spool->pool, spool->vaddr, spool->size);
+}
+
+static struct sram_pool *devm_sram_pool_alloc(struct device *dev,
+					      struct gen_pool *pool)
+{
+	struct sram_pool *spool = devres_alloc(devm_sram_pool_release,
+					       sizeof(*spool), GFP_KERNEL);
+
+	if (!spool)
+		return ERR_PTR(-ENOMEM);
+
+	spool->size = gen_pool_size(pool);
+	spool->vaddr = gen_pool_alloc(pool, spool->size);
+	if (!spool->vaddr) {
+		devres_free(spool);
+		return ERR_PTR(-ENOMEM);
+	}
+
+	spool->pool = pool;
+	devres_add(dev, spool);
+
+	return spool;
+}
+
+static int alloc_sram_pool(struct platform_device *pdev,
+			   struct llce_mb *mb)
+{
+	struct device_node *sram_node;
+	struct device *dev = &pdev->dev;
+	struct gen_pool *pool;
+	const char *name;
+	struct sram_pool *spool;
+	struct platform_device *sram_pdev;
+
+	sram_node = of_parse_phandle(pdev->dev.of_node, "memory-region", 0);
+	if (!sram_node) {
+		dev_err(&pdev->dev, "Failed to get 'memory-region'\n");
+		return -EIO;
+	}
+
+	name = sram_node->name;
+	sram_pdev = of_find_device_by_node(sram_node);
+	if (!sram_pdev) {
+		dev_err(dev, "failed to find sram device for '%s'!\n", name);
+		return -ENODEV;
+	}
+
+	pool = gen_pool_get(&sram_pdev->dev, NULL);
+	if (!pool) {
+		dev_err(dev, "Pool '%s' is unavailable!\n", name);
+		return -ENODEV;
+	}
+
+	spool = devm_sram_pool_alloc(dev, pool);
+	if (IS_ERR(spool)) {
+		dev_err(dev, "Unable to alloc '%s' pool\n", name);
+		return PTR_ERR(spool);
+	}
+
+	mb->sh_mem = (void *)spool->vaddr;
+
+	return 0;
+}
+
+static void __iomem *get_icsr(struct llce_mb *mb, struct llce_fifoirq *irqs,
+			      uint32_t icsr_index, int irq,
+			      uint8_t *base_id)
+{
+	uint32_t icsr_id;
+	const struct llce_icsr *icsrs_conf = &icsrs[icsr_index];
+
+	if (irq == irqs->irq0) {
+		icsr_id = icsrs_conf->icsr0_num;
+		*base_id = 0;
+	} else {
+		icsr_id = icsrs_conf->icsr8_num;
+		*base_id = 8;
+	}
+
+	return mb->icsr + icsr_id * sizeof(uint32_t);
+}
+
+static void __iomem *get_txack_icsr(struct llce_mb *mb, int irq,
+				    uint8_t *base_id)
+{
+	return get_icsr(mb, &mb->txack_irqs, LLCE_CAN_ICSR_TXACK_INDEX,
+			irq, base_id);
+}
+
+static void __iomem *get_rxin_icsr(struct llce_mb *mb, int irq,
+				   uint8_t *base_id)
+{
+	return get_icsr(mb, &mb->rxin_irqs, LLCE_CAN_ICSR_RXIN_INDEX,
+			irq, base_id);
+}
+
+static void __iomem *get_rxout_icsr(struct llce_mb *mb, int irq,
+				   uint8_t *base_id)
+{
+	return get_icsr(mb, &mb->rxout_irqs, LLCE_CAN_ICSR_RXOUT_INDEX,
+			irq, base_id);
+}
+
+static void llce_process_tx_ack(struct llce_mb *mb, uint8_t index)
+{
+	void __iomem *tx_ack = get_txack_by_index(mb, index);
+	void __iomem *status1 = LLCE_FIFO_STATUS1(tx_ack);
+	void __iomem *pop0 = LLCE_FIFO_POP0(tx_ack);
+	struct mbox_controller *ctrl = &mb->controller;
+	struct llce_can_shared_memory *sh_mem = mb->sh_mem;
+	struct llce_can_tx2host_ack_info *info;
+	struct llce_notif notif;
+	uint32_t ack_id;
+	unsigned int chan_index;
+
+	while (!(readl(status1) & LLCE_FIFO_FEMTYD)) {
+		/* Get ACK mailbox */
+		ack_id = readl(pop0) & LLCE_CAN_CONFIG_FIFO_FIXED_MASK;
+
+		info = &sh_mem->can_tx_ack_info[ack_id];
+		chan_index = get_channel_offset(S32G274_LLCE_CAN_TX_MB,
+						info->frame_tag1);
+		notif.error = 0;
+		notif.tx_timestamp = info->tx_timestamp;
+
+		/* Notify the client and send the timestamp */
+		llce_mbox_chan_received_data(&ctrl->chans[chan_index], &notif);
+		mbox_chan_txdone(&ctrl->chans[chan_index], 0);
+	}
+
+	/* Clear the interrupt status flag. */
+	writel(LLCE_FIFO_FNEMTY, status1);
+}
+
+static void process_chan_err(struct llce_mb *mb, uint32_t chan_type,
+			     struct llce_can_channel_error_notif *error)
+{
+	unsigned int chan_index;
+	struct mbox_controller *ctrl = &mb->controller;
+	struct llce_notif notif = {
+		.error = error->error_info.error_code,
+	};
+
+	chan_index = get_channel_offset(chan_type, error->hw_ctrl);
+	notif.error = error->error_info.error_code;
+
+	/* Release the channel if an error occurred */
+	if (chan_type == S32G274_LLCE_CAN_TX_MB)
+		mbox_chan_txdone(&ctrl->chans[chan_index], 0);
+
+	llce_mbox_chan_received_data(&ctrl->chans[chan_index], &notif);
+}
+
+static void process_channel_err(struct llce_mb *mb,
+				struct llce_can_channel_error_notif *error)
+{
+	enum llce_can_module module_id = error->error_info.module_id;
+
+	dev_warn(mb->controller.dev, "Error module:%s Error:%s HW module:%d\n",
+		 get_module_name(module_id),
+		 get_error_name(error->error_info.error_code),
+		 error->hw_ctrl);
+
+	switch (module_id) {
+	case LLCE_TX:
+		return process_chan_err(mb, S32G274_LLCE_CAN_TX_MB, error);
+	case LLCE_RX:
+		return process_chan_err(mb, S32G274_LLCE_CAN_RX_MB, error);
+	default:
+		break;
+	}
+}
+
+static void process_platform_err(struct llce_mb *mb,
+				 struct llce_can_error_notif *error)
+{
+}
+
+static void process_ctrl_err(struct llce_mb *mb,
+			     struct llce_can_ctrl_mode_notif *error)
+{
+}
+
+static void llce_process_rxin(struct llce_mb *mb, uint8_t index)
+{
+	void __iomem *rxin = get_rxin_by_index(mb, index);
+	void __iomem *status1 = LLCE_FIFO_STATUS1(rxin);
+	void __iomem *pop0 = LLCE_FIFO_POP0(rxin);
+	struct llce_can_shared_memory *sh_mem = mb->sh_mem;
+	struct llce_can_notification_table *table;
+	struct llce_can_notification *notif;
+	union llce_can_notification_list *list;
+
+	uint32_t rxin_id;
+
+	while (!(readl(status1) & LLCE_FIFO_FEMTYD)) {
+		/* Get notification mailbox */
+		rxin_id = readl(pop0) & LLCE_CAN_CONFIG_FIFO_FIXED_MASK;
+		table = &sh_mem->can_notification_table;
+		notif = &table->can_notif_intr_table[LLCE_CAN_HIF0][rxin_id];
+		list = &notif->notif_list;
+
+		switch (notif->notif_id) {
+		case LLCE_CAN_NOTIF_CHANNELERROR:
+			process_channel_err(mb, &list->channel_error);
+			break;
+		case LLCE_CAN_NOTIF_PLATFORMERROR:
+			process_platform_err(mb, &list->platform_error);
+			break;
+		case LLCE_CAN_NOTIF_CTRLMODE:
+			process_ctrl_err(mb, &list->ctrl_mode);
+			break;
+		case LLCE_CAN_NOTIF_NOERROR:
+			break;
+		}
+	}
+
+	/* Clear the interrupt status flag. */
+	writel(LLCE_FIFO_FNEMTY, status1);
+}
+
+static void read_rxout_message(struct llce_mb *mb, uint32_t rx_mb,
+			       uint8_t rx_index)
+{
+	struct mbox_controller *ctrl = &mb->controller;
+	struct llce_can_shared_memory *sh_mem = mb->sh_mem;
+	struct llce_notif notif = {
+		.error = 0,
+	};
+	uint32_t frame_id;
+	unsigned int chan_index;
+
+	frame_id = sh_mem->can_rx_mb_desc[rx_mb].mb_frame_idx;
+	chan_index = get_channel_offset(S32G274_LLCE_CAN_RX_MB, rx_index);
+	notif.can_mb = &sh_mem->can_mb[frame_id];
+	llce_mbox_chan_received_data(&ctrl->chans[chan_index], &notif);
+}
+
+static void llce_process_rxout(struct llce_mb *mb, uint8_t index)
+{
+	void __iomem *host_rxin = get_host_rxin(mb, LLCE_CAN_HIF0);
+	void __iomem *rxout = get_rxout_by_index(mb, index);
+	void __iomem *status1 = LLCE_FIFO_STATUS1(rxout);
+	void __iomem *pop0 = LLCE_FIFO_POP0(rxout);
+	void __iomem *host_push0 = LLCE_FIFO_PUSH0(host_rxin);
+	uint32_t rx_mb;
+
+	while (!(readl(status1) & LLCE_FIFO_FEMTYD)) {
+		/* Get RX mailbox */
+		rx_mb = readl(pop0) & LLCE_CAN_CONFIG_FIFO_FIXED_MASK;
+		/* Process RX message */
+		read_rxout_message(mb, rx_mb, index);
+		/* Make the index available for another reception flow */
+		writel(rx_mb, host_push0);
+	}
+
+	/* Clear the interrupt status flag. */
+	writel(LLCE_FIFO_FNEMTY, status1);
+}
+
+typedef void (*icsr_consumer_t)(struct llce_mb *, uint8_t);
+
+static void llce_consume_icsr(struct llce_mb *mb, void __iomem *icsr_addr,
+			      uint8_t base, icsr_consumer_t callback)
+{
+	uint32_t icsr;
+	uint8_t i;
+
+	icsr = readl(icsr_addr);
+	for (i = 0; i < LLCE_CAN_ICSR_N_ACK; i++) {
+		if (!(icsr & BIT(i)))
+			continue;
+
+		callback(mb, base + i);
+	}
+}
+
+static irqreturn_t llce_rxin_fifo_irq(int irq, void *data)
+{
+	struct llce_mb *mb = data;
+	uint8_t base_icsr;
+	void __iomem *icsr_addr = get_rxin_icsr(mb, irq, &base_icsr);
+
+	llce_consume_icsr(mb, icsr_addr, base_icsr, llce_process_rxin);
+
+	return IRQ_HANDLED;
+}
+
+static irqreturn_t llce_txack_fifo_irq(int irq, void *data)
+{
+	struct llce_mb *mb = data;
+	uint8_t base_icsr;
+	void __iomem *icsr_addr = get_txack_icsr(mb, irq, &base_icsr);
+
+	llce_consume_icsr(mb, icsr_addr, base_icsr, llce_process_tx_ack);
+
+	return IRQ_HANDLED;
+}
+
+static irqreturn_t llce_rxout_fifo_irq(int irq, void *data)
+{
+	struct llce_mb *mb = data;
+	uint8_t base_icsr;
+	void __iomem *icsr_addr = get_rxout_icsr(mb, irq, &base_icsr);
+
+	llce_consume_icsr(mb, icsr_addr, base_icsr, llce_process_rxout);
+
+	return IRQ_HANDLED;
+}
+
+static int init_llce_irq_resources(struct platform_device *pdev,
+				   struct llce_mb *mb)
+{
+	int irq, ret;
+	size_t i;
+	struct device *dev = &pdev->dev;
+	struct {
+		const char *name;
+		int *irq;
+		irq_handler_t handler;
+	} resources[] = {
+		{
+			.name = "rxin_fifo_0_7",
+			.irq = &mb->rxin_irqs.irq0,
+			.handler = llce_rxin_fifo_irq,
+		},
+		{
+			.name = "rxin_fifo_8_15",
+			.irq = &mb->rxin_irqs.irq8,
+			.handler = llce_rxin_fifo_irq,
+		},
+		{
+			.name = "rxout_fifo_0_7",
+			.irq = &mb->rxout_irqs.irq0,
+			.handler = llce_rxout_fifo_irq,
+		},
+		{
+			.name = "rxout_fifo_8_15",
+			.irq = &mb->rxout_irqs.irq8,
+			.handler = llce_rxout_fifo_irq,
+		},
+		{
+			.name = "txack_fifo_0_7",
+			.irq = &mb->txack_irqs.irq0,
+			.handler = llce_txack_fifo_irq,
+		},
+		{
+			.name = "txack_fifo_8_15",
+			.irq = &mb->txack_irqs.irq8,
+			.handler = llce_txack_fifo_irq,
+		},
+	};
+
+	for (i = 0; i < ARRAY_SIZE(resources); i++) {
+		irq = platform_get_irq_byname(pdev, resources[i].name);
+		if (irq < 0) {
+			dev_err(dev, "Failed to request '%s' IRQ\n",
+				resources[i].name);
+			return irq;
+		}
+
+		*resources[i].irq = irq;
+		ret = devm_request_irq(dev, irq, resources[i].handler,
+				       IRQF_SHARED,
+				       resources[i].name, mb);
+		if (ret < 0) {
+			dev_err(&pdev->dev,
+				"Failed to register '%s' IRQ\n",
+				resources[i].name);
+			return ret;
+		}
+	}
+
+	return 0;
+}
+
+static int init_llce_mem_resources(struct platform_device *pdev,
+				   struct llce_mb *mb)
+{
+	size_t i;
+	struct resource *res;
+	void __iomem *vaddr;
+	struct device *dev = &pdev->dev;
+	struct {
+		const char *res_name;
+		void __iomem **vaddr;
+	} resources[] = {
+		{ .res_name = "rxout_fifo", .vaddr = &mb->rxout_fifo, },
+		{ .res_name = "txack_fifo", .vaddr = &mb->txack_fifo, },
+		{ .res_name = "blrout_fifo", .vaddr = &mb->blrout_fifo, },
+		{ .res_name = "blrin_fifo", .vaddr = &mb->blrin_fifo, },
+		{ .res_name = "rxin_fifo", .vaddr = &mb->rxin_fifo, },
+		{ .res_name = "icsr", .vaddr = &mb->icsr, },
+	};
+
+	for (i = 0; i < ARRAY_SIZE(resources); i++) {
+		res = platform_get_resource_byname(pdev, IORESOURCE_MEM,
+						   resources[i].res_name);
+		if (!res) {
+			dev_err(dev, "Missing '%s' reg region.\n",
+				resources[i].res_name);
+			return -EIO;
+		}
+
+		vaddr = devm_ioremap(dev, res->start,
+				     resource_size(res));
+		if (!vaddr) {
+			dev_err(dev, "Failed to map '%s'\n",
+				resources[i].res_name);
+			return -ENOMEM;
+		}
+
+		*resources[i].vaddr = vaddr;
+	}
+
+	return 0;
+}
+
+static int get_llce_can_id(const char *node_name, unsigned long *id)
+{
+	const char *p = node_name + strlen(node_name) - 1;
+
+	while (isdigit(*p))
+		p--;
+
+	return kstrtoul(p + 1, 10, id);
+}
+
+static struct mbox_chan *get_hif_cfg_chan(struct llce_mb *mb)
+{
+	struct mbox_controller *ctrl = &mb->controller;
+	unsigned int chan_index;
+
+	chan_index = get_channel_offset(S32G274_LLCE_HIF_CONF_MB,
+					LLCE_CAN_HIF0);
+	return &ctrl->chans[chan_index];
+}
+
+static int init_hif_config_chan(struct llce_mb *mb)
+{
+	struct mbox_chan *chan = get_hif_cfg_chan(mb);
+
+	return init_chan_priv(chan, mb, S32G274_LLCE_HIF_CONF_MB,
+			      LLCE_CAN_HIF0);
+}
+
+static void deinit_hif_config_chan(struct llce_mb *mb)
+{
+	struct mbox_chan *chan = get_hif_cfg_chan(mb);
+
+	deinit_chan_priv(chan);
+}
+
+static int execute_hif_cmd(struct llce_mb *mb,
+			   struct llce_can_command *cmd)
+{
+	struct mbox_controller *ctrl = &mb->controller;
+	struct device *dev = ctrl->dev;
+	static struct mbox_chan *chan;
+	int ret;
+
+	chan = get_hif_cfg_chan(mb);
+
+	ret = execute_config_cmd(chan, cmd);
+	if (ret) {
+		dev_err(dev, "Failed to send command\n");
+		return ret;
+	}
+
+	/* Wait for command completion */
+	if (!llce_mb_last_tx_done(chan))
+		return -EIO;
+
+	if (cmd->return_value != LLCE_CAN_SUCCESS) {
+		dev_err(dev, "LLCE FW error %d\n", cmd->return_value);
+		return -EIO;
+	}
+
+	return 0;
+}
+
+static int llce_platform_init(struct device *dev, struct llce_mb *mb)
+{
+	struct device_node *child, *parent;
+	struct llce_can_init_platform_cmd *pcmd;
+	const char *node_name;
+	unsigned long id;
+	int ret;
+
+	struct llce_can_command cmd = {
+		.cmd_id = LLCE_CAN_CMD_INIT_PLATFORM,
+		.cmd_list.init_platform = {
+			.can_error_reporting = {
+				.can_protocol_err = INTERRUPT,
+				.data_lost_err = INTERRUPT,
+				.init_err = INTERRUPT,
+				.internal_err = INTERRUPT,
+			},
+		},
+	};
+
+	pcmd = &cmd.cmd_list.init_platform;
+	memset(&pcmd->ctrl_init_status, UNINITIALIZED,
+	       sizeof(pcmd->ctrl_init_status));
+	memset(&pcmd->max_int_tx_ack_count, 0,
+	       sizeof(pcmd->max_int_tx_ack_count));
+	memset(&pcmd->max_poll_tx_ack_count, 0,
+	       sizeof(pcmd->max_poll_tx_ack_count));
+	memset(&pcmd->can_error_reporting.bus_off_err, IGNORE,
+	       sizeof(pcmd->can_error_reporting.bus_off_err));
+	memset(&pcmd->max_filter_count, 0, sizeof(pcmd->max_filter_count));
+	memset(&pcmd->max_int_mb_count, 0, sizeof(pcmd->max_int_mb_count));
+	memset(&pcmd->max_poll_mb_count, 0, sizeof(pcmd->max_poll_mb_count));
+
+	parent = dev->of_node->parent;
+
+	for_each_child_of_node(dev->of_node->parent, child) {
+		if (!(of_device_is_compatible(child, LLCE_CAN_COMPATIBLE) &&
+		      of_device_is_available(child)))
+			continue;
+
+		node_name = child->name;
+		ret = get_llce_can_id(node_name, &id);
+		if (ret) {
+			dev_err(dev, "Failed to get ID of the node: %s\n",
+				node_name);
+			return ret;
+		}
+
+		if (id >= LLCE_NFIFO_WITH_IRQ)
+			continue;
+
+		pcmd->ctrl_init_status[id] = INITIALIZED;
+		pcmd->max_filter_count[id] = 16;
+		pcmd->max_int_mb_count[id] = 100;
+		pcmd->max_int_tx_ack_count[id] = 16;
+		pcmd->can_error_reporting.bus_off_err[id] = INTERRUPT;
+	}
+
+	return execute_hif_cmd(mb, &cmd);
+}
+
+static int llce_platform_deinit(struct llce_mb *mb)
+{
+	struct llce_can_command cmd = {
+		.cmd_id = LLCE_CAN_CMD_DEINIT_PLATFORM,
+	};
+
+	return execute_hif_cmd(mb, &cmd);
+}
+
+static int print_fw_version(struct llce_mb *mb)
+{
+	struct mbox_controller *ctrl = &mb->controller;
+	struct device *dev = ctrl->dev;
+	struct llce_can_get_fw_version *ver;
+	char *ver_str;
+	struct llce_can_command cmd = {
+		.cmd_id = LLCE_CAN_CMD_GETFWVERSION,
+	};
+	int ret;
+
+	ret = execute_hif_cmd(mb, &cmd);
+	if (ret)
+		return ret;
+
+	ver = &cmd.cmd_list.get_fw_version;
+	ver_str = ver->version_string;
+
+	dev_info(dev, "LLCE interface version: %c\n",
+		 ver_str[LLCE_VERSION_INTERFACE]);
+	dev_info(dev, "LLCE basic version: %c\n",
+		 ver_str[LLCE_VERSION_BASIC_FUNC]);
+	dev_info(dev, "LLCE CAN2CAN version: %c\n",
+		 ver_str[LLCE_VERSION_ROUTING_CAN2CAN]);
+	dev_info(dev, "LLCE CAN2ETH version: %c\n",
+		 ver_str[LLCE_VERSION_ROUTING_CAN2ETH]);
+	dev_info(dev, "LLCE CAN logging version: %c\n",
+		 ver_str[LLCE_VERSION_LOGGING]);
+
+	return 0;
+}
+
+static int init_core_clock(struct device *dev, struct clk **clk)
+{
+	int ret;
+
+	*clk = devm_clk_get(dev, "llce_sys");
+	if (IS_ERR(*clk)) {
+		dev_err(dev, "No clock available\n");
+		return PTR_ERR(*clk);
+	}
+
+	ret = clk_prepare_enable(*clk);
+	if (ret) {
+		dev_err(dev, "Failed to enable clock\n");
+		return ret;
+	}
+
+	return 0;
+}
+
+static void deinit_core_clock(struct clk *clk)
+{
+	clk_disable_unprepare(clk);
+}
+
+static int llce_mb_probe(struct platform_device *pdev)
+{
+	struct mbox_controller *ctrl;
+	struct llce_mb *mb;
+	struct device *dev = &pdev->dev;
+	int ret;
+
+	mb = devm_kzalloc(&pdev->dev, sizeof(*mb), GFP_KERNEL);
+	if (!mb)
+		return -ENOMEM;
+
+	mutex_init(&mb->txack_lock);
+
+	ctrl = &mb->controller;
+	ctrl->txdone_irq = false;
+	ctrl->txdone_poll = true;
+	ctrl->txpoll_period = 1;
+	ctrl->of_xlate = llce_mb_xlate;
+	ctrl->num_chans = get_num_chans();
+	ctrl->dev = dev;
+	ctrl->ops = &llce_mb_ops;
+
+	ctrl->chans = devm_kcalloc(dev, ctrl->num_chans,
+				   sizeof(*ctrl->chans), GFP_KERNEL);
+	if (!ctrl->chans)
+		return -ENOMEM;
+
+	platform_set_drvdata(pdev, mb);
+
+	ret = init_llce_mem_resources(pdev, mb);
+	if (ret)
+		return ret;
+
+	ret = init_llce_irq_resources(pdev, mb);
+	if (ret)
+		return ret;
+
+	ret = alloc_sram_pool(pdev, mb);
+	if (ret)
+		return ret;
+
+	ret = init_hif_config_chan(mb);
+	if (ret) {
+		dev_err(dev, "Failed to initialize HIF config channel\n");
+		return ret;
+	}
+
+	ret = init_core_clock(dev, &mb->clk);
+	if (ret)
+		goto hif_deinit;
+
+	ret = print_fw_version(mb);
+	if (ret) {
+		dev_err(dev, "Failed to get firmware version\n");
+		goto disable_clk;
+	}
+
+	ret = llce_platform_init(dev, mb);
+	if (ret) {
+		dev_err(dev, "Failed to initialize platform\n");
+		goto disable_clk;
+	}
+
+	ret = devm_mbox_controller_register(dev, ctrl);
+	if (ret < 0) {
+		dev_err(dev, "Failed to register can config mailbox: %d\n",
+			ret);
+		goto deinit_plat;
+	}
+
+deinit_plat:
+	if (ret)
+		llce_platform_deinit(mb);
+
+disable_clk:
+	if (ret)
+		deinit_core_clock(mb->clk);
+
+hif_deinit:
+	if (ret)
+		deinit_hif_config_chan(mb);
+
+	return ret;
+}
+
+static int llce_mb_remove(struct platform_device *pdev)
+{
+	struct llce_mb *mb = platform_get_drvdata(pdev);
+	struct device *dev = &pdev->dev;
+	int ret;
+
+	ret = llce_platform_deinit(mb);
+	if (ret) {
+		dev_err(dev, "Failed to deinitialize LLCE platform");
+		return ret;
+	}
+
+	deinit_core_clock(mb->clk);
+	deinit_hif_config_chan(mb);
+
+	return 0;
+}
+
+static const struct of_device_id llce_mb_match[] = {
+	{
+		.compatible = "nxp,s32g274a-llce-mailbox",
+	},
+	{ /* sentinel */ }
+};
+MODULE_DEVICE_TABLE(of, llce_mb_match);
+
+static struct platform_driver llce_mb_driver = {
+	.probe = llce_mb_probe,
+	.remove = llce_mb_remove,
+	.driver = {
+		.name = "llce_mb",
+		.of_match_table = llce_mb_match,
+	},
+};
+module_platform_driver(llce_mb_driver)
+
+MODULE_AUTHOR("Ghennadi Procopciuc <ghennadi.procopciuc@nxp.com>");
+MODULE_DESCRIPTION("NXP LLCE Mailbox");
+MODULE_LICENSE("GPL");
diff --git a/include/linux/mailbox/nxp-llce/llce_can.h b/include/linux/mailbox/nxp-llce/llce_can.h
new file mode 100644
index 000000000000..32ee884e7a73
--- /dev/null
+++ b/include/linux/mailbox/nxp-llce/llce_can.h
@@ -0,0 +1,1364 @@
+/* SPDX-License-Identifier: GPL-2.0+ */
+/* Copyright 2020 NXP */
+#ifndef LLCE_INTERFACECANTYPES_H
+#define LLCE_INTERFACECANTYPES_H
+
+#include <linux/types.h>
+#include "llce_fw_version.h"
+#include "llce_interface_config.h"
+
+/**
+ * Controller option used by the initialization command in order to
+ * inform LLCE firmware that a specific controller shall be initialized.
+ * See struct llce_can_init_cmd
+ */
+#define LLCE_CAN_CONTROLLERCONFIG_CTRL_EN (0x10000000U)
+/** Not used currently by LLCE firmware.*/
+#define LLCE_CAN_CONTROLLERCONFIG_RXPOL_EN (0x00000400U)
+/** Not used currently by LLCE firmware.*/
+#define LLCE_CAN_CONTROLLERCONFIG_RXINT_EN (0x00000200U)
+/** Not used currently by LLCE firmware.*/
+#define LLCE_CAN_CONTROLLERCONFIG_TXPOL_EN (0x00000800U)
+/** Not used currently by LLCE firmware.*/
+#define LLCE_CAN_CONTROLLERCONFIG_TXINT_EN (0x00000100U)
+/** Not used currently by LLCE firmware.*/
+#define LLCE_CAN_CONTROLLERCONFIG_BOPOL_EN (0x00001000U)
+/** Not used currently by LLCE firmware.*/
+#define LLCE_CAN_CONTROLLERCONFIG_ERR_EN (0x00020000U)
+/**
+ * CAN controller option used to enable reporting of the Protocol
+ * Exception errors.See struct llce_can_get_status_cmd.
+ */
+#define LLCE_CAN_CONTROLLERCONFIG_PE_EN (0x00040000U)
+/** CAN controller option used to enable Timestamp feature. */
+#define LLCE_CAN_CONTROLLERCONFIG_TST_END (0x00080000U)
+/**
+ * CAN controller option used to enable Timestamp feature at the start
+ * of the CAN frame.
+ */
+#define LLCE_CAN_CONTROLLERCONFIG_TST_START (0x00000080U)
+/**
+ * CAN controller option used to enable Timestamp feature in the start
+ * of frame for classical CAN frames and in the res bit for CAN FD frames.
+ */
+#define LLCE_CAN_CONTROLLERCONFIG_TST_FD (0x00000040U)
+/** CAN controller option used to enable Listen-Only mode. */
+#define LLCE_CAN_CONTROLLERCONFIG_LOM_EN (0x00100000U)
+/** CAN controller option used to enable internal Loop_back mode. */
+#define LLCE_CAN_CONTROLLERCONFIG_LPB_EN (0x00200000U)
+/** CAN controller option used to enable self-reception mode. */
+#define LLCE_CAN_CONTROLLERCONFIG_SRX_EN (0x00400000U)
+/** CAN controller option used to enable automatic bus-off recovery. */
+#define LLCE_CAN_CONTROLLERCONFIG_ABR_EN (0x00000001U)
+
+/**
+ * Number of interfaces used for interrupt reporting (one per channel)
+ * + number of polling classes.
+ */
+#define LLCE_CAN_RX_TX_INTERFACES                                              \
+	((u8)(LLCE_CAN_CONFIG_MAXCTRL_COUNT + LLCE_CAN_MAX_POLLING_CLASSES))
+/** Not used currently by LLCE firmware.*/
+#define LLCE_CAN_REFERENCE_NOT_USED (0xFFU)
+/**
+ * Default value in the transmission request informing LLCE that tx
+ * confirmation is not needed for that frame.
+ */
+#define LLCE_CAN_ACK_DISABLED (0xADU)
+
+/** Frame DLC field mask. */
+#define LLCE_CAN_MB_DLC_MASK (0x0000000FU)
+/** Frame ID field mask. */
+#define LLCE_CAN_MB_ID_MASK (0x1FFFFFFFU)
+/** Frame FDF field mask. */
+#define LLCE_CAN_MB_FDF (0x00008000U)
+/** Frame BRS field mask. */
+#define LLCE_CAN_MB_BRS (0x00010000U)
+/** Frame ESI field mask. */
+#define LLCE_CAN_MB_ESI (0x00020000U)
+/** Frame IDE field mask. */
+#define LLCE_CAN_MB_IDE (0x40000000U)
+/** Frame RTR field mask. */
+#define LLCE_CAN_MB_RTR (0x80000000U)
+/** Frame standard ID field mask. */
+#define LLCE_CAN_MB_IDSTD_MASK (0x1FFC0000U)
+/** Frame extended ID field mask. */
+#define LLCE_CAN_MB_IDEXT_MASK (0x0003FFFFU)
+/** Routing feature default configuration. */
+#define LLCE_CAN_ROUTING_OPTION_DEFAULT_CONFIG (0x00000000U)
+/** Routing feature mask for non-converting frame. */
+#define LLCE_CAN_ROUTING_NOCHANGE (0x00000001U)
+/** Routing feature mask for converting frame (CANFD->CAN). */
+#define LLCE_CAN_ROUTING_CAN (0x00000002U)
+/** Routing feature mask for converting frame (CAN->CANFD). */
+#define LLCE_CAN_ROUTING_CANFD (0x00000004U)
+/** Routing feature mask for id remapping. */
+#define LLCE_CAN_ROUTING_ID_REMAPPING_EN (0x00000008U)
+
+/** Shift value for extracting FD flag  from CAN frame. */
+#define LLCE_CAN_MB_FDF_SHIFT (15U)
+/** Shift value for extracting Baud Rate Switch flag from CAN frame. */
+#define LLCE_CAN_MB_BRS_SHIFT (16U)
+/** Shift value for extracting ESI flag feature from CAN frame. */
+#define LLCE_CAN_MB_ESI_SHIFT (17U)
+/** Shift value for extracting frame ID from CAN frame. */
+#define LLCE_CAN_MB_IDSTD_SHIFT (18U)
+/** Shift value for extracting IDE flag from CAN frame. */
+#define LLCE_CAN_MB_IDE_SHIFT (30U)
+/** Shift value for extracting RTR flag from CAN frame. */
+#define LLCE_CAN_MB_RTR_SHIFT (31U)
+
+/** Shift value for extracting precalculated length from CAN frame. */
+#define LLCE_CAN_MB_PRECALC_LEN_SHIFT (24U)
+
+/** Constant used to identify a reserved mask id. */
+#define LLCE_CAN_FULLCAN_MASK 0xFFFFFFFFU
+
+/**
+ * Notifications sent by LLCE to host core.
+ */
+enum llce_can_notification_id {
+	/** No error. */
+	LLCE_CAN_NOTIF_NOERROR = 0U,
+	/** Error related to the common platform area. */
+	LLCE_CAN_NOTIF_PLATFORMERROR,
+	/** Error related to a specific channel.*/
+	LLCE_CAN_NOTIF_CHANNELERROR,
+	/** Notification related to changing CAN controller mode.*/
+	LLCE_CAN_NOTIF_CTRLMODE,
+} __packed;
+
+/**
+ * Command IDs used to interface with LLCE.
+ *
+ * Some of those commands are sent by the host to LLCE module and
+ * others are send by LLCE module to the host.
+ */
+enum llce_can_command_id {
+	/** Host initializes LLCE module. */
+	LLCE_CAN_CMD_INIT = 0U,
+	/** Host De_initialize a specific CAN controller. */
+	LLCE_CAN_CMD_DEINIT,
+	/** Host sets a baud rate for a specific CAN controller.*/
+	LLCE_CAN_CMD_SETBAUDRATE,
+	/** Host checks the state for a specific CAN controller.*/
+	LLCE_CAN_CMD_GETCONTROLLERMODE,
+	/** Host changes the state for a specific CAN controller.*/
+	LLCE_CAN_CMD_SETCONTROLLERMODE,
+	/**
+	 * LLCE notify host about bus off event for a specific CAN
+	 * controller.
+	 */
+	LLCE_CAN_CMD_BUSOFF_CONFIRMATION,
+	/**
+	 * LLCE deliver to the host the content of all status register
+	 * of CAN controller.
+	 */
+	LLCE_CAN_CMD_GETSTATUS,
+	/** Host configure multiple filters on the reception side.*/
+	LLCE_CAN_CMD_SETFILTER,
+	/**
+	 * Host configure multiple advanced feature filters on the
+	 * reception side.
+	 */
+	LLCE_CAN_CMD_SETADVANCEDFILTER,
+	/** Request version string from FW.*/
+	LLCE_CAN_CMD_GETFWVERSION,
+	/** Host request for platform initialization.*/
+	LLCE_CAN_CMD_INIT_PLATFORM,
+	/**
+	 * LLCE internal command request for initialization of common
+	 * resources.
+	 */
+	LLCE_CAN_CMD_INIT_PLATFORM_COMMON,
+	/* Host request for platform deinitialization.*/
+	LLCE_CAN_CMD_DEINIT_PLATFORM,
+	/**
+	 * Host request for platform initialization regarding can2eth
+	 * use case.
+	 */
+	LLCE_CAN_CMD_INIT_PFE,
+	/* Host invalidate a specific filter.*/
+	LLCE_CAN_CMD_REMOVE_FILTER,
+	/**
+	 * Host creates a destination to be used by advanced routing
+	 * filters.
+	 */
+	LLCE_CAN_CMD_CREATE_AF_DESTINATION
+} __packed;
+
+/** Return status codes reported at the end of each command execution.*/
+enum llce_can_return {
+	/* Command was executed successfully. */
+	LLCE_CAN_SUCCESS = 0x55,
+	/* During command execution it was detected an error condition. */
+	LLCE_CAN_ERROR,
+	/* Command default value set by the host before to send it to LLCE. */
+	LLCE_CAN_NOTRUN
+} __packed;
+
+/**
+ * CAN frame ID type.
+ *
+ * It specify the CAN frame ID type based on it's length as it is defined by CAN
+ * specification.
+ */
+enum llce_can_id_length {
+	/** Extended ID (29 bits) */
+	LLCE_CAN_EXTENDED = 0U,
+	/** Standard ID (11 bits) */
+	LLCE_CAN_STANDARD,
+	/** Mixed ID (29 bits) */
+	LLCE_CAN_MIXED
+} __packed;
+
+/**
+ * Requested transitions of a CAN controller.
+ *
+ * Those controller state transitions are requested by the host in a
+ * specific order.
+ */
+enum llce_can_state_transition {
+	/** Request transition from START state into STOP state. */
+	LLCE_CAN_T_STOP = 0U,
+	/** Request transition from STOP state into START state. */
+	LLCE_CAN_T_START,
+} __packed;
+
+/**
+ * CAN controller states.
+ *
+ * CAN controller states as they are reported by the LLCE firmware as a
+ * result of state transition requests.
+ */
+enum llce_can_ctrl_state {
+	/** Controller is uninitialised (default) */
+	LLCE_CAN_UNINIT_CTRL = 0U,
+	/**
+	 * Controller is in a pending state of unitialization, waiting
+	 * for the resources to be restored (e.g Rx tokens)
+	 */
+	LLCE_CAN_UNINIT_CTRL_PENDING,
+	/** Controller is stopping, but not offline yet */
+	LLCE_CAN_STOP_PENDING,
+	/** Controller is in the STOPPED state which means that it does
+	 * not do any bus transactions.
+	 */
+	LLCE_CAN_STOPPED,
+	/** Controller is starting, but cannot do bus transactions yet. */
+	LLCE_CAN_START_PENDING,
+	/**
+	 * Controller is in the STARTED state which means that it do
+	 * bus transactions.
+	 */
+	LLCE_CAN_STARTED,
+	/**
+	 * Controller is in the IDLE state. This state is not used by
+	 * LLCE module.
+	 */
+	LLCE_CAN_IDLE,
+	/**
+	 * Controller is in state when the common components of the
+	 * platfor are not initialized.
+	 */
+	LLCE_CAN_UNINIT_PLATFORM
+} __packed;
+
+/**
+ * CAN firmware error values.
+ *
+ * CAN error values as they are reported by the LLCE firmware.Some of
+ * them are channel related and other are platform related.
+ */
+enum llce_can_error {
+	/** FIFO is full. */
+	LLCE_ERROR_TXACK_FIFO_FULL = 1U,
+	/** FIFO is full. */
+	LLCE_ERROR_RXOUT_FIFO_FULL,
+	/** FIFO is empty. */
+	LLCE_ERROR_FIFO_EMPTY,
+	/** Message buffer is not avaialable. */
+	LLCE_ERROR_MB_NOTAVAILABLE,
+	/**
+	 * CAN protocol error due to inability to get out from the
+	 * freeze mode.
+	 */
+	LLCE_ERROR_BCAN_FRZ_EXIT,
+	/**
+	 * CAN protocol error due to inability to synchronize on the
+	 * bus.
+	 */
+	LLCE_ERROR_BCAN_SYNC,
+	/** CAN protocol error due to inability to enter in freeze mode. */
+	LLCE_ERROR_BCAN_FRZ_ENTER,
+	/** CAN protocol error due to inability to enter in low-power mode */
+	LLCE_ERROR_BCAN_LPM_EXIT,
+	/** CAN protocol error due to inability to enter in soft reset. */
+	LLCE_ERROR_BCAN_SRT_ENTER,
+	/** CAN protocol error due to inability to enter in soft reset. */
+	LLCE_ERROR_BCAN_UNKNOWN_ERROR,
+	/**
+	 * ACKERR indicates that an acknowledge error has been detected
+	 * by the transmitter node.
+	 */
+	LLCE_ERROR_BCAN_ACKERR,
+	/**
+	 * CRCERR indicates that a CRC error has been detected by the
+	 * receiver node in a CAN frame.
+	 */
+	LLCE_ERROR_BCAN_CRCERR,
+	/**
+	 * BIT0ERR indicates when an inconsistency occurs between the
+	 * transmitted and the received bit in a CAN frame.
+	 */
+	LLCE_ERROR_BCAN_BIT0ERR,
+	/**
+	 * BIT1ERR indicates when an inconsistency occurs between the
+	 * transmitted and the received bit in a CAN frame.
+	 */
+	LLCE_ERROR_BCAN_BIT1ERR,
+	/**
+	 * FRMERR indicates that a form error has been detected by the
+	 * receiver node in a CAN frame, that is, a fixed-form bit field
+	 * contains at least one illegal bit.
+	 */
+	LLCE_ERROR_BCAN_FRMERR,
+	/**
+	 * STFERR indicates that a stuffing error has been detected by
+	 * the receiver node in a CAN frame.
+	 */
+	LLCE_ERROR_BCAN_STFERR,
+	/**
+	 * Reports data lost event due to resources exceeded after the
+	 * frame was received
+	 */
+	LLCE_ERROR_DATA_LOST,
+	/** TXLUT acclerator is full. */
+	LLCE_ERROR_TXLUT_FULL,
+	/** Error during command processing. */
+	LLCE_ERROR_CMD_PROCESSING,
+	/** Error regarding RXLUT hardware. */
+	LLCE_ERROR_RXLUT_SLOW_SEARCH,
+	/** Error regarding RXLUT hardware. */
+	LLCE_ERROR_RXLUT_ACCESS_MODE,
+	/** Error regarding RXLUT hardware. */
+	LLCE_ERROR_RXLUT_SEARCH_MODE,
+	/** Error regarding RXLUT hardware. */
+	LLCE_ERROR_RXLUT_SLOW_OPERATION,
+	/** Error regarding RXLUT hardware. */
+	LLCE_ERROR_RXLUT_INCOMPLETE_OP,
+	/** Error regarding RXLUT hardware. */
+	LLCE_ERROR_RXLUT_OPERATING_MODE,
+	/** Error regarding RXLUT hardware. */
+	LLCE_ERROR_RXLUT_INIT_SLOW_OP,
+	/** Error regarding RXLUT hardware. */
+	LLCE_ERROR_RXLUT_DEINIT_SLOW_OP,
+	/** Error regarding RXLUT hardware. */
+	LLCE_ERROR_RXLUT_INIT_OPERATING_MODE,
+	/** Error regarding RXLUT hardware. */
+	LLCE_ERROR_RXLUT_DEINIT_OPERATING_MODE1,
+	/** Error regarding RXLUT hardware. */
+	LLCE_ERROR_RXLUT_DEINIT_OPERATING_MODE2,
+	/** Error regarding bus off event. */
+	LLCE_ERROR_HARDWARE_BUSOFF,
+	/** Controller is not ready. */
+	LLCE_ERROR_CTRL_NOT_READY,
+	/** Error regarding bus off. */
+	LLCE_ERROR_BUSOFF,
+	/** Logging fifo is full. */
+	LLCE_ERROR_FIFO_LOG_FULL,
+	/** Error reported due to can2can routing error. */
+	LLCE_ERROR_CAN2CAN,
+	/** Error reported due to wrong command parameters received from host */
+	LLCE_ERROR_COMMAND_PARAM,
+	/** Error reported due to the rx core not responding. */
+	LLCE_ERROR_COMMAND_RXPPE_NOTRESPONSE,
+	/** Error reported because the controller is not stopped. */
+	LLCE_ERROR_COMMAND_DEINIT_NOTSTOP,
+	/**
+	 * Error reported because the host didn't read all the RX
+	 * tokens (indexes in fifos). LLCE waits for indexes to be read and
+	 * returned.
+	 */
+	LLCE_ERROR_RXTOKENS_UNRETURNED,
+	/**
+	 * Error reported because the host didn't read all the ACKs
+	 * (indexes in fifos). LLCE waits for indexes to be read.
+	 */
+	LLCE_ERROR_TXACK_NOT_READ,
+	/** Error reported because the requested command is not supported. */
+	LLCE_ERROR_COMMAND_NOTSUPPORTED,
+	/**
+	 * Error reported because command is not validated by the
+	 * command flow.
+	 */
+	LLCE_ERROR_COMMAND_NOTVALIDATED,
+	/**
+	 * Error reported because the requested command is correct but
+	 * it not accepted.
+	 */
+	LLCE_ERROR_COMMAND_NOTACCEPTED,
+	/**
+	 * Error reported because the requested command parameters are
+	 * invalid.
+	 */
+	LLCE_ERROR_COMMAND_INVALID_PARAMS,
+	/** Controller is not started. */
+	LLCE_ERROR_CTRL_NOT_STARTED,
+	/**
+	 * Reports frame accepted, but not delivered to host because of
+	 * filters misconfiguration.
+	 */
+	LLCE_ERROR_FRAME_NOT_DELIVERED,
+	/**
+	 * Reports frame accepted, but not delivered to AF destination
+	 * because of full fifo.
+	 */
+	LLCE_ERROR_FRAME_NOT_DELIVERED_TO_AF,
+	/**
+	 * Reports frame accepted, but not delivered to host due to
+	 * lack of descriptors in sw fifo.
+	 */
+	LLCE_ERROR_FRAME_NOT_DELIVERED_TO_HOST,
+	/** Reports detection of lost indexes in RX-DTE subsystem . */
+	LLCE_ERROR_LOST_INDEXES,
+	/**
+	 * Error reported because there are no filters avaialable to be
+	 * set for a specific controller.
+	 */
+	LLCE_ERROR_FILTERS_FULL,
+	/**
+	 * The filter pointed by the related address is not used by the
+	 * related controller.
+	 */
+	LLCE_ERROR_FILTERS_NOTEXIST,
+	/** There are no free configuration filters. */
+	LLCE_ERROR_FILTERS_MASK_EMPTY,
+	/** There are no free configuration filters. */
+	LLCE_ERROR_FILTERS_RANGE_EMPTY,
+	/** There are no free exact match filters. */
+	LLCE_ERROR_FILTERS_EM_EMPTY,
+	/** The index return by host is not valid. */
+	LLCE_ERROR_IDX_NOT_VALID_HOST,
+	/** The index return by logging is not valid. */
+	LLCE_ERROR_IDX_NOT_VALID_LOG,
+	/**
+	 * The host core which sent a free rx descriptor index to Llce
+	 * is invalid.
+	 */
+	LLCE_ERROR_INVALID_HOST_CORE,
+	/**
+	 * Reports frame accepted, but not delivered to HSE because of
+	 * full fifo.
+	 */
+	LLCE_ERROR_RXFRAME_NOT_DELIVERED_TO_HSE,
+	/** Tx frame was not delivered to HSE because of full fifo. */
+	LLCE_ERROR_TXFRAME_NOT_DELIVERED_TO_HSE,
+	/** Rx frame was dropped because it is not authentic. */
+	LLCE_ERROR_RXFRAME_AUTH_ERROR,
+	/** FRPE core received an invalid request from Tx core. */
+	LLCE_ERROR_INVALID_REQUEST_FROM_TX,
+	/** FRPE core received an invalid request from Rx core. */
+	LLCE_ERROR_INVALID_REQUEST_FROM_RX,
+	/** RX Software FIFO is empty. */
+	LLCE_ERROR_RX_SW_FIFO_EMPTY
+} __packed;
+
+/**
+ * CAN firmware components IDs.
+ *
+ * CAN firmware components IDs used to identify the component which
+ * generated a specific error.
+ */
+enum llce_can_module {
+	/** CAN TX firmware component. */
+	LLCE_TX = 101U,
+	/** CAN RX firmware component. */
+	LLCE_RX,
+	/** CAN DTE firmware component. */
+	LLCE_DTE,
+	/** CAN FRPE firmware component. */
+	LLCE_FRPE
+} __packed;
+
+/**
+ * CAN Logging options
+ *
+ * CAN options for logging frames feature.
+ */
+enum llce_af_logging_options {
+	/** Logging of CAN frame is disabled.*/
+	LLCE_AF_LOGGING_DISABLED = 1U,
+	/** Logging of CAN frame is enabled.*/
+	LLCE_AF_LOGGING_ENABLED
+} __packed;
+
+enum llce_can_host_receive_options {
+	/** Logging of CAN frame is disabled.*/
+	LLCE_AF_HOSTRECEIVE_DISABLED = 1U,
+	/** Logging of CAN frame is enabled.*/
+	LLCE_AF_HOSTRECEIVE_ENABLED
+} __packed;
+
+enum llce_af_authentication_options {
+	/** Authentication of CAN frame is disabled.*/
+	LLCE_AF_AUTHENTICATION_DISABLED = 1U,
+	/** Authentication of CAN frame is enabled.*/
+	LLCE_AF_AUTHENTICATION_ENABLED,
+	LLCE_AF_AUTHENTICATION_NOT_SUPPORTED
+} __packed;
+
+/**
+ * RXLUT entries type
+ *
+ * Specifies the type of entry in the table.
+ */
+enum llce_can_entry {
+	/** Exact match entry type. */
+	LLCE_CAN_ENTRY_EXACT_MATCH = 0U,
+	/** Masked match entry type. */
+	LLCE_CAN_ENTRY_CFG_MASKED,
+	/** Range match entry type. */
+	LLCE_CAN_ENTRY_CFG_RANGED,
+} __packed;
+
+/**
+ * Type of Advanced Feature(AF) rule.
+ *
+ * Specifies the type of entry in the destination rule table.
+ */
+enum llce_af_rule_id {
+	/** Destination rule type used for can2can use case. */
+	CAN_AF_CAN2CAN = 0U,
+	/** Destination rule type used for can2eth use case. */
+	CAN_AF_CAN2ETH
+} __packed;
+
+/**
+ * Initialization status of the controllers.
+ * See struct llce_can_init_platform_cmd
+ */
+enum llce_can_status {
+	/** Entity is initialised */
+	INITIALIZED = 1U,
+	/** Entity is uninitialised (default) */
+	UNINITIALIZED = 2U
+} __packed;
+
+/**
+ * Processing type of a specific error.
+ * See struct llce_can_init_platform_cmd.
+ */
+enum llce_can_error_processing {
+	/** LLCE Firmware does not report the error */
+	IGNORE = 1U,
+	/**
+	 * LLCE Firmware reports the error through the notification
+	 * table corresponding to interrupt processing
+	 */
+	INTERRUPT,
+	/**
+	 * LLCE Firmware reports the error through the notification
+	 * table corresponding to polling processing
+	 */
+	POLLING,
+} __packed;
+
+#pragma pack(4)
+
+/**
+ * CAN message buffer.
+ *
+ * CAN message buffer is a memory area placed in the shared memory which is used
+ * by the LLCE firmware to receive/transmit from/to BCAN controller.
+ * LLCE firmware transmits/receives the frame in a word by word way so the
+ * content of the 4 structure fields contains the frame fields.
+ * For the reception process the LLCE firmware store inside message buffer frame
+ * the time stamp read from the hardware CAN controller.
+ * Before to use any message buffer it is needed to initialize, configure and
+ * start a CAN controller
+ */
+struct llce_can_mb {
+	/**
+	 * INPUT/OUTPUT: The first word of a frame as it is
+	 * expected/provided by the CAN controller.
+	 */
+	u32 word0;
+	/**
+	 * INPUT/OUTPUT: The second word of a frame as it is
+	 * expected/provided by the CAN controller.
+	 */
+	u32 word1;
+	/**
+	 * INPUT/OUTPUT: Frame payload needed for the maximum payload
+	 * size case.
+	 */
+	u8 payload[LLCE_CAN_CONFIG_PAYLOAD_MAX_SIZE];
+	/**
+	 * INPUT: Time stamp of the received frames.It is not used for
+	 * the transmitted frames.
+	 */
+	u32 timestamp;
+};
+
+/** Reception message buffer descriptor.
+ *
+ * Reception message buffer descriptor is a memory area placed in the
+ * shared memory which is written by the LLCE firmware  with the specific
+ * runtime info needed by the host software.(e.g.matching filter ID ).
+ * Also it includes an index to a CAN message buffer allocated during
+ * initialization to each descriptor.
+ * After reception, the host shall copy the content of the reception message
+ * buffer descriptor and the referred message buffer by this descriptor from
+ * the shared memory into the host memory in order to be processed later by
+ * the host software and to allow the current message buffer descriptor to be
+ * used by LLCE firmware for the reception of a new frame.
+ * Before to use any receive message buffer descriptor it is needed to
+ * initialize, configure and start a CAN controller
+ */
+struct llce_can_rx_mb_desc {
+	/**
+	 * OUTPUT: Filter identifier resulted at the end of filtering
+	 * process.
+	 * This field is completed by the LLCE filtering mechanism with a
+	 * value which was configured during initialization time.
+	 * It is used in order to map a received frame to a specific filter
+	 * defined by the host.
+	 */
+	u16 filter_id;
+	/**
+	 * OUTPUT: Index to the CAN message buffer.
+	 * See struct llce_can_mb
+	 */
+	u16 mb_frame_idx;
+};
+
+/**
+ * Transmission message buffer descriptor.
+ *
+ * Transmission message buffer descriptor is a memory area placed in the shared
+ * memory which is written by the host software with other additional info
+ * (e.g. frame tag IDs) which is send back to the host by the LLCE firmware as
+ * acknowledge information.
+ *
+ * Those internal tags are not changed/used by the LLCE firmware.
+ * Before to use any transmission message buffer descriptor it is needed to
+ * initialize, configure and start a CAN controller
+ */
+struct llce_can_tx_mb_desc {
+	/**
+	 * INPUT: Host defined tag used to track a specific frame. This
+	 * field is not changed by the LLCE firmware and is returned back to the
+	 * host as it is.
+	 * See struct llce_can_tx2host_ack_info
+	 */
+	u16 frame_tag1;
+	/**
+	 * INPUT: Host defined tag used to track a specific frame. This
+	 * field is not changed by the LLCE firmware and is returned back to the
+	 * host as it is.
+	 * See  struct llce_can_tx2host_ack_info
+	 */
+	u16 frame_tag2;
+	/**
+	 * INPUT: Host defined interface used to select the acknowledge
+	 * interface of a specific frame. This field is not changed by the LLCE
+	 * firmware.
+	 */
+	u8 ack_interface;
+	/**
+	 * OUTPUT: Index to the frame message buffer.
+	 * See struct llce_can_mb
+	 */
+	u16 mb_frame_idx;
+	/**
+	 * INPUT: Request firmware to add MAC code to the transmitted
+	 * frame payload.
+	 */
+	bool enable_tx_frame_mac;
+};
+
+/**
+ * Acknowledge transmission information send from LLCE to host.
+ *
+ * It is used in order to send from LLCE to host needed information in order to
+ * identify and confirm that a specific frame was transmitted on the CAN bus.
+ * This data structure type is used in order to implement a circular buffer for
+ * each channel which is accessed by using indexes transferred from LLCE to host
+ * by using TXACK FIFOs.
+ * This approach allows usage of existing hardware FIFOs even the size of the
+ * transferred data is higher than the FIFO element width size.
+ * Before to read any acknowledge information, it is needed to do a transmission
+ * request.
+ */
+struct llce_can_tx2host_ack_info {
+	/**
+	 * OUTPUT: Host defined tag used to track a specific frame. This
+	 * field is not changed by the LLCE firmware and is returned back to the
+	 * host as it is.
+	 * See struct llce_can_tx_mb_desc
+	 */
+	u16 frame_tag1;
+	/**
+	 * OUTPUT: Host defined tag used to track a specific frame. This field
+	 * is not changed by the LLCE firmware and is returned back to the host
+	 * as it is.
+	 * See  struct llce_can_tx_mb_desc
+	 */
+	u16 frame_tag2;
+	/** OUTPUT: Transmission time stamp.*/
+	u32 tx_timestamp;
+
+};
+
+/**
+ * Command for polling of controller state.
+ *
+ * It is send from host to LLCE to query it for the controller state.
+ */
+struct llce_can_get_controller_mode_cmd {
+	/** OUTPUT: Current state of the CAN controller. */
+	enum llce_can_ctrl_state controller_state;
+
+};
+
+/**
+ * Set controller mode command.
+ *
+ * It is send from host to LLCE module in order request changing the state of a
+ * CAN controller. Currently it allows only to start and stop a controller.
+ * When a controller is started it allows to transmit and receive frames from
+ * the bus. When the controller is stopped it ignores all frames from the bus
+ * and it doesn't transmit any frame.
+ *
+ * Before changing the controller state it must be initialized.
+ */
+struct llce_can_set_controller_mode_cmd {
+	/** INPUT: The new state which is requested. */
+	enum llce_can_state_transition transition;
+};
+
+/**
+ * Data baud rate settings for a CAN FD controller.
+ *
+ * It is used to configure the CAN FD settings including baudrate used
+ * during data phase.
+ */
+struct llce_can_controller_fd_config {
+	/**
+	 * INPUT: Enable or disable FD related features of the CAN controller.
+	 */
+	bool can_fd_enable;
+	/**
+	 * INPUT: Configuration of data phase baud rate:
+	 *	- prescaler divisor (bit23-27)
+	 *	- Resynchronization Jump Width (bit16-19)
+	 *	- Time Segment2 (bit9-12)
+	 *	- Time Segment1 (bit0-4)
+	 * Each parameter value shall be decreased by 1 when it is
+	 * written into this data structure field.
+	 */
+	u32 can_data_baudrate_config;
+	/**
+	 * INPUT: Enable or disable baud rate switch(BRS) at the level
+	 * of CAN controller.
+	 */
+	bool can_controller_tx_bit_rate_switch;
+	/**
+	 * INPUT: Enable or disable Transceiver Delay Compensation:
+	 * TRUE=enabled, FALSE=disabled.
+	 */
+	bool can_trcv_delay_comp_enable;
+	/**
+	 * INPUT: Enable or disable Transceiver Delay Measurement:
+	 *	- TRUE=enabled,
+	 *	- FALSE=disabled.
+	 * When it is enabled, the secondary sample point is determined by the
+	 * sum of the tranceiver delay measurement plus transceiver delay
+	 * compensation offset.
+	 * When it is disabled, the secondary sample point  is determined only
+	 * by the transceiver delay compensation offset.
+	 */
+	bool can_trcv_delay_meas_enable;
+	/** INPUT: Value of Transceiver Delay Compensation Offset*/
+	u8 can_trcv_delay_comp_offset;
+};
+
+/**
+ * Set baud rate command.
+ *
+ * It is send from host to LLCE module in order to configure baud rate
+ * parameters for arbitration phase.
+ */
+struct llce_can_set_baudrate_cmd {
+	/**
+	 * INPUT: Configuration parameters for nominal baud
+	 * rate:
+	 *	- prescaler divisor(bit23-31),
+	 *	- Resynchronization Jump Width(bit16-22),
+	 *	- Time Segment2(bit9-15),
+	 *	- Time Segment1(bit0-7).
+	 * Each parameter value shall be decreased by 1 when it is
+	 * written into this data structure field.
+	 */
+	u32 nominal_baudrate_config;
+	/**
+	 * INPUT: Configuration parameters for data baud rate of the CAN
+	 * controller.
+	 */
+	struct llce_can_controller_fd_config controller_fd;
+};
+
+/**
+ * Filter element settings.
+ *
+ * It is used to define a specific filter.Current filtering process suppose to
+ * accept a frame if it's frame ID match the filter ID masked with the mask
+ * value. At the end of filtering process an internal filter ID is mapped to the
+ * accepted frame in order to track it later by the host software.
+ * A maximum number of frames accepted by a specific filter can be managed by
+ * LLCE at each point in time.
+ */
+struct llce_can_rx_filter {
+	/**
+	 * INPUT: For MASK filters: Frame id mask value. Bit fields containing
+	 * 0 means don't care.
+	 * For RANGE filters: Maximum accepted id value.
+	 * For EXACT MATCH: not used.
+	 */
+	u32 id_mask;
+	/**
+	 * INPUT: For MASK filters: CAN frame ID value.
+	 * For RANGE filters: Minimum accepted id value.
+	 * For EXACT MATCH: id value
+	 */
+	u32 message_id;
+	/**
+	 * INPUT: Filter identifier used to track frames after filtering
+	 * process on the reception side.
+	 * See also: struct llce_can_rx_mb_desc
+	 */
+	u16 filter_id;
+	/**
+	 * INPUT: Maximum number of message buffers which can be used to
+	 * store frames accepted by this filter at each specific point in time.
+	 * When the maximum value is reached the firmware will begin to drop the
+	 * received frames accepted by that filter.It is used also in order to
+	 * prevent that the frames accepted by a specific filter do not overload
+	 * the LLCE internal hardware resources (e.g. message buffers, FIFOs).
+	 */
+	u16 mb_count;
+	/**
+	 * INPUT: Reception interface id used to deliver frames accepted
+	 * by that filter to the host.
+	 */
+	u8 rx_dest_interface;
+	/** INPUT: Filter entry type: mask, range, exact match */
+	enum llce_can_entry entry_type;
+	/**
+	 * OUTPUT: Filter address inside hw filtering accelerator where
+	 * the filter fields are stored. Host side application can use this to
+	 * track used filter entries.
+	 * The search operation start from low filter addresses and continue to
+	 * the high filter addresses.
+	 */
+	u16 filter_addr;
+
+};
+
+/**
+ * Set filter command.
+ *
+ * It is send by the host to LLCE in order to configure one or more reception
+ * filters inside LLCE.
+ */
+struct llce_can_set_filter_cmd {
+	/** INPUT: Number of configured filters. */
+	u16 rx_filters_count;
+	/** INPUT: Array containing configuration for reception filters. */
+	struct llce_can_rx_filter rx_filters[LLCE_CAN_CONFIG_MAX_FILTERS_COUNT];
+};
+
+/**
+ * CAN to CAN routing filter configuration.
+ *
+ * It is used to define a specific routing filter. Current routing
+ * implementation suppose to accept a received frame for a specific ID and ID
+ * mask combination, then route that frame to one or more transmission channels.
+ */
+struct llce_can_can2can_routing_table {
+	/** INPUT: List of destination CAN controllers for the accepted frame */
+	u8 dest_hw_ch_list[LLCE_CAN_CONFIG_MAXCTRL_COUNT];
+	/** INPUT: Length of the destination CAN controller list.*/
+	u8 dest_hw_ch_list_count;
+	/** INPUT: Special option for advanced routing.*/
+	u32 can2can_routing_options;
+	/** INPUT: Can Id Remap Value.*/
+	u32 can_id_remap_value;
+} __aligned(4);
+
+/**
+ * Data strucure type containing CAN to Ethernet destination rule configuration.
+ *
+ * It is used to define a specific destination rule for can2eth internal routing
+ */
+struct llce_can_can2eth_routing_table {
+	/**
+	 * INPUT: Ethernet MAC destination address as it is defined by
+	 * IEEE 802.3 standard.
+	 */
+	u8 can2eth_dest_mac[6];
+} __aligned(4);
+
+/**
+ * Data structure type representing  destination rule used by
+ * Advanced Features(AF)
+ *
+ * Used to hold a generic type of AF destination rule
+ */
+struct can_af_dest_rules {
+	/** INPUT: Destination rule type.*/
+	enum llce_af_rule_id af_dest_id;
+	/** Destination rule content.*/
+	union {
+		/**
+		 * INPUT: Destination rule for can2can internal routing
+		 * use case.
+		 */
+		struct llce_can_can2can_routing_table can2can;
+		/** INPUT: Destination rule for can2eth use case.*/
+		struct llce_can_can2eth_routing_table can2eth;
+	} af_dest;
+};
+
+/**
+ * Advanced filter configuration.
+ *
+ * It is used to define an advanced filter. It contains references to
+ * the individual features configured by the host.
+ */
+struct llce_can_advanced_feature {
+	/** INPUT: Option for frame authentication feature. */
+	enum llce_af_authentication_options can_authentication_feature;
+	/** INPUT: Option for host receive feature. */
+	enum llce_can_host_receive_options host_receive;
+	/** INPUT: Option for logging feature. */
+	enum llce_af_logging_options can_logging_feature;
+	/**
+	 * INPUT: can2can routing table index. Reference to the routing
+	 * table rule. See  struct llce_can_can2can_routing_table
+	 */
+	u8 can2can_routing_table_idx;
+	/**
+	 * INPUT: can2eth routing table index. Reference to the routing
+	 * table rule. See struct llce_can_can2eth_routing_table
+	 */
+	u8 can2eth_routing_table_idx;
+} __aligned(4);
+
+/**
+ * Advanced filter element configuration.
+ *
+ * It is used to define a specific filter. Current filtering suppose to accept
+ * a frame for processing if it's frame ID match the filter ID masked with the
+ * mask value. At the end of filtering process the frame is processed according
+ * to the advanced configuration of the filter.
+ */
+struct llce_can_advanced_filter {
+	/** INPUT: Standard filter configuration. */
+	struct llce_can_rx_filter llce_can_rx_filter;
+	/** INPUT: Can advanced features used by the filter. */
+	struct llce_can_advanced_feature llce_can_advanced_feature;
+} __aligned(4);
+
+/**
+ * Set advanced filter command.
+ *
+ * It is send by the host to LLCE in order to set one or more advanced filters.
+ */
+struct llce_can_set_advanced_filter_cmd {
+	/** INPUT: Number of configured filters. */
+	u16 rx_filters_count;
+	/** INPUT: Array containing configuration for one or more filters. */
+	struct llce_can_advanced_filter
+		advanced_filters[LLCE_CAN_CONFIG_ADVANCED_FILTERS_COUNT];
+};
+
+/** Configurable errors that LLCE Firmware handles.
+ *
+ * Configurable errors that LLCE Firmware handles using different types of
+ * processing. It is part of platform init command. Only Bus_off processing type
+ * is selectable per channel.
+ */
+struct llce_can_error_category {
+	/** CAN Protocol errors supported by CAN controller. */
+	enum llce_can_error_processing can_protocol_err;
+	/** DATALOST event as described by Autosar standard */
+	enum llce_can_error_processing data_lost_err;
+	/**
+	 * Initialization errors, like resources overflow, bad commands flow,
+	 * bad command parameters, invalid indexes or any other errors caused by
+	 * bad usage or a malicious host.
+	 */
+	enum llce_can_error_processing init_err;
+	/** Internal errors, like timeouts. */
+	enum llce_can_error_processing internal_err;
+	/** Bus_off processing is selectable per channel */
+	enum llce_can_error_processing
+		bus_off_err[LLCE_CAN_CONFIG_MAXCTRL_COUNT];
+};
+
+/**
+ * Platform initialization command.
+ *
+ * It is send by the host to LLCE in order to configure the platform related
+ * parameters. It is the first command which shall be send to LLCE module after
+ * booting in order to configure common LLCE components.
+ * Most important operations done by LLCE firmware at platform initialization
+ * are:
+ * - initialize also all common internal LLCE components.
+ * - prepare filter management data structures
+ */
+struct llce_can_init_platform_cmd {
+	/**
+	 * INPUT: Array containing the initialization status of the controllers
+	 */
+	enum llce_can_status ctrl_init_status[LLCE_CAN_CONFIG_MAXCTRL_COUNT];
+	/**
+	 * INPUT: Array containing maximum number of filters per channel.
+	 * See LLCE_CAN_CONTROLLERCONFIG_CTRL_EN_U32 as a controller option
+	 * example
+	 */
+	u16 max_filter_count[LLCE_CAN_CONFIG_MAXCTRL_COUNT];
+	/**
+	 * INPUT: Array containing maximum number of RX message buffers
+	 * per channel, considering interrupt processing.
+	 */
+	u16 max_int_mb_count[LLCE_CAN_CONFIG_MAXCTRL_COUNT];
+	/**
+	 * INPUT: Array containing maximum number of RX message buffers per
+	 * polling class, considering polling processing. There are a number
+	 * of LLCE_CAN_MAX_POLLING_CLASSES provided.
+	 */
+	u16 max_poll_mb_count[LLCE_CAN_MAX_POLLING_CLASSES];
+	/**
+	 * INPUT: Array containing maximum number of reserved TX confirmation
+	 * buffers per channel, considering interrupt processing.
+	 */
+	u16 max_int_tx_ack_count[LLCE_CAN_CONFIG_MAXCTRL_COUNT];
+	/**
+	 * INPUT: Array containing maximum number of reserved TX confirmation
+	 * buffers per polling class, considering polling processing. There are
+	 * a number of  LLCE_CAN_MAX_POLLING_CLASSES provided.
+	 */
+	u16 max_poll_tx_ack_count[LLCE_CAN_MAX_POLLING_CLASSES];
+	/**
+	 * INPUT: Structure describing the way of processing each errors
+	 * category. This can be: INTERRUPT, POLLING or IGNORE.
+	 */
+	struct llce_can_error_category can_error_reporting;
+};
+
+/**
+ * Initialization command.
+ *
+ * It is send by the host to LLCE in order to load and configure all needed
+ * parameters inside LLCE. It is the first command which shall be send to LLCE
+ * module after booting.
+ * Most important operations done by LLCE firmware at initialization are:
+ * - when this command is executed for the first CAN channel it initialize also
+ * all internal LLCE components.
+ * - configure the hardware features of a CAN controller.
+ * - set a CAN controller in the stop state.
+ */
+struct llce_can_init_cmd {
+	/**
+	 * INPUT: Configuration options for a hardware CAN controller.
+	 * See LLCE_CAN_CONTROLLERCONFIG_CTRL_EN_U32 as a controller option
+	 * example
+	 */
+	u32 ctrl_config;
+	/**
+	 * INPUT: Number of transmission message buffer descriptors used
+	 * for transmissions initialized by the host.The remaining elements are
+	 * used for internal routing scenarios.
+	 */
+	u8 tx_mb_count;
+};
+
+/**
+ * LLCE-PFE Initialization command.
+ *
+ * It is sent by the host to LLCE in order to activate the LLCE-PFE
+ * interface, and obtain the addresses of the relevant data structures.
+ */
+struct llce_can_init_pfe_cmd {
+	/** OUTPUT: Address of the PFE RX Ring in LLCE memory */
+	void *rx_ring;
+	/** OUTPUT: Address of the PFE RX Writeback Ring in LLCE memory */
+	void *rx_wb_ring;
+	/** OUTPUT: Address of the PFE TX Ring in LLCE memory */
+	void *tx_ring;
+	/** OUTPUT: Address of the PFE TX Writeback Ring in LLCE memory */
+	void *tx_wb_ring;
+};
+
+/**
+ * Get status command.
+ *
+ * It is send by the host to LLCE in order to get the content of all status
+ * registers of a specific CAN controller. This command makes only a read
+ * operation on the status registers of CAN controller.
+ */
+struct llce_can_get_status_cmd {
+	/** OUTPUT: Register ECR of CAN controller. */
+	u32 ecr;
+	/** OUTPUT: Register ISR of CAN controller. */
+	u32 isr;
+	/** OUTPUT: Register SR of CAN controller. */
+	u32 sr;
+	/** OUTPUT: Register CRC of CAN controller. */
+	u32 crc;
+};
+
+/**
+ * Get firmware version command.
+ *
+ * It is send by the host to LLCE in order to get the firmware version string.
+ * It is copied in the response.
+ */
+struct llce_can_get_fw_version {
+	/** OUTPUT: LLCE FW version string actual length. */
+	u8 string_length;
+	/** OUTPUT: LLCE FW version string. */
+	u8 version_string[LLCE_VERSION_MAX_LENGTH];
+};
+
+/**
+ * Remove filter command structure.
+ *
+ * It is send by the host to LLCE in order to remove a specific filter
+ * identified by a hardware address.
+ */
+struct llce_can_remove_filter {
+	/** INPUT: Address of the filter which shall be removed/disabled. */
+	u16 filter_addr;
+
+};
+
+/**
+ * Add AF destination command structure.
+ *
+ * It is send by the host to LLCE in order add a destination to be used by AF
+ */
+struct llce_can_create_af_destination {
+	/** INPUT: Destination to add to the list */
+	struct can_af_dest_rules rule;
+	/** OUTPUT: Index in LLCE list where destination was inserted */
+	u8 idx;
+};
+
+/**
+ * List of commands used by host.
+ *
+ * It is used in order to use the same memory area for all commands send from
+ * host to LLCE.
+ */
+union llce_can_command_list {
+	/** Command for initializing a specific CAN channel. */
+	struct llce_can_init_cmd init;
+	/**
+	 * Command for getting the hardware status information for a
+	 * specific CAN controller.
+	 */
+	struct llce_can_get_status_cmd get_status;
+	/**
+	 * Command for configuring filters for a specific CAN controller
+	 * in order to deliver frames to the host.
+	 */
+	struct llce_can_set_filter_cmd set_filter;
+	/**
+	 * Command for configuring baud rate parameters for a specific
+	 * CAN controller.
+	 */
+	struct llce_can_set_baudrate_cmd set_baudrate;
+	/** Command for getting the status of a specific CAN controller. */
+	struct llce_can_get_controller_mode_cmd get_controller_mode;
+	/** Command for changing the status of a specific CAN controller. */
+	struct llce_can_set_controller_mode_cmd set_controller_mode;
+	/**
+	 * Command for configuring filters in order to route frames to other
+	 * destinations than host.
+	 */
+	struct llce_can_set_advanced_filter_cmd set_advanced_filter;
+	/** Command for getting the firmware version. */
+	struct llce_can_get_fw_version get_fw_version;
+	/**
+	 * Command for configuring platform related parameters and common HW
+	 * components used by all CAN channels
+	 */
+	struct llce_can_init_platform_cmd init_platform;
+	/**
+	 * Command for initializing the LLCE-PFE interface and getting buffer
+	 * locations
+	 */
+	struct llce_can_init_pfe_cmd init_pfe;
+	/** Command for removing/disable a single filter. */
+	struct llce_can_remove_filter remove_filter;
+	/** Command for creating a destination for AF */
+	struct llce_can_create_af_destination create_af_dest;
+};
+
+/**
+ * Command used by host.
+ *
+ * It is used in order to send commands from host to LLCE using shared memory.
+ */
+struct llce_can_command {
+	/** INPUT: Command ID. */
+	enum llce_can_command_id cmd_id;
+	/** OUTPUT: Return status code after command completion.*/
+	enum llce_can_return return_value;
+	/** INPUT: Command parameters. */
+	union llce_can_command_list cmd_list;
+};
+
+/**
+ * Set controller mode notification.
+ *
+ * Notification send from LLCe to host in order to inform about a specific
+ * controller state change.
+ */
+struct llce_can_ctrl_mode_notif {
+	/**
+	 * OUTPUT: Current state of the CAN controller.
+	 * See also enum llce_can_ctrl_state
+	 */
+	enum llce_can_ctrl_state controller_state;
+	/** OUTPUT: CAN controller id. */
+	u8 hw_ctrl;
+};
+
+/**
+ * Platform specific error.
+ *
+ * Platform error details send to host in order to report an internal LLCE error
+ */
+struct llce_can_error_notif {
+	/**
+	 * OUTPUT: LLCE firmware component id.
+	 * See also enum llce_can_module
+	 */
+	enum llce_can_module module_id;
+	/** OUTPUT: LLCE error code.See also  enum llce_can_error */
+	enum llce_can_error error_code;
+	/** OUTPUT: Number of ocurrences of the last error. */
+	u8 error_count;
+};
+
+/**
+ * Channel specific error.
+ *
+ * Channel error details send to host in order to report an internal LLCE error.
+ */
+struct llce_can_channel_error_notif {
+	struct llce_can_error_notif error_info;
+	/** OUTPUT: Controller ID. */
+	u8 hw_ctrl;
+};
+
+/**
+ * List of notifications send by LLCe to host. used by host.
+ *
+ * It is used by LLCE to notify host about specific events inside LLCE.
+ */
+union llce_can_notification_list {
+	/**
+	 * OUTPUT: Notification parameters for controller state changes.
+	 * See also struct llce_can_ctrl_mode_notif
+	 */
+	struct llce_can_ctrl_mode_notif ctrl_mode;
+	/**
+	 * OUTPUT: Notification parameters for platform errors.
+	 * See also struct llce_can_error_notif
+	 */
+	struct llce_can_error_notif platform_error;
+	/**
+	 * OUTPUT: Notification parameters for channel errors.
+	 * See also struct llce_can_channel_error_notif
+	 */
+	struct llce_can_channel_error_notif channel_error;
+};
+
+/**
+ * Notifications used by LLCE.
+ *
+ * It is used in order to send notifications from LLCE to host by using shared
+ * memory.
+ */
+struct llce_can_notification {
+	/**
+	 * OUTPUT: Notification ID.
+	 * See also enum llce_can_notification_id
+	 */
+	enum llce_can_notification_id notif_id;
+	/**
+	 * OUTPUT: Notification parameters.
+	 * See also llce_can_notification_list_type
+	 */
+	union llce_can_notification_list notif_list;
+};
+
+/**
+ * Notification tables.
+ *
+ * Notification tables used to store the details of the notifications.The index
+ * of entries are send to host cores.The two tables are related to reporting
+ * method:interrupt or polling.
+ */
+struct llce_can_notification_table {
+	/**
+	 * OUTPUT: Table used to report notifications in interrupt mode.
+	 * See also  struct llce_can_notification
+	 */
+	struct llce_can_notification
+		can_notif_intr_table[LLCE_CAN_CONFIG_HIF_COUNT]
+		[LLCE_CAN_CONFIG_NOTIF_TABLE_SIZE];
+	/**
+	 * OUTPUT: Table used to report notifications in polling mode.
+	 * See also  struct llce_can_notification
+	 */
+	struct llce_can_notification
+		can_notif_poll_table[LLCE_CAN_CONFIG_HIF_COUNT]
+		[LLCE_CAN_CONFIG_NOTIF_TABLE_SIZE];
+};
+
+/**
+ * Shared memory structure
+ *
+ * Structure that encapsulates all the shared memory with llce on the can side.
+ */
+struct llce_can_shared_memory {
+	/** Receive message buffer descriptors. */
+	struct llce_can_rx_mb_desc can_rx_mb_desc[LLCE_CAN_CONFIG_MAXRXMB];
+	/** Transmit message buffer descriptors. */
+	struct llce_can_tx_mb_desc can_tx_mb_desc[LLCE_CAN_CONFIG_MAXTXMB];
+	/** Shared memory used store the CAN message buffers. */
+	struct llce_can_mb can_mb[LLCE_CAN_CONFIG_MAXTXMB +
+		LLCE_CAN_CONFIG_MAXRXMB +
+		LLCE_CAN_CONFIG_MAXAFFRMB];
+	/** Shared memory used to send commands from Host to Llce . */
+	struct llce_can_command can_cmd[LLCE_CAN_CONFIG_MAXCTRL_COUNT];
+	/** Shared memory used to store notifications from LLCE to host. */
+	struct llce_can_notification_table can_notification_table;
+	/**
+	 * Circular buffer used to send ack info from Tx core to HOST core.
+	 * Reserved 1 extra buffer for each interface for consistency
+	 * purposes.
+	 */
+	struct llce_can_tx2host_ack_info
+		can_tx_ack_info[LLCE_CAN_CONFIG_MAX_TXACKINFO];
+};
+
+#pragma pack()
+
+#endif /* LLCE_INTERFACECANTYPES_H */
diff --git a/include/linux/mailbox/nxp-llce/llce_fw_version.h b/include/linux/mailbox/nxp-llce/llce_fw_version.h
new file mode 100644
index 000000000000..159ca55f4c1b
--- /dev/null
+++ b/include/linux/mailbox/nxp-llce/llce_fw_version.h
@@ -0,0 +1,32 @@
+/* SPDX-License-Identifier: GPL-2.0+ */
+/* Copyright 2020 NXP */
+#ifndef LLCE_FW_VERSION_H
+#define LLCE_FW_VERSION_H
+
+#define LLCE_VERSION_MAX_LENGTH 50
+
+/**
+ * CAN functionality list type.
+ *
+ * Enumeration containing the list of features.
+ */
+enum llce_component_version {
+	/** Label of the version value regarding interface feature. */
+	LLCE_VERSION_INTERFACE = 0,
+	/** Label of the version value regarding interface basic features. */
+	LLCE_VERSION_BASIC_FUNC,
+	/**
+	 * Label of the version value regarding can2can internal
+	 * routing feature.
+	 */
+	LLCE_VERSION_ROUTING_CAN2CAN,
+	/**
+	 * Label of the version value regarding can2eth internal
+	 * routing feature.
+	 */
+	LLCE_VERSION_ROUTING_CAN2ETH,
+	/** Label of the version value regarding logging feature. */
+	LLCE_VERSION_LOGGING
+};
+
+#endif /* LLCE_FW_VERSION_H*/
diff --git a/include/linux/mailbox/nxp-llce/llce_interface_config.h b/include/linux/mailbox/nxp-llce/llce_interface_config.h
new file mode 100644
index 000000000000..51c16bd1344e
--- /dev/null
+++ b/include/linux/mailbox/nxp-llce/llce_interface_config.h
@@ -0,0 +1,169 @@
+/* SPDX-License-Identifier: GPL-2.0+ */
+/* Copyright 2020 NXP */
+#ifndef LLCE_INTERFACECONFIG_H
+#define LLCE_INTERFACECONFIG_H
+
+#include <linux/types.h>
+
+/* LLCE cores startup ending information values */
+
+/**
+ * Define used to detect if the boot was finalized for a specific LLCE
+ * internal core.
+ */
+#define LLCE_MGR_DTE_BOOT_END (0x0000000F)
+/**
+ * Define used to detect if the boot was finalized for a specific LLCE
+ * internal core.
+ */
+#define LLCE_MGR_RX_BOOT_END (0x000000F0)
+/**
+ * Define used to detect if the boot was finalized for a specific LLCE
+ * internal core.
+ */
+#define LLCE_MGR_TX_BOOT_END (0x00000F00)
+/**
+ * Define used to detect if the boot was finalized for a specific LLCE
+ * internal core.
+ */
+#define LLCE_MGR_FRPE_BOOT_END (0x0000F000)
+/**
+ * Define used to detect if the boot was finalized for all LLCE
+ * internal cores.
+ */
+#define LLCE_MGR_BOOT_END_ALL_CORES_MASK (0x0000FFFF)
+
+/* LLCE configuration parameters. */
+
+/**
+ * Default controller ID needed by the host 0 interface in order to
+ * transmit INIT_PLATFORM and DEINIT_PLATFORM commands from host to LLCE.
+ */
+#define LLCE_CAN_CONFIG_DEFAULT_CAN_CTRL_HOST0_U8 0U
+/**
+ * Default controller ID needed by the host 1 interface in order to
+ * transmit INIT_PLATFORM and DEINIT_PLATFORM commands from host to LLCE.
+ */
+#define LLCE_CAN_CONFIG_DEFAULT_CAN_CTRL_HOST1_U8 8U
+
+/** Maximum number of notifications which can be reported by LLCE to host. */
+#define LLCE_CAN_CONFIG_NOTIF_TABLE_SIZE 17U
+/**
+ * Number fo ETH buffers used to interface with the host core for can2eth
+ * use case.
+ */
+#define LLCE_CAN_CONFIG_MAX_ETH_FRAME 2U
+/**
+ * Maximum buffer size used to store the CAN FD frame payload.
+ * See llce_can_mb_type
+ */
+#define LLCE_CAN_CONFIG_PAYLOAD_MAX_SIZE 64U
+/**
+ * Maximum number of hardware controllers usable inside LLCE.
+ * See llce_can_init_cmd_type
+ */
+#define LLCE_CAN_CONFIG_MAXCTRL_COUNT 16U
+/**
+ * Maximum number of hardware controllers usable inside LLCE.
+ * See llce_can_init_cmd_type
+ */
+#define LLCE_CAN_MAX_POLLING_CLASSES 6U
+
+/**
+ * Maximum number of transmission message buffers.
+ * See llce_can_tx_mb_desc_type
+ */
+#define LLCE_CAN_CONFIG_MAXTXMB 256U
+/**
+ * Maximum number of reception message buffers.32 from those are
+ * reserved for internal usage and are not available to the host.
+ * See llce_can_rx_mb_desc_type
+ */
+#define LLCE_CAN_CONFIG_MAXRXMB 2048U
+#define LLCE_CAN_CONFIG_MAXAFRXMB 256U
+#define LLCE_CAN_CONFIG_MAXAFTXMB 256U
+#define LLCE_CAN_CONFIG_MAXAFFRMB 256U
+
+/**
+ * Maximum number of standard filters which can be configured using a
+ * single command.Multiple commands can be executed when more filters are
+ * needed.
+ * See llce_can_rx_filter_type
+ */
+#define LLCE_CAN_CONFIG_MAX_FILTERS_COUNT (20U)
+/**
+ * Number of entries of the circular buffer used to send ack
+ * information from Tx core to host core. There is 1 extra buffer for each
+ * interface for consistency purpose.
+ */
+#define LLCE_CAN_CONFIG_MAX_TXACKINFO ((u16)(512U + LLCE_CAN_RX_TX_INTERFACES))
+/**
+ * Mask used to get the right data from FIFOs. See FMR config register
+ * of FIFO.
+ */
+#define LLCE_CAN_CONFIG_FIFO_FIXED_MASK (0x0007FFFF)
+/**
+ * Maximum number of advanced filters which can be configured using a
+ * single command.Multiple commands can be executed when more filters are
+ * needed.
+ * See llce_can_advanced_filter_type
+ */
+#define LLCE_CAN_CONFIG_ADVANCED_FILTERS_COUNT 8U
+/** Shared memory size allocated for each channel for commands exchange. */
+#define LLCE_CAN_CONFIG_CTRL_SHARED_MEMORY_SIZE 0x400
+/** Reserved value in order to detect if an advanced filter entry is not used */
+#define LLCE_CAN_ADVANCED_FILTER_NOT_USED 0xFFU
+/** Interface ID used by different hosts for multihost scenarios. */
+#define LLCE_CAN_HIF0 0U
+/** Interface ID used by different hosts for multihost scenarios. */
+#define LLCE_CAN_HIF1 1U
+/** Number of interfaces which can be used by host cores. */
+#define LLCE_CAN_CONFIG_HIF_COUNT 2U
+/**
+ * Number of ocurrences of last error reported by the notification mechanism.
+ * Limited by \link llce_can_error_notif_type \endlink structure size.
+ */
+#define LLCE_CAN_CONFIG_MAX_OCCURENCES 255U
+
+/* LIN defines */
+
+/** Maximum buffer size used to store the LIN frame payload */
+#define LLCE_LIN_CONFIG_PAYLOAD_MAX_SIZE 8U
+/** Maximum number of LIN transmission buffers */
+#define LLCE_LIN_CONFIG_MAXTXBUFF 64U
+/** Maximum number of LIN reception buffers */
+#define LLCE_LIN_CONFIG_MAXRXBUFF 64U
+
+/**
+ * Boot sequence data type.
+ *
+ * Data type used to access shared memory area for managing LLCE boot sequence
+ */
+struct llce_mgr_status {
+	/**
+	 * Information used by any host application to detect the TXPE
+	 * startup ending.
+	 */
+	u32 tx_boot_end;
+	/**
+	 * Information used by any host application to detect the RXPE
+	 * startup ending.
+	 */
+	u32 rx_boot_end;
+	/**
+	 * Information used by any host application to detect the DTE
+	 * startup ending.
+	 */
+	u32 dte_boot_end;
+	/**
+	 * Information used by any host application to detect the FRPE
+	 * startup ending.
+	 */
+	u32 frpe_boot_end;
+	/** Information used by host for the runtime error count about LLCE */
+	u32 error_counter;
+	/* Information used by host for the LLCE performance benchmark. */
+	u32 stm_init_count;
+} __aligned(4);
+
+#endif /* LLCE_FIFO_H */
diff --git a/include/linux/mailbox/nxp-llce/llce_interface_fifo.h b/include/linux/mailbox/nxp-llce/llce_interface_fifo.h
new file mode 100644
index 000000000000..9d8e1d24828e
--- /dev/null
+++ b/include/linux/mailbox/nxp-llce/llce_interface_fifo.h
@@ -0,0 +1,74 @@
+/* SPDX-License-Identifier: GPL-2.0+ */
+/* Copyright 2020 NXP */
+#ifndef LLCE_FIFOINTERFACE_H
+#define LLCE_FIFOINTERFACE_H
+
+#define LLCE_CONFIG_FIFO_DEPTH		(16U)
+
+/** Configuration value of register FMR of the FIFO. */
+#define LLCE_FIFO_CONFIG_FMR		(0x00000420)
+
+#define LLCE_FIFO_FFULLD		(0x00000001U)
+#define LLCE_FIFO_FEMTYD		(0x00000002U)
+#define LLCE_FIFO_SR_QCOUNT_SHIFT	(24U)
+
+#define LLCE_FIFO_FCR_FIFOEN		(0x00000001U)
+#define LLCE_FIFO_FCR_FLENOWEN		(0x00000002U)
+#define LLCE_FIFO_FCR_POPEN		(0x00000004U)
+#define LLCE_FIFO_FCR_PUSHEN		(0x00000008U)
+#define LLCE_FIFO_FCR_FLUSH		(0x00000010U)
+
+#define LLCE_FIFO_FCR_RESET		(0x0U)
+
+/* Generic defines used to access STATUS, ILR and IER registers of FIFOs. */
+#define LLCE_FIFO_FFULL		(0x00000100U)
+#define LLCE_FIFO_FNFULL	(0x00000200U)
+#define LLCE_FIFO_FEMTY		(0x00000400U)
+#define LLCE_FIFO_FNEMTY	(0x00000800U)
+#define LLCE_FIFO_POPEVT	(0x00001000U)
+#define LLCE_FIFO_WMKFL		(0x00002000U)
+#define LLCE_FIFO_WMKEM		(0x00004000U)
+
+/* Default value returned when popping an empty fifo */
+#define LLCE_FIFO_NULL_VALUE	(0xFFFFFFFFU)
+
+/* Specific FIFOs base address calculation macros. */
+#define LLCE_GET_BLRIN_BASE_ADDRESS(hw_ctrl)                            \
+	((u32)(LLCE_BLRIN0_BASEADDR + ((u32)(hw_ctrl)*0x400U)))
+#define LLCE_GET_BLROUT_BASE_ADDRESS(hw_ctrl)                           \
+	((u32)(LLCE_BLROUT0_BASEADDR + ((u32)(hw_ctrl)*0x400U)))
+#define LLCE_GET_TXACK_BASE_ADDRESS(hw_ctrl)                            \
+	((u32)(LLCE_TXACK0_BASEADDR + ((u32)(hw_ctrl)*0x400U)))
+#define LLCE_GET_RXIN_BASE_ADDRESS(hw_ctrl)                             \
+	((u32)(LLCE_RXIN0_BASEADDR + ((u32)(hw_ctrl)*0x400U)))
+#define LLCE_GET_RXOUT_BASE_ADDRESS(hw_ctrl)                            \
+	((u32)(LLCE_RXOUT0_BASEADDR + ((u32)(hw_ctrl)*0x400U)))
+#define LLCE_GET_GENERIC_FIFO_BASE_ADDRESS(gen_ffo)                     \
+	((u32)(LLCE_GENERIC_FIFO_BASEADDR + ((u32)(gen_ffo)*0x400U)))
+#define LLCE_GENERIC_FIFO_CONFIG(gen_ffo)                               \
+	((u32)(LLCE_GET_GENERIC_FIFO_BASE_ADDRESS(gen_ffo)))
+#define LLCE_GENERIC_FIFO_STATUS0(gen_ffo)                              \
+	((u32)(LLCE_GET_GENERIC_FIFO_BASE_ADDRESS(gen_ffo) + 0x04U))
+#define LLCE_GENERIC_FIFO_STATUS1(gen_ffo)                              \
+	((u32)(LLCE_GET_GENERIC_FIFO_BASE_ADDRESS(gen_ffo) + 0x08U))
+#define LLCE_GENERIC_FIFO_IER(gen_ffo)                                  \
+	((u32)(LLCE_GET_GENERIC_FIFO_BASE_ADDRESS(gen_ffo) + 0x0CU))
+#define LLCE_GENERIC_FIFO_ILR(gen_ffo)                                  \
+	((u32)(LLCE_GET_GENERIC_FIFO_BASE_ADDRESS(gen_ffo) + 0x10U))
+#define LLCE_GENERIC_FIFO_PUSH0(gen_ffo)                                \
+	((u32)(LLCE_GET_GENERIC_FIFO_BASE_ADDRESS(gen_ffo) + 0x14U))
+#define LLCE_GENERIC_FIFO_POP0(gen_ffo)                                 \
+	((u32)(LLCE_GET_GENERIC_FIFO_BASE_ADDRESS(gen_ffo) + 0x24U))
+#define LLCE_GENERIC_FIFO_FMR(gen_ffo)                                  \
+	((u32)(LLCE_GET_GENERIC_FIFO_BASE_ADDRESS(gen_ffo) + 0x34U))
+
+#define LLCE_FIFO_CONFIG(BASE)	(BASE)
+#define LLCE_FIFO_STATUS0(BASE)	((BASE) + 0x04U)
+#define LLCE_FIFO_STATUS1(BASE)	((BASE) + 0x08U)
+#define LLCE_FIFO_IER(BASE)	((BASE) + 0x0CU)
+#define LLCE_FIFO_ILR(BASE)	((BASE) + 0x10U)
+#define LLCE_FIFO_PUSH0(BASE)	((BASE) + 0x14U)
+#define LLCE_FIFO_POP0(BASE)	((BASE) + 0x24U)
+#define LLCE_FIFO_FMR(BASE)	((BASE) + 0x34U)
+
+#endif /* LLCE_FIFOINTERFACE_H */
diff --git a/include/linux/mailbox/nxp-llce/llce_mailbox.h b/include/linux/mailbox/nxp-llce/llce_mailbox.h
new file mode 100644
index 000000000000..f96846b2b6db
--- /dev/null
+++ b/include/linux/mailbox/nxp-llce/llce_mailbox.h
@@ -0,0 +1,42 @@
+/* SPDX-License-Identifier: GPL-2.0+ */
+/* Copyright 2020 NXP */
+#ifndef LLCE_MAILBOX_H
+#define LLCE_MAILBOX_H
+
+#include <linux/spinlock_types.h>
+#include <linux/mailbox/nxp-llce/llce_can.h>
+#include <uapi/linux/can.h>
+
+struct llce_mb;
+
+enum llce_chan_state {
+	LLCE_UNREGISTERED_CHAN,
+	LLCE_REGISTERED_CHAN,
+};
+
+/** Private data attached to a LLCE channel */
+struct llce_chan_priv {
+	struct llce_mb *mb;
+	void *last_msg;
+	unsigned int type;
+	unsigned int index;
+	enum llce_chan_state state;
+	spinlock_t lock;
+};
+
+struct llce_tx_msg {
+	bool fd;
+	struct canfd_frame *cf;
+};
+
+struct llce_notif {
+	enum llce_can_error error;
+	union {
+		/* TX notification */
+		uint32_t tx_timestamp;
+		/* RX notiication */
+		struct llce_can_mb *can_mb;
+	};
+};
+
+#endif
-- 
2.25.1

