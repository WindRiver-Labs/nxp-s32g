From 8900174f1885f5b9a9779cc6834bcfc2971d1d90 Mon Sep 17 00:00:00 2001
From: Larisa Grigore <larisa.grigore@nxp.com>
Date: Fri, 5 Feb 2021 15:40:31 +0200
Subject: [PATCH 66/78] serial:linflex: Make sure fifo is empty when entering
 INIT

In FIFO mode, we should wait for UARTCR.TDFL_TFC(number of entries
(bytes) of the Tx FIFO) and UARTCR.RDFL_RFC(number of entries (bytes)
of the Rx FIFO) becoming 0.
Otherwise, linflex will have an undefined behavior:
- corrupted characters will be printed
- linflex doesn't receive any character (the cable must be reconnected)
- restart remains blocked because after leaving INIT state, no other
character can be transmited.

Issue: ALB-6257, ALB-6375
Signed-off-by: Larisa Grigore <larisa.grigore@nxp.com>
---
 drivers/tty/serial/fsl_linflexuart.c | 54 ++++++++++++++++++++++++++++
 1 file changed, 54 insertions(+)

diff --git a/drivers/tty/serial/fsl_linflexuart.c b/drivers/tty/serial/fsl_linflexuart.c
index 4f6b28573d14..5e6b3e3ea248 100644
--- a/drivers/tty/serial/fsl_linflexuart.c
+++ b/drivers/tty/serial/fsl_linflexuart.c
@@ -98,6 +98,17 @@
 #define LINFLEXD_UARTCR_SBUR_2SBITS	(0x1 << 17)
 #define LINFLEXD_UARTCR_SBUR_3SBITS	(0x2 << 17)
 
+#define LINFLEXD_UARTCR_RDFLRFC_OFFSET	10
+#define LINFLEXD_UARTCR_RDFLRFC_MASK	(0x7 << LINFLEXD_UARTCR_RDFLRFC_OFFSET)
+#define LINFLEXD_UARTCR_RDFLRFC(uartcr)	(((uartcr) \
+					& LINFLEXD_UARTCR_RDFLRFC_MASK) >> \
+					LINFLEXD_UARTCR_RDFLRFC_OFFSET)
+#define LINFLEXD_UARTCR_TDFLTFC_OFFSET	13
+#define LINFLEXD_UARTCR_TDFLTFC_MASK	(0x7 << LINFLEXD_UARTCR_TDFLTFC_OFFSET)
+#define LINFLEXD_UARTCR_TDFLTFC(uartcr)	(((uartcr) \
+					& LINFLEXD_UARTCR_TDFLTFC_MASK) >> \
+					LINFLEXD_UARTCR_TDFLTFC_OFFSET)
+
 #define LINFLEXD_UARTCR_RFBM		BIT(9)
 #define LINFLEXD_UARTCR_TFBM		BIT(8)
 #define LINFLEXD_UARTCR_WL1		BIT(7)
@@ -295,6 +306,34 @@ static void linflex_disable_dma_tx(struct uart_port *port)
 		;
 }
 
+static void inline linflex_wait_rx_fifo_empty(struct uart_port *port)
+{
+	unsigned long cr = readl(port->membase + UARTCR);
+
+	/* Check the register because dma_rx_use can be true
+	 * and the bit not set yet.
+	 */
+	if (!(cr & LINFLEXD_UARTCR_RFBM))
+		return;
+
+	while (LINFLEXD_UARTCR_RDFLRFC(readl(port->membase + UARTCR)))
+		;
+}
+
+static void inline linflex_wait_tx_fifo_empty(struct uart_port *port)
+{
+	unsigned long cr = readl(port->membase + UARTCR);
+
+	/* Check the register because dma_tx_use can be true
+	 * and the bit not set yet.
+	 */
+	if (!(cr & LINFLEXD_UARTCR_TFBM))
+		return;
+
+	while (LINFLEXD_UARTCR_TDFLTFC(readl(port->membase + UARTCR)))
+		;
+}
+
 static void linflex_stop_tx(struct uart_port *port)
 {
 	unsigned long ier;
@@ -705,9 +744,17 @@ static void linflex_setup_watermark(struct linflex_port *sport)
 	cr &= ~(LINFLEXD_UARTCR_RXEN | LINFLEXD_UARTCR_TXEN);
 	writel(cr, sport->port.membase + UARTCR);
 
+	/* In FIFO mode, we should make sure the fifo is empty
+	 * before entering INIT otherwise the remaining characters
+	 * will be corrupted.
+	 */
+	linflex_wait_rx_fifo_empty(&sport->port);
+	linflex_wait_tx_fifo_empty(&sport->port);
+
 	/* Enter initialization mode by setting INIT bit */
 
 	/* set the Linflex in master mode and activate by-pass filter */
+
 	cr1 = LINFLEXD_LINCR1_BF | LINFLEXD_LINCR1_MME
 	      | LINFLEXD_LINCR1_INIT;
 	writel(cr1, sport->port.membase + LINCR1);
@@ -964,6 +1011,13 @@ linflex_set_termios(struct uart_port *port, struct ktermios *termios,
 	cr = old_cr = readl(sport->port.membase + UARTCR) &
 		~(LINFLEXD_UARTCR_RXEN | LINFLEXD_UARTCR_TXEN);
 
+	/* In FIFO mode, we should make sure the fifo is empty
+	 * before entering INIT otherwise the remaining characters
+	 * will be corrupted.
+	 */
+	linflex_wait_rx_fifo_empty(&sport->port);
+	linflex_wait_tx_fifo_empty(&sport->port);
+
 	/* disable transmit and receive */
 	writel(old_cr, sport->port.membase + UARTCR);
 
-- 
2.25.1

