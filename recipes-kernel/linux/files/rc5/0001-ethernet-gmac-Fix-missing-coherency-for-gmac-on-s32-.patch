From e601567fe1de6a68fc91b474719fb35a763958b0 Mon Sep 17 00:00:00 2001
From: Ondrej Spacek <ondrej.spacek@nxp.com>
Date: Fri, 30 Jul 2021 09:18:54 +0200
Subject: [PATCH 01/49] ethernet: gmac: Fix missing coherency for gmac on s32
 platform.

commit e601567fe1de6a68fc91b474719fb35a763958b0 from
https://source.codeaurora.org/external/autobsps32/linux

The coherency has to be configured via GMAC ACE registers.

Upstream-Status: Pending

Issue: ALB-7461
Signed-off-by: Ondrej Spacek <ondrej.spacek@nxp.com>
Signed-off-by: Zhantao Tang <zhantao.tang@windriver.com>
---
 .../net/ethernet/stmicro/stmmac/dwmac-s32cc.c |  4 ++
 .../net/ethernet/stmicro/stmmac/dwmac4_dma.c  | 49 ++++++++++++++++++-
 .../net/ethernet/stmicro/stmmac/dwmac4_dma.h  | 32 ++++++++++++
 3 files changed, 84 insertions(+), 1 deletion(-)

diff --git a/drivers/net/ethernet/stmicro/stmmac/dwmac-s32cc.c b/drivers/net/ethernet/stmicro/stmmac/dwmac-s32cc.c
index b9811d04a753..43c33405759f 100644
--- a/drivers/net/ethernet/stmicro/stmmac/dwmac-s32cc.c
+++ b/drivers/net/ethernet/stmicro/stmmac/dwmac-s32cc.c
@@ -302,6 +302,10 @@ static int s32cc_dwmac_probe(struct platform_device *pdev)
 
 	plat_dat->bsp_priv = gmac;
 
+	/* Enable AXI fixup call */
+	plat_dat->axi = devm_kzalloc(&pdev->dev, sizeof(struct stmmac_axi),
+				     GFP_KERNEL);
+
 	if (plat_dat->phy_interface != PHY_INTERFACE_MODE_SGMII &&
 	    !phy_interface_mode_is_rgmii(plat_dat->phy_interface)) {
 		dev_err(&pdev->dev, "Not supported phy interface mode: [%s]\n",
diff --git a/drivers/net/ethernet/stmicro/stmmac/dwmac4_dma.c b/drivers/net/ethernet/stmicro/stmmac/dwmac4_dma.c
index 4a1f31a29ff7..b079dd301a42 100644
--- a/drivers/net/ethernet/stmicro/stmmac/dwmac4_dma.c
+++ b/drivers/net/ethernet/stmicro/stmmac/dwmac4_dma.c
@@ -6,6 +6,7 @@
  * This contains the functions to handle the dma.
  *
  * Copyright (C) 2015  STMicroelectronics Ltd
+ * Copyright 2021 NXP
  *
  * Author: Alexandre Torgue <alexandre.torgue@st.com>
  */
@@ -68,6 +69,52 @@ static void dwmac4_dma_axi(void __iomem *ioaddr, struct stmmac_axi *axi)
 	writel(value, ioaddr + DMA_SYS_BUS_MODE);
 }
 
+static void dwmac5_dma_axi(void __iomem *ioaddr, struct stmmac_axi *axi)
+{
+	u32 value;
+
+	value = DMA_AXI_AWAR(DMA_AXI_OUTER_SHARABLE,
+			     DMA_AXI_WBACK_RWALLOCATE,
+			     DMA_ACE_TX_DESCRIPTOR_R);
+	value |= DMA_AXI_AWAR(DMA_AXI_OUTER_SHARABLE,
+			      DMA_AXI_WBACK_RWALLOCATE,
+			      DMA_ACE_TX_EXT_BUFF_TSO_R);
+	value |= DMA_AXI_AWAR(DMA_AXI_OUTER_SHARABLE,
+			      DMA_AXI_WBACK_RWALLOCATE,
+			      DMA_ACE_TX_FIRST_BUFF_TSO_R);
+
+	writel(value, ioaddr + DMA_AXI4_TX_AR_ACE_CONTROL);
+
+	value = DMA_AXI_AWAR(DMA_AXI_OUTER_SHARABLE,
+			     DMA_AXI_WBACK_RWALLOCATE,
+			     DMA_ACE_RX_DESCRIPTOR_W);
+	value |= DMA_AXI_AWAR(DMA_AXI_OUTER_SHARABLE,
+			      DMA_AXI_WBACK_RWALLOCATE,
+			      DMA_ACE_RX_PAYLOAD_W);
+	value |= DMA_AXI_AWAR(DMA_AXI_OUTER_SHARABLE,
+			      DMA_AXI_WBACK_RWALLOCATE,
+			      DMA_ACE_RX_DMA_HEADER_W);
+	value |= DMA_AXI_AWAR(DMA_AXI_OUTER_SHARABLE,
+			      DMA_AXI_WBACK_RWALLOCATE,
+			      DMA_ACE_RX_BUFFER_W);
+
+	writel(value, ioaddr + DMA_AXI4_RX_AW_ACE_CONTROL);
+
+	value = DMA_AXI_AWAR(DMA_AXI_OUTER_SHARABLE,
+			     DMA_AXI_WBACK_RWALLOCATE,
+			     DMA_ACE_TXRX_DESCRIPTOR_W);
+	value |= DMA_AXI_AWAR(DMA_AXI_OUTER_SHARABLE,
+			      DMA_AXI_WBACK_RWALLOCATE,
+			      DMA_ACE_TXRX_DESCRIPTOR_R);
+
+	value |= DMA_AXI_AWAR_PROT(DMA_AXI_NON_SECURE_ACCESS,
+				   DMA_ACE_TXRX_DMA_ARPROT);
+	value |= DMA_AXI_AWAR_PROT(DMA_AXI_NON_SECURE_ACCESS,
+				   DMA_ACE_TXRX_DMA_AWPROT);
+
+	writel(value, ioaddr + DMA_AXI4_TXRX_AWAR_ACE_CONTROL);
+}
+
 static void dwmac4_dma_init_rx_chan(void __iomem *ioaddr,
 				    struct stmmac_dma_cfg *dma_cfg,
 				    dma_addr_t dma_rx_phy, u32 chan)
@@ -583,7 +630,7 @@ const struct stmmac_dma_ops dwmac410_s32cc_dma_ops = {
 	.init_chan = dwmac4_dma_init_channel,
 	.init_rx_chan = dwmac4_dma_init_rx_chan,
 	.init_tx_chan = dwmac4_dma_init_tx_chan,
-	.axi = dwmac4_dma_axi,
+	.axi = dwmac5_dma_axi,
 	.dump_regs = dwmac4_dump_dma_regs,
 	.dma_rx_mode = dwmac4_dma_rx_chan_op_mode,
 	.dma_tx_mode = dwmac4_dma_tx_chan_op_mode,
diff --git a/drivers/net/ethernet/stmicro/stmmac/dwmac4_dma.h b/drivers/net/ethernet/stmicro/stmmac/dwmac4_dma.h
index 84e2f99f17ef..448a4c8218c7 100644
--- a/drivers/net/ethernet/stmicro/stmmac/dwmac4_dma.h
+++ b/drivers/net/ethernet/stmicro/stmmac/dwmac4_dma.h
@@ -3,6 +3,7 @@
  * DWMAC4 DMA Header file.
  *
  * Copyright (C) 2007-2015  STMicroelectronics Ltd
+ * Copyright 2021 NXP
  *
  * Author: Alexandre Torgue <alexandre.torgue@st.com>
  */
@@ -24,6 +25,11 @@
 #define DMA_AXI_BUS_MODE		0x00001028
 #define DMA_TBS_CTRL			0x00001050
 
+/* Ace configuration */
+#define DMA_AXI4_TX_AR_ACE_CONTROL	0x00001020
+#define DMA_AXI4_RX_AW_ACE_CONTROL	0x00001024
+#define DMA_AXI4_TXRX_AWAR_ACE_CONTROL	0x00001028
+
 /* DMA Bus Mode bitmap */
 #define DMA_BUS_MODE_SFT_RESET		BIT(0)
 
@@ -83,6 +89,32 @@
 
 #define DMA_AXI_BURST_LEN_MASK		0x000000FE
 
+/* DMA AXI ACE config */
+#define DMA_AXI_OUTER_SHARABLE		(0x2)
+
+#define DMA_AXI_SECURE_ACCESS		(0x0)
+#define DMA_AXI_NON_SECURE_ACCESS	(0x2)
+
+#define DMA_AXI_WBACK_RWALLOCATE	(0xf)
+
+#define DMA_AXI_AWAR(dom, cache, off) ((((dom) & 0x3) << 4 | ((cache) & 0xf)) \
+				       << (off))
+#define DMA_AXI_AWAR_PROT(prot, off) (((prot) & 0x3) << (off))
+
+#define DMA_ACE_TX_DESCRIPTOR_R	(0)
+#define DMA_ACE_TX_EXT_BUFF_TSO_R	(8)
+#define DMA_ACE_TX_FIRST_BUFF_TSO_R	(16)
+
+#define DMA_ACE_RX_DESCRIPTOR_W		(0)
+#define DMA_ACE_RX_PAYLOAD_W		(8)
+#define DMA_ACE_RX_DMA_HEADER_W		(16)
+#define DMA_ACE_RX_BUFFER_W		(24)
+
+#define DMA_ACE_TXRX_DESCRIPTOR_W	(0)
+#define DMA_ACE_TXRX_DESCRIPTOR_R	(8)
+#define DMA_ACE_TXRX_DMA_ARPROT		(16)
+#define DMA_ACE_TXRX_DMA_AWPROT		(20)
+
 /* DMA TBS Control */
 #define DMA_TBS_FTOS			GENMASK(31, 8)
 #define DMA_TBS_FTOV			BIT(0)
-- 
2.17.1

