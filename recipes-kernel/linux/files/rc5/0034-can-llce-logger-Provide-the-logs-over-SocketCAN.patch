From 9b13b30bb50f7fc2b179222a1e9957ed89be8d25 Mon Sep 17 00:00:00 2001
From: Ghennadi Procopciuc <ghennadi.procopciuc@nxp.com>
Date: Wed, 4 Aug 2021 10:15:47 +0300
Subject: [PATCH 34/49] can: llce: logger: Provide the logs over SocketCAN

commit 9b13b30bb50f7fc2b179222a1e9957ed89be8d25 from
https://source.codeaurora.org/external/autobsps32/linux

This changes the design of LLCE Logger from one single instance
that provides the logs in text mode to one virtual CAN instance for
each LLCE CAN interface which sends the logs using SoketCAN.

Upstream-Status: Pending

Issue: ALB-7505
Signed-off-by: Ghennadi Procopciuc <ghennadi.procopciuc@nxp.com>
Signed-off-by: Zhantao Tang <zhantao.tang@windriver.com>
---
 .../net/can/nxp,s32g-llce-can-logger.yaml     |   2 +-
 arch/arm64/boot/dts/freescale/fsl-s32g.dtsi   |  92 +++-
 drivers/net/can/llce/Kconfig                  |   7 +-
 drivers/net/can/llce/llce_logger.c            | 478 ++++--------------
 4 files changed, 200 insertions(+), 379 deletions(-)

diff --git a/Documentation/devicetree/bindings/net/can/nxp,s32g-llce-can-logger.yaml b/Documentation/devicetree/bindings/net/can/nxp,s32g-llce-can-logger.yaml
index c50020c098c1..d5e42508c669 100644
--- a/Documentation/devicetree/bindings/net/can/nxp,s32g-llce-can-logger.yaml
+++ b/Documentation/devicetree/bindings/net/can/nxp,s32g-llce-can-logger.yaml
@@ -11,7 +11,7 @@ maintainers:
 
 description: |
   This driver is used on S32G2xx to log CAN messages received from LLCE.
-  It provides a interface to userspace, as a char device.
+  It provides a interface to userspace, as a vcan interface.
   Separate LLCE configuration for CAN is expected.
   It assumes that the LLCE Firmware is already loaded.
 
diff --git a/arch/arm64/boot/dts/freescale/fsl-s32g.dtsi b/arch/arm64/boot/dts/freescale/fsl-s32g.dtsi
index 77e31f53b7a6..134b2423d5f3 100644
--- a/arch/arm64/boot/dts/freescale/fsl-s32g.dtsi
+++ b/arch/arm64/boot/dts/freescale/fsl-s32g.dtsi
@@ -629,12 +629,102 @@
 			status = "okay";
 		};
 
-		llce_can_logger: llce_can_logger {
+		llce_can_logger0: llce_can_logger0 {
 			compatible = "nxp,s32g-llce-can-logger";
 			mboxes = <&llce_mb S32G_LLCE_CAN_LOGGER_MB 0>;
 			status = "okay";
 		};
 
+		llce_can_logger1: llce_can_logger1 {
+			compatible = "nxp,s32g-llce-can-logger";
+			mboxes = <&llce_mb S32G_LLCE_CAN_LOGGER_MB 1>;
+			status = "okay";
+		};
+
+		llce_can_logger2: llce_can_logger2 {
+			compatible = "nxp,s32g-llce-can-logger";
+			mboxes = <&llce_mb S32G_LLCE_CAN_LOGGER_MB 2>;
+			status = "okay";
+		};
+
+		llce_can_logger3: llce_can_logger3 {
+			compatible = "nxp,s32g-llce-can-logger";
+			mboxes = <&llce_mb S32G_LLCE_CAN_LOGGER_MB 3>;
+			status = "okay";
+		};
+
+		llce_can_logger4: llce_can_logger4 {
+			compatible = "nxp,s32g-llce-can-logger";
+			mboxes = <&llce_mb S32G_LLCE_CAN_LOGGER_MB 4>;
+			status = "okay";
+		};
+
+		llce_can_logger5: llce_can_logger5 {
+			compatible = "nxp,s32g-llce-can-logger";
+			mboxes = <&llce_mb S32G_LLCE_CAN_LOGGER_MB 5>;
+			status = "okay";
+		};
+
+		llce_can_logger6: llce_can_logger6 {
+			compatible = "nxp,s32g-llce-can-logger";
+			mboxes = <&llce_mb S32G_LLCE_CAN_LOGGER_MB 6>;
+			status = "okay";
+		};
+
+		llce_can_logger7: llce_can_logger7 {
+			compatible = "nxp,s32g-llce-can-logger";
+			mboxes = <&llce_mb S32G_LLCE_CAN_LOGGER_MB 7>;
+			status = "okay";
+		};
+
+		llce_can_logger8: llce_can_logger8 {
+			compatible = "nxp,s32g-llce-can-logger";
+			mboxes = <&llce_mb S32G_LLCE_CAN_LOGGER_MB 8>;
+			status = "okay";
+		};
+
+		llce_can_logger9: llce_can_logger9 {
+			compatible = "nxp,s32g-llce-can-logger";
+			mboxes = <&llce_mb S32G_LLCE_CAN_LOGGER_MB 9>;
+			status = "okay";
+		};
+
+		llce_can_logger10: llce_can_logger10 {
+			compatible = "nxp,s32g-llce-can-logger";
+			mboxes = <&llce_mb S32G_LLCE_CAN_LOGGER_MB 10>;
+			status = "okay";
+		};
+
+		llce_can_logger11: llce_can_logger11 {
+			compatible = "nxp,s32g-llce-can-logger";
+			mboxes = <&llce_mb S32G_LLCE_CAN_LOGGER_MB 11>;
+			status = "okay";
+		};
+
+		llce_can_logger12: llce_can_logger12 {
+			compatible = "nxp,s32g-llce-can-logger";
+			mboxes = <&llce_mb S32G_LLCE_CAN_LOGGER_MB 12>;
+			status = "okay";
+		};
+
+		llce_can_logger13: llce_can_logger13 {
+			compatible = "nxp,s32g-llce-can-logger";
+			mboxes = <&llce_mb S32G_LLCE_CAN_LOGGER_MB 13>;
+			status = "okay";
+		};
+
+		llce_can_logger14: llce_can_logger14 {
+			compatible = "nxp,s32g-llce-can-logger";
+			mboxes = <&llce_mb S32G_LLCE_CAN_LOGGER_MB 14>;
+			status = "okay";
+		};
+
+		llce_can_logger15: llce_can_logger15 {
+			compatible = "nxp,s32g-llce-can-logger";
+			mboxes = <&llce_mb S32G_LLCE_CAN_LOGGER_MB 15>;
+			status = "okay";
+		};
+
 		llce_can0: llce_can0 {
 			compatible = "nxp,s32g-llce-can";
 			mboxes = <&llce_mb S32G_LLCE_CAN_CONF_MB 0>,
diff --git a/drivers/net/can/llce/Kconfig b/drivers/net/can/llce/Kconfig
index 209f609d46f3..6cb17d77e322 100644
--- a/drivers/net/can/llce/Kconfig
+++ b/drivers/net/can/llce/Kconfig
@@ -26,9 +26,10 @@ config CAN_LLCE_LOGGER
 	tristate "LLCE CAN Logger"
 	depends on m
 	help
-	  This driver is used on S32G2xx to log CAN messages received from LLCE.
-	  It provides a interface to userspace, as a char device, on which you
-	  can cat or you can echo a value to set the log size to that dimension.
+	  This driver is used on S32G2XX to log CAN messages received from LLCE.
+	  It provides to user space as a virtual can (vcan) interface, on which
+	  you can listen to receive the RX traffic associated with its LLCE CAN
+	  counterpart.
 	  Separate LLCE configuration for CAN is expected.
 
 	  It assumes that the LLCE Firmware is already loaded.
diff --git a/drivers/net/can/llce/llce_logger.c b/drivers/net/can/llce/llce_logger.c
index d63c1156c913..ca93e8ba2b3c 100644
--- a/drivers/net/can/llce/llce_logger.c
+++ b/drivers/net/can/llce/llce_logger.c
@@ -1,445 +1,175 @@
-// SPDX-License-Identifier: GPL-2.0-or-later
+// SPDX-License-Identifier: GPL-2.0+ OR BSD-3-Clause
 /* Copyright 2020-2021 NXP
  *
  * Driver for the NXP Semiconductors LLCE engine logging of CAN messages.
  * The LLCE can be found on S32G2xx.
  */
-
-#include <linux/atomic.h>
-#include <linux/bitops.h>
 #include <linux/can/dev.h>
-#include <linux/circ_buf.h>
-#include <linux/debugfs.h>
-#include <linux/delay.h>
-#include <linux/freezer.h>
-#include <linux/fs.h>
-#include <linux/io.h>
+#include <linux/can/dev/llce_can_common.h>
+#include <linux/clk.h>
+#include <linux/ctype.h>
 #include <linux/kernel.h>
 #include <linux/mailbox/nxp-llce/llce_can.h>
-#include <linux/mailbox/nxp-llce/llce_can_utils.h>
-#include <linux/mailbox/nxp-llce/llce_interface_fifo.h>
 #include <linux/mailbox/nxp-llce/llce_mailbox.h>
 #include <linux/mailbox_client.h>
+#include <linux/mailbox_controller.h>
 #include <linux/module.h>
 #include <linux/moduleparam.h>
-#include <linux/of_device.h>
 #include <linux/platform_device.h>
-#include <linux/slab.h>
-#include <linux/uaccess.h>
-
-#define	DRIVER_NAME			"llce-logger"
-#define	INPUT_STRING_LENGTH 5
-
-/* Logging structure
- */
-struct frame_log {
-	struct llce_can_mb frame;
-	u8 hw_ctrl;
-};
-
-struct llce_dbg {
-	struct dentry *dir;
-	struct dentry *log;
-};
-
-struct llce_syncs {
-	wait_queue_head_t fifo_event;
-	/* guarantees max 1 userspace thread for consistency */
-	struct mutex userspace_access;
-};
-
-struct llce_data {
-	struct circ_buf cbuf;
-	atomic_t frames_received;
-	size_t max_ser_size;
-};
 
-struct llce_priv {
-	struct llce_data data;
-	struct llce_syncs syncs;
-	struct llce_dbg dbg;
-	struct mbox_client rx_client;
+#define LLCE_LOGGER_NETDEV_IF_NAME	"llcelogger"
 
-	struct device *dev;
-	struct mbox_chan *rx_chan;
+struct llce_logger {
+	struct llce_can_dev common; /* Must be the first member */
 };
 
-/* This must be a power of two due to circular buffer implementation */
-static unsigned long log_size = 4096;
-module_param(log_size, ulong, 0660);
-
-static size_t get_left_len(size_t cur_idx, size_t str_len)
+static int llce_logger_open(struct net_device *dev)
 {
-	if (!str_len)
-		return 0;
-	return str_len - cur_idx;
-}
-
-static unsigned int create_entry_string(struct frame_log *frame,
-					char *out_str, int cur_idx,
-					size_t str_len)
-{
-	int wr_size, j;
-	bool ide, fdf, rtr, brs, esi;
-	u32 tstamp, std_id, ext_id, can_id;
-	u8 cur_char, dlc;
-	char *str_start;
-
-	unpack_word0(frame->frame.word0, &rtr, &ide, &std_id, &ext_id);
-	unpack_word1(frame->frame.word1, &fdf, &dlc, &brs, &esi);
-	can_id = std_id & CAN_SFF_MASK;
-	if (fdf && ide)
-		can_id |= ((ext_id << CAN_SFF_ID_BITS) & CAN_EFF_MASK);
-
-	tstamp = frame->frame.timestamp;
-	str_start = out_str + cur_idx;
-	wr_size = snprintf(str_start, get_left_len(cur_idx, str_len),
-			   "intf=%2d t=%8x rtr=%d brs=%d esi=%d id=%8x ",
-			   frame->hw_ctrl, tstamp, rtr, brs, esi, can_id);
-	cur_idx += wr_size;
-
-	str_start = out_str + cur_idx;
-	wr_size = snprintf(str_start, get_left_len(cur_idx, str_len), "d=(");
-	cur_idx += wr_size;
-
-	for (j = 0; j < can_dlc2len(dlc); j++) {
-		cur_char = frame->frame.payload[j];
-		str_start = out_str + cur_idx;
-		wr_size = snprintf(str_start, get_left_len(cur_idx, str_len),
-				   "%02x ", cur_char);
-		cur_idx += wr_size;
-	}
-
-	/* Remove extra space */
-	if (j)
-		cur_idx--;
-	str_start = out_str + cur_idx;
-	wr_size = snprintf(str_start, get_left_len(cur_idx, str_len), ")\n");
-	cur_idx += wr_size;
-
-	return cur_idx;
-}
+	struct llce_logger *llce = netdev_priv(dev);
+	struct llce_can_dev *llce_dev = &llce->common;
+	int ret = 0;
 
-static bool has_elem_space(struct llce_priv *priv, size_t fill, size_t size)
-{
-	if (priv->data.max_ser_size + fill >= size)
-		return false;
+	napi_enable(&llce_dev->napi);
 
-	return true;
-}
+	llce_dev->rx = mbox_request_channel(&llce_dev->rx_client, 0);
+	if (IS_ERR(llce_dev->rx)) {
+		ret = PTR_ERR(llce_dev->rx);
+		netdev_err(dev, "Failed to get logger RX mailbox: %d\n",
+			   ret);
+		goto disable_napi;
+	}
 
-static int dump_can_frames(struct llce_priv *priv, char *out_str,
-			   unsigned int *cur_idx, size_t size)
-{
-	struct llce_data *data = &priv->data;
-	struct frame_log *buffer;
-	size_t circ_elem, i;
-	int head, tail, ret;
-
-	buffer = (struct frame_log *)data->cbuf.buf;
-	ret = wait_event_freezable(priv->syncs.fifo_event,
-				   CIRC_CNT(data->cbuf.head,
-					    data->cbuf.tail, log_size) >= 1);
+	ret = enable_llce_rx_notif(llce_dev);
 	if (ret)
-		return ret;
+		netdev_err(dev, "Failed to enable interrupt\n");
 
-	/* Read index before reading contents at that index. */
-	head = smp_load_acquire(&data->cbuf.head);
-	tail = data->cbuf.tail;
-
-	circ_elem = CIRC_CNT_TO_END(head, tail, log_size);
-
-	for (i = 0; i < circ_elem && has_elem_space(priv, *cur_idx, size);
-	     i++) {
-		*cur_idx = create_entry_string(&buffer[tail + i], out_str,
-					       *cur_idx, size);
-
-		atomic_inc(&priv->data.frames_received);
-	}
-
-	/* Finish reading descriptor before incrementing tail. */
-	smp_store_release(&data->cbuf.tail, (tail + i) & (log_size - 1));
+disable_napi:
+	if (ret)
+		napi_disable(&llce_dev->napi);
 
-	return 0;
+	return ret;
 }
 
-static int can_logger_open(struct inode *inode, struct file *file)
+static int llce_logger_close(struct net_device *dev)
 {
-	struct llce_priv *priv;
+	struct llce_logger *llce = netdev_priv(dev);
+	struct llce_can_dev *common = &llce->common;
 
-	file->private_data = (struct llce_priv *)inode->i_private;
-	priv = file->private_data;
-	/* Allow only one userspace thread at a time (for consistency) */
-	mutex_lock(&priv->syncs.userspace_access);
+	napi_disable(&common->napi);
+	mbox_free_channel(common->rx);
 
 	return 0;
 }
 
-static int can_logger_release(struct inode *inode, struct file *file)
-{
-	struct llce_priv *priv;
-
-	priv = file->private_data;
-	mutex_unlock(&priv->syncs.userspace_access);
-
-	return 0;
-}
+static const struct net_device_ops llce_logger_netdev_ops = {
+	.ndo_open	= llce_logger_open,
+	.ndo_stop	= llce_logger_close,
+};
 
-/**
- *  Used to return a string which contains the CAN logs.
- */
-static ssize_t can_logger_read(struct file *file, char __user *user_buffer,
-			       size_t size, loff_t *offset)
+static int llce_logger_probe(struct platform_device *pdev)
 {
-	struct llce_priv *priv;
-	char *out_str;
-	unsigned int fill = 0;
+	struct net_device *netdev;
+	struct llce_logger *logger;
+	struct llce_can_dev *common;
+	struct device *dev = &pdev->dev;
+	struct can_priv *can;
 	int ret;
 
-	priv = file->private_data;
+	common = init_llce_can_dev(dev, sizeof(struct llce_logger),
+				   LLCE_LOGGER_NETDEV_IF_NAME);
+	if (IS_ERR(common))
+		return PTR_ERR(common);
 
-	out_str = kmalloc(size, GFP_KERNEL);
-	if (!out_str)
-		return -ENOMEM;
-
-	ret = dump_can_frames(priv, out_str, &fill, size);
-	if (ret) {
-		if (ret == -ERANGE)
-			ret = 0;
-		goto free_mem;
-	}
+	logger = container_of(common, struct llce_logger, common);
+	can = &common->can;
+	netdev = can->dev;
 
-	if (copy_to_user(user_buffer, out_str, fill)) {
-		ret = -EFAULT;
-		goto free_mem;
-	}
+	platform_set_drvdata(pdev, netdev);
 
-	*offset += fill;
+	netdev->netdev_ops = &llce_logger_netdev_ops;
 
-free_mem:
-	kfree(out_str);
-	return fill;
-}
+	can->restart_ms = 1;
+	can->state = CAN_STATE_STOPPED;
+	can->ctrlmode_supported = CAN_CTRLMODE_FD |
+		CAN_CTRLMODE_FD_NON_ISO |
+		CAN_CTRLMODE_LISTENONLY;
 
-static const struct file_operations fops = {
-	.owner		= THIS_MODULE,
-	.open		= can_logger_open,
-	.release	= can_logger_release,
-	.read		= can_logger_read,
-	.llseek		= no_llseek,
-};
+	enable_llce_napi(common);
 
-static const struct of_device_id llce_logger_dt_ids[] = {
-	{
-		.compatible = "nxp,s32g-llce-can-logger",
-	},
-	{ /* sentinel */ }
-};
-
-static int add_dbgfs_entry(struct llce_priv *priv)
-{
-	int ret = 0;
-	struct device *dev = priv->dev;
-
-	priv->dbg.dir = debugfs_create_dir("llce", 0);
-	if (!priv->dbg.dir) {
-		dev_err(dev, "Couldn't create debugfs dir\n");
-		return -ENOENT;
-	}
-
-	priv->dbg.log = debugfs_create_file("log", 0600, priv->dbg.dir,
-					    priv, &fops);
-	if (!priv->dbg.log) {
-		dev_err(dev, "Couldn't create debugfs file\n");
-		ret = -ENOENT;
+	ret = register_candev(netdev);
+	if (ret) {
+		dev_err(dev, "Failed to register %s\n", netdev->name);
+		free_llce_netdev(common);
 	}
 
-	if (ret)
-		debugfs_remove_recursive(priv->dbg.dir);
-
 	return ret;
 }
 
-static void remove_dbgfs_entry(struct llce_priv *priv)
-{
-	debugfs_remove_recursive(priv->dbg.dir);
-}
-
-/**
- * This is called from IRQ context
- */
-static void logger_notif_callback(struct mbox_client *cl, void *msg)
-{
-	struct llce_priv *priv = container_of(cl, struct llce_priv, rx_client);
-	struct llce_data *data = &priv->data;
-	int head = data->cbuf.head;
-	int tail = READ_ONCE(data->cbuf.tail);
-	struct llce_logger_msg *item = msg;
-	struct frame_log *log_frame, *buffer;
-
-	buffer = (struct frame_log *)data->cbuf.buf;
-	if (CIRC_SPACE(head, tail, log_size) >= 1) {
-		log_frame = &buffer[head];
-
-		memcpy_fromio(&log_frame->frame, item->frame,
-			      sizeof(log_frame->frame));
-		log_frame->hw_ctrl = item->hw_ctrl;
-
-		/* Increment head and wake-up once consume */
-		smp_store_release(&data->cbuf.head,
-				  (head + 1) & (log_size - 1));
-		wake_up(&priv->syncs.fifo_event);
-	} else {
-		dev_warn_ratelimited(priv->dev, "Dropped a packet\n");
-	}
-}
-
-static int init_mb_channel(struct llce_priv *priv)
+static int llce_logger_remove(struct platform_device *pdev)
 {
-	int ret = 0;
-
-	priv->rx_client.dev = priv->dev;
-	priv->rx_client.tx_block = false;
-	priv->rx_client.rx_callback = logger_notif_callback;
-
-	priv->rx_chan = mbox_request_channel(&priv->rx_client, 0);
-	if (IS_ERR(priv->rx_chan)) {
-		ret = PTR_ERR(priv->rx_chan);
-		dev_err(priv->dev, "Failed to get logger mailbox: %d\n", ret);
-	}
+	struct net_device *netdev = platform_get_drvdata(pdev);
+	struct llce_logger *logger = netdev_priv(netdev);
+	struct llce_can_dev *common = &logger->common;
 
-	return ret;
-}
+	unregister_candev(netdev);
+	netif_napi_del(&common->napi);
+	free_candev(netdev);
 
-static void release_mb_channel(struct llce_priv *priv)
-{
-	mbox_free_channel(priv->rx_chan);
-}
-
-static void init_max_ser_size(struct llce_priv *priv)
-{
-	struct frame_log dummy = {
-		.frame = {
-			.word0 = pack_word0(true, true, CAN_EFF_MASK),
-			.word1 = pack_word1(true, 0xFFU, true, true),
-		},
-		.hw_ctrl = 15,
-	};
-
-	priv->data.max_ser_size = create_entry_string(&dummy, NULL, 0, 0);
+	return 0;
 }
 
-static int llce_logger_probe(struct platform_device *pdev)
+static int __maybe_unused llce_logger_suspend(struct device *device)
 {
-	int err;
-	struct llce_priv *priv;
-	struct device *dev = &pdev->dev;
-
-	if (hweight_long(log_size) != 1) {
-		dev_err(dev, "log_size parameter must be a power of two\n");
-		return -EINVAL;
-	}
-
-	priv = devm_kmalloc(dev, sizeof(*priv), GFP_KERNEL);
-	if (!priv)
-		return -ENOMEM;
-
-	platform_set_drvdata(pdev, priv);
-	priv->dev = dev;
-
-	init_max_ser_size(priv);
-
-	priv->data.cbuf.tail = 0;
-	priv->data.cbuf.head = 0;
-
-	priv->data.cbuf.buf = devm_kmalloc(dev, sizeof(*priv) * log_size,
-					   GFP_KERNEL);
-	if (!priv->data.cbuf.buf)
-		return -ENOMEM;
-
-	atomic_set(&priv->data.frames_received, 0);
-	init_waitqueue_head(&priv->syncs.fifo_event);
-	mutex_init(&priv->syncs.userspace_access);
-
-	err = add_dbgfs_entry(priv);
-	if (err)
-		return err;
+	struct net_device *dev = dev_get_drvdata(device);
+	struct llce_logger *llce = netdev_priv(dev);
+	struct llce_can_dev *common = &llce->common;
+	int ret;
 
-	err = init_mb_channel(priv);
-	if (err)
-		goto remove_dbgfs_entry;
+	if (netif_running(dev))
+		ret = llce_logger_close(dev);
 
-remove_dbgfs_entry:
-	if (err)
-		remove_dbgfs_entry(priv);
+	common->can.state = CAN_STATE_SLEEPING;
 
-	return err;
+	return 0;
 }
 
-static int llce_logger_remove(struct platform_device *pdev)
+static int __maybe_unused llce_logger_resume(struct device *device)
 {
-	struct llce_priv *priv;
-
-	priv = platform_get_drvdata(pdev);
+	struct net_device *dev = dev_get_drvdata(device);
+	struct llce_logger *llce = netdev_priv(dev);
+	struct llce_can_dev *common = &llce->common;
+	int ret;
 
-	dev_info(&pdev->dev,
-		 "Total number of frames received = %u.\n",
-		 atomic_read(&priv->data.frames_received));
+	if (netif_running(dev))
+		ret = llce_logger_open(dev);
 
-	release_mb_channel(priv);
-	remove_dbgfs_entry(priv);
+	common->can.state = CAN_STATE_ERROR_ACTIVE;
 
 	return 0;
 }
 
-static int __maybe_unused logger_suspend(struct device *device)
-{
-	struct llce_priv *priv = dev_get_drvdata(device);
-
-	release_mb_channel(priv);
-	return 0;
-}
-
-static int __maybe_unused logger_resume(struct device *device)
-{
-	struct llce_priv *priv = dev_get_drvdata(device);
-
-	return init_mb_channel(priv);
-}
+static const struct of_device_id llce_logger_match[] = {
+	{
+		.compatible = "nxp,s32g-llce-can-logger",
+	},
+	{ /* sentinel */ }
+};
+MODULE_DEVICE_TABLE(of, llce_logger_match);
 
-static SIMPLE_DEV_PM_OPS(logger_pm_ops, logger_suspend, logger_resume);
+static SIMPLE_DEV_PM_OPS(llce_logger_pm_ops, llce_logger_suspend,
+			 llce_logger_resume);
 
 static struct platform_driver llce_logger_driver = {
-	.probe	= llce_logger_probe,
-	.remove	= llce_logger_remove,
-	.driver	= {
-		.name			= DRIVER_NAME,
-		.owner			= THIS_MODULE,
-		.of_match_table		= llce_logger_dt_ids,
-		.pm			= &logger_pm_ops,
+	.probe = llce_logger_probe,
+	.remove = llce_logger_remove,
+	.driver = {
+		.name = "llce_logger",
+		.of_match_table = llce_logger_match,
+		.pm = &llce_logger_pm_ops,
 	},
 };
+module_platform_driver(llce_logger_driver)
 
-static int __init llce_logger_init(void)
-{
-	int ret;
-
-	ret = platform_driver_register(&llce_logger_driver);
-	if (ret) {
-		pr_err("%s Problem registering platform driver\n",
-		       DRIVER_NAME);
-	}
-
-	return ret;
-}
-
-static void __exit llce_logger_exit(void)
-{
-	platform_driver_unregister(&llce_logger_driver);
-}
-
-module_init(llce_logger_init);
-module_exit(llce_logger_exit);
-
-MODULE_DESCRIPTION("NXP LLCE logger driver for S32G");
-MODULE_LICENSE("GPL v2");
+MODULE_AUTHOR("Ghennadi Procopciuc <ghennadi.procopciuc@nxp.com>");
+MODULE_DESCRIPTION("NXP LLCE CAN Logger");
+MODULE_LICENSE("Dual BSD/GPL");
-- 
2.17.1

