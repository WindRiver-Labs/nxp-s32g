From a93668920a9e1a927d4570ce4a0a222570f66e62 Mon Sep 17 00:00:00 2001
From: Ghennadi Procopciuc <ghennadi.procopciuc@nxp.com>
Date: Wed, 28 Jul 2021 14:27:28 +0300
Subject: [PATCH 27/49] llce: Replace memory pools with mapped areas

commit a93668920a9e1a927d4570ce4a0a222570f66e62 from
https://source.codeaurora.org/external/autobsps32/linux

This commit replaces the LLCE SRAM memory pools with
memory mapped areas in order to perform SRAM initialization
when it's needed only. The previous implementation delegated this
operation to SRAM driver and, as a direct consequence, the memory
was initialized even in cases where the LLCE management was split
between Linux and another software stack.

Upstream-Status: Pending

Issue: ALB-5830
Signed-off-by: Ghennadi Procopciuc <ghennadi.procopciuc@nxp.com>
Signed-off-by: Zhantao Tang <zhantao.tang@windriver.com>
---
 arch/arm64/boot/dts/freescale/fsl-s32g.dtsi |  16 +-
 drivers/mailbox/llce-mailbox.c              |  93 +------
 drivers/mfd/llce-core.c                     | 287 +++++++++-----------
 3 files changed, 145 insertions(+), 251 deletions(-)

diff --git a/arch/arm64/boot/dts/freescale/fsl-s32g.dtsi b/arch/arm64/boot/dts/freescale/fsl-s32g.dtsi
index 9b052a5e53aa..77e31f53b7a6 100644
--- a/arch/arm64/boot/dts/freescale/fsl-s32g.dtsi
+++ b/arch/arm64/boot/dts/freescale/fsl-s32g.dtsi
@@ -529,32 +529,32 @@
 	};
 
 	llce0_sram: llce0_sram@43000000 {
-		compatible = "nxp,s32g-llce-sram";
+		compatible = "mmio-sram";
 		reg = <0x0 0x43000000 0x0 0x2000>;
 	};
 
 	llce1_sram: llce1_sram@43100000 {
-		compatible = "nxp,s32g-llce-sram";
+		compatible = "mmio-sram";
 		reg = <0x0 0x43100000 0x0 0x8000>;
 	};
 
 	llce2_sram: llce2_sram@43200000 {
-		compatible = "nxp,s32g-llce-sram";
+		compatible = "mmio-sram";
 		reg = <0x0 0x43200000 0x0 0x8000>;
 	};
 
 	llce3_sram: llce3_sram@43300000 {
-		compatible = "nxp,s32g-llce-sram";
+		compatible = "mmio-sram";
 		reg = <0x0 0x43300000 0x0 0x10000>;
 	};
 
 	llce_shmem: llce_shmem@43800000 {
-		compatible = "nxp,s32g-llce-sram";
+		compatible = "mmio-sram";
 		reg = <0x0 0x43800000 0x0 0x40000>;
 	};
 
 	llce_boot_status: llce_boot_status@43840000 {
-		compatible = "nxp,s32g-llce-sram";
+		compatible = "mmio-sram";
 		reg = <0x0 0x43840000 0x0 0x10000>;
 	};
 
@@ -580,7 +580,9 @@
 			"ppe_tx.bin", "frpe.bin";
 		memory-region = <&llce0_sram>, <&llce1_sram>,
 			<&llce2_sram>, <&llce3_sram>,
-			<&llce_boot_status>;
+			<&llce_shmem>, <&llce_boot_status>;
+		memory-region-names = "dte.bin", "ppe_rx.bin",
+			"ppe_tx.bin", "frpe.bin", "shmem", "status";
 		/* LLCE system control registers */
 		reg = <0x0 0x43FF8000 0x0 0x4000>;
 		reg-names = "sysctrl";
diff --git a/drivers/mailbox/llce-mailbox.c b/drivers/mailbox/llce-mailbox.c
index 9071e52f0f87..b4edea75ae43 100644
--- a/drivers/mailbox/llce-mailbox.c
+++ b/drivers/mailbox/llce-mailbox.c
@@ -103,13 +103,6 @@ struct llce_mb {
 	bool suspended;
 };
 
-struct sram_pool {
-	struct gen_pool *pool;
-	size_t size;
-	unsigned long vaddr;
-	const char *name;
-};
-
 struct llce_mb_desc {
 	unsigned int nchan;
 	int (*startup)(struct mbox_chan *chan);
@@ -933,35 +926,6 @@ static const struct mbox_chan_ops llce_mb_ops = {
 	.last_tx_done = llce_mb_last_tx_done,
 };
 
-static void devm_sram_pool_release(struct device *dev, void *res)
-{
-	struct sram_pool *spool = res;
-
-	gen_pool_free(spool->pool, spool->vaddr, spool->size);
-}
-
-static struct sram_pool *devm_sram_pool_alloc(struct device *dev,
-					      struct gen_pool *pool)
-{
-	struct sram_pool *spool = devres_alloc(devm_sram_pool_release,
-					       sizeof(*spool), GFP_KERNEL);
-
-	if (!spool)
-		return ERR_PTR(-ENOMEM);
-
-	spool->size = gen_pool_size(pool);
-	spool->vaddr = gen_pool_alloc(pool, spool->size);
-	if (!spool->vaddr) {
-		devres_free(spool);
-		return ERR_PTR(-ENOMEM);
-	}
-
-	spool->pool = pool;
-	devres_add(dev, spool);
-
-	return spool;
-}
-
 static struct device_node *get_sram_node(struct device *dev, const char *name)
 {
 	struct device_node *node, *dev_node;
@@ -978,14 +942,15 @@ static struct device_node *get_sram_node(struct device *dev, const char *name)
 	return node;
 }
 
-static int map_llce_status(struct device *dev, struct llce_mb *mb)
+static int map_sram_node(struct device *dev, const char *name,
+			 void __iomem **addr)
 {
 	struct device_node *sram_node;
 	struct resource r;
 	resource_size_t size;
 	int ret;
 
-	sram_node = get_sram_node(dev, LLCE_STATUS_REG_NAME);
+	sram_node = get_sram_node(dev, name);
 	if (IS_ERR(sram_node))
 		return PTR_ERR(sram_node);
 
@@ -996,52 +961,24 @@ static int map_llce_status(struct device *dev, struct llce_mb *mb)
 
 	size = resource_size(&r);
 
-	mb->status = devm_ioremap(dev, r.start, size);
-	if (!mb->status) {
-		dev_err(dev, "Failed to map '%s' memory region\n",
-			LLCE_STATUS_REG_NAME);
+	*addr = devm_ioremap_wc(dev, r.start, size);
+	if (!*addr) {
+		dev_err(dev, "Failed to map '%s' memory region\n", name);
 		return -ENOMEM;
 	}
 
 	return 0;
 }
 
-static int alloc_llce_shmem(struct platform_device *pdev,
-			    struct llce_mb *mb)
+static int map_llce_status(struct llce_mb *mb)
 {
-	struct device_node *sram_node;
-	struct device *dev = &pdev->dev;
-	struct gen_pool *pool;
-	const char *name;
-	struct sram_pool *spool;
-	struct platform_device *sram_pdev;
-
-	sram_node = get_sram_node(dev, LLCE_SHMEM_REG_NAME);
-	if (IS_ERR(sram_node))
-		return PTR_ERR(sram_node);
-
-	name = sram_node->name;
-	sram_pdev = of_find_device_by_node(sram_node);
-	if (!sram_pdev) {
-		dev_err(dev, "failed to find sram device for '%s'!\n", name);
-		return -ENODEV;
-	}
-
-	pool = gen_pool_get(&sram_pdev->dev, NULL);
-	if (!pool) {
-		dev_err(dev, "Pool '%s' is unavailable!\n", name);
-		return -ENODEV;
-	}
-
-	spool = devm_sram_pool_alloc(dev, pool);
-	if (IS_ERR(spool)) {
-		dev_err(dev, "Unable to alloc '%s' pool\n", name);
-		return PTR_ERR(spool);
-	}
-
-	mb->sh_mem = (void *)spool->vaddr;
+	return map_sram_node(mb->dev, LLCE_STATUS_REG_NAME, &mb->status);
+}
 
-	return 0;
+static int map_llce_shmem(struct llce_mb *mb)
+{
+	return map_sram_node(mb->dev, LLCE_SHMEM_REG_NAME,
+			     (void __iomem **)&mb->sh_mem);
 }
 
 static void __iomem *get_icsr_addr(struct llce_mb *mb, uint32_t icsr_id)
@@ -1772,11 +1709,11 @@ static int llce_mb_probe(struct platform_device *pdev)
 	if (ret)
 		return ret;
 
-	ret = alloc_llce_shmem(pdev, mb);
+	ret = map_llce_status(mb);
 	if (ret)
 		return ret;
 
-	ret = map_llce_status(dev, mb);
+	ret = map_llce_shmem(mb);
 	if (ret)
 		return ret;
 
diff --git a/drivers/mfd/llce-core.c b/drivers/mfd/llce-core.c
index f64ef60ee842..2ea0c537dfa6 100644
--- a/drivers/mfd/llce-core.c
+++ b/drivers/mfd/llce-core.c
@@ -13,7 +13,7 @@
 #include <linux/processor.h>
 #include <linux/slab.h>
 
-#define LLCE_STATUS_POOL	"llce_boot_status"
+#define LLCE_STATUS_REGION	"status"
 #define LLCE_SYSRSTR		0x0
 #define LLCE_SYSRSTR_RST0	BIT(0)
 #define LLCE_SYSRSTR_RST1	BIT(1)
@@ -38,23 +38,24 @@ struct llce_fw_cont {
 	u16 retries;
 };
 
-struct sram_pool {
-	struct gen_pool *pool;
-	const struct firmware *fw_entry;
-	size_t size;
-	unsigned long vaddr;
+struct sram_node {
 	const char *name;
+	void __iomem *addr;
+	size_t size;
+};
+
+struct llce_fw {
+	const struct firmware *fw_entry;
+	struct sram_node *node;
 };
 
 struct llce_core {
 	struct clk *clk;
 	void __iomem *sysctrl_base;
+	struct llce_fw *fws;
 
-	/* SRAM pools */
-	struct sram_pool **pools;
-	size_t npools;
-
-	void __iomem *status;
+	struct sram_node *sram_nodes;
+	size_t n_sram;
 
 	size_t nfrws;
 };
@@ -62,188 +63,137 @@ struct llce_core {
 static bool load_fw = true;
 module_param(load_fw, bool, 0660);
 
-static void devm_sram_pool_release(struct device *dev, void *res)
+static struct device_node *get_sram_node(struct device *dev, const char *name)
 {
-	struct sram_pool *spool = res;
-
-	gen_pool_free(spool->pool, spool->vaddr, spool->size);
-}
-
-static struct sram_pool *devm_sram_pool_alloc(struct device *dev,
-					      struct gen_pool *pool)
-{
-	struct sram_pool *spool = devres_alloc(devm_sram_pool_release,
-					       sizeof(*spool), GFP_KERNEL);
-
-	if (!spool)
-		return ERR_PTR(-ENOMEM);
-
-	spool->size = gen_pool_size(pool);
-	spool->vaddr = gen_pool_alloc(pool, spool->size);
-	if (!spool->vaddr) {
-		devres_free(spool);
-		return ERR_PTR(-ENOMEM);
+	struct device_node *node, *dev_node;
+	int idx;
+
+	dev_node = dev->of_node;
+	idx = of_property_match_string(dev_node, "memory-region-names", name);
+	node = of_parse_phandle(dev_node, "memory-region", idx);
+	if (!node) {
+		dev_err(dev, "Failed to get '%s' memory region\n", name);
+		return ERR_PTR(-EIO);
 	}
 
-	spool->pool = pool;
-	devres_add(dev, spool);
-
-	return spool;
+	return node;
 }
 
-static struct sram_pool *alloc_sram_node(struct device_node *sram_node,
-					 struct device *dev)
+static int map_sram_nodes(struct device *dev, struct llce_core *core)
 {
-	struct platform_device *pdev;
-	struct gen_pool *pool;
-	struct sram_pool *spool;
-	const char *name = sram_node->name;
-
-	pdev = of_find_device_by_node(sram_node);
-	if (!pdev) {
-		dev_err(dev, "failed to find SRAM device for '%s'!\n", name);
-		return ERR_PTR(-ENODEV);
-	}
-
-	pool = gen_pool_get(&pdev->dev, NULL);
-	if (!pool) {
-		dev_err(dev, "Pool '%s' is unavailable!\n", name);
-		return ERR_PTR(-ENODEV);
-	}
+	int ret, n_reg, i;
+	const char *img_name;
+	struct device_node *node;
+	struct resource r;
+	resource_size_t size;
 
-	spool = devm_sram_pool_alloc(dev, pool);
-	if (IS_ERR(spool)) {
-		dev_err(dev, "Unable to allocate '%s' pool\n", name);
-		return spool;
-	}
-	spool->name = name;
+	n_reg = of_property_count_strings(dev->of_node, "memory-region-names");
+	if (n_reg < 0)
+		return n_reg;
 
-	return spool;
-}
+	core->sram_nodes = devm_kmalloc(dev, sizeof(*core->sram_nodes) * n_reg,
+					GFP_KERNEL);
+	if (!core->sram_nodes)
+		return -ENOMEM;
 
-static struct device_node *get_sram_node(struct platform_device *pdev, int index)
-{
-	struct device_node *sram_node = of_parse_phandle(pdev->dev.of_node, "memory-region", index);
+	core->n_sram = n_reg;
 
-	if (!sram_node) {
-		dev_err(&pdev->dev, "Failed to get the element %d from 'memory-region' list\n",
-			index);
-		return ERR_PTR(-EINVAL);
-	}
+	for (i = 0; i < n_reg; i++) {
+		ret = of_property_read_string_index(dev->of_node,
+						    "memory-region-names",
+						    i, &img_name);
+		if (ret) {
+			dev_err(dev, "Failed to get 'memory-region-names' %d property\n",
+				i);
+			return ret;
+		}
 
-	return sram_node;
-}
+		core->sram_nodes[i].name = img_name;
+		node = get_sram_node(dev, img_name);
+		if (IS_ERR(node))
+			return PTR_ERR(node);
 
-static int llce_fw_load(struct platform_device *pdev, int index,
-			struct sram_pool *spool)
-{
-	int ret;
-	const char *img_name;
+		ret = of_address_to_resource(node, 0, &r);
+		of_node_put(node);
+		if (ret)
+			return ret;
 
-	ret = of_property_read_string_index(pdev->dev.of_node, "firmware-name",
-					    index, &img_name);
-	if (ret) {
-		dev_err(&pdev->dev, "Failed to get 'firmware-name' property\n");
-		return ret;
-	}
+		size = resource_size(&r);
+		core->sram_nodes[i].size = size;
 
-	ret = request_firmware(&spool->fw_entry, img_name, &pdev->dev);
-	if (ret) {
-		dev_err(&pdev->dev, "Failed to load '%s' binary\n", img_name);
-		return ret;
+		core->sram_nodes[i].addr = devm_ioremap_wc(dev, r.start, size);
+		if (!core->sram_nodes[i].addr) {
+			dev_err(dev, "Failed to map '%s' memory region\n",
+				img_name);
+			return -ENOMEM;
+		}
 	}
 
 	return ret;
 }
 
-static void llce_release_fw(struct sram_pool *spool)
+static void init_sram_nodes(struct llce_core *core)
 {
-	release_firmware(spool->fw_entry);
+	size_t i;
+
+	for (i = 0; i < core->n_sram; i++)
+		memset_io(core->sram_nodes[i].addr, 0,
+			  core->sram_nodes[i].size);
 }
 
-static int map_status_sram(struct llce_core *core,
-			   struct device *dev,
-			   struct device_node *sram_node)
+static struct sram_node *get_core_sram(struct llce_core *core, const char *name)
 {
-	struct resource r;
-	resource_size_t size;
-	int ret;
+	int i;
 
-	ret = of_address_to_resource(sram_node, 0, &r);
-	of_node_put(sram_node);
-	if (ret)
-		return ret;
-
-	size = resource_size(&r);
-
-	core->status = devm_ioremap(dev, r.start, size);
-	if (!core->status) {
-		dev_err(dev, "Failed to map '%s' memory region\n",
-			LLCE_STATUS_POOL);
-		return -ENOMEM;
+	for (i = 0; i < core->n_sram; i++) {
+		if (!strcmp(core->sram_nodes[i].name, name))
+			return &core->sram_nodes[i];
 	}
 
-	return 0;
+	return NULL;
 }
 
-static int map_and_alloc_sram(struct platform_device *pdev,
-			      struct llce_core *core)
+static int llce_load_fw_images(struct device *dev, struct llce_core *core)
 {
-	int i, j, ret;
-	struct sram_pool *spool;
-	struct device_node *sram_node;
-	size_t dtb_npools;
-
-	dtb_npools = of_count_phandle_with_args(pdev->dev.of_node,
-						"memory-region",
-						NULL);
-	/* Exclude boot status pool as it's only mapped */
-	core->npools = dtb_npools - 1;
-	core->pools = devm_kzalloc(&pdev->dev,
-				   core->npools * sizeof(*core->pools),
-				   GFP_KERNEL);
-	if (!core->pools)
-		return -ENOMEM;
+	int i, ret;
+	struct llce_fw *fw;
+	const char *img_name;
 
-	for (i = 0, j = 0; i < dtb_npools; i++) {
-		sram_node = get_sram_node(pdev, i);
-		if (!sram_node)
-			return PTR_ERR(sram_node);
+	core->nfrws = of_property_count_strings(dev->of_node, "firmware-name");
+	if (core->nfrws < 0) {
+		dev_err(dev, "Failed to get 'firmware-name' property\n");
+		return core->nfrws;
+	}
 
-		if (!strcmp(sram_node->name, LLCE_STATUS_POOL)) {
-			ret = map_status_sram(core, &pdev->dev, sram_node);
-			if (ret)
-				return ret;
-			continue;
-		}
+	core->fws = devm_kmalloc(dev, core->nfrws * sizeof(*core->fws),
+				 GFP_KERNEL);
+	if (!core->fws)
+		return -ENOMEM;
 
-		spool = alloc_sram_node(sram_node, &pdev->dev);
-		if (IS_ERR(spool)) {
-			dev_err(&pdev->dev, "Failed to initialize SRAM buffer %d\n",
+	for (i = 0; i < core->nfrws; i++) {
+		ret = of_property_read_string_index(dev->of_node,
+						    "firmware-name", i,
+						    &img_name);
+		if (ret) {
+			dev_err(dev, "Failed to get firmware's name (idx=%d)\n",
 				i);
-			return PTR_ERR(spool);
-		}
-
-		if (j < core->npools) {
-			core->pools[j] = spool;
-			j++;
+			return ret;
 		}
-	}
-
-	return 0;
-}
 
-static int llce_load_fw_images(struct platform_device *pdev,
-			       struct llce_core *core)
-{
-	int i, ret;
+		fw = &core->fws[i];
 
-	core->nfrws = of_property_count_strings(pdev->dev.of_node,
-						"firmware-name");
-	for (i = 0; i < core->nfrws; i++) {
-		ret = llce_fw_load(pdev, i, core->pools[i]);
-		if (ret)
+		ret = request_firmware(&fw->fw_entry, img_name, dev);
+		if (ret) {
+			dev_err(dev, "Failed to load '%s' binary\n", img_name);
 			return ret;
+		}
+
+		fw->node = get_core_sram(core, img_name);
+		if (!fw->node) {
+			dev_err(dev, "Unable to find '%s' sram node\n",
+				img_name);
+			return -EINVAL;
+		}
 	}
 
 	return 0;
@@ -251,14 +201,14 @@ static int llce_load_fw_images(struct platform_device *pdev,
 
 static void llce_flush_fw(struct llce_core *core)
 {
-	struct sram_pool *pool;
+	struct llce_fw *fw;
 	size_t i;
 
 	for (i = 0; i < core->nfrws; i++) {
-		pool = core->pools[i];
+		fw = &core->fws[i];
 
-		memcpy_toio((void __iomem *)pool->vaddr, pool->fw_entry->data,
-			    pool->fw_entry->size);
+		memcpy_toio(fw->node->addr, fw->fw_entry->data,
+			    fw->fw_entry->size);
 	}
 }
 
@@ -267,7 +217,7 @@ static void llce_release_fw_images(struct llce_core *core)
 	size_t i;
 
 	for (i = 0; i < core->nfrws; i++)
-		llce_release_fw(core->pools[i]);
+		release_firmware(core->fws[i].fw_entry);
 }
 
 static void reset_llce_cores(void __iomem *sysctrl_base)
@@ -365,12 +315,13 @@ static void deinit_core_clock(struct llce_core *core)
 static int start_llce_cores(struct device *dev, struct llce_core *core)
 {
 	int ret;
+	struct sram_node *status = get_core_sram(core, LLCE_STATUS_REGION);
 
 	reset_llce_cores(core->sysctrl_base);
 
 	llce_flush_fw(core);
 
-	ret = llce_cores_kickoff(dev, core->sysctrl_base, core->status);
+	ret = llce_cores_kickoff(dev, core->sysctrl_base, status->addr);
 	if (ret) {
 		dev_err(dev, "Failed to start LLCE cores\n");
 		return ret;
@@ -402,8 +353,8 @@ static int llce_core_probe(struct platform_device *pdev)
 		return -EIO;
 	}
 
-	core->sysctrl_base = devm_ioremap(dev, sysctrl_res->start,
-				    resource_size(sysctrl_res));
+	core->sysctrl_base = devm_ioremap_wc(dev, sysctrl_res->start,
+					     resource_size(sysctrl_res));
 	if (!core->sysctrl_base) {
 		dev_err(dev, "Failed to map 'sysctrl'\n");
 		return -ENOMEM;
@@ -413,11 +364,13 @@ static int llce_core_probe(struct platform_device *pdev)
 	if (ret)
 		return ret;
 
-	ret = map_and_alloc_sram(pdev, core);
+	ret = map_sram_nodes(dev, core);
 	if (ret)
 		goto disable_clk;
 
-	ret = llce_load_fw_images(pdev, core);
+	init_sram_nodes(core);
+
+	ret = llce_load_fw_images(dev, core);
 	if (ret)
 		goto disable_clk;
 
@@ -473,6 +426,8 @@ static int __maybe_unused llce_core_resume(struct device *dev)
 	if (!load_fw)
 		return 0;
 
+	init_sram_nodes(core);
+
 	ret = init_core_clock(dev, core);
 	if (ret)
 		return ret;
-- 
2.17.1

