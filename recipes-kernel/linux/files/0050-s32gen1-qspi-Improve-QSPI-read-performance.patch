From ca404fad8d3dfab33929fc455ac37ef53a420190 Mon Sep 17 00:00:00 2001
From: Ciprian Marian Costea <ciprianmarian.costea@nxp.com>
Date: Thu, 28 Jan 2021 15:28:40 +0200
Subject: [PATCH 50/78] s32gen1: qspi: Improve QSPI read performance

During QSPI read operation, using AHB buffer,
the call to 'memcpy_fromio' is not necessary.
Moreover, it leads to a performance decrease of up to 40%.

The solution is to use a simple 'memcpy' call, since
QSPI is memory mapped.

Also, we add performance indicators when performing a
QSPI read operation, measured in MiB/s.

Issue: ALB-6395
Signed-off-by: Ciprian Marian Costea <ciprianmarian.costea@nxp.com>
---
 drivers/mtd/spi-nor/s32gen1_qspi.c | 23 +++++++++++++++++++++--
 1 file changed, 21 insertions(+), 2 deletions(-)

diff --git a/drivers/mtd/spi-nor/s32gen1_qspi.c b/drivers/mtd/spi-nor/s32gen1_qspi.c
index 6a8d2477858f..c66a2fccb854 100644
--- a/drivers/mtd/spi-nor/s32gen1_qspi.c
+++ b/drivers/mtd/spi-nor/s32gen1_qspi.c
@@ -1,6 +1,6 @@
 // SPDX-License-Identifier: GPL-2.0+
 /*
- * Copyright 2020 NXP
+ * Copyright 2020-2021 NXP
  */
 #include <linux/io.h>
 #include <linux/mtd/spi-nor.h>
@@ -8,6 +8,9 @@
 #include <linux/mm.h>
 #include <linux/cache.h>
 #include <asm/cacheflush.h>
+#include <linux/ktime.h>
+#include <linux/math64.h>
+#include <asm/div64.h>
 #include "fsl-quadspi.h"
 
 #define LUT_INVALID_INDEX -1
@@ -946,6 +949,9 @@ int qspi_read_mem(struct fsl_qspi *q,
 	u32 mcr_reg;
 	void __iomem *base = q->iobase;
 	void *ahb_virt;
+	struct timespec64 start, end, duration;
+	u64 mb_int, mb_frac;
+	u32 us_passed, rem;
 
 	while (qspi_readl(q, base + QUADSPI_SR) & QUADSPI_SR_BUSY_MASK)
 		;
@@ -960,8 +966,21 @@ int qspi_read_mem(struct fsl_qspi *q,
 	__inval_dcache_area(ahb_virt, op->data.nbytes);
 
 	/* Read out the data directly from the AHB buffer. */
-	memcpy_fromio(op->data.buf.in, ahb_virt,
+	ktime_get_ts64(&start);
+	memcpy(op->data.buf.in, ahb_virt,
 		      op->data.nbytes);
+	ktime_get_ts64(&end);
+
+	duration = timespec64_sub(end, start);
+	us_passed = duration.tv_sec * 1000000 +
+		(duration.tv_nsec / NSEC_PER_USEC);
+
+	if (us_passed > 0) {
+		mb_int = div_u64_rem(op->data.nbytes, us_passed, &rem);
+		mb_frac = div64_u64(rem * 1000, us_passed);
+		dev_info(q->dev, "%u bytes read in %u us (%llu.%llu MB/s)\n",
+				op->data.nbytes, us_passed, mb_int, mb_frac);
+	}
 
 	qspi_writel(q, mcr_reg, base + QUADSPI_MCR);
 	iounmap(ahb_virt);
-- 
2.25.1

