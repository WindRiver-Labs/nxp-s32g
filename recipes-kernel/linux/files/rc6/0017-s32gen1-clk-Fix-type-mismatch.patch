From 3b741269911be84dd3c6bcb4c1f9d5c991285c30 Mon Sep 17 00:00:00 2001
From: Ciprian Marian Costea <ciprianmarian.costea@nxp.com>
Date: Tue, 17 Aug 2021 16:52:32 +0300
Subject: [PATCH 17/19] s32gen1: clk: Fix type mismatch

commit 3b741269911be84dd3c6bcb4c1f9d5c991285c30 from
https://source.codeaurora.org/external/autobsps32/linux

Also, we add 'static' keyword to locally used members.

Upstream-Status: Pending

Issue: ALB-7520
Signed-off-by: Ciprian Marian Costea <ciprianmarian.costea@nxp.com>
Signed-off-by: Zhantao Tang <zhantao.tang@windriver.com>
---
 drivers/clk/s32/s32-gen1/cgm_div.c    |  4 ++--
 drivers/clk/s32/s32-gen1/clk-dfs.c    |  4 ++--
 drivers/clk/s32/s32-gen1/clk-plldig.c | 17 +++++++++--------
 drivers/clk/s32/s32-gen1/clk.c        | 12 ++++++------
 drivers/clk/s32/s32-gen1/fxosc.c      |  8 ++++----
 drivers/clk/s32/s32-gen1/part_block.c |  2 +-
 6 files changed, 24 insertions(+), 23 deletions(-)

diff --git a/drivers/clk/s32/s32-gen1/cgm_div.c b/drivers/clk/s32/s32-gen1/cgm_div.c
index f04bc1ff07e1..72817d6f3856 100644
--- a/drivers/clk/s32/s32-gen1/cgm_div.c
+++ b/drivers/clk/s32/s32-gen1/cgm_div.c
@@ -1,6 +1,6 @@
 // SPDX-License-Identifier: GPL-2.0+
 /*
- * Copyright 2020 NXP
+ * Copyright 2020-2021 NXP
  */
 #include <linux/clk-provider.h>
 #include <linux/err.h>
@@ -84,7 +84,7 @@ static int clk_cgm_div_enable(struct clk_hw *hw)
 	return 0;
 }
 
-const struct clk_ops clk_cgm_div_ops = {
+static const struct clk_ops clk_cgm_div_ops = {
 	.recalc_rate = clk_cgm_div_recalc_rate,
 	.round_rate = clk_cgm_div_round_rate,
 	.set_rate = clk_cgm_div_set_rate,
diff --git a/drivers/clk/s32/s32-gen1/clk-dfs.c b/drivers/clk/s32/s32-gen1/clk-dfs.c
index b09022c2fccf..fdd3a98ec820 100644
--- a/drivers/clk/s32/s32-gen1/clk-dfs.c
+++ b/drivers/clk/s32/s32-gen1/clk-dfs.c
@@ -1,6 +1,6 @@
 /*
  * Copyright 2015-2016 Freescale Semiconductor, Inc.
- * Copyright 2017,2020 NXP
+ * Copyright 2017,2020-2021 NXP
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
@@ -100,7 +100,7 @@ static unsigned long get_pllx_dfsy_max_rate(enum s32gen1_plldig_type plltype,
 	return -EINVAL;
 }
 
-static void read_mfi_mfn(void *dfs_addr, u32 port, u32 *mfi, u32 *mfn)
+static void read_mfi_mfn(void __iomem *dfs_addr, u32 port, u32 *mfi, u32 *mfn)
 {
 	u32 dvport = readl_relaxed(DFS_DVPORTn(dfs_addr, port));
 
diff --git a/drivers/clk/s32/s32-gen1/clk-plldig.c b/drivers/clk/s32/s32-gen1/clk-plldig.c
index c9d1004b3172..68ec1d3f37c4 100644
--- a/drivers/clk/s32/s32-gen1/clk-plldig.c
+++ b/drivers/clk/s32/s32-gen1/clk-plldig.c
@@ -1,5 +1,5 @@
 /*
- * Copyright 2018,2020 NXP
+ * Copyright 2018,2020-2021 NXP
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
@@ -231,7 +231,7 @@ static int clk_plldig_set_rate(struct clk_hw *hw, unsigned long rate,
 
 	/* Disable dividers. */
 	for (i = 0; i < pll->phi_nr; i++)
-		writel_relaxed(0x0, PLLDIG_PLLODIV(pll, i));
+		writel_relaxed(0x0, (void __iomem *)PLLDIG_PLLODIV(pll, i));
 
 	/* Disable PLL. */
 	writel_relaxed(PLLDIG_PLLCR_PLLPD, PLLDIG_PLLCR(pll->base));
@@ -248,21 +248,22 @@ static int clk_plldig_set_rate(struct clk_hw *hw, unsigned long rate,
 		pllodiv = readl_relaxed(PLLDIG_PLLODIV(pll->base, i));
 		writel_relaxed(pllodiv |
 			PLLDIG_PLLODIV_DIV_SET(pll->plldv_pllodiv[i] - 1),
-			PLLDIG_PLLODIV(pll, i));
+			(void __iomem *)PLLDIG_PLLODIV(pll, i));
 	}
 
 	/* Enable the PLL. */
-	writel_relaxed(0x0, PLLDIG_PLLCR(pll));
+	writel_relaxed(0x0, (void __iomem *)PLLDIG_PLLCR(pll));
 
 	/* Poll until PLL acquires lock. */
-	while (!(readl_relaxed(PLLDIG_PLLSR(pll)) & PLLDIG_PLLSR_LOCK))
+	while (!(readl_relaxed((void __iomem *)PLLDIG_PLLSR(pll)) &
+				PLLDIG_PLLSR_LOCK))
 		;
 
 	/* Enable dividers. */
 	for (i = 0; i < pll->phi_nr; i++)
 		writel_relaxed(PLLDIG_PLLODIV_DE |
-				readl_relaxed(PLLDIG_PLLODIV(pll, i)),
-				PLLDIG_PLLODIV(pll, i));
+				readl_relaxed((void __iomem *)PLLDIG_PLLODIV(pll, i)),
+				(void __iomem *)PLLDIG_PLLODIV(pll, i));
 
 	return 0;
 }
@@ -412,7 +413,7 @@ static int plldig_phi_enable(struct clk_hw *hw)
 	return 0;
 }
 
-const struct clk_ops plldig_phi_ops = {
+static const struct clk_ops plldig_phi_ops = {
 	.round_rate = plldig_phi_round_rate,
 	.set_rate = plldig_phi_set_rate,
 	.recalc_rate = plldig_phi_recalc_rate,
diff --git a/drivers/clk/s32/s32-gen1/clk.c b/drivers/clk/s32/s32-gen1/clk.c
index 4f6380452ccc..eca4810e4f19 100644
--- a/drivers/clk/s32/s32-gen1/clk.c
+++ b/drivers/clk/s32/s32-gen1/clk.c
@@ -22,7 +22,7 @@
 
 static struct s32gen1_clk_modules clk_modules;
 
-DEFINE_SPINLOCK(s32gen1_lock);
+static DEFINE_SPINLOCK(s32gen1_lock);
 
 /* sources for multiplexer clocks, this is used multiple times */
 PNAME(osc_sels) = {"firc", "fxosc", };
@@ -174,7 +174,7 @@ struct s32gen1_clocks {
 	struct clk_onecell_data scmi_clks;
 };
 
-struct clk *s32gen1_clk_src_get(struct of_phandle_args *clkspec, void *data)
+static struct clk *s32gen1_clk_src_get(struct of_phandle_args *clkspec, void *data)
 {
 	struct s32gen1_clocks *clks = data;
 	unsigned int idx = clkspec->args[0];
@@ -307,7 +307,7 @@ static void __init s32r45_extra_clocks_init(struct device_node *clocking_node)
 	set_plat_clk(S32GEN1_CLK_GMAC_1_RX, c);
 }
 
-void __init s32gen1_clocks_init(struct device_node *clocking_node)
+static void __init s32gen1_clocks_init(struct device_node *clocking_node)
 {
 	struct device_node *np;
 	struct clk *c;
@@ -683,7 +683,7 @@ void __init s32gen1_clocks_init(struct device_node *clocking_node)
 	of_clk_add_provider(clocking_node, s32gen1_clk_src_get, &plat_clks);
 }
 
-void __init s32gen1_mux0_gmac0_clock_init(struct device_node *clocking_node)
+static void __init s32gen1_mux0_gmac0_clock_init(struct device_node *clocking_node)
 {
 	struct clk *c;
 
@@ -712,7 +712,7 @@ void __init s32gen1_mux0_gmac0_clock_init(struct device_node *clocking_node)
 	set_plat_clk(S32GEN1_CLK_GMAC_0_TS, c);
 }
 
-void __init s32gen1_mux6_gmac0_clock_init(struct device_node *clocking_node)
+static void __init s32gen1_mux6_gmac0_clock_init(struct device_node *clocking_node)
 {
 	struct device_node *np;
 	struct clk *c;
@@ -758,7 +758,7 @@ static void init_scmi_clk(uint32_t scmi_id, uint32_t plat_clk)
 	scmi_clk[scmi_id] = get_plat_clk(plat_clk);
 }
 
-void s32gen1_scmi_clocks_init(void)
+static void s32gen1_scmi_clocks_init(void)
 {
 	init_scmi_clk(S32GEN1_SCMI_CLK_A53,
 		      S32GEN1_CLK_A53);
diff --git a/drivers/clk/s32/s32-gen1/fxosc.c b/drivers/clk/s32/s32-gen1/fxosc.c
index c9e2ba511d92..67a7d63a1dee 100644
--- a/drivers/clk/s32/s32-gen1/fxosc.c
+++ b/drivers/clk/s32/s32-gen1/fxosc.c
@@ -1,6 +1,6 @@
 // SPDX-License-Identifier: GPL-2.0+
 /*
- * Copyright 2020 NXP
+ * Copyright 2020-2021 NXP
  */
 #include <linux/clk-provider.h>
 #include <linux/err.h>
@@ -63,7 +63,7 @@ static unsigned long fxosc_recalc_accuracy(struct clk_hw *hw,
 static int fxosc_is_enabled(struct clk_hw *hw)
 {
 	struct fxosc *osc = to_fxosc(hw);
-	void *base = osc->base;
+	void __iomem *base = osc->base;
 
 	if (readl(FXOSC_CTRL(base)) & FXOSC_CTRL_OSCON)
 		return 1;
@@ -74,7 +74,7 @@ static int fxosc_is_enabled(struct clk_hw *hw)
 static int fxosc_enable(struct clk_hw *hw)
 {
 	struct fxosc *osc = to_fxosc(hw);
-	void *base = osc->base;
+	void __iomem *base = osc->base;
 	uint32_t ctrl;
 
 	if (fxosc_is_enabled(hw))
@@ -96,7 +96,7 @@ static int fxosc_enable(struct clk_hw *hw)
 	return 0;
 }
 
-const struct clk_ops fxosc_ops = {
+static const struct clk_ops fxosc_ops = {
 	.recalc_rate = fxosc_recalc_rate,
 	.recalc_accuracy = fxosc_recalc_accuracy,
 	.enable = fxosc_enable,
diff --git a/drivers/clk/s32/s32-gen1/part_block.c b/drivers/clk/s32/s32-gen1/part_block.c
index 8786460395ae..af0f87182eff 100644
--- a/drivers/clk/s32/s32-gen1/part_block.c
+++ b/drivers/clk/s32/s32-gen1/part_block.c
@@ -46,7 +46,7 @@ static void mc_me_wait_update(u32 partition_n, u32 mask,
 static int is_enabled_clk_part_block(struct clk_hw *hw)
 {
 	struct clk_part_block *block = to_clk_part_block(hw);
-	void __iomem *mc_me = block->clk_mods->mc_me;
+	struct regmap *mc_me = block->clk_mods->mc_me;
 	unsigned int block_mask, part_status;
 	u32 partition_n = block->part;
 
-- 
2.17.1

