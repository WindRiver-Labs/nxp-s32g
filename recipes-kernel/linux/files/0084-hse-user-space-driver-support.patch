From 86e0faa19c02bab4cebaa38fa0513a13c40d2736 Mon Sep 17 00:00:00 2001
From: Bogdan Folea <bogdan.folea@nxp.com>
Date: Thu, 25 Feb 2021 09:13:48 +0200
Subject: [PATCH 84/84] hse: user-space driver support

Issue: ALB-5887
Signed-off-by: Bogdan Folea <bogdan.folea@nxp.com>
---
 drivers/crypto/hse/Kconfig    |  21 +++-
 drivers/crypto/hse/Makefile   |   3 +-
 drivers/crypto/hse/hse-core.c |  43 +++++--
 drivers/crypto/hse/hse-core.h |   8 +-
 drivers/crypto/hse/hse-uio.c  | 226 ++++++++++++++++++++++++++++++++++
 5 files changed, 284 insertions(+), 17 deletions(-)
 create mode 100644 drivers/crypto/hse/hse-uio.c

diff --git a/drivers/crypto/hse/Kconfig b/drivers/crypto/hse/Kconfig
index 35a20a36fa43..c5c10621cdbb 100644
--- a/drivers/crypto/hse/Kconfig
+++ b/drivers/crypto/hse/Kconfig
@@ -18,9 +18,18 @@ config CRYPTO_DEV_NXP_HSE_MU_ID
 	help
 	  The Messaging Unit (MU) Instance index used by HSE crypto driver.
 
+config CRYPTO_DEV_NXP_HSE_UIO
+	depends on CRYPTO_DEV_NXP_HSE
+	bool "NXP HSE user-space driver support"
+	default n
+	select UIO
+	help
+	  Enables NXP HSE user-space driver support. The driver shall not
+	  register any algorithms with crypto API when this is enabled.
+
 config CRYPTO_DEV_NXP_HSE_HWRNG
 	bool "NXP HSE hardware RNG support"
-	depends on CRYPTO_DEV_NXP_HSE
+	depends on CRYPTO_DEV_NXP_HSE && !CRYPTO_DEV_NXP_HSE_UIO
 	default y
 	select HW_RANDOM
 	help
@@ -28,13 +37,13 @@ config CRYPTO_DEV_NXP_HSE_HWRNG
 
 config CRYPTO_DEV_NXP_HSE_KEY_WRAPPING
 	bool "NXP key wrapping/blobbing support"
-	depends on CRYPTO_DEV_NXP_HSE
+	depends on CRYPTO_DEV_NXP_HSE && !CRYPTO_DEV_NXP_HSE_UIO
 	default n
 	help
 	  Enables NXP key wrapping/blobbing support.
 
 config CRYPTO_DEV_NXP_HSE_AES_KEY_GID
-	depends on CRYPTO_DEV_NXP_HSE
+	depends on CRYPTO_DEV_NXP_HSE && !CRYPTO_DEV_NXP_HSE_UIO
 	int "AES Key Group ID within RAM Key Catalog: [0-256]"
 	range 0 256
 	default "1"
@@ -42,7 +51,7 @@ config CRYPTO_DEV_NXP_HSE_AES_KEY_GID
 	  The AES 256-bit Key Group ID within RAM Key Catalog.
 
 config CRYPTO_DEV_NXP_HSE_AES_KEY_GSIZE
-	depends on CRYPTO_DEV_NXP_HSE
+	depends on CRYPTO_DEV_NXP_HSE && !CRYPTO_DEV_NXP_HSE_UIO
 	int "Number of AES Key Slots in AES Key Group: [0-256]"
 	range 0 256
 	default "20"
@@ -50,7 +59,7 @@ config CRYPTO_DEV_NXP_HSE_AES_KEY_GSIZE
 	  Number of Key Slots available in the 256-bit AES Key Group.
 
 config CRYPTO_DEV_NXP_HSE_HMAC_KEY_GID
-	depends on CRYPTO_DEV_NXP_HSE
+	depends on CRYPTO_DEV_NXP_HSE && !CRYPTO_DEV_NXP_HSE_UIO
 	int "HMAC Key Group ID within RAM Key Catalog: [0-256]"
 	range 0 256
 	default "2"
@@ -58,7 +67,7 @@ config CRYPTO_DEV_NXP_HSE_HMAC_KEY_GID
 	  The HMAC Key Group ID within RAM Key Catalog.
 
 config CRYPTO_DEV_NXP_HSE_HMAC_KEY_GSIZE
-	depends on CRYPTO_DEV_NXP_HSE
+	depends on CRYPTO_DEV_NXP_HSE && !CRYPTO_DEV_NXP_HSE_UIO
 	int "Number of HMAC Key Slots in HMAC Key Group: [0-256]"
 	range 0 256
 	default "10"
diff --git a/drivers/crypto/hse/Makefile b/drivers/crypto/hse/Makefile
index 0b02db83a929..d820219d711c 100644
--- a/drivers/crypto/hse/Makefile
+++ b/drivers/crypto/hse/Makefile
@@ -1,8 +1,9 @@
 # SPDX-License-Identifier: BSD-3-Clause
 #
-# Copyright 2019-2020 NXP
+# Copyright 2019-2021 NXP
 #
 
 obj-$(CONFIG_CRYPTO_DEV_NXP_HSE) += hse.o
 
 hse-y := hse-core.o hse-mu.o hse-ahash.o hse-skcipher.o hse-aead.o hse-rng.o
+hse-$(CONFIG_CRYPTO_DEV_NXP_HSE_UIO) += hse-uio.o
diff --git a/drivers/crypto/hse/hse-core.c b/drivers/crypto/hse/hse-core.c
index 4d70d780198e..941333214c34 100644
--- a/drivers/crypto/hse/hse-core.c
+++ b/drivers/crypto/hse/hse-core.c
@@ -4,7 +4,7 @@
  *
  * This file contains the device driver core for the HSE cryptographic engine.
  *
- * Copyright 2019-2020 NXP
+ * Copyright 2019-2021 NXP
  */
 
 #include <linux/kernel.h>
@@ -27,6 +27,7 @@
  * @skcipher_algs: registered symmetric key cipher algorithms
  * @aead_algs: registered AEAD algorithms
  * @mu: MU instance handle
+ * @uio: user-space I/O device handle
  * @channel_busy[n]: internally cached status of MU channel n
  * @refcnt: acquired service channel reference count
  * @rx_cbk[n].fn: upper layer RX callback for channel n
@@ -46,6 +47,7 @@ struct hse_drvdata {
 	struct list_head skcipher_algs;
 	struct list_head aead_algs;
 	void *mu;
+	void *uio;
 	bool channel_busy[HSE_NUM_CHANNELS];
 	atomic_t refcnt[HSE_NUM_CHANNELS];
 	struct {
@@ -90,7 +92,7 @@ static void hse_print_fw_version(struct device *dev)
 	if (unlikely(dma_mapping_error(dev, srv_desc_dma)))
 		goto err_unmap_fw_ver;
 
-	err = hse_srv_req_sync(dev, HSE_CHANNEL_ANY, srv_desc_dma);
+	err = hse_srv_req_sync(dev, HSE_CHANNEL_ADM, srv_desc_dma);
 	if (unlikely(err)) {
 		dev_dbg(dev, "%s: request failed: %d\n", __func__, err);
 		goto err_unmap_srv_desc;
@@ -111,6 +113,7 @@ static void hse_print_fw_version(struct device *dev)
 	dma_unmap_single(dev, fw_ver_dma, sizeof(drv->fw_ver), DMA_FROM_DEVICE);
 }
 
+#ifndef CONFIG_CRYPTO_DEV_NXP_HSE_UIO
 /**
  * hse_key_ring_init - initialize all keys in a specific key group
  * @dev: HSE device
@@ -152,6 +155,7 @@ static void hse_key_ring_free(struct list_head *key_ring)
 	list_for_each_entry_safe(key, tmp, key_ring, entry)
 		list_del(&key->entry);
 }
+#endif /* CONFIG_CRYPTO_DEV_NXP_HSE_UIO */
 
 /**
  * hse_key_slot_acquire - acquire a HSE key slot
@@ -537,6 +541,14 @@ static void hse_srv_rsp_dispatch(struct device *dev, u8 channel)
 		dev_dbg(dev, "%s: service response 0x%08X on channel %d\n",
 			__func__, srv_rsp, channel);
 
+#ifdef CONFIG_CRYPTO_DEV_NXP_HSE_UIO
+	/* when UIO support is enabled, let upper layer handle the reply */
+	if (likely(drv->uio)) {
+		hse_uio_notify(drv->uio, channel, srv_rsp);
+		return;
+	}
+#endif /* CONFIG_CRYPTO_DEV_NXP_HSE_UIO */
+
 	if (drv->rx_cbk[channel].fn) {
 		drv->rx_cbk[channel].fn(err, drv->rx_cbk[channel].ctx);
 		drv->rx_cbk[channel].fn = NULL;
@@ -623,7 +635,7 @@ static int hse_probe(struct platform_device *pdev)
 	u16 status, init_ok_mask;
 	int err;
 
-	dev_info(dev, "probing driver\n");
+	dev_dbg(dev, "probing driver\n");
 
 	drv = devm_kzalloc(dev, sizeof(*drv), GFP_KERNEL);
 	if (IS_ERR_OR_NULL(drv))
@@ -632,13 +644,17 @@ static int hse_probe(struct platform_device *pdev)
 
 	/* MU interface setup */
 	drv->mu = hse_mu_init(dev, hse_rx_dispatcher, hse_event_dispatcher);
-	if (IS_ERR(drv->mu))
+	if (IS_ERR(drv->mu)) {
+		dev_dbg(dev, "failed to initialize HSE communication\n");
 		return PTR_ERR(drv->mu);
+	}
 
 	/* check HSE global status */
 	status = hse_mu_check_status(drv->mu);
-	if (!likely(status & HSE_STATUS_INIT_OK))
+	if (!likely(status & HSE_STATUS_INIT_OK)) {
 		dev_err(dev, "HSE firmware not loaded or not initialized\n");
+		return -ENODEV;
+	}
 	if (!likely(status & HSE_STATUS_INSTALL_OK))
 		dev_err(dev, "config not found, key stores not formatted\n");
 	if (unlikely(status & HSE_STATUS_PUBLISH_SYS_IMAGE))
@@ -656,18 +672,20 @@ static int hse_probe(struct platform_device *pdev)
 	spin_lock_init(&drv->tx_lock);
 	spin_lock_init(&drv->key_ring_lock);
 
+#ifndef CONFIG_CRYPTO_DEV_NXP_HSE_UIO
 	/* initialize key rings */
 	err = hse_key_ring_init(dev, &drv->hmac_key_ring, HSE_KEY_TYPE_HMAC,
 				CONFIG_CRYPTO_DEV_NXP_HSE_HMAC_KEY_GID,
 				CONFIG_CRYPTO_DEV_NXP_HSE_HMAC_KEY_GSIZE);
-	if (err)
+	if (unlikely(err))
 		return err;
 
 	err = hse_key_ring_init(dev, &drv->aes_key_ring, HSE_KEY_TYPE_AES,
 				CONFIG_CRYPTO_DEV_NXP_HSE_AES_KEY_GID,
 				CONFIG_CRYPTO_DEV_NXP_HSE_AES_KEY_GSIZE);
-	if (err)
+	if (unlikely(err))
 		return err;
+#endif /* CONFIG_CRYPTO_DEV_NXP_HSE_UIO */
 
 	/* enable RX and error notifications */
 	hse_mu_irq_enable(drv->mu, HSE_INT_RESPONSE, HSE_CH_MASK_ALL);
@@ -676,6 +694,7 @@ static int hse_probe(struct platform_device *pdev)
 	/* check firmware version */
 	hse_print_fw_version(dev);
 
+#ifndef CONFIG_CRYPTO_DEV_NXP_HSE_UIO
 	/* register algorithms */
 	hse_ahash_register(dev, &drv->ahash_algs);
 	hse_skcipher_register(dev, &drv->skcipher_algs);
@@ -683,6 +702,14 @@ static int hse_probe(struct platform_device *pdev)
 
 	if (IS_ENABLED(CONFIG_CRYPTO_DEV_NXP_HSE_HWRNG))
 		hse_hwrng_register(dev);
+#else
+
+	drv->uio = hse_uio_register(dev, drv->mu);
+	if (IS_ERR_OR_NULL(drv->uio)) {
+		dev_err(dev, "failed to register UIO device\n");
+		return PTR_ERR(drv->uio);
+	}
+#endif /* CONFIG_CRYPTO_DEV_NXP_HSE_UIO */
 
 	dev_info(dev, "device ready, status 0x%04X\n", status);
 
@@ -698,6 +725,7 @@ static int hse_remove(struct platform_device *pdev)
 	hse_mu_irq_disable(drv->mu, HSE_INT_RESPONSE, HSE_CH_MASK_ALL);
 	hse_mu_irq_disable(drv->mu, HSE_INT_SYS_EVENT, HSE_CH_MASK_ALL);
 
+#ifndef CONFIG_CRYPTO_DEV_NXP_HSE_UIO
 	/* unregister algorithms */
 	hse_ahash_unregister(&drv->ahash_algs);
 	hse_skcipher_unregister(&drv->skcipher_algs);
@@ -706,6 +734,7 @@ static int hse_remove(struct platform_device *pdev)
 	/* empty used key rings */
 	hse_key_ring_free(&drv->aes_key_ring);
 	hse_key_ring_free(&drv->hmac_key_ring);
+#endif /* CONFIG_CRYPTO_DEV_NXP_HSE_UIO */
 
 	dev_info(dev, "device removed\n");
 
diff --git a/drivers/crypto/hse/hse-core.h b/drivers/crypto/hse/hse-core.h
index d112df3a87d7..e2cb6384ac59 100644
--- a/drivers/crypto/hse/hse-core.h
+++ b/drivers/crypto/hse/hse-core.h
@@ -4,17 +4,16 @@
  *
  * This file defines the driver core interface for the HSE cryptographic engine.
  *
- * Copyright 2019-2020 NXP
+ * Copyright 2019-2021 NXP
  */
 
 #ifndef HSE_CORE_H
 #define HSE_CORE_H
 
-#include <crypto/aes.h>
-
 #define HSE_CRA_PRIORITY    2000u /* HSE crypto algorithm priority */
 
 #define HSE_CHANNEL_ANY    0xACu /* use any channel, no request ordering */
+#define HSE_CHANNEL_ADM    0u /* channel reserved for administrative services */
 
 /**
  * enum hse_ch_type - channel type
@@ -72,4 +71,7 @@ void hse_aead_unregister(struct list_head *alg_list);
 
 void hse_hwrng_register(struct device *dev);
 
+void *hse_uio_register(struct device *dev, void *mu);
+void hse_uio_notify(void *uio, u8 channel, u32 srv_rsp);
+
 #endif /* HSE_CORE_H */
diff --git a/drivers/crypto/hse/hse-uio.c b/drivers/crypto/hse/hse-uio.c
new file mode 100644
index 000000000000..c75e719b94ba
--- /dev/null
+++ b/drivers/crypto/hse/hse-uio.c
@@ -0,0 +1,226 @@
+// SPDX-License-Identifier: BSD-3-Clause
+/*
+ * NXP HSE Driver - User-space Driver Support
+ *
+ * This file contains the HSE user-space I/O driver support.
+ *
+ * Copyright 2021 NXP
+ */
+
+#include <linux/kernel.h>
+#include <linux/io.h>
+#include <linux/platform_device.h>
+#include <linux/uio_driver.h>
+
+#include "hse-abi.h"
+#include "hse-core.h"
+#include "hse-mu.h"
+
+#define HSE_SHARED_RAM_ADDR    0x22C00000ul /* HSE shared RAM */
+#define HSE_SHARED_RAM_SIZE    0x4000u /* 16k */
+
+/**
+ * enum hse_uio_irqctl - HSE UIO interrupt control commands
+ * @HSE_UIO_DISABLE_RX_IRQ_CMD: disable HSE MU rx interrupt
+ * @HSE_UIO_ENABLE_RX_IRQ_CMD: enable HSE MU rx interrupt
+ * @HSE_UIO_DISABLE_TX_IRQ_CMD: disable HSE MU tx interrupt
+ * @HSE_UIO_ENABLE_TX_IRQ_CMD: enable HSE MU tx interrupt
+ * @HSE_UIO_DISABLE_EVT_IRQ_CMD: disable HSE MU sys event interrupt
+ * @HSE_UIO_ENABLE_EVT_IRQ_CMD: enable HSE MU sys event interrupt
+ * @HSE_UIO_CLEAR_EVT_IRQ_CMD: clear HSE MU sys event interrupt
+ */
+enum hse_uio_irqctl {
+	HSE_UIO_DISABLE_RX_IRQ_CMD = 0u,
+	HSE_UIO_ENABLE_RX_IRQ_CMD = 1u,
+	HSE_UIO_DISABLE_TX_IRQ_CMD = 2u,
+	HSE_UIO_ENABLE_TX_IRQ_CMD = 3u,
+	HSE_UIO_DISABLE_EVT_IRQ_CMD = 4u,
+	HSE_UIO_ENABLE_EVT_IRQ_CMD = 5u,
+	HSE_UIO_CLEAR_EVT_IRQ_CMD = 6u,
+};
+
+/**
+ * struct hse_uio_shm - HSE shared RAM layout
+ * @ready[n]: reply ready on channel n
+ * @reply[n]: service response on channel n
+ */
+struct hse_uio_shm {
+	u8 ready[HSE_NUM_CHANNELS];
+	u32 reply[HSE_NUM_CHANNELS];
+};
+
+/**
+ * struct hse_uio_priv - HSE UIO component private data
+ * @dev: HSE device
+ * @mu: MU instance handle
+ * @info: UIO device info
+ * @refcnt: reference counter
+ * @shm: pointer to HSE shared RAM
+ */
+struct hse_uio_priv {
+	struct device *dev;
+	void *mu;
+	struct uio_info info;
+	atomic_t refcnt;
+	struct hse_uio_shm __iomem *shm;
+};
+
+/**
+ * hse_uio_open - open /dev/uioX device
+ * @info: UIO device info
+ * @inode: inode, not used
+ *
+ * Protects against multiple driver instances using UIO support.
+ */
+static int hse_uio_open(struct uio_info *info, struct inode *inode)
+{
+	struct hse_uio_priv *priv = info->priv;
+
+	if (!atomic_dec_and_test(&priv->refcnt)) {
+		dev_err(priv->dev, "%s device already in use\n", info->name);
+		atomic_inc(&priv->refcnt);
+
+		return -EBUSY;
+	}
+
+	return 0;
+}
+
+/**
+ * hse_uio_release - release /dev/uioX device
+ * @info: UIO device info
+ * @inode: inode, not used
+ *
+ * Protects against multiple driver instances using UIO support.
+ */
+static int hse_uio_release(struct uio_info *info, struct inode *inode)
+{
+	struct hse_uio_priv *priv = info->priv;
+
+	atomic_inc(&priv->refcnt);
+
+	return 0;
+}
+
+/**
+ * hse_uio_irqcontrol - control HSE MU interrupt status by writing to /dev/uioX
+ * @info: UIO device info
+ * @cmd: interrupt control command
+ */
+static int hse_uio_irqcontrol(struct uio_info *info, int cmd)
+{
+	struct hse_uio_priv *priv = info->priv;
+
+	switch (cmd) {
+	case HSE_UIO_DISABLE_RX_IRQ_CMD:
+		hse_mu_irq_disable(priv->mu, HSE_INT_RESPONSE, HSE_CH_MASK_ALL);
+		break;
+	case HSE_UIO_ENABLE_RX_IRQ_CMD:
+		hse_mu_irq_enable(priv->mu, HSE_INT_RESPONSE, HSE_CH_MASK_ALL);
+		break;
+	case HSE_UIO_DISABLE_TX_IRQ_CMD:
+		hse_mu_irq_disable(priv->mu, HSE_INT_ACK_REQUEST,
+				   HSE_CH_MASK_ALL);
+		break;
+	case HSE_UIO_ENABLE_TX_IRQ_CMD:
+		hse_mu_irq_enable(priv->mu, HSE_INT_ACK_REQUEST,
+				  HSE_CH_MASK_ALL);
+		break;
+	case HSE_UIO_DISABLE_EVT_IRQ_CMD:
+		hse_mu_irq_enable(priv->mu, HSE_INT_SYS_EVENT, HSE_CH_MASK_ALL);
+		break;
+	case HSE_UIO_ENABLE_EVT_IRQ_CMD:
+		hse_mu_irq_enable(priv->mu, HSE_INT_SYS_EVENT, HSE_CH_MASK_ALL);
+		break;
+	case HSE_UIO_CLEAR_EVT_IRQ_CMD:
+		hse_mu_irq_clear(priv->mu, HSE_INT_SYS_EVENT, HSE_CH_MASK_ALL);
+		break;
+	default:
+		break;
+	}
+
+	return 0;
+}
+
+/**
+ * hse_uio_notify - notify upper layer of HSE reply
+ * @uio: UIO device handle
+ * @channel: channel index
+ * @srv_rsp: service response
+ */
+void hse_uio_notify(void *uio, u8 channel, u32 srv_rsp)
+{
+	struct uio_info *info = uio;
+	struct hse_uio_priv *priv = info->priv;
+
+	priv->shm->ready[channel] = 1;
+	priv->shm->reply[channel] = srv_rsp;
+
+	uio_event_notify(uio);
+}
+
+/**
+ * hse_uio_register - initialize and register UIO device
+ * @dev: HSE device
+ * @mu: MU instance handle, for interrupt control
+ *
+ * Return: UIO device handle on success, error code otherwise
+ */
+void *hse_uio_register(struct device *dev, void *mu)
+{
+	struct hse_uio_priv *priv;
+	struct resource *reg;
+	int err;
+
+	priv = devm_kzalloc(dev, sizeof(*priv), GFP_KERNEL);
+	if (IS_ERR_OR_NULL(priv))
+		return ERR_PTR(-ENOMEM);
+	priv->dev = dev;
+	priv->mu = mu;
+
+	atomic_set(&priv->refcnt, 1);
+
+	/* get HSE MU register space info from device tree */
+	reg = platform_get_resource(to_platform_device(dev), IORESOURCE_MEM, 0);
+	if (IS_ERR_OR_NULL(reg))
+		return ERR_PTR(-ENODEV);
+
+	/* expose HSE MU register space to upper layer */
+	priv->info.mem[0].name = "HSE MU registers";
+	priv->info.mem[0].addr = reg->start;
+	priv->info.mem[0].size = resource_size(reg);
+	priv->info.mem[0].memtype = UIO_MEM_PHYS;
+
+	priv->info.version = "0.8.5";
+	priv->info.name = "HSE UIO driver";
+
+	priv->info.open = hse_uio_open;
+	priv->info.release = hse_uio_release;
+
+	priv->info.irq = UIO_IRQ_CUSTOM;
+	priv->info.irqcontrol = hse_uio_irqcontrol;
+	priv->info.priv = priv;
+
+	/* map HSE shared RAM area */
+	priv->shm = devm_ioremap_nocache(dev, HSE_SHARED_RAM_ADDR,
+					 HSE_SHARED_RAM_SIZE);
+	if (IS_ERR_OR_NULL(priv->shm))
+		return ERR_PTR(-ENOMEM);
+
+	/* expose HSE shared RAM to upper layer */
+	priv->info.mem[1].name = "HSE shared RAM";
+	priv->info.mem[1].addr = HSE_SHARED_RAM_ADDR;
+	priv->info.mem[1].internal_addr = priv->shm;
+	priv->info.mem[1].size = HSE_SHARED_RAM_SIZE;
+	priv->info.mem[1].memtype = UIO_MEM_PHYS;
+
+	err = uio_register_device(dev, &priv->info);
+	if (err) {
+		dev_err(dev, "failed to register UIO device: %d\n", err);
+		return ERR_PTR(err);
+	}
+
+	dev_info(dev, "successfully registered UIO device\n");
+
+	return &priv->info;
+}
-- 
2.17.1

