From eb667247d016121eb8d0c28760c5baff7115b515 Mon Sep 17 00:00:00 2001
From: Bogdan-Gabriel Roman <bogdan-gabriel.roman@nxp.com>
Date: Tue, 9 Nov 2021 14:58:16 +0200
Subject: [PATCH 24/24] spi: fsl-dspi: halt the module after a new message
 transfer

commit eb667247d016121eb8d0c28760c5baff7115b515 from
https://source.codeaurora.org/external/autobsps32/linux

The XSPI mode implementation in this driver still uses the EOQ flag to
signal the last word in a transmission and deassert the PCS signal.
However, at speeds lower than ~200kHZ, the PCS signal seems to remain
asserted even when SR[EOQF] = 1 indicates the end of a transmission.
This is a problem for slave devices which require the deassertation of
the PCS signal between transfers.

Hence, this commit 'forces' the deassertation of the PCS by stopping the
module through MCR[HALT] after completing a new transfer. According to
the reference manual, the module stops or transitions from the
Running state to the Stopped state after the current frame, when any one
of the following conditions exist:
- The value of SR[EOQF] = 1.
- The chip is in Debug mode and the value of MCR[FRZ] = 1.
- The value of MCR[HALT] = 1.

Issue: ALB-6756
Upstream-Status: Pending 

Signed-off-by: Bogdan-Gabriel Roman <bogdan-gabriel.roman@nxp.com>
Signed-off-by: Zhantao Tang <zhantao.tang@windriver.com>
---
 drivers/spi/spi-fsl-dspi.c | 16 ++++++++++++++++
 1 file changed, 16 insertions(+)

diff --git a/drivers/spi/spi-fsl-dspi.c b/drivers/spi/spi-fsl-dspi.c
index 377799cf6365..eae46f8a8914 100644
--- a/drivers/spi/spi-fsl-dspi.c
+++ b/drivers/spi/spi-fsl-dspi.c
@@ -64,6 +64,7 @@
 #define SPI_SR_TFIWF			BIT(18)
 #define SPI_SR_RFDF			BIT(17)
 #define SPI_SR_CMDFFF			BIT(16)
+#define SPI_SR_TXRXS			BIT(30)
 #define SPI_SR_CLEAR			(SPI_SR_TCFQF | \
 					SPI_SR_TFUF | SPI_SR_TFFF | \
 					SPI_SR_CMDTCF | SPI_SR_SPEF | \
@@ -951,10 +952,17 @@ static int dspi_transfer_one_message(struct spi_controller *ctlr,
 	struct spi_transfer *transfer;
 	int status = 0;
 	u8 pushr_cmd_pcs;
+	u32 val = 0;
 
 	message->actual_length = 0;
 	pushr_cmd_pcs = get_dspi_pushr_cmd_pcs(dspi, spi->chip_select);
 
+	/* Put DSPI in running mode */
+	regmap_update_bits(dspi->regmap, SPI_MCR, SPI_MCR_HALT, 0);
+	while (regmap_read(dspi->regmap, SPI_SR, &val) >= 0 &&
+		!(val & SPI_SR_TXRXS))
+		;
+
 	list_for_each_entry(transfer, &message->transfers, transfer_list) {
 		dspi->cur_transfer = transfer;
 		dspi->cur_msg = message;
@@ -1010,6 +1018,12 @@ static int dspi_transfer_one_message(struct spi_controller *ctlr,
 		spi_transfer_delay_exec(transfer);
 	}
 
+	/* Put DSPI in stop mode */
+	regmap_update_bits(dspi->regmap, SPI_MCR, SPI_MCR_HALT, SPI_MCR_HALT);
+	while (regmap_read(dspi->regmap, SPI_SR, &val) >= 0 &&
+		val & SPI_SR_TXRXS)
+		;
+
 	message->status = status;
 	spi_finalize_current_message(ctlr);
 
@@ -1176,6 +1190,8 @@ static int dspi_init(struct fsl_dspi *dspi)
 	if (!spi_controller_is_slave(dspi->ctlr))
 		mcr |= SPI_MCR_MASTER;
 
+	mcr |= SPI_MCR_HALT;
+
 	regmap_write(dspi->regmap, SPI_MCR, mcr);
 	regmap_write(dspi->regmap, SPI_SR, SPI_SR_CLEAR);
 
-- 
2.17.1

