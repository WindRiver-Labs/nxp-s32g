From 7f7acf69199a7e7c834cf26594e033d2f99985f6 Mon Sep 17 00:00:00 2001
From: Vlad Pelin <vlad.pelin@nxp.com>
Date: Wed, 7 Jul 2021 14:31:05 +0300
Subject: [PATCH 3/4] pkcs: conform to expected interface behaviour

pkcs11-hse does not fully conform to expected output
according to the pkcs11 spec, since we do not use
multithread or multiple instances. tests expect
default behaviour, so fix at least some of these
issues

Issue: ALB-7136, ALB-7427
Upstream-Status: Pending 

Signed-off-by: Vlad Pelin <vlad.pelin@nxp.com>
Signed-off-by: Zhantao Tang <zhantao.tang@windriver.com>
---
 libpkcs/pkcs11.c         | 55 ++++++++++++++++++++++++---------
 libpkcs/pkcs11_context.h |  2 ++
 libpkcs/pkcs11_crypt.c   | 66 ++++++++++++++++++++++------------------
 3 files changed, 79 insertions(+), 44 deletions(-)

diff --git a/libpkcs/pkcs11.c b/libpkcs/pkcs11.c
index 734baa9..2ba01de 100644
--- a/libpkcs/pkcs11.c
+++ b/libpkcs/pkcs11.c
@@ -55,7 +55,8 @@ static CK_FUNCTION_LIST gFunctionList = {
 	.C_Decrypt =                            C_Decrypt,
 	.C_SignInit =                           C_SignInit,
 	.C_Sign =                               C_Sign,
-	.C_VerifyInit =                         C_VerifyInit
+	.C_VerifyInit =                         C_VerifyInit,
+	.C_Verify =                             C_Verify
 };
 
 /*
@@ -209,6 +210,7 @@ CK_DEFINE_FUNCTION(CK_RV, C_Finalize)(
 	list_destroy(&gCtx->objects);
 
 	gCtx->cryptokiInit = CK_FALSE;
+	gCtx->tokenInit = CK_FALSE;
 
 	return CKR_OK;
 }
@@ -217,11 +219,6 @@ CK_DEFINE_FUNCTION(CK_RV, C_GetInfo)(
 	CK_INFO_PTR pInfo
 )
 {
-	struct globalCtx *gCtx = getCtx();
-
-	if (!gCtx->cryptokiInit)
-		return CKR_CRYPTOKI_NOT_INITIALIZED;
-
 	if (pInfo == NULL)
 		return CKR_ARGUMENTS_BAD;
 
@@ -375,6 +372,26 @@ CK_DEFINE_FUNCTION(CK_RV, C_GetMechanismInfo)(
 		return CKR_SLOT_ID_INVALID;
 
 	switch (type) {
+		case CKM_AES_ECB:
+			pInfo->ulMinKeySize = 0;
+			pInfo->ulMaxKeySize = 256;
+			pInfo->flags = CKF_HW | CKF_ENCRYPT | CKF_DECRYPT;
+			break;
+		case CKM_AES_GCM:
+			pInfo->ulMinKeySize = 0;
+			pInfo->ulMaxKeySize = 256;
+			pInfo->flags = CKF_HW | CKF_ENCRYPT | CKF_DECRYPT;
+			break;
+		case CKM_SHA256_RSA_PKCS:
+			pInfo->ulMinKeySize = 0;
+			pInfo->ulMaxKeySize = 2048;
+			pInfo->flags = CKF_HW | CKF_SIGN | CKF_VERIFY;
+			break;
+		case CKM_ECDSA_SHA1:
+			pInfo->ulMinKeySize = 0;
+			pInfo->ulMaxKeySize = 256;
+			pInfo->flags = CKF_HW | CKF_SIGN | CKF_VERIFY;
+			break;
 		default:
 			return CKR_MECHANISM_INVALID;
 	}
@@ -447,7 +464,11 @@ CK_DEFINE_FUNCTION(CK_RV, C_InitToken)(
 	CK_UTF8CHAR_PTR pLabel
 )
 {
-	return CKR_OK;
+	struct globalCtx *gCtx = getCtx();
+
+	gCtx->tokenInit = CK_TRUE;
+
+    return CKR_OK;
 }
 
 CK_DEFINE_FUNCTION(CK_RV, C_InitPIN)(
@@ -485,7 +506,7 @@ CK_DEFINE_FUNCTION(CK_RV, C_OpenSession)(
 	if (!gCtx->cryptokiInit)
 		return CKR_CRYPTOKI_NOT_INITIALIZED;
 
-	if (slotID != SLOT_ID)
+    if (slotID != SLOT_ID)
 		return CKR_SLOT_ID_INVALID;
 
 	if (!phSession)
@@ -498,6 +519,12 @@ CK_DEFINE_FUNCTION(CK_RV, C_OpenSession)(
 	if (!(flags & CKF_SERIAL_SESSION))
 		return CKR_SESSION_PARALLEL_NOT_SUPPORTED;
 
+	if ((Notify && !pApplication) || (!Notify && pApplication))
+		return CKR_ARGUMENTS_BAD;
+
+	if (!gCtx->tokenInit)
+		return CKR_TOKEN_NOT_RECOGNIZED;
+
 	if (flags & CKF_RW_SESSION) {
 		if (pToken->ulRwSessionCount >= pToken->ulMaxRwSessionCount)
 			return CKR_SESSION_COUNT;
@@ -506,15 +533,15 @@ CK_DEFINE_FUNCTION(CK_RV, C_OpenSession)(
 			return CKR_TOKEN_WRITE_PROTECTED;
 
 		pToken->ulRwSessionCount++;
-		pSession->state = CKS_RW_USER_FUNCTIONS;
+		pSession->state = CKS_RW_PUBLIC_SESSION;
 	} else {
-		pSession->state = CKS_RO_USER_FUNCTIONS;
+		pSession->state = CKS_RO_PUBLIC_SESSION;
 	}
 
-	pToken->ulSessionCount++;
-	pSession->flags = flags;
-	pSession->slotID = slotID;
-	*phSession = SESSION_ID;
+    pToken->ulSessionCount++;
+    pSession->flags = flags;
+    pSession->slotID = slotID;
+    *phSession = SESSION_ID;
 
 	return CKR_OK;
 }
diff --git a/libpkcs/pkcs11_context.h b/libpkcs/pkcs11_context.h
index 8279025..9b824ae 100644
--- a/libpkcs/pkcs11_context.h
+++ b/libpkcs/pkcs11_context.h
@@ -96,6 +96,7 @@ struct hse_keyObject {
  * struct globalCtx - global context for PKCS11 operations
  *
  * @cryptokiInit:     check if cryptoki has been initialized
+ * @tokenInit:        check if token has been initialized
  * @session:          session info
  * @slot:             slot info
  * @token:            token info
@@ -106,6 +107,7 @@ struct hse_keyObject {
  */
 struct globalCtx {
 	CK_BBOOL cryptokiInit;
+	CK_BBOOL tokenInit;
 	CK_SESSION_INFO session;
 	CK_SLOT_INFO slot;
 	CK_TOKEN_INFO token;
diff --git a/libpkcs/pkcs11_crypt.c b/libpkcs/pkcs11_crypt.c
index 235ca89..4b203d1 100644
--- a/libpkcs/pkcs11_crypt.c
+++ b/libpkcs/pkcs11_crypt.c
@@ -368,9 +368,6 @@ CK_DEFINE_FUNCTION(CK_RV, C_SignInit)(
 	if (gCtx->cryptokiInit == CK_FALSE)
 		return CKR_CRYPTOKI_NOT_INITIALIZED;
 
-	if (gCtx->signCtx.init == CK_TRUE)
-		return CKR_OPERATION_ACTIVE;
-
 	if (hSession != SESSION_ID)
 		return CKR_SESSION_HANDLE_INVALID;
 
@@ -380,6 +377,9 @@ CK_DEFINE_FUNCTION(CK_RV, C_SignInit)(
 	if (list_seek(&gCtx->objects, &hKey) == NULL)
 		return CKR_KEY_HANDLE_INVALID;
 
+	if (gCtx->signCtx.init == CK_TRUE)
+		return CKR_OPERATION_ACTIVE;
+
 	gCtx->signCtx.init = CK_TRUE;
 	gCtx->signCtx.mechanism = pMechanism;
 	gCtx->signCtx.keyHandle = hKey;
@@ -409,20 +409,23 @@ CK_DEFINE_FUNCTION(CK_RV, C_Sign)(
 		goto gen_err;
 	}
 
-	if (gCtx->signCtx.init == CK_FALSE) {
-		rc = CKR_OPERATION_NOT_INITIALIZED;
-		goto gen_err;
-	}
+	if (hSession != SESSION_ID)
+		return CKR_SESSION_HANDLE_INVALID;
 
-	if (hSession != SESSION_ID) {
-		rc = CKR_SESSION_HANDLE_INVALID;
-		goto gen_err;
-	}
+	if (pData == NULL)
+		return CKR_DATA_INVALID;
 
-	if (pData == NULL || pSignature == NULL || pulSignatureLen == NULL) {
-		rc = CKR_ARGUMENTS_BAD;
-		goto gen_err;
-	}
+	if (ulDataLen == 0)
+		return CKR_DATA_LEN_RANGE;
+
+	if (pSignature == NULL)
+		return CKR_SIGNATURE_INVALID;
+
+	if (pulSignatureLen == NULL)
+		return CKR_SIGNATURE_LEN_RANGE;
+
+	if (gCtx->signCtx.init == CK_FALSE)
+		return CKR_OPERATION_NOT_INITIALIZED;
 
 	key = (struct hse_keyObject *)list_seek(&gCtx->objects, &gCtx->signCtx.keyHandle);
 
@@ -554,9 +557,6 @@ CK_DEFINE_FUNCTION(CK_RV, C_VerifyInit)(
 	if (gCtx->cryptokiInit == CK_FALSE)
 		return CKR_CRYPTOKI_NOT_INITIALIZED;
 
-	if (gCtx->signCtx.init == CK_TRUE)
-		return CKR_OPERATION_ACTIVE;
-
 	if (hSession != SESSION_ID)
 		return CKR_SESSION_HANDLE_INVALID;
 
@@ -566,6 +566,9 @@ CK_DEFINE_FUNCTION(CK_RV, C_VerifyInit)(
 	if (list_seek(&gCtx->objects, &hKey) == NULL)
 		return CKR_KEY_HANDLE_INVALID;
 
+	if (gCtx->signCtx.init == CK_TRUE)
+		return CKR_OPERATION_ACTIVE;
+
 	gCtx->signCtx.init = CK_TRUE;
 	gCtx->signCtx.mechanism = pMechanism;
 	gCtx->signCtx.keyHandle = hKey;
@@ -595,20 +598,23 @@ CK_DEFINE_FUNCTION(CK_RV, C_Verify)(
 		goto gen_err;
 	}
 
-	if (gCtx->signCtx.init == CK_FALSE) {
-		rc = CKR_OPERATION_NOT_INITIALIZED;
-		goto gen_err;
-	}
+	if (hSession != SESSION_ID)
+		return CKR_SESSION_HANDLE_INVALID;
 
-	if (hSession != SESSION_ID) {
-		rc = CKR_SESSION_HANDLE_INVALID;
-		goto gen_err;
-	}
+	if (pData == NULL)
+		return CKR_DATA_INVALID;
 
-	if (pData == NULL || pSignature == NULL) {
-		rc = CKR_ARGUMENTS_BAD;
-		goto gen_err;
-	}
+	if (ulDataLen == 0)
+		return CKR_DATA_LEN_RANGE;
+
+	if (pSignature == NULL)
+		return CKR_SIGNATURE_INVALID;
+
+	if (ulSignatureLen == 0)
+		return CKR_SIGNATURE_LEN_RANGE;
+
+	if (gCtx->signCtx.init == CK_FALSE)
+		return CKR_OPERATION_NOT_INITIALIZED;
 
 	key = (struct hse_keyObject *)list_seek(&gCtx->objects, &gCtx->signCtx.keyHandle);
 
-- 
2.17.1

