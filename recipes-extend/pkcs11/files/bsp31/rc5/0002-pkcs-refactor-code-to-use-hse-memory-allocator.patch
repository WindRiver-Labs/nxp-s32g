From 8f36b874bfbb3c9def78f5723e789d5b499cb1d9 Mon Sep 17 00:00:00 2001
From: Vlad Pelin <vlad.pelin@nxp.com>
Date: Thu, 14 Oct 2021 17:08:59 +0300
Subject: [PATCH 2/4] pkcs: refactor code to use hse memory allocator

Issue: ALB-6511
Upstream-Status: Pending 

Signed-off-by: Vlad Pelin <vlad.pelin@nxp.com>
Signed-off-by: Zhantao Tang <zhantao.tang@windriver.com>
---
 Makefile                             |   8 +-
 libhse/hse-internal.h                |   2 +
 libhse/{hse_memalloc.c => hse-mem.c} |  44 ++-
 libhse/hse-usr.c                     |   9 +-
 libhse/hse_memalloc.h                |  25 --
 libpkcs/pkcs11.c                     |   4 +-
 libpkcs/pkcs11_context.h             |  12 -
 libpkcs/pkcs11_crypt.c               | 446 +++++++++++++++++----------
 libpkcs/pkcs11_object.c              | 199 ++++++------
 9 files changed, 432 insertions(+), 317 deletions(-)
 rename libhse/{hse_memalloc.c => hse-mem.c} (71%)
 delete mode 100644 libhse/hse_memalloc.h

diff --git a/Makefile b/Makefile
index 0c7d156..e6c45af 100644
--- a/Makefile
+++ b/Makefile
@@ -24,7 +24,7 @@ endif
 
 ifeq (,$(HSE_FWDIR))
     HSE_FWDIR ?= $(HOME)/HSE_$(PLATFORM)_$(FWTYPE)_$(FWMAJOR)_$(FWMINOR)_$(FWPATCH)
-    $(warning Path to HSE firmware package not defined, using default $HSE_FWDIR)
+    $(warning Path to HSE firmware package not defined, using default $(HSE_FWDIR))
 endif
 
 ifeq (,$(UIO_DEV))
@@ -62,7 +62,7 @@ INCL = -I$(HSE_FWDIR)/interface                                                \
 
 DEFS := -DUIO_DEV=$(UIO_DEV)
 
-all: $(HSE_LIB).$(HSE_LIBVER)
+all: $(PKCS_LIB)
 
 $(PKCS_LIB): $(HSE_LIB).$(HSE_LIBVER) $(PKCS_OBJS)
 	$(CC) -shared $(CFLAGS) -L$(shell pwd) $(LDFLAGS) $(PKCS_OBJS) -o $@ -lhse
@@ -74,8 +74,8 @@ $(PKCS_ODIR):
 	mkdir -p $@
 
 $(HSE_LIB).$(HSE_LIBVER): $(HSE_OBJS)
-	$(CC) -shared $(CFLAGS) -Wl,-soname,$(HSE_LIB).$(HSE_LIBVER_MAJOR) $(LDFLAGS) $< -o $@
-	ln -s $@ $(HSE_LIB)
+	$(CC) -shared $(CFLAGS) -Wl,-soname,$(HSE_LIB).$(HSE_LIBVER_MAJOR) $(LDFLAGS) $(HSE_OBJS) -o $@
+	ln -sf $@ $(HSE_LIB)
 
 $(HSE_ODIR)/%.o: $(HSE_SDIR)/%.c $(HSE_ODIR)
 	$(CC) -c $(CFLAGS) $(INCL) $(DEFS) $(LDFLAGS) $< -o $@
diff --git a/libhse/hse-internal.h b/libhse/hse-internal.h
index 641ca91..7350677 100644
--- a/libhse/hse-internal.h
+++ b/libhse/hse-internal.h
@@ -10,4 +10,6 @@
 
 #define HSE_SRV_DESC_MAX_SIZE    256u /* maximum service descriptor size */
 
+int hse_mem_init(void *rmem_base_addr, uint64_t rmem_size);
+
 #endif /* HSE_INTERNAL_H */
diff --git a/libhse/hse_memalloc.c b/libhse/hse-mem.c
similarity index 71%
rename from libhse/hse_memalloc.c
rename to libhse/hse-mem.c
index a2a99e9..eb28645 100644
--- a/libhse/hse_memalloc.c
+++ b/libhse/hse-mem.c
@@ -1,6 +1,6 @@
 /* SPDX-License-Identifier: BSD-3-Clause */
 /*
- * NXP HSE Driver - Userspace memory allocation
+ * NXP HSE Userspace Driver - Memory Management
  *
  * Copyright 2021 NXP
  */
@@ -8,35 +8,49 @@
 #include <stdio.h>
 #include <stdint.h>
 #include "libhse.h"
-#include "hse_memalloc.h"
+#include "hse-internal.h"
 
-static unsigned char PLACEHOLDER[PLACEHOLDER_MEM_SIZE];
+#define ALIGNMENT 16
+#define HSE_NODE_SIZE sizeof(struct node_data)
 
-static struct node_data *mem_start = (struct node_data *)PLACEHOLDER;
+struct node_data {
+	size_t size;
+	struct node_data *next;
+} __attribute__((packed));
 
-void hse_mem_init()
+static struct node_data *mem_start;
+
+int hse_mem_init(void *rmem_base_addr, uint64_t rmem_size)
 {
-	mem_start = (struct node_data *)PLACEHOLDER;
-	mem_start->size = PLACEHOLDER_MEM_SIZE;
+	if (!rmem_base_addr)
+		return 1;
+
+	mem_start = (struct node_data *)rmem_base_addr;
+	mem_start->size = rmem_size - HSE_NODE_SIZE;
 	mem_start->next = NULL;
+
+	return 0;
 }
 
-void *hse_mem_malloc(size_t size)
+void *hse_mem_alloc(size_t size)
 {
 	struct node_data *curr_block;
 	struct node_data *best_block;
 	struct node_data *alloc_block;
-	uint32_t best_block_size;
+	size_t best_block_size;
 
 	/* align size to 16 */
-	size = (size + (ALIGNMENT - 1)) & ~ALIGNMENT;
+	size = (size + (ALIGNMENT - 1)) & ~(ALIGNMENT-1);
+	if (!size)
+		return NULL;
 
 	curr_block = mem_start;
 	best_block = NULL;
-	best_block_size = PLACEHOLDER_MEM_SIZE;
+	best_block_size = mem_start->size;
+
 	while (curr_block) {
 		/* check if curr_block fits */
-		if ((curr_block->size >= size + HSE_NODE_SIZE) &&
+		if ((curr_block->size >= (size + HSE_NODE_SIZE)) &&
 		    (curr_block->size <= best_block_size)) {
 			best_block = curr_block;
 			best_block_size = curr_block->size;
@@ -57,17 +71,17 @@ void *hse_mem_malloc(size_t size)
 	return NULL;
 }
 
-void hse_mem_free(void *p)
+void hse_mem_free(void *addr)
 {
 	struct node_data *prev_block;
 	struct node_data *next_block;
 	struct node_data *free_block;
 
-	if (p == NULL)
+	if (addr == NULL)
 		return;
 
 	/* get the node_data for the block to be freed */
-	free_block = (struct node_data *)((uint8_t *)p - HSE_NODE_SIZE);
+	free_block = (struct node_data *)((uint8_t *)addr - HSE_NODE_SIZE);
 	if (free_block == NULL)
 		return;
 
diff --git a/libhse/hse-usr.c b/libhse/hse-usr.c
index e55469f..92e5035 100644
--- a/libhse/hse-usr.c
+++ b/libhse/hse-usr.c
@@ -103,7 +103,7 @@ struct hse_uio_intl {
 	volatile uint8_t ready[HSE_NUM_CHANNELS];
 	volatile uint32_t reply[HSE_NUM_CHANNELS];
 	volatile uint32_t event;
-	uint8_t reserved_end;
+	uint8_t reserved_end __attribute__((aligned(16)));
 } __attribute__((packed));
 
 /**
@@ -451,6 +451,13 @@ int hse_dev_open(void)
 		priv.channel_busy[i] = false;
 	}
 
+	/* init mem pool */
+	if (hse_mem_init(&priv.shared->reserved_end, priv.rmem_size - sizeof(struct hse_uio_intl))) {
+		printf("hse: failed to init mem pool\n");
+		err = ENOMEM;
+		goto err_unmap_intl;
+	}
+
 	priv.init = true;
 
 	status = hse_check_status();
diff --git a/libhse/hse_memalloc.h b/libhse/hse_memalloc.h
deleted file mode 100644
index b37d3bc..0000000
--- a/libhse/hse_memalloc.h
+++ /dev/null
@@ -1,25 +0,0 @@
-/* SPDX-License-Identifier: BSD-3-Clause */
-/*
- * NXP HSE Driver - Userspace memory allocation
- *
- * Copyright 2021 NXP
- */
-
-#ifndef HSE_MEMALLOC_H
-#define HSE_MEMALLOC_H
-
-#define ALIGNMENT 16
-#define HSE_NODE_SIZE sizeof(struct node_data)
-#define PLACEHOLDER_MEM_SIZE 4096
-
-struct node_data {
-	uint32_t size;
-	struct node_data *next;
-};
-
-void hse_mem_init();
-
-void *hse_mem_malloc(size_t size);
-void hse_mem_free(void *p);
-
-#endif /* HSE_MEMALLOC_H */
diff --git a/libpkcs/pkcs11.c b/libpkcs/pkcs11.c
index 6f163da..734baa9 100644
--- a/libpkcs/pkcs11.c
+++ b/libpkcs/pkcs11.c
@@ -183,7 +183,7 @@ CK_DEFINE_FUNCTION(CK_RV, C_Initialize) (
 	list_attributes_seeker(&gCtx->objects, object_list_seeker);
 	list_attributes_comparator(&gCtx->objects, object_list_comparator);
 
-	if (hse_usr_initialize())
+	if (hse_dev_open())
 		return CKR_HOST_MEMORY;
 
 	gCtx->cryptokiInit = CK_TRUE;
@@ -201,7 +201,7 @@ CK_DEFINE_FUNCTION(CK_RV, C_Finalize)(
 	if (!gCtx->cryptokiInit)
 		return CKR_CRYPTOKI_NOT_INITIALIZED;
 
-	hse_usr_finalize();
+	hse_dev_close();
 
 	for (i = 0; i < list_size(&gCtx->objects); i++) {
 		list_delete_at(&gCtx->objects, i);
diff --git a/libpkcs/pkcs11_context.h b/libpkcs/pkcs11_context.h
index e55c561..8279025 100644
--- a/libpkcs/pkcs11_context.h
+++ b/libpkcs/pkcs11_context.h
@@ -28,18 +28,6 @@
 /* missing mechanisms from the PKCS11 interface header */
 #define CKM_AES_GCM        0x1087ul
 
-#define HSE_SRVDESC_SRAM   0x2000
-#define HSE_KEYINFO_SRAM   0x2200
-#define HSE_PKEY0_SRAM     0x2400
-#define HSE_PKEY1_SRAM     0x2600
-#define HSE_PKEY2_SRAM     0x2800
-#define HSE_INPUT_SRAM     0x3000
-#define HSE_OUTPUT_SRAM    0x3400
-#define HSE_OUTPUTLEN_SRAM 0x3800
-#define HSE_SIGN0_SRAM     0x4200
-#define HSE_SIGN1_SRAM     0x4600
-#define HSE_IV_SRAM        0x5000
-
 #ifndef ARRAY_SIZE
 #define ARRAY_SIZE(x) (sizeof(x) / sizeof((x)[0]))
 #endif
diff --git a/libpkcs/pkcs11_crypt.c b/libpkcs/pkcs11_crypt.c
index ef5721c..235ca89 100644
--- a/libpkcs/pkcs11_crypt.c
+++ b/libpkcs/pkcs11_crypt.c
@@ -5,21 +5,10 @@
 
 #include <stdio.h>
 #include <stdlib.h>
+#include <string.h>
 
 #include "pkcs11_context.h"
 
-static inline void hse_memcpy(void *dst, void *src, size_t n)
-{
-	uint8_t *s = (uint8_t *)src;
-	uint8_t *d = (uint8_t *)dst;
-
-	if (!dst || !src || n == 0)
-		return;
-
-	for (int i = 0; i < n; i++)
-		d[i] = s[i];
-}
-
 CK_DEFINE_FUNCTION(CK_RV, C_EncryptInit)(
 		CK_SESSION_HANDLE hSession,
 		CK_MECHANISM_PTR pMechanism,
@@ -67,34 +56,59 @@ CK_DEFINE_FUNCTION(CK_RV, C_Encrypt)(
 	hseSrvDescriptor_t srv_desc;
 	hseSymCipherSrv_t *sym_cipher_srv;
 	hseAeadSrv_t *aead_srv;
-	void *_srv_desc, *_input, *_output, *_output_len, *_pIV;
+	void *input, *output, *output_len, *pIV = NULL;
 	struct hse_keyObject *key;
+	CK_RV rc = CKR_OK;
 	int err;
 
-	if (gCtx->cryptokiInit == CK_FALSE)
-		return CKR_CRYPTOKI_NOT_INITIALIZED;
+	if (gCtx->cryptokiInit == CK_FALSE) {
+		rc = CKR_CRYPTOKI_NOT_INITIALIZED;
+		goto gen_err;
+	}
 
-	if (gCtx->cryptCtx.init == CK_FALSE)
-		return CKR_OPERATION_NOT_INITIALIZED;
+	if (gCtx->cryptCtx.init == CK_FALSE) {
+		rc = CKR_OPERATION_NOT_INITIALIZED;
+		goto gen_err;
+	}
 
-	if (hSession != SESSION_ID)
-		return CKR_SESSION_HANDLE_INVALID;
+	if (hSession != SESSION_ID) {
+		rc = CKR_SESSION_HANDLE_INVALID;
+		goto gen_err;
+	}
 
-	if (pData == NULL || pEncryptedData == NULL || pulEncryptedDataLen == NULL)
-		return CKR_ARGUMENTS_BAD;
+	if (pData == NULL || pEncryptedData == NULL || pulEncryptedDataLen == NULL) {
+		rc = CKR_ARGUMENTS_BAD;
+		goto gen_err;
+	}
 
 	key = (struct hse_keyObject *)list_seek(&gCtx->objects, &gCtx->cryptCtx.keyHandle);
 
-	_input = hse_get_shared_mem_addr(HSE_INPUT_SRAM);
-	_output = hse_get_shared_mem_addr(HSE_OUTPUT_SRAM);
-	_output_len = hse_get_shared_mem_addr(HSE_OUTPUTLEN_SRAM);
-	hse_memcpy(_output_len, pulEncryptedDataLen, sizeof(uint32_t));
-	hse_memcpy(_input, pData, ulDataLen);
+	input = hse_mem_alloc(ulDataLen);
+	if (input == NULL) {
+		rc = CKR_HOST_MEMORY;
+		goto gen_err;
+	}
+	memcpy(input, pData, ulDataLen);
+
+	output_len = hse_mem_alloc(sizeof(uint32_t));
+	if (output_len == NULL) {
+		rc = CKR_HOST_MEMORY;
+		goto output_len_err;
+	}
+	memcpy(output_len, pulEncryptedDataLen, sizeof(uint32_t));
+	output = hse_mem_alloc(*(uint32_t *)output_len);
+	if (output == NULL) {
+		rc = CKR_HOST_MEMORY;
+		goto output_err;
+	}
 
 	if (gCtx->cryptCtx.mechanism->pParameter != NULL) {
-		_pIV = hse_get_shared_mem_addr(HSE_IV_SRAM);
-		hse_memcpy(_pIV, gCtx->cryptCtx.mechanism->pParameter,
-		                 gCtx->cryptCtx.mechanism->ulParameterLen);
+		pIV = hse_mem_alloc(gCtx->cryptCtx.mechanism->ulParameterLen);
+		if (pIV == NULL) {
+			rc = CKR_HOST_MEMORY;
+			goto piv_err;
+		}
+		memcpy(pIV, gCtx->cryptCtx.mechanism->pParameter, gCtx->cryptCtx.mechanism->ulParameterLen);
 	}
 
 	switch (gCtx->cryptCtx.mechanism->mechanism) {
@@ -112,14 +126,14 @@ CK_DEFINE_FUNCTION(CK_RV, C_Encrypt)(
 			sym_cipher_srv->keyHandle = key->key_handle;
 
 			if (gCtx->cryptCtx.mechanism->pParameter != NULL) {
-				sym_cipher_srv->pIV = hse_virt_to_phys(_pIV);
+				sym_cipher_srv->pIV = hse_virt_to_dma(pIV);
 			} else {
 				sym_cipher_srv->pIV = 0u; /* IV is not required for ecb */
 			}
 
 			sym_cipher_srv->inputLength = ulDataLen;
-			sym_cipher_srv->pInput = hse_virt_to_phys(_input);
-			sym_cipher_srv->pOutput= hse_virt_to_phys(_output);
+			sym_cipher_srv->pInput = hse_virt_to_dma(input);
+			sym_cipher_srv->pOutput= hse_virt_to_dma(output);
 
 			break;
 		case CKM_AES_GCM:
@@ -133,31 +147,40 @@ CK_DEFINE_FUNCTION(CK_RV, C_Encrypt)(
 			aead_srv->cipherDir = HSE_CIPHER_DIR_ENCRYPT;
 			aead_srv->keyHandle = key->key_handle;
 			aead_srv->ivLength = gCtx->cryptCtx.mechanism->ulParameterLen;
-			aead_srv->pIV = hse_virt_to_phys(_pIV);
+			aead_srv->pIV = hse_virt_to_dma(pIV);
 			aead_srv->aadLength = 0u;
 			aead_srv->pAAD = 0u;
 			aead_srv->sgtOption = HSE_SGT_OPTION_NONE;
 			aead_srv->inputLength = ulDataLen;
-			aead_srv->pInput = hse_virt_to_phys(_input);
+			aead_srv->pInput = hse_virt_to_dma(input);
 			aead_srv->tagLength = 0u;
 			aead_srv->pTag = 0u;
-			aead_srv->pOutput = hse_virt_to_phys(_output);
+			aead_srv->pOutput = hse_virt_to_dma(output);
 
 		default:
-			return CKR_ARGUMENTS_BAD;
+			rc = CKR_ARGUMENTS_BAD;
+			goto req_err;
 	}
 
-	_srv_desc = hse_get_shared_mem_addr(HSE_SRVDESC_SRAM);
-	hse_memcpy(_srv_desc, &srv_desc, sizeof(hseSrvDescriptor_t));
-
-	err = hse_srv_req_sync(HSE_CHANNEL_ANY, hse_virt_to_phys(_srv_desc));
-	if (err)
-		return CKR_FUNCTION_FAILED;
-
-	hse_memcpy(pEncryptedData, _output, *(uint32_t *)_output_len);
-	hse_memcpy(pulEncryptedDataLen, _output_len, sizeof(uint32_t));
+	err = hse_srv_req_sync(HSE_CHANNEL_ANY, &srv_desc);
+	if (err) {
+		rc = CKR_FUNCTION_FAILED;
+		goto req_err;
+	}
 
-	return CKR_OK;
+	memcpy(pEncryptedData, output, *(uint32_t *)output_len);
+	memcpy(pulEncryptedDataLen, output_len, sizeof(uint32_t));
+
+req_err:
+	hse_mem_free(pIV);
+piv_err:
+	hse_mem_free(output);
+output_err:
+	hse_mem_free(output_len);
+output_len_err:
+	hse_mem_free(input);
+gen_err:
+	return rc;
 }
 
 CK_DEFINE_FUNCTION(CK_RV, C_DecryptInit)(
@@ -207,34 +230,59 @@ CK_DEFINE_FUNCTION(CK_RV, C_Decrypt)(
 	hseSrvDescriptor_t srv_desc;
 	hseSymCipherSrv_t *sym_cipher_srv;
 	hseAeadSrv_t *aead_srv;
-	void *_srv_desc, *_input, *_output, *_output_len, *_pIV;
+	void *input, *output, *output_len, *pIV = NULL;
 	struct hse_keyObject *key;
+	CK_RV rc = CKR_OK;
 	int err;
 
-	if (gCtx->cryptokiInit == CK_FALSE)
-		return CKR_CRYPTOKI_NOT_INITIALIZED;
+	if (gCtx->cryptokiInit == CK_FALSE) {
+		rc = CKR_CRYPTOKI_NOT_INITIALIZED;
+		goto gen_err;
+	}
 
-	if (gCtx->cryptCtx.init == CK_FALSE)
-		return CKR_OPERATION_NOT_INITIALIZED;
+	if (gCtx->cryptCtx.init == CK_FALSE) {
+		rc = CKR_OPERATION_NOT_INITIALIZED;
+		goto gen_err;
+	}
 
-	if (hSession != SESSION_ID)
-		return CKR_SESSION_HANDLE_INVALID;
+	if (hSession != SESSION_ID) {
+		rc = CKR_SESSION_HANDLE_INVALID;
+		goto gen_err;
+	}
 
-	if (pData == NULL || pEncryptedData == NULL || pulDataLen == NULL)
-		return CKR_ARGUMENTS_BAD;
+	if (pData == NULL || pEncryptedData == NULL || pulDataLen == NULL) {
+		rc = CKR_ARGUMENTS_BAD;
+		goto gen_err;
+	}
 
 	key = (struct hse_keyObject *)list_seek(&gCtx->objects, &gCtx->cryptCtx.keyHandle);
 
-	_input = hse_get_shared_mem_addr(HSE_INPUT_SRAM);
-	_output = hse_get_shared_mem_addr(HSE_OUTPUT_SRAM);
-	_output_len = hse_get_shared_mem_addr(HSE_OUTPUTLEN_SRAM);
-	hse_memcpy(_input, pEncryptedData, ulEncryptedDataLen);
-	hse_memcpy(_output_len, pulDataLen, sizeof(uint32_t));
+	input = hse_mem_alloc(ulEncryptedDataLen);
+	if (input == NULL) {
+		rc = CKR_HOST_MEMORY;
+		goto gen_err;
+	}
+	memcpy(input, pEncryptedData, ulEncryptedDataLen);
+
+	output_len = hse_mem_alloc(sizeof(uint32_t));
+	if (output_len == NULL) {
+		rc = CKR_HOST_MEMORY;
+		goto output_len_err;
+	}
+	memcpy(output_len, pulDataLen, sizeof(uint32_t));
+	output = hse_mem_alloc(*(uint32_t *)output_len);
+	if (output == NULL) {
+		rc = CKR_HOST_MEMORY;
+		goto output_err;
+	}
 
 	if (gCtx->cryptCtx.mechanism->pParameter != NULL) {
-		_pIV = hse_get_shared_mem_addr(HSE_IV_SRAM);
-		hse_memcpy(_pIV, gCtx->cryptCtx.mechanism->pParameter,
-		                 gCtx->cryptCtx.mechanism->ulParameterLen);
+		pIV = hse_mem_alloc(gCtx->cryptCtx.mechanism->ulParameterLen);
+		if (pIV == NULL) {
+			rc = CKR_HOST_MEMORY;
+			goto piv_err;
+		}
+		memcpy(pIV, gCtx->cryptCtx.mechanism->pParameter, gCtx->cryptCtx.mechanism->ulParameterLen);
 	}
 
 	switch (gCtx->cryptCtx.mechanism->mechanism) {
@@ -252,14 +300,14 @@ CK_DEFINE_FUNCTION(CK_RV, C_Decrypt)(
 			sym_cipher_srv->keyHandle = key->key_handle;
 
 			if (gCtx->cryptCtx.mechanism->pParameter != NULL) {
-				sym_cipher_srv->pIV = hse_virt_to_phys(_pIV);
+				sym_cipher_srv->pIV = hse_virt_to_dma(pIV);
 			} else {
 				sym_cipher_srv->pIV = 0u; /* IV is not required for ecb */
 			}
 
 			sym_cipher_srv->inputLength = ulEncryptedDataLen;
-			sym_cipher_srv->pInput = hse_virt_to_phys(_input);
-			sym_cipher_srv->pOutput= hse_virt_to_phys(_output);
+			sym_cipher_srv->pInput = hse_virt_to_dma(input);
+			sym_cipher_srv->pOutput= hse_virt_to_dma(output);
 
 			break;
 		case CKM_AES_GCM:
@@ -273,31 +321,40 @@ CK_DEFINE_FUNCTION(CK_RV, C_Decrypt)(
 			aead_srv->cipherDir = HSE_CIPHER_DIR_DECRYPT;
 			aead_srv->keyHandle = key->key_handle;
 			aead_srv->ivLength = gCtx->cryptCtx.mechanism->ulParameterLen;
-			aead_srv->pIV = hse_virt_to_phys(_pIV);
+			aead_srv->pIV = hse_virt_to_dma(pIV);
 			aead_srv->aadLength = 0u;
 			aead_srv->pAAD = 0u;
 			aead_srv->sgtOption = HSE_SGT_OPTION_NONE;
 			aead_srv->inputLength = ulEncryptedDataLen;
-			aead_srv->pInput = hse_virt_to_phys(_input);
+			aead_srv->pInput = hse_virt_to_dma(input);
 			aead_srv->tagLength = 0u;
 			aead_srv->pTag = 0u;
-			aead_srv->pOutput = hse_virt_to_phys(_output);
+			aead_srv->pOutput = hse_virt_to_dma(output);
 
 		default:
-			return CKR_ARGUMENTS_BAD;
+			rc = CKR_ARGUMENTS_BAD;
+			goto req_err;
 	}
 
-	_srv_desc = hse_get_shared_mem_addr(HSE_SRVDESC_SRAM);
-	hse_memcpy(_srv_desc, &srv_desc, sizeof(hseSrvDescriptor_t));
-
-	err = hse_srv_req_sync(HSE_CHANNEL_ANY, hse_virt_to_phys(_srv_desc));
-	if (err)
-		return CKR_FUNCTION_FAILED;
-
-	hse_memcpy(pData, _output, *(uint32_t *)_output_len);
-	hse_memcpy(pulDataLen, _output_len, sizeof(uint32_t));
+	err = hse_srv_req_sync(HSE_CHANNEL_ANY, &srv_desc);
+	if (err) {
+		rc = CKR_FUNCTION_FAILED;
+		goto req_err;
+	}
 
-	return CKR_OK;
+	memcpy(pData, output, *(uint32_t *)output_len);
+	memcpy(pulDataLen, output_len, sizeof(uint32_t));
+
+req_err:
+	hse_mem_free(pIV);
+piv_err:
+	hse_mem_free(output);
+output_err:
+	hse_mem_free(output_len);
+output_len_err:
+	hse_mem_free(input);
+gen_err:
+	return rc;
 }
 
 CK_DEFINE_FUNCTION(CK_RV, C_SignInit)(
@@ -342,28 +399,46 @@ CK_DEFINE_FUNCTION(CK_RV, C_Sign)(
 	hseSrvDescriptor_t srv_desc;
 	hseSignSrv_t *sign_srv;
 	hseSignScheme_t *sign_scheme;
-	void *_srv_desc, *_input, *_sign0, *_sign1, *_output_len;
+	void *input, *sign0 = NULL, *sign1 = NULL, *output_len;
 	struct hse_keyObject *key;
+	CK_RV rc = CKR_OK;
 	int err;
 
-	if (gCtx->cryptokiInit == CK_FALSE)
-		return CKR_CRYPTOKI_NOT_INITIALIZED;
+	if (gCtx->cryptokiInit == CK_FALSE) {
+		rc = CKR_CRYPTOKI_NOT_INITIALIZED;
+		goto gen_err;
+	}
 
-	if (gCtx->signCtx.init == CK_FALSE)
-		return CKR_OPERATION_NOT_INITIALIZED;
+	if (gCtx->signCtx.init == CK_FALSE) {
+		rc = CKR_OPERATION_NOT_INITIALIZED;
+		goto gen_err;
+	}
 
-	if (hSession != SESSION_ID)
-		return CKR_SESSION_HANDLE_INVALID;
+	if (hSession != SESSION_ID) {
+		rc = CKR_SESSION_HANDLE_INVALID;
+		goto gen_err;
+	}
 
-	if (pData == NULL || pSignature == NULL || pulSignatureLen == NULL)
-		return CKR_ARGUMENTS_BAD;
+	if (pData == NULL || pSignature == NULL || pulSignatureLen == NULL) {
+		rc = CKR_ARGUMENTS_BAD;
+		goto gen_err;
+	}
 
 	key = (struct hse_keyObject *)list_seek(&gCtx->objects, &gCtx->signCtx.keyHandle);
 
-	_input = hse_get_shared_mem_addr(HSE_INPUT_SRAM);
-	_output_len = hse_get_shared_mem_addr(HSE_OUTPUTLEN_SRAM);
-	hse_memcpy(_input, pData, ulDataLen);
-	hse_memcpy(_output_len, pulSignatureLen, sizeof(uint32_t));
+	input = hse_mem_alloc(ulDataLen);
+	if (input == NULL) {
+		rc = CKR_HOST_MEMORY;
+		goto gen_err;
+	}
+	memcpy(input, pData, ulDataLen);
+
+	output_len = hse_mem_alloc(sizeof(uint32_t));
+	if (output_len == NULL) {
+		rc = CKR_HOST_MEMORY;
+		goto output_len_err;
+	}
+	memcpy(output_len, pulSignatureLen, sizeof(uint32_t));
 
 	sign_srv = &srv_desc.hseSrv.signReq;
 	sign_scheme = &sign_srv->signScheme;
@@ -371,38 +446,51 @@ CK_DEFINE_FUNCTION(CK_RV, C_Sign)(
 	switch (gCtx->signCtx.mechanism->mechanism) {
 		case CKM_SHA256_RSA_PKCS:
 
-			_sign0 = hse_get_shared_mem_addr(HSE_SIGN0_SRAM);
+			sign0 = hse_mem_alloc(*(uint32_t *)output_len);
+			if (sign0 == NULL) {
+				rc = CKR_HOST_MEMORY;
+				goto sign0_err;
+			}
 
 			sign_scheme->signSch = HSE_SIGN_RSASSA_PKCS1_V15;
 			sign_scheme->sch.rsaPkcs1v15.hashAlgo = HSE_HASH_ALGO_SHA2_256;
 
-			sign_srv->pSignatureLength[0] = hse_virt_to_phys(_output_len);
+			sign_srv->pSignatureLength[0] = hse_virt_to_dma(output_len);
 			sign_srv->pSignatureLength[1] = 0u;
-			sign_srv->pSignature[0] = hse_virt_to_phys(_sign0); /* rsa */
+			sign_srv->pSignature[0] = hse_virt_to_dma(sign0); /* rsa */
 			sign_srv->pSignature[1] = 0u;
 
 			break;
 		case CKM_ECDSA_SHA1:
 
-			_sign0 = hse_get_shared_mem_addr(HSE_SIGN0_SRAM);
-			_sign1 = hse_get_shared_mem_addr(HSE_SIGN1_SRAM);
-
 			/* we only get one output length, which has to hold (r,s)
 			 * (r,s) are both the length of the used curve in bytes - equal
 			 * as such, assume it is doubled, and halve it */
-			*(uint32_t *)_output_len = *(uint32_t *)_output_len / 2;
+			*(uint32_t *)output_len = *(uint32_t *)output_len / 2;
+
+			sign0 = hse_mem_alloc(*(uint32_t *)output_len);
+			if (sign0 == NULL) {
+				rc = CKR_HOST_MEMORY;
+				goto sign0_err;
+			}
+			sign1 = hse_mem_alloc(*(uint32_t *)output_len);
+			if (sign1 == NULL) {
+				rc = CKR_HOST_MEMORY;
+				goto sign1_err;
+			}
 
 			sign_scheme->signSch = HSE_SIGN_ECDSA;
 			sign_scheme->sch.ecdsa.hashAlgo = HSE_HASH_ALGO_SHA_1;
 
-			sign_srv->pSignatureLength[0] = hse_virt_to_phys(_output_len);
-			sign_srv->pSignatureLength[1] = hse_virt_to_phys(_output_len);
-			sign_srv->pSignature[0] = hse_virt_to_phys(_sign0);
-			sign_srv->pSignature[1] = hse_virt_to_phys(_sign1);
+			sign_srv->pSignatureLength[0] = hse_virt_to_dma(output_len);
+			sign_srv->pSignatureLength[1] = hse_virt_to_dma(output_len);
+			sign_srv->pSignature[0] = hse_virt_to_dma(sign0);
+			sign_srv->pSignature[1] = hse_virt_to_dma(sign1);
 
 			break;
 		default:
-			return CKR_ARGUMENTS_BAD;
+			rc = CKR_ARGUMENTS_BAD;
+			goto req_err;
 	}
 
 	srv_desc.srvId = HSE_SRV_ID_SIGN;
@@ -413,37 +501,46 @@ CK_DEFINE_FUNCTION(CK_RV, C_Sign)(
 	sign_srv->keyHandle = key->key_handle;
 	sign_srv->sgtOption = HSE_SGT_OPTION_NONE;
 	sign_srv->inputLength = ulDataLen;
-	sign_srv->pInput = hse_virt_to_phys(_input);
-
-	_srv_desc = hse_get_shared_mem_addr(HSE_SRVDESC_SRAM);
-	hse_memcpy(_srv_desc, &srv_desc, sizeof(hseSrvDescriptor_t));
+	sign_srv->pInput = hse_virt_to_dma(input);
 
-	err = hse_srv_req_sync(HSE_CHANNEL_ANY, hse_virt_to_phys(_srv_desc));
-	if (err)
-		return CKR_FUNCTION_FAILED;
+	err = hse_srv_req_sync(HSE_CHANNEL_ANY, &srv_desc);
+	if (err) {
+		rc = CKR_FUNCTION_FAILED;
+		goto req_err;
+	}
 
 	switch (gCtx->signCtx.mechanism->mechanism) {
 		case CKM_SHA256_RSA_PKCS:
 
-			hse_memcpy(pSignature, _sign0, *(uint32_t *)_output_len);
-			hse_memcpy(pulSignatureLen, _output_len, sizeof(uint32_t));
+			memcpy(pSignature, sign0, *(uint32_t *)output_len);
+			memcpy(pulSignatureLen, output_len, sizeof(uint32_t));
 
 			break;
 		case CKM_ECDSA_SHA1:
 
-			hse_memcpy(pSignature, _sign0, *(uint32_t *)_output_len);
-			hse_memcpy(pSignature + *(uint32_t *)_output_len, _sign1, *(uint32_t *)_output_len);
+			memcpy(pSignature, sign0, *(uint32_t *)output_len);
+			memcpy(pSignature + *(uint32_t *)output_len, sign1, *(uint32_t *)output_len);
 
 			/* restore actual length */
-			*(uint32_t *)_output_len = *(uint32_t *)_output_len * 2;
-			hse_memcpy(pulSignatureLen, _output_len, sizeof(uint32_t));
+			*(uint32_t *)output_len = *(uint32_t *)output_len * 2;
+			memcpy(pulSignatureLen, output_len, sizeof(uint32_t));
 
 			break;
 		default:
-			return CKR_ARGUMENTS_BAD;
+			rc = CKR_ARGUMENTS_BAD;
+			goto req_err;
 	}
 
-	return CKR_OK;
+req_err:
+	hse_mem_free(sign1);
+sign1_err:
+	hse_mem_free(sign0);
+sign0_err:
+	hse_mem_free(output_len);
+output_len_err:
+	hse_mem_free(input);
+gen_err:
+	return rc;
 }
 
 CK_DEFINE_FUNCTION(CK_RV, C_VerifyInit)(
@@ -488,28 +585,46 @@ CK_DEFINE_FUNCTION(CK_RV, C_Verify)(
 	hseSrvDescriptor_t srv_desc;
 	hseSignSrv_t *sign_srv;
 	hseSignScheme_t *sign_scheme;
-	void *_srv_desc, *_input, *_sign0, *_sign1, *_output_len;
+	void *input, *sign0 = NULL, *sign1 = NULL, *output_len;
 	struct hse_keyObject *key;
+	CK_RV rc = CKR_OK;
 	int err;
 
-	if (gCtx->cryptokiInit == CK_FALSE)
-		return CKR_CRYPTOKI_NOT_INITIALIZED;
+	if (gCtx->cryptokiInit == CK_FALSE) {
+		rc = CKR_CRYPTOKI_NOT_INITIALIZED;
+		goto gen_err;
+	}
 
-	if (gCtx->signCtx.init == CK_FALSE)
-		return CKR_OPERATION_NOT_INITIALIZED;
+	if (gCtx->signCtx.init == CK_FALSE) {
+		rc = CKR_OPERATION_NOT_INITIALIZED;
+		goto gen_err;
+	}
 
-	if (hSession != SESSION_ID)
-		return CKR_SESSION_HANDLE_INVALID;
+	if (hSession != SESSION_ID) {
+		rc = CKR_SESSION_HANDLE_INVALID;
+		goto gen_err;
+	}
 
-	if (pData == NULL || pSignature == NULL)
-		return CKR_ARGUMENTS_BAD;
+	if (pData == NULL || pSignature == NULL) {
+		rc = CKR_ARGUMENTS_BAD;
+		goto gen_err;
+	}
 
 	key = (struct hse_keyObject *)list_seek(&gCtx->objects, &gCtx->signCtx.keyHandle);
 
-	_input = hse_get_shared_mem_addr(HSE_INPUT_SRAM);
-	_output_len = hse_get_shared_mem_addr(HSE_OUTPUTLEN_SRAM);
-	hse_memcpy(_input, pData, ulDataLen);
-	hse_memcpy(_output_len, &ulSignatureLen, sizeof(uint32_t));
+	input = hse_mem_alloc(ulDataLen);
+	if (input == NULL) {
+		rc = CKR_HOST_MEMORY;
+		goto gen_err;
+	}
+	memcpy(input, pData, ulDataLen);
+
+	output_len = hse_mem_alloc(sizeof(uint32_t));
+	if (output_len == NULL) {
+		rc = CKR_HOST_MEMORY;
+		goto output_len_err;
+	}
+	memcpy(output_len, &ulSignatureLen, sizeof(uint32_t));
 
 	sign_srv = &srv_desc.hseSrv.signReq;
 	sign_scheme = &sign_srv->signScheme;
@@ -517,15 +632,19 @@ CK_DEFINE_FUNCTION(CK_RV, C_Verify)(
 	switch (gCtx->signCtx.mechanism->mechanism) {
 		case CKM_SHA256_RSA_PKCS:
 
-			_sign0 = hse_get_shared_mem_addr(HSE_SIGN0_SRAM);
-			hse_memcpy(_sign0, pSignature, ulSignatureLen);
+			sign0 = hse_mem_alloc(ulSignatureLen);
+			if (sign0 == NULL) {
+				rc = CKR_HOST_MEMORY;
+				goto sign0_err;
+			}
+			memcpy(sign0, pSignature, ulSignatureLen);
 
 			sign_scheme->signSch = HSE_SIGN_RSASSA_PKCS1_V15;
 			sign_scheme->sch.rsaPkcs1v15.hashAlgo = HSE_HASH_ALGO_SHA2_256;
 
-			sign_srv->pSignatureLength[0] = hse_virt_to_phys(_output_len);
+			sign_srv->pSignatureLength[0] = hse_virt_to_dma(output_len);
 			sign_srv->pSignatureLength[1] = 0u;
-			sign_srv->pSignature[0] = hse_virt_to_phys(_sign0); /* rsa */
+			sign_srv->pSignature[0] = hse_virt_to_dma(sign0); /* rsa */
 			sign_srv->pSignature[1] = 0u;
 
 			break;
@@ -534,23 +653,32 @@ CK_DEFINE_FUNCTION(CK_RV, C_Verify)(
 			/* we only get one signature input and length
 			 * (r,s) are the same length
 			 * assume the signature contains both, one after the other */
-			*(uint32_t *)_output_len = *(uint32_t *)_output_len / 2;
+			*(uint32_t *)output_len = *(uint32_t *)output_len / 2;
 
-			_sign0 = hse_get_shared_mem_addr(HSE_SIGN0_SRAM);
-			_sign1 = hse_get_shared_mem_addr(HSE_SIGN1_SRAM);
-			hse_memcpy(_sign0, pSignature, *(uint32_t *)_output_len);
-			hse_memcpy(_sign1, pSignature + *(uint32_t *)_output_len, *(uint32_t *)_output_len);
+			sign0 = hse_mem_alloc(*(uint32_t *)output_len);
+			if (sign0 == NULL) {
+				rc = CKR_HOST_MEMORY;
+				goto sign0_err;
+			}
+			sign1 = hse_mem_alloc(*(uint32_t *)output_len);
+			if (sign1 == NULL) {
+				rc = CKR_HOST_MEMORY;
+				goto sign1_err;
+			}
+			memcpy(sign0, pSignature, *(uint32_t *)output_len);
+			memcpy(sign1, pSignature + *(uint32_t *)output_len, *(uint32_t *)output_len);
 
 			sign_scheme->signSch = HSE_SIGN_ECDSA;
 			sign_scheme->sch.ecdsa.hashAlgo = HSE_HASH_ALGO_SHA_1;
 
-			sign_srv->pSignatureLength[0] = hse_virt_to_phys(_output_len);
-			sign_srv->pSignatureLength[1] = hse_virt_to_phys(_output_len);
-			sign_srv->pSignature[0] = hse_virt_to_phys(_sign0);
-			sign_srv->pSignature[1] = hse_virt_to_phys(_sign1);
+			sign_srv->pSignatureLength[0] = hse_virt_to_dma(output_len);
+			sign_srv->pSignatureLength[1] = hse_virt_to_dma(output_len);
+			sign_srv->pSignature[0] = hse_virt_to_dma(sign0);
+			sign_srv->pSignature[1] = hse_virt_to_dma(sign1);
 
 		default:
-			return CKR_ARGUMENTS_BAD;
+			rc = CKR_ARGUMENTS_BAD;
+			goto req_err;
 	}
 
 	srv_desc.srvId = HSE_SRV_ID_SIGN;
@@ -561,19 +689,27 @@ CK_DEFINE_FUNCTION(CK_RV, C_Verify)(
 	sign_srv->keyHandle = key->key_handle;
 	sign_srv->sgtOption = HSE_SGT_OPTION_NONE;
 	sign_srv->inputLength = ulDataLen;
-	sign_srv->pInput = hse_virt_to_phys(_input);
+	sign_srv->pInput = hse_virt_to_dma(input);
 
-	_srv_desc = hse_get_shared_mem_addr(HSE_SRVDESC_SRAM);
-	hse_memcpy(_srv_desc, &srv_desc, sizeof(hseSrvDescriptor_t));
-
-	err = hse_srv_req_sync(HSE_CHANNEL_ANY, hse_virt_to_phys(_srv_desc));
+	err = hse_srv_req_sync(HSE_CHANNEL_ANY, &srv_desc);
 	if (err == EBADMSG) {
-		return CKR_SIGNATURE_INVALID;
+		rc = CKR_SIGNATURE_INVALID;
+		goto req_err;
 	} else {
-		return CKR_FUNCTION_FAILED;
+		rc = CKR_FUNCTION_FAILED;
+		goto req_err;
 	}
 
-	return CKR_OK;
+req_err:
+	hse_mem_free(sign1);
+sign1_err:
+	hse_mem_free(sign0);
+sign0_err:
+	hse_mem_free(output_len);
+output_len_err:
+	hse_mem_free(input);
+gen_err:
+	return rc;
 }
 
 CK_DEFINE_FUNCTION(CK_RV, C_EncryptUpdate)(
diff --git a/libpkcs/pkcs11_object.c b/libpkcs/pkcs11_object.c
index d25dcbd..6bdd1d6 100644
--- a/libpkcs/pkcs11_object.c
+++ b/libpkcs/pkcs11_object.c
@@ -90,35 +90,6 @@ static CK_ULONG getattr_len(CK_ATTRIBUTE_PTR template,
 	return -1;
 }
 
-static inline void hse_memcpy(void *dst, void *src, size_t n)
-{
-	uint8_t *s = (uint8_t *)src;
-	uint8_t *d = (uint8_t *)dst;
-
-	if (!dst || !src || n == 0)
-		return;
-
-	for (int i = 0; i < n; i++)
-		d[i] = s[i];
-}
-
-static int attrcpy(void *dest, CK_ATTRIBUTE_PTR template,
-		CK_ATTRIBUTE_TYPE attr,
-		CK_ULONG attrCount)
-{
-	void *temp;
-	CK_ULONG temp_size;
-
-	temp_size = getattr_len(template, attr, attrCount);
-	temp = getattr_pval(template, attr, attrCount);
-	if (temp == NULL)
-		return 1;
-
-	hse_memcpy(dest, temp, temp_size);
-
-	return 0;
-}
-
 CK_DEFINE_FUNCTION(CK_RV, C_CreateObject)(
 		CK_SESSION_HANDLE hSession,
 		CK_ATTRIBUTE_PTR pTemplate,
@@ -128,9 +99,10 @@ CK_DEFINE_FUNCTION(CK_RV, C_CreateObject)(
 {
 	struct globalCtx *gCtx = getCtx();
 	hseSrvDescriptor_t srv_desc;
-	hseKeyInfo_t key_info;
 	hseImportKeySrv_t *import_key_req;
-	void *_srv_desc, *_key_info, *_pkey0, *_pkey1, *_pkey2, *_ecc_oid;
+	hseKeyInfo_t *key_info;
+	uint32_t pkey0_len, pkey1_len, pkey2_len;
+	void *pkey0 = NULL, *pkey1 = NULL, *pkey2 = NULL, *ecc_oid;
 	struct hse_keyObject *key, *keytemp;
 	CK_UTF8CHAR *labeltemp;
 	CK_BYTE *idtemp;
@@ -152,13 +124,16 @@ CK_DEFINE_FUNCTION(CK_RV, C_CreateObject)(
 		goto gen_err;
 	}
 
-	_srv_desc = hse_get_shared_mem_addr(HSE_SRVDESC_SRAM);
-	_key_info = hse_get_shared_mem_addr(HSE_KEYINFO_SRAM);
+	key_info = (hseKeyInfo_t *)hse_mem_alloc(sizeof(hseKeyInfo_t));
+	if (key_info == NULL) {
+		rc = CKR_HOST_MEMORY;
+		goto gen_err;
+	}
 
 	key = malloc(sizeof(*key));
 	if (key == NULL) {
 		rc = CKR_HOST_MEMORY;
-		goto gen_err;
+		goto key_err;
 	}
 
 	/* get key data and create key object struct */
@@ -173,7 +148,7 @@ CK_DEFINE_FUNCTION(CK_RV, C_CreateObject)(
 		rc = CKR_ARGUMENTS_BAD;
 		goto id_err;
 	}
-	hse_memcpy(key->id, idtemp, key->id_len);
+	memcpy(key->id, idtemp, key->id_len);
 
 	key->key_handle = GET_KEY_HANDLE(key->id[2], key->id[1], key->id[0]);
 
@@ -202,9 +177,7 @@ CK_DEFINE_FUNCTION(CK_RV, C_CreateObject)(
 		rc = CKR_ARGUMENTS_BAD;
 		goto label_err;
 	}
-	hse_memcpy(key->label, labeltemp, key->label_len);
-
-	import_key_req = &srv_desc.hseSrv.importKeyReq;
+	memcpy(key->label, labeltemp, key->label_len);
 
 	/* check if key is already in nvm catalog */
 	if (key->id[2] == 1) {
@@ -218,11 +191,13 @@ CK_DEFINE_FUNCTION(CK_RV, C_CreateObject)(
 		key->nvm_ctr = 0ul;
 	}
 
-	key_info.keyCounter = key->nvm_ctr;
-	key_info.smrFlags = 0ul;
+	key_info->keyCounter = key->nvm_ctr;
+	key_info->smrFlags = 0ul;
+
+	import_key_req = &srv_desc.hseSrv.importKeyReq;
 
 	srv_desc.srvId = HSE_SRV_ID_IMPORT_KEY;
-	import_key_req->pKeyInfo = hse_virt_to_phys(_key_info);
+	import_key_req->pKeyInfo = hse_virt_to_dma(key_info);
 	import_key_req->targetKeyHandle = key->key_handle;
 	import_key_req->cipher.cipherKeyHandle = HSE_INVALID_KEY_HANDLE;
 	import_key_req->keyContainer.authKeyHandle = HSE_INVALID_KEY_HANDLE;
@@ -230,26 +205,30 @@ CK_DEFINE_FUNCTION(CK_RV, C_CreateObject)(
 	switch (key->key_type) {
 		case CKK_RSA:
 
-			_pkey0 = hse_get_shared_mem_addr(HSE_PKEY0_SRAM);
-			if (attrcpy(_pkey0, pTemplate, CKA_MODULUS, ulCount)) {
-				rc = CKR_ARGUMENTS_BAD;
-				goto label_err;
+			pkey0_len = getattr_len(pTemplate, CKA_MODULUS, ulCount);
+			pkey0 = hse_mem_alloc(pkey0_len);
+			if (pkey0 == NULL) {
+				rc = CKR_HOST_MEMORY;
+				goto pkey0_err;
 			}
+			memcpy(pkey0, getattr_pval(pTemplate, CKA_MODULUS, ulCount), pkey0_len);
 
-			_pkey1 = hse_get_shared_mem_addr(HSE_PKEY1_SRAM);
-			if (attrcpy(_pkey1, pTemplate, CKA_PUBLIC_EXPONENT, ulCount)) {
-				rc = CKR_ARGUMENTS_BAD;
-				goto label_err;
+			pkey1_len = getattr_len(pTemplate, CKA_PUBLIC_EXPONENT, ulCount);
+			pkey1 = hse_mem_alloc(pkey1_len);
+			if (pkey1 == NULL) {
+				rc = CKR_HOST_MEMORY;
+				goto pkey1_err;
 			}
+			memcpy(pkey1, getattr_pval(pTemplate, CKA_PUBLIC_EXPONENT, ulCount), pkey1_len);
 
 			/* rsa can be used for sign/verify */
-			key_info.keyFlags = HSE_KF_USAGE_VERIFY;
-			key_info.keyBitLen = getattr_len(pTemplate, CKA_MODULUS, ulCount) * 8;
-			key_info.specific.pubExponentSize = getattr_len(pTemplate, CKA_PUBLIC_EXPONENT, ulCount);
-			key_info.keyType = HSE_KEY_TYPE_RSA_PUB;
+			key_info->keyFlags = HSE_KF_USAGE_VERIFY;
+			key_info->keyBitLen = getattr_len(pTemplate, CKA_MODULUS, ulCount) * 8;
+			key_info->specific.pubExponentSize = getattr_len(pTemplate, CKA_PUBLIC_EXPONENT, ulCount);
+			key_info->keyType = HSE_KEY_TYPE_RSA_PUB;
 
-			import_key_req->pKey[0] = hse_virt_to_phys(_pkey0); /* public modulus */
-			import_key_req->pKey[1] = hse_virt_to_phys(_pkey1); /* public exponent */
+			import_key_req->pKey[0] = hse_virt_to_dma(pkey0); /* public modulus */
+			import_key_req->pKey[1] = hse_virt_to_dma(pkey1); /* public exponent */
 			import_key_req->pKey[2] = 0u;
 			import_key_req->keyLen[0] = getattr_len(pTemplate, CKA_MODULUS, ulCount);
 			import_key_req->keyLen[1] = getattr_len(pTemplate, CKA_PUBLIC_EXPONENT, ulCount);
@@ -257,44 +236,49 @@ CK_DEFINE_FUNCTION(CK_RV, C_CreateObject)(
 
 			if (key->key_class == CKO_PRIVATE_KEY) {
 
-				_pkey2 = hse_get_shared_mem_addr(HSE_PKEY2_SRAM);
-				if (attrcpy(_pkey2, pTemplate, CKA_PRIVATE_EXPONENT, ulCount)) {
-					rc = CKR_ARGUMENTS_BAD;
-					goto label_err;
+				pkey2_len = getattr_len(pTemplate, CKA_PRIVATE_EXPONENT, ulCount);
+				pkey2 = hse_mem_alloc(pkey2_len);
+				if (pkey2 == NULL) {
+					rc = CKR_HOST_MEMORY;
+					goto pkey2_err;
 				}
+				memcpy(pkey2, getattr_pval(pTemplate, CKA_PRIVATE_EXPONENT, ulCount), pkey2_len);
 
-				key_info.keyFlags |= HSE_KF_USAGE_SIGN;
-				key_info.keyType = HSE_KEY_TYPE_RSA_PAIR;
+				key_info->keyFlags |= HSE_KF_USAGE_SIGN;
+				key_info->keyType = HSE_KEY_TYPE_RSA_PAIR;
 
-				import_key_req->pKey[2] = hse_virt_to_phys(_pkey2); /* private exponent */
+				import_key_req->pKey[2] = hse_virt_to_dma(pkey2); /* private exponent */
 				import_key_req->keyLen[2] = getattr_len(pTemplate, CKA_PRIVATE_EXPONENT, ulCount);
 			}
 
 			break;
 		case CKK_EC:
 
-			_pkey0 = hse_get_shared_mem_addr(HSE_PKEY0_SRAM);
-			if (attrcpy(_pkey0, pTemplate, CKA_EC_POINT, ulCount)) {
-				rc = CKR_ARGUMENTS_BAD;
-				goto label_err;
+			pkey0_len = getattr_len(pTemplate, CKA_EC_POINT, ulCount);
+			pkey0 = hse_mem_alloc(pkey0_len);
+			if (pkey0 == NULL) {
+				rc = CKR_HOST_MEMORY;
+				goto pkey0_err;
 			}
+			memcpy(pkey0, getattr_pval(pTemplate, CKA_EC_POINT, ulCount), pkey0_len);
+			
 			/* bypass DER encoding header, we don't support it */
-			_pkey0 = (uint8_t *)_pkey0 + 3;
+			pkey0 = (uint8_t *)pkey0 + 3;
 
-			_ecc_oid = getattr_pval(pTemplate, CKA_EC_PARAMS, ulCount);
-			if (_ecc_oid == NULL) {
+			ecc_oid = getattr_pval(pTemplate, CKA_EC_PARAMS, ulCount);
+			if (ecc_oid == NULL) {
 				rc = CKR_ARGUMENTS_BAD;
-				goto label_err;
+				goto pkey0_err;
 			}
 
 			/* ecc keys can only be used for sign/verify */
-			key_info.keyFlags = HSE_KF_USAGE_VERIFY;
-			key_info.specific.eccCurveId = gethsecurveid((char *)_ecc_oid);
-			key_info.keyBitLen = getkeybitlen(key_info.specific.eccCurveId);
+			key_info->keyFlags = HSE_KF_USAGE_VERIFY;
+			key_info->specific.eccCurveId = gethsecurveid((char *)ecc_oid);
+			key_info->keyBitLen = getkeybitlen(key_info->specific.eccCurveId);
 
-			key_info.keyType = HSE_KEY_TYPE_ECC_PUB;
+			key_info->keyType = HSE_KEY_TYPE_ECC_PUB;
 
-			import_key_req->pKey[0] = hse_virt_to_phys(_pkey0); /* public x & y coords of ec */
+			import_key_req->pKey[0] = hse_virt_to_dma(pkey0); /* public x & y coords of ec */
 			import_key_req->pKey[1] = 0u;
 			import_key_req->pKey[2] = 0u;
 			import_key_req->keyLen[0] = getattr_len(pTemplate, CKA_EC_POINT, ulCount) - 3; /* bypass DER encoding header */
@@ -303,36 +287,40 @@ CK_DEFINE_FUNCTION(CK_RV, C_CreateObject)(
 
 			if (key->key_class == CKO_PRIVATE_KEY) {
 
-				_pkey2 = hse_get_shared_mem_addr(HSE_PKEY2_SRAM);
-				if (attrcpy(_pkey2, pTemplate, CKA_VALUE, ulCount)) {
-					rc = CKR_ARGUMENTS_BAD;
-					goto label_err;
+				pkey2_len = getattr_len(pTemplate, CKA_VALUE, ulCount);
+				pkey2 = hse_mem_alloc(pkey2_len);
+				if (pkey2 == NULL) {
+					rc = CKR_HOST_MEMORY;
+					goto pkey2_err;
 				}
+				memcpy(pkey2, getattr_pval(pTemplate, CKA_VALUE, ulCount), pkey2_len);
 
-				key_info.keyFlags |= HSE_KF_USAGE_SIGN;
-				key_info.keyType = HSE_KEY_TYPE_ECC_PAIR;
+				key_info->keyFlags |= HSE_KF_USAGE_SIGN;
+				key_info->keyType = HSE_KEY_TYPE_ECC_PAIR;
 
-				import_key_req->pKey[2] = hse_virt_to_phys(_pkey2); /* ec private scalar/order */
+				import_key_req->pKey[2] = hse_virt_to_dma(pkey2); /* ec private scalar/order */
 				import_key_req->keyLen[2] = getattr_len(pTemplate, CKA_VALUE, ulCount);
 			}
 
 			break;
 		case CKK_AES:
 
-			_pkey2 = hse_get_shared_mem_addr(HSE_PKEY2_SRAM);
-			if (attrcpy(_pkey2, pTemplate, CKA_VALUE, ulCount)) {
-				rc = CKR_ARGUMENTS_BAD;
-				goto label_err;
+			pkey2_len = getattr_len(pTemplate, CKA_VALUE, ulCount);
+			pkey2 = hse_mem_alloc(pkey2_len);
+			if (pkey2 == NULL) {
+				rc = CKR_HOST_MEMORY;
+				goto pkey2_err;
 			}
+			memcpy(pkey2, getattr_pval(pTemplate, CKA_VALUE, ulCount), pkey2_len);
 
 			/* aes keys can only be used for encrypt/decrypt */
-			key_info.keyFlags =	(HSE_KF_USAGE_ENCRYPT | HSE_KF_USAGE_DECRYPT);
-			key_info.keyBitLen = getattr_len(pTemplate, CKA_VALUE, ulCount) * 8;
-			key_info.keyType = HSE_KEY_TYPE_AES;
+			key_info->keyFlags = (HSE_KF_USAGE_ENCRYPT | HSE_KF_USAGE_DECRYPT);
+			key_info->keyBitLen = getattr_len(pTemplate, CKA_VALUE, ulCount) * 8;
+			key_info->keyType = HSE_KEY_TYPE_AES;
 
 			import_key_req->pKey[0] = 0u;
 			import_key_req->pKey[1] = 0u;
-			import_key_req->pKey[2] = hse_virt_to_phys(_pkey2); /* sym key */
+			import_key_req->pKey[2] = hse_virt_to_dma(pkey2); /* sym key */
 			import_key_req->keyLen[0] = 0u;
 			import_key_req->keyLen[1] = 0u;
 			import_key_req->keyLen[2] = getattr_len(pTemplate, CKA_VALUE, ulCount);
@@ -340,29 +328,39 @@ CK_DEFINE_FUNCTION(CK_RV, C_CreateObject)(
 			break;
 		default:
 			rc = CKR_ARGUMENTS_BAD;
-			goto label_err;
+			goto req_err;
 	}
 
-	hse_memcpy(_srv_desc, &srv_desc, sizeof(hseSrvDescriptor_t));
-	hse_memcpy(_key_info, &key_info, sizeof(hseKeyInfo_t));
-
-	err = hse_srv_req_sync(HSE_CHANNEL_ANY, hse_virt_to_phys(_srv_desc));
+	err = hse_srv_req_sync(HSE_CHANNEL_ANY, &srv_desc);
 	if (err) {
 		rc = CKR_FUNCTION_FAILED;
-		goto class_err;
+		goto req_err;
 	}
 
 	*phObject = key->key_handle;
 
 	list_append(&gCtx->objects, key);
 
+	hse_mem_free(pkey2);
+	hse_mem_free(pkey1);
+	hse_mem_free(pkey0);
+	hse_mem_free(key_info);
+
 	return CKR_OK;
-class_err:
+req_err:
+	hse_mem_free(pkey2);
+pkey2_err:
+	hse_mem_free(pkey1);
+pkey1_err:
+	hse_mem_free(pkey0);
+pkey0_err:
 	free(key->label);
 label_err:
 	free(key->id);
 id_err:
 	free(key);
+key_err:
+	hse_mem_free(key_info);
 gen_err:
 	return rc;
 }
@@ -374,7 +372,6 @@ CK_DEFINE_FUNCTION(CK_RV, C_DestroyObject)(
 {
 	struct globalCtx *gCtx = getCtx();
 	hseSrvDescriptor_t srv_desc;
-	void *_srv_desc;
 	struct hse_keyObject *pkey;
 	int err;
 
@@ -388,15 +385,11 @@ CK_DEFINE_FUNCTION(CK_RV, C_DestroyObject)(
 	if (pkey == NULL)
 		return CKR_OBJECT_HANDLE_INVALID;
 
-	_srv_desc = hse_get_shared_mem_addr(HSE_SRVDESC_SRAM);
-
 	srv_desc.srvId = HSE_SRV_ID_ERASE_KEY;
 	srv_desc.hseSrv.eraseKeyReq.keyHandle = pkey->key_handle;
 	srv_desc.hseSrv.eraseKeyReq.eraseKeyOptions = 0u;
 
-	hse_memcpy(_srv_desc, &srv_desc, sizeof(hseSrvDescriptor_t));
-
-	err = hse_srv_req_sync(HSE_CHANNEL_ANY, hse_virt_to_phys(_srv_desc));
+	err = hse_srv_req_sync(HSE_CHANNEL_ANY, &srv_desc);
 	if (err)
 		return CKR_FUNCTION_FAILED;
 
-- 
2.17.1

