From 52f0ee9ac36c56a2d468b340d03a92b598280235 Mon Sep 17 00:00:00 2001
From: Vlad Pelin <vlad.pelin@nxp.com>
Date: Mon, 11 Oct 2021 17:19:56 +0300
Subject: [PATCH 4/5] pkcs: switch gCtx access from extern to getter

global context is now accessed through a getter, where needed
fixed inconsistent whitespace
fixed lib name in pkcs-keyop

Issue: ALB-7684
Upstream-Status: Pending 

Signed-off-by: Vlad Pelin <vlad.pelin@nxp.com>
Signed-off-by: Zhantao Tang <zhantao.tang@windriver.com>
---
 examples/pkcs-keyop.c    |   2 +-
 libpkcs/pkcs11.c         | 324 +++++++++++++++++++++------------------
 libpkcs/pkcs11_context.h |   2 +-
 libpkcs/pkcs11_crypt.c   | 114 ++++++++------
 libpkcs/pkcs11_object.c  |  95 ++++++------
 5 files changed, 289 insertions(+), 248 deletions(-)

diff --git a/examples/pkcs-keyop.c b/examples/pkcs-keyop.c
index 49eaf48..6fa2950 100644
--- a/examples/pkcs-keyop.c
+++ b/examples/pkcs-keyop.c
@@ -25,7 +25,7 @@ int main(int argc, char *argv[])
 	unsigned int keycount;
 
 	if (argc != 2) {
-		printf("usage: ./pkcs-keyop <path>/pkcs11-hse.so\n");
+		printf("usage: ./pkcs-keyop <path>/libpkcs-hse.so\n");
 		return -EINVAL;
 	}
 
diff --git a/libpkcs/pkcs11.c b/libpkcs/pkcs11.c
index d42a2f9..6f163da 100644
--- a/libpkcs/pkcs11.c
+++ b/libpkcs/pkcs11.c
@@ -11,8 +11,8 @@
 #include "pkcs11_context.h"
 #include "simclist.h"
 
-struct globalCtx gCtx = {
-    .cryptokiInit = CK_FALSE,
+struct globalCtx context = {
+	.cryptokiInit = CK_FALSE,
 };
 
 static const CK_MECHANISM_TYPE mechanismList[] = {
@@ -23,29 +23,29 @@ static const CK_MECHANISM_TYPE mechanismList[] = {
 };
 
 static CK_FUNCTION_LIST gFunctionList = {
-    .version =                              {CRYPTOKI_VERSION_MAJOR,
+	.version =                              {CRYPTOKI_VERSION_MAJOR,
                                              CRYPTOKI_VERSION_MINOR},
-    .C_Initialize =                         C_Initialize,
-    .C_Finalize  =                          C_Finalize,
-    .C_GetInfo  =                           C_GetInfo,
-    .C_GetFunctionList  =                   C_GetFunctionList,
-    .C_GetSlotList  =                       C_GetSlotList,
-    .C_GetSlotInfo  =                       C_GetSlotInfo,
-    .C_GetTokenInfo  =                      C_GetTokenInfo,
-    .C_GetMechanismList  =                  C_GetMechanismList,
-    .C_GetMechanismInfo  =                  C_GetMechanismInfo,
+	.C_Initialize =                         C_Initialize,
+	.C_Finalize  =                          C_Finalize,
+	.C_GetInfo  =                           C_GetInfo,
+	.C_GetFunctionList  =                   C_GetFunctionList,
+	.C_GetSlotList  =                       C_GetSlotList,
+	.C_GetSlotInfo  =                       C_GetSlotInfo,
+	.C_GetTokenInfo  =                      C_GetTokenInfo,
+	.C_GetMechanismList  =                  C_GetMechanismList,
+	.C_GetMechanismInfo  =                  C_GetMechanismInfo,
 	.C_GetAttributeValue  =                 C_GetAttributeValue,
-    .C_InitToken  =                         C_InitToken,
-    .C_InitPIN  =                           C_InitPIN,
-    .C_SetPIN  =                            C_SetPIN,
-    .C_OpenSession  =                       C_OpenSession,
-    .C_CloseSession  =                      C_CloseSession,
-    .C_CloseAllSessions  =                  C_CloseAllSessions,
-    .C_GetSessionInfo  =                    C_GetSessionInfo,
-    .C_Login  =                             C_Login,
-    .C_Logout  =                            C_Logout,
-	.C_CreateObject =						C_CreateObject,
-	.C_DestroyObject =						C_DestroyObject,
+	.C_InitToken  =                         C_InitToken,
+	.C_InitPIN  =                           C_InitPIN,
+	.C_SetPIN  =                            C_SetPIN,
+	.C_OpenSession  =                       C_OpenSession,
+	.C_CloseSession  =                      C_CloseSession,
+	.C_CloseAllSessions  =                  C_CloseAllSessions,
+	.C_GetSessionInfo  =                    C_GetSessionInfo,
+	.C_Login  =                             C_Login,
+	.C_Logout  =                            C_Logout,
+	.C_CreateObject =                       C_CreateObject,
+	.C_DestroyObject =                      C_DestroyObject,
 	.C_FindObjectsInit =                    C_FindObjectsInit,
 	.C_FindObjects =                        C_FindObjects,
 	.C_FindObjectsFinal =                   C_FindObjectsFinal,
@@ -63,15 +63,15 @@ static CK_FUNCTION_LIST gFunctionList = {
  * MUST NOT be null-terminated.
  */
 static void strcpyPKCS11padding(
-    unsigned char *dest,
-    const char *source,
-    size_t destSize
+	unsigned char *dest,
+	const char *source,
+	size_t destSize
 )
 {
-    size_t sLen = strlen(source);
-    strncpy((char *)dest, source, destSize);
+	size_t sLen = strlen(source);
+	strncpy((char *)dest, source, destSize);
 
-    if (sLen < destSize)
+	if (sLen < destSize)
 		memset(dest + sLen, ' ', destSize - sLen);
 }
 
@@ -121,14 +121,20 @@ static int object_list_comparator(const void *a, const void *b)
 	return 0;
 }
 
+struct globalCtx *getCtx(void)
+{
+	return &context;
+}
+
 CK_DEFINE_FUNCTION(CK_RV, C_Initialize) (
 	CK_VOID_PTR pInitArgs
 )
 {
-    CK_TOKEN_INFO_PTR pToken = &gCtx.token;
-    CK_SLOT_INFO_PTR pSlot = &gCtx.slot;
+	struct globalCtx *gCtx = getCtx();
+	CK_TOKEN_INFO_PTR pToken = &gCtx->token;
+	CK_SLOT_INFO_PTR pSlot = &gCtx->slot;
 
-	if (gCtx.cryptokiInit)
+	if (gCtx->cryptokiInit)
 		return CKR_CRYPTOKI_ALREADY_INITIALIZED;
 
 	strcpyPKCS11padding(pSlot->slotDescription, SLOT_DESC,
@@ -139,10 +145,10 @@ CK_DEFINE_FUNCTION(CK_RV, C_Initialize) (
 
 	/* rev2 */
 	pSlot->hardwareVersion.major = 2;
-    pSlot->hardwareVersion.minor = 0;
+	pSlot->hardwareVersion.minor = 0;
 	/* hse fw 0.9.0 */
-    pSlot->firmwareVersion.major = 0;
-    pSlot->firmwareVersion.minor = 9;
+	pSlot->firmwareVersion.major = 0;
+	pSlot->firmwareVersion.minor = 9;
 
 	strcpyPKCS11padding(pToken->label, TOKEN_DESC,
 	                    sizeof(pToken->label));
@@ -172,197 +178,208 @@ CK_DEFINE_FUNCTION(CK_RV, C_Initialize) (
 	pToken->firmwareVersion.major = 0;
 	pToken->firmwareVersion.minor = 9;
 
-	if (list_init(&gCtx.objects) != 0)
+	if (list_init(&gCtx->objects) != 0)
 		return CKR_HOST_MEMORY;
-	list_attributes_seeker(&gCtx.objects, object_list_seeker);
-	list_attributes_comparator(&gCtx.objects, object_list_comparator);
+	list_attributes_seeker(&gCtx->objects, object_list_seeker);
+	list_attributes_comparator(&gCtx->objects, object_list_comparator);
 
 	if (hse_usr_initialize())
 		return CKR_HOST_MEMORY;
 
-    gCtx.cryptokiInit = CK_TRUE;
+	gCtx->cryptokiInit = CK_TRUE;
 
-    return CKR_OK;
+	return CKR_OK;
 }
 
 CK_DEFINE_FUNCTION(CK_RV, C_Finalize)(
 	CK_VOID_PTR pReserved
 )
 {
+	struct globalCtx *gCtx = getCtx();
 	int i;
 
-    if (!gCtx.cryptokiInit)
+	if (!gCtx->cryptokiInit)
 		return CKR_CRYPTOKI_NOT_INITIALIZED;
 
 	hse_usr_finalize();
 
-	for (i = 0; i < list_size(&gCtx.objects); i++) {
-		list_delete_at(&gCtx.objects, i);
+	for (i = 0; i < list_size(&gCtx->objects); i++) {
+		list_delete_at(&gCtx->objects, i);
 	}
-	list_destroy(&gCtx.objects);
+	list_destroy(&gCtx->objects);
 
-    gCtx.cryptokiInit = CK_FALSE;
+	gCtx->cryptokiInit = CK_FALSE;
 
-    return CKR_OK;
+	return CKR_OK;
 }
 
 CK_DEFINE_FUNCTION(CK_RV, C_GetInfo)(
-    CK_INFO_PTR pInfo
+	CK_INFO_PTR pInfo
 )
 {
-    if (!gCtx.cryptokiInit)
+	struct globalCtx *gCtx = getCtx();
+
+	if (!gCtx->cryptokiInit)
 		return CKR_CRYPTOKI_NOT_INITIALIZED;
 
-    if (pInfo == NULL)
+	if (pInfo == NULL)
 		return CKR_ARGUMENTS_BAD;
 
-    pInfo->cryptokiVersion.major = CRYPTOKI_VERSION_MAJOR;
-    pInfo->cryptokiVersion.minor = CRYPTOKI_VERSION_MINOR;
-    strcpyPKCS11padding(pInfo->manufacturerID, MANUFACTURER,
+	pInfo->cryptokiVersion.major = CRYPTOKI_VERSION_MAJOR;
+	pInfo->cryptokiVersion.minor = CRYPTOKI_VERSION_MINOR;
+	strcpyPKCS11padding(pInfo->manufacturerID, MANUFACTURER,
 	                    sizeof(pInfo->manufacturerID));
-    pInfo->flags = 0;
-    strcpyPKCS11padding(pInfo->libraryDescription, LIBRARY_DESC,
+	pInfo->flags = 0;
+	strcpyPKCS11padding(pInfo->libraryDescription, LIBRARY_DESC,
 	                    sizeof(pInfo->libraryDescription));
-    pInfo->libraryVersion.major = LIBRARY_VERSION_MAJOR;
-    pInfo->libraryVersion.minor = LIBRARY_VERSION_MINOR;
+	pInfo->libraryVersion.major = LIBRARY_VERSION_MAJOR;
+	pInfo->libraryVersion.minor = LIBRARY_VERSION_MINOR;
 
-    return CKR_OK;
+	return CKR_OK;
 }
 
 CK_DEFINE_FUNCTION(CK_RV, C_GetFunctionList) (
-    CK_FUNCTION_LIST_PTR_PTR ppFunctionList
+	CK_FUNCTION_LIST_PTR_PTR ppFunctionList
 )
 {
-    if (ppFunctionList == NULL)
+	if (ppFunctionList == NULL)
 		return CKR_ARGUMENTS_BAD;
 
-    *ppFunctionList = &gFunctionList;
+	*ppFunctionList = &gFunctionList;
 
-    return CKR_OK;
+	return CKR_OK;
 }
 
 CK_DEFINE_FUNCTION(CK_RV, C_GetSlotList)(
-    CK_BBOOL tokenPresent,
-    CK_SLOT_ID_PTR pSlotList,
-    CK_ULONG_PTR pulCount
+	CK_BBOOL tokenPresent,
+	CK_SLOT_ID_PTR pSlotList,
+	CK_ULONG_PTR pulCount
 )
 {
-    int ret = CKR_OK;
+	struct globalCtx *gCtx = getCtx();
+	int ret = CKR_OK;
 
-    if (!gCtx.cryptokiInit)
+	if (!gCtx->cryptokiInit)
 		return CKR_CRYPTOKI_NOT_INITIALIZED;
 
-    if (pulCount == NULL)
+	if (pulCount == NULL)
 		return CKR_ARGUMENTS_BAD;
 
-    if (pSlotList == NULL)
+	if (pSlotList == NULL)
 		goto ret_count;
 
-    /* only support 1 slot. */
-    if (*pulCount >= 1)
+	/* only support 1 slot. */
+	if (*pulCount >= 1)
 		pSlotList[0] = SLOT_ID;
-    else
+	else
 		ret = CKR_BUFFER_TOO_SMALL;
 
 ret_count:
-    *pulCount = 1;
+	*pulCount = 1;
 
-    return ret;
+	return ret;
 }
 
 CK_DEFINE_FUNCTION(CK_RV, C_GetSlotInfo)(
-    CK_SLOT_ID slotID,
-    CK_SLOT_INFO_PTR pInfo
+	CK_SLOT_ID slotID,
+	CK_SLOT_INFO_PTR pInfo
 )
 {
-    if (!gCtx.cryptokiInit)
+	struct globalCtx *gCtx = getCtx();
+
+	if (!gCtx->cryptokiInit)
 		return CKR_CRYPTOKI_NOT_INITIALIZED;
 
-    if (!pInfo)
+	if (!pInfo)
 		return CKR_ARGUMENTS_BAD;
 
-    if (slotID != SLOT_ID)
+	if (slotID != SLOT_ID)
 		return CKR_SLOT_ID_INVALID;
 
-    memcpy(pInfo, &gCtx.slot, sizeof(CK_SLOT_INFO));
+	memcpy(pInfo, &gCtx->slot, sizeof(CK_SLOT_INFO));
 
-    return CKR_OK;
+	return CKR_OK;
 }
 
 CK_DEFINE_FUNCTION(CK_RV, C_GetTokenInfo)(
-    CK_SLOT_ID slotID,
-    CK_TOKEN_INFO_PTR pInfo
+	CK_SLOT_ID slotID,
+	CK_TOKEN_INFO_PTR pInfo
 )
 {
-    if (!gCtx.cryptokiInit)
+	struct globalCtx *gCtx = getCtx();
+
+	if (!gCtx->cryptokiInit)
 		return CKR_CRYPTOKI_NOT_INITIALIZED;
 
-    if (!pInfo)
+	if (!pInfo)
 		return CKR_ARGUMENTS_BAD;
 
-    if (slotID != SLOT_ID)
+	if (slotID != SLOT_ID)
 		return CKR_SLOT_ID_INVALID;
 
-    memcpy(pInfo, &gCtx.token, sizeof(CK_TOKEN_INFO));
+	memcpy(pInfo, &gCtx->token, sizeof(CK_TOKEN_INFO));
 
-    return CKR_OK;
+	return CKR_OK;
 }
 
 CK_DEFINE_FUNCTION(CK_RV, C_GetMechanismList)(
-    CK_SLOT_ID slotID,
-    CK_MECHANISM_TYPE_PTR pMechanismList,
-    CK_ULONG_PTR pulCount
+	CK_SLOT_ID slotID,
+	CK_MECHANISM_TYPE_PTR pMechanismList,
+	CK_ULONG_PTR pulCount
 )
 {
-    CK_RV rv = CKR_OK;
+	struct globalCtx *gCtx = getCtx();
+	CK_RV rv = CKR_OK;
 
-    if (!gCtx.cryptokiInit)
+	if (!gCtx->cryptokiInit)
 		return CKR_CRYPTOKI_NOT_INITIALIZED;
 
-    if (slotID != SLOT_ID)
+	if (slotID != SLOT_ID)
 		return CKR_SLOT_ID_INVALID;
 
-    if (pulCount == NULL)
+	if (pulCount == NULL)
 		return CKR_ARGUMENTS_BAD;
 
-    if (pMechanismList == NULL)
+	if (pMechanismList == NULL)
 		goto ret_count;
 
 	if (*pulCount < ARRAY_SIZE(mechanismList)) {
 		rv = CKR_BUFFER_TOO_SMALL;
 		goto ret_count;
-    }
+	}
 
-    memcpy(pMechanismList, mechanismList,
+	memcpy(pMechanismList, mechanismList,
 	       ARRAY_SIZE(mechanismList) * sizeof(CK_MECHANISM_TYPE));
 
 ret_count:
-    *pulCount = ARRAY_SIZE(mechanismList);
+	*pulCount = ARRAY_SIZE(mechanismList);
 
-    return rv;
+	return rv;
 }
 
 CK_DEFINE_FUNCTION(CK_RV, C_GetMechanismInfo)(
-    CK_SLOT_ID slotID,
-    CK_MECHANISM_TYPE type,
-    CK_MECHANISM_INFO_PTR pInfo
+	CK_SLOT_ID slotID,
+	CK_MECHANISM_TYPE type,
+	CK_MECHANISM_INFO_PTR pInfo
 )
 {
-    if (!gCtx.cryptokiInit)
+	struct globalCtx *gCtx = getCtx();
+
+	if (!gCtx->cryptokiInit)
 		return CKR_CRYPTOKI_NOT_INITIALIZED;
 
-    if (!pInfo)
+	if (!pInfo)
 		return CKR_ARGUMENTS_BAD;
 
-    if (slotID != SLOT_ID)
+	if (slotID != SLOT_ID)
 		return CKR_SLOT_ID_INVALID;
 
-    switch (type) {
+	switch (type) {
 		default:
 			return CKR_MECHANISM_INVALID;
-    }
+	}
 
-    return CKR_OK;
+	return CKR_OK;
 }
 
 CK_DEFINE_FUNCTION(CK_RV, C_GetAttributeValue)(
@@ -372,10 +389,11 @@ CK_DEFINE_FUNCTION(CK_RV, C_GetAttributeValue)(
 	CK_ULONG ulCount
 )
 {
+	struct globalCtx *gCtx = getCtx();
 	struct hse_keyObject *pkey;
 	int i;
 
-    if (!gCtx.cryptokiInit)
+	if (!gCtx->cryptokiInit)
 		return CKR_CRYPTOKI_NOT_INITIALIZED;
 
 	if (pTemplate == NULL || ulCount == 0)
@@ -384,7 +402,7 @@ CK_DEFINE_FUNCTION(CK_RV, C_GetAttributeValue)(
 	if (hSession != SESSION_ID)
 		return CKR_SESSION_HANDLE_INVALID;
 
-	pkey = (struct hse_keyObject *)list_seek(&gCtx.objects, &hObject);
+	pkey = (struct hse_keyObject *)list_seek(&gCtx->objects, &hObject);
 	if (pkey == NULL)
 		return CKR_OBJECT_HANDLE_INVALID;
 
@@ -423,13 +441,13 @@ CK_DEFINE_FUNCTION(CK_RV, C_GetAttributeValue)(
 }
 
 CK_DEFINE_FUNCTION(CK_RV, C_InitToken)(
-    CK_SLOT_ID slotID,
-    CK_UTF8CHAR_PTR pPin,
-    CK_ULONG ulPinLen,
-    CK_UTF8CHAR_PTR pLabel
+	CK_SLOT_ID slotID,
+	CK_UTF8CHAR_PTR pPin,
+	CK_ULONG ulPinLen,
+	CK_UTF8CHAR_PTR pLabel
 )
 {
-    return CKR_OK;
+	return CKR_OK;
 }
 
 CK_DEFINE_FUNCTION(CK_RV, C_InitPIN)(
@@ -438,7 +456,7 @@ CK_DEFINE_FUNCTION(CK_RV, C_InitPIN)(
 	CK_ULONG ulPinLen
 )
 {
-    return CKR_OK;
+	return CKR_OK;
 }
 
 CK_DEFINE_FUNCTION(CK_RV, C_SetPIN)(
@@ -460,26 +478,27 @@ CK_DEFINE_FUNCTION(CK_RV, C_OpenSession)(
 	CK_SESSION_HANDLE_PTR phSession
 )
 {
-    CK_TOKEN_INFO_PTR pToken = &gCtx.token;
-    CK_SESSION_INFO_PTR pSession = &gCtx.session;
+	struct globalCtx *gCtx = getCtx();
+	CK_TOKEN_INFO_PTR pToken = &gCtx->token;
+	CK_SESSION_INFO_PTR pSession = &gCtx->session;
 
-    if (!gCtx.cryptokiInit)
+	if (!gCtx->cryptokiInit)
 		return CKR_CRYPTOKI_NOT_INITIALIZED;
 
-    if (slotID != SLOT_ID)
+	if (slotID != SLOT_ID)
 		return CKR_SLOT_ID_INVALID;
 
-    if (!phSession)
+	if (!phSession)
 		return CKR_ARGUMENTS_BAD;
 
-    if (pToken->ulSessionCount >= pToken->ulMaxSessionCount)
+	if (pToken->ulSessionCount >= pToken->ulMaxSessionCount)
 		return CKR_SESSION_COUNT;
 
-    /* flag MUST be set due to legacy reasons */
-    if (!(flags & CKF_SERIAL_SESSION))
+	/* flag MUST be set due to legacy reasons */
+	if (!(flags & CKF_SERIAL_SESSION))
 		return CKR_SESSION_PARALLEL_NOT_SUPPORTED;
 
-    if (flags & CKF_RW_SESSION) {
+	if (flags & CKF_RW_SESSION) {
 		if (pToken->ulRwSessionCount >= pToken->ulMaxRwSessionCount)
 			return CKR_SESSION_COUNT;
 
@@ -488,55 +507,57 @@ CK_DEFINE_FUNCTION(CK_RV, C_OpenSession)(
 
 		pToken->ulRwSessionCount++;
 		pSession->state = CKS_RW_USER_FUNCTIONS;
-    } else {
+	} else {
 		pSession->state = CKS_RO_USER_FUNCTIONS;
-    }
+	}
 
-    pToken->ulSessionCount++;
-    pSession->flags = flags;
-    pSession->slotID = slotID;
-    *phSession = SESSION_ID;
+	pToken->ulSessionCount++;
+	pSession->flags = flags;
+	pSession->slotID = slotID;
+	*phSession = SESSION_ID;
 
-    return CKR_OK;
+	return CKR_OK;
 }
 
 CK_DEFINE_FUNCTION(CK_RV, C_CloseSession)(
 	CK_SESSION_HANDLE hSession
 )
 {
-    CK_TOKEN_INFO_PTR pToken = &gCtx.token;
-    CK_SESSION_INFO_PTR pSession = &gCtx.session;
+	struct globalCtx *gCtx = getCtx();
+	CK_TOKEN_INFO_PTR pToken = &gCtx->token;
+	CK_SESSION_INFO_PTR pSession = &gCtx->session;
 
-    if (!gCtx.cryptokiInit)
+	if (!gCtx->cryptokiInit)
 		return CKR_CRYPTOKI_NOT_INITIALIZED;
 
-    if (pToken->ulSessionCount == 0 || hSession != SESSION_ID)
+	if (pToken->ulSessionCount == 0 || hSession != SESSION_ID)
 		return CKR_SESSION_HANDLE_INVALID;
 
-    pToken->ulSessionCount--;
+	pToken->ulSessionCount--;
 
-    if (pSession->flags & CKF_RW_SESSION)
+	if (pSession->flags & CKF_RW_SESSION)
 		pToken->ulRwSessionCount--;
 
-    return CKR_OK;
+	return CKR_OK;
 }
 
 CK_DEFINE_FUNCTION(CK_RV, C_CloseAllSessions)(
 	CK_SLOT_ID slotID
 )
 {
-	CK_TOKEN_INFO_PTR pToken = &gCtx.token;
+	struct globalCtx *gCtx = getCtx();
+	CK_TOKEN_INFO_PTR pToken = &gCtx->token;
 
-	if (!gCtx.cryptokiInit)
+	if (!gCtx->cryptokiInit)
 		return CKR_CRYPTOKI_NOT_INITIALIZED;
 
-    if (slotID != SLOT_ID)
+	if (slotID != SLOT_ID)
 		return CKR_SLOT_ID_INVALID;
 
-    if (pToken->ulSessionCount > 0)
+	if (pToken->ulSessionCount > 0)
 		return C_CloseSession(SESSION_ID);
 
-    return CKR_OK;
+	return CKR_OK;
 }
 
 CK_DEFINE_FUNCTION(CK_RV, C_GetSessionInfo)(
@@ -544,21 +565,22 @@ CK_DEFINE_FUNCTION(CK_RV, C_GetSessionInfo)(
 	CK_SESSION_INFO_PTR pInfo
 )
 {
-    CK_TOKEN_INFO_PTR pToken = &gCtx.token;
-    CK_SESSION_INFO_PTR pSession = &gCtx.session;
+	struct globalCtx *gCtx = getCtx();
+	CK_TOKEN_INFO_PTR pToken = &gCtx->token;
+	CK_SESSION_INFO_PTR pSession = &gCtx->session;
 
-    if (!gCtx.cryptokiInit)
+	if (!gCtx->cryptokiInit)
 		return CKR_CRYPTOKI_NOT_INITIALIZED;
 
-    if (!pInfo)
+	if (!pInfo)
 		return CKR_ARGUMENTS_BAD;
 
-    if (pToken->ulSessionCount == 0 || hSession != SESSION_ID)
+	if (pToken->ulSessionCount == 0 || hSession != SESSION_ID)
 		return CKR_SESSION_HANDLE_INVALID;
 
-    memcpy(pInfo, pSession, sizeof(CK_SESSION_INFO));
+	memcpy(pInfo, pSession, sizeof(CK_SESSION_INFO));
 
-    return CKR_OK;
+	return CKR_OK;
 }
 
 CK_DEFINE_FUNCTION(CK_RV, C_Login)(
diff --git a/libpkcs/pkcs11_context.h b/libpkcs/pkcs11_context.h
index ffbfbba..e55c561 100644
--- a/libpkcs/pkcs11_context.h
+++ b/libpkcs/pkcs11_context.h
@@ -127,6 +127,6 @@ struct globalCtx {
 	struct hse_signCtx signCtx;
 };
 
-extern struct globalCtx gCtx;
+struct globalCtx *getCtx(void);
 
 #endif /* ___PKCS11_CONTEXT_H___ */
diff --git a/libpkcs/pkcs11_crypt.c b/libpkcs/pkcs11_crypt.c
index 1e6d2db..ef5721c 100644
--- a/libpkcs/pkcs11_crypt.c
+++ b/libpkcs/pkcs11_crypt.c
@@ -26,10 +26,12 @@ CK_DEFINE_FUNCTION(CK_RV, C_EncryptInit)(
 		CK_OBJECT_HANDLE hKey
 )
 {
-	if (gCtx.cryptokiInit == CK_FALSE)
+	struct globalCtx *gCtx = getCtx();
+
+	if (gCtx->cryptokiInit == CK_FALSE)
 		return CKR_CRYPTOKI_NOT_INITIALIZED;
 
-	if (gCtx.cryptCtx.init == CK_TRUE)
+	if (gCtx->cryptCtx.init == CK_TRUE)
 		return CKR_OPERATION_ACTIVE;
 
 	if (hSession != SESSION_ID)
@@ -38,7 +40,7 @@ CK_DEFINE_FUNCTION(CK_RV, C_EncryptInit)(
 	if (pMechanism == NULL)
 		return CKR_ARGUMENTS_BAD;
 
-	if (list_seek(&gCtx.objects, &hKey) == NULL)
+	if (list_seek(&gCtx->objects, &hKey) == NULL)
 		return CKR_KEY_HANDLE_INVALID;
 
 	/* IV is optional for AES-ECB */
@@ -46,9 +48,9 @@ CK_DEFINE_FUNCTION(CK_RV, C_EncryptInit)(
 	    pMechanism->mechanism != CKM_AES_ECB)
 		return CKR_ARGUMENTS_BAD;
 
-	gCtx.cryptCtx.init = CK_TRUE;
-	gCtx.cryptCtx.mechanism = pMechanism;
-	gCtx.cryptCtx.keyHandle = hKey;
+	gCtx->cryptCtx.init = CK_TRUE;
+	gCtx->cryptCtx.mechanism = pMechanism;
+	gCtx->cryptCtx.keyHandle = hKey;
 
 	return CKR_OK;
 }
@@ -61,6 +63,7 @@ CK_DEFINE_FUNCTION(CK_RV, C_Encrypt)(
 		CK_ULONG_PTR pulEncryptedDataLen
 )
 {
+	struct globalCtx *gCtx = getCtx();
 	hseSrvDescriptor_t srv_desc;
 	hseSymCipherSrv_t *sym_cipher_srv;
 	hseAeadSrv_t *aead_srv;
@@ -68,10 +71,10 @@ CK_DEFINE_FUNCTION(CK_RV, C_Encrypt)(
 	struct hse_keyObject *key;
 	int err;
 
-	if (gCtx.cryptokiInit == CK_FALSE)
+	if (gCtx->cryptokiInit == CK_FALSE)
 		return CKR_CRYPTOKI_NOT_INITIALIZED;
 
-	if (gCtx.cryptCtx.init == CK_FALSE)
+	if (gCtx->cryptCtx.init == CK_FALSE)
 		return CKR_OPERATION_NOT_INITIALIZED;
 
 	if (hSession != SESSION_ID)
@@ -80,7 +83,7 @@ CK_DEFINE_FUNCTION(CK_RV, C_Encrypt)(
 	if (pData == NULL || pEncryptedData == NULL || pulEncryptedDataLen == NULL)
 		return CKR_ARGUMENTS_BAD;
 
-	key = (struct hse_keyObject *)list_seek(&gCtx.objects, &gCtx.cryptCtx.keyHandle);
+	key = (struct hse_keyObject *)list_seek(&gCtx->objects, &gCtx->cryptCtx.keyHandle);
 
 	_input = hse_get_shared_mem_addr(HSE_INPUT_SRAM);
 	_output = hse_get_shared_mem_addr(HSE_OUTPUT_SRAM);
@@ -88,13 +91,13 @@ CK_DEFINE_FUNCTION(CK_RV, C_Encrypt)(
 	hse_memcpy(_output_len, pulEncryptedDataLen, sizeof(uint32_t));
 	hse_memcpy(_input, pData, ulDataLen);
 
-	if (gCtx.cryptCtx.mechanism->pParameter != NULL) {
+	if (gCtx->cryptCtx.mechanism->pParameter != NULL) {
 		_pIV = hse_get_shared_mem_addr(HSE_IV_SRAM);
-		hse_memcpy(_pIV, gCtx.cryptCtx.mechanism->pParameter,
-		                 gCtx.cryptCtx.mechanism->ulParameterLen);
+		hse_memcpy(_pIV, gCtx->cryptCtx.mechanism->pParameter,
+		                 gCtx->cryptCtx.mechanism->ulParameterLen);
 	}
 
-	switch (gCtx.cryptCtx.mechanism->mechanism) {
+	switch (gCtx->cryptCtx.mechanism->mechanism) {
 		case CKM_AES_ECB:
 
 			sym_cipher_srv = &srv_desc.hseSrv.symCipherReq;
@@ -108,7 +111,7 @@ CK_DEFINE_FUNCTION(CK_RV, C_Encrypt)(
 			sym_cipher_srv->sgtOption = HSE_SGT_OPTION_NONE;
 			sym_cipher_srv->keyHandle = key->key_handle;
 
-			if (gCtx.cryptCtx.mechanism->pParameter != NULL) {
+			if (gCtx->cryptCtx.mechanism->pParameter != NULL) {
 				sym_cipher_srv->pIV = hse_virt_to_phys(_pIV);
 			} else {
 				sym_cipher_srv->pIV = 0u; /* IV is not required for ecb */
@@ -129,7 +132,7 @@ CK_DEFINE_FUNCTION(CK_RV, C_Encrypt)(
 			aead_srv->authCipherMode = HSE_AUTH_CIPHER_MODE_GCM;
 			aead_srv->cipherDir = HSE_CIPHER_DIR_ENCRYPT;
 			aead_srv->keyHandle = key->key_handle;
-			aead_srv->ivLength = gCtx.cryptCtx.mechanism->ulParameterLen;
+			aead_srv->ivLength = gCtx->cryptCtx.mechanism->ulParameterLen;
 			aead_srv->pIV = hse_virt_to_phys(_pIV);
 			aead_srv->aadLength = 0u;
 			aead_srv->pAAD = 0u;
@@ -163,10 +166,12 @@ CK_DEFINE_FUNCTION(CK_RV, C_DecryptInit)(
 		CK_OBJECT_HANDLE hKey
 )
 {
-	if (gCtx.cryptokiInit == CK_FALSE)
+	struct globalCtx *gCtx = getCtx();
+
+	if (gCtx->cryptokiInit == CK_FALSE)
 		return CKR_CRYPTOKI_NOT_INITIALIZED;
 
-	if (gCtx.cryptCtx.init == CK_TRUE)
+	if (gCtx->cryptCtx.init == CK_TRUE)
 		return CKR_OPERATION_ACTIVE;
 
 	if (hSession != SESSION_ID)
@@ -175,7 +180,7 @@ CK_DEFINE_FUNCTION(CK_RV, C_DecryptInit)(
 	if (pMechanism == NULL)
 		return CKR_ARGUMENTS_BAD;
 
-	if (list_seek(&gCtx.objects, &hKey) == NULL)
+	if (list_seek(&gCtx->objects, &hKey) == NULL)
 		return CKR_KEY_HANDLE_INVALID;
 
 	/* IV is optional for AES-ECB */
@@ -183,9 +188,9 @@ CK_DEFINE_FUNCTION(CK_RV, C_DecryptInit)(
 		pMechanism->mechanism != CKM_AES_ECB)
 		return CKR_ARGUMENTS_BAD;
 
-	gCtx.cryptCtx.init = CK_TRUE;
-	gCtx.cryptCtx.mechanism = pMechanism;
-	gCtx.cryptCtx.keyHandle = hKey;
+	gCtx->cryptCtx.init = CK_TRUE;
+	gCtx->cryptCtx.mechanism = pMechanism;
+	gCtx->cryptCtx.keyHandle = hKey;
 
 	return CKR_OK;
 }
@@ -198,6 +203,7 @@ CK_DEFINE_FUNCTION(CK_RV, C_Decrypt)(
 		CK_ULONG_PTR pulDataLen
 )
 {
+	struct globalCtx *gCtx = getCtx();
 	hseSrvDescriptor_t srv_desc;
 	hseSymCipherSrv_t *sym_cipher_srv;
 	hseAeadSrv_t *aead_srv;
@@ -205,10 +211,10 @@ CK_DEFINE_FUNCTION(CK_RV, C_Decrypt)(
 	struct hse_keyObject *key;
 	int err;
 
-	if (gCtx.cryptokiInit == CK_FALSE)
+	if (gCtx->cryptokiInit == CK_FALSE)
 		return CKR_CRYPTOKI_NOT_INITIALIZED;
 
-	if (gCtx.cryptCtx.init == CK_FALSE)
+	if (gCtx->cryptCtx.init == CK_FALSE)
 		return CKR_OPERATION_NOT_INITIALIZED;
 
 	if (hSession != SESSION_ID)
@@ -217,7 +223,7 @@ CK_DEFINE_FUNCTION(CK_RV, C_Decrypt)(
 	if (pData == NULL || pEncryptedData == NULL || pulDataLen == NULL)
 		return CKR_ARGUMENTS_BAD;
 
-	key = (struct hse_keyObject *)list_seek(&gCtx.objects, &gCtx.cryptCtx.keyHandle);
+	key = (struct hse_keyObject *)list_seek(&gCtx->objects, &gCtx->cryptCtx.keyHandle);
 
 	_input = hse_get_shared_mem_addr(HSE_INPUT_SRAM);
 	_output = hse_get_shared_mem_addr(HSE_OUTPUT_SRAM);
@@ -225,13 +231,13 @@ CK_DEFINE_FUNCTION(CK_RV, C_Decrypt)(
 	hse_memcpy(_input, pEncryptedData, ulEncryptedDataLen);
 	hse_memcpy(_output_len, pulDataLen, sizeof(uint32_t));
 
-	if (gCtx.cryptCtx.mechanism->pParameter != NULL) {
+	if (gCtx->cryptCtx.mechanism->pParameter != NULL) {
 		_pIV = hse_get_shared_mem_addr(HSE_IV_SRAM);
-		hse_memcpy(_pIV, gCtx.cryptCtx.mechanism->pParameter,
-		                 gCtx.cryptCtx.mechanism->ulParameterLen);
+		hse_memcpy(_pIV, gCtx->cryptCtx.mechanism->pParameter,
+		                 gCtx->cryptCtx.mechanism->ulParameterLen);
 	}
 
-	switch (gCtx.cryptCtx.mechanism->mechanism) {
+	switch (gCtx->cryptCtx.mechanism->mechanism) {
 		case CKM_AES_ECB:
 
 			sym_cipher_srv = &srv_desc.hseSrv.symCipherReq;
@@ -245,7 +251,7 @@ CK_DEFINE_FUNCTION(CK_RV, C_Decrypt)(
 			sym_cipher_srv->sgtOption = HSE_SGT_OPTION_NONE;
 			sym_cipher_srv->keyHandle = key->key_handle;
 
-			if (gCtx.cryptCtx.mechanism->pParameter != NULL) {
+			if (gCtx->cryptCtx.mechanism->pParameter != NULL) {
 				sym_cipher_srv->pIV = hse_virt_to_phys(_pIV);
 			} else {
 				sym_cipher_srv->pIV = 0u; /* IV is not required for ecb */
@@ -266,7 +272,7 @@ CK_DEFINE_FUNCTION(CK_RV, C_Decrypt)(
 			aead_srv->authCipherMode = HSE_AUTH_CIPHER_MODE_GCM;
 			aead_srv->cipherDir = HSE_CIPHER_DIR_DECRYPT;
 			aead_srv->keyHandle = key->key_handle;
-			aead_srv->ivLength = gCtx.cryptCtx.mechanism->ulParameterLen;
+			aead_srv->ivLength = gCtx->cryptCtx.mechanism->ulParameterLen;
 			aead_srv->pIV = hse_virt_to_phys(_pIV);
 			aead_srv->aadLength = 0u;
 			aead_srv->pAAD = 0u;
@@ -300,10 +306,12 @@ CK_DEFINE_FUNCTION(CK_RV, C_SignInit)(
 		CK_OBJECT_HANDLE hKey
 )
 {
-	if (gCtx.cryptokiInit == CK_FALSE)
+	struct globalCtx *gCtx = getCtx();
+
+	if (gCtx->cryptokiInit == CK_FALSE)
 		return CKR_CRYPTOKI_NOT_INITIALIZED;
 
-	if (gCtx.signCtx.init == CK_TRUE)
+	if (gCtx->signCtx.init == CK_TRUE)
 		return CKR_OPERATION_ACTIVE;
 
 	if (hSession != SESSION_ID)
@@ -312,12 +320,12 @@ CK_DEFINE_FUNCTION(CK_RV, C_SignInit)(
 	if (pMechanism == NULL)
 		return CKR_ARGUMENTS_BAD;
 
-	if (list_seek(&gCtx.objects, &hKey) == NULL)
+	if (list_seek(&gCtx->objects, &hKey) == NULL)
 		return CKR_KEY_HANDLE_INVALID;
 
-	gCtx.signCtx.init = CK_TRUE;
-	gCtx.signCtx.mechanism = pMechanism;
-	gCtx.signCtx.keyHandle = hKey;
+	gCtx->signCtx.init = CK_TRUE;
+	gCtx->signCtx.mechanism = pMechanism;
+	gCtx->signCtx.keyHandle = hKey;
 
 	return CKR_OK;
 }
@@ -330,6 +338,7 @@ CK_DEFINE_FUNCTION(CK_RV, C_Sign)(
 		CK_ULONG_PTR pulSignatureLen
 )
 {
+	struct globalCtx *gCtx = getCtx();
 	hseSrvDescriptor_t srv_desc;
 	hseSignSrv_t *sign_srv;
 	hseSignScheme_t *sign_scheme;
@@ -337,10 +346,10 @@ CK_DEFINE_FUNCTION(CK_RV, C_Sign)(
 	struct hse_keyObject *key;
 	int err;
 
-	if (gCtx.cryptokiInit == CK_FALSE)
+	if (gCtx->cryptokiInit == CK_FALSE)
 		return CKR_CRYPTOKI_NOT_INITIALIZED;
 
-	if (gCtx.signCtx.init == CK_FALSE)
+	if (gCtx->signCtx.init == CK_FALSE)
 		return CKR_OPERATION_NOT_INITIALIZED;
 
 	if (hSession != SESSION_ID)
@@ -349,7 +358,7 @@ CK_DEFINE_FUNCTION(CK_RV, C_Sign)(
 	if (pData == NULL || pSignature == NULL || pulSignatureLen == NULL)
 		return CKR_ARGUMENTS_BAD;
 
-	key = (struct hse_keyObject *)list_seek(&gCtx.objects, &gCtx.signCtx.keyHandle);
+	key = (struct hse_keyObject *)list_seek(&gCtx->objects, &gCtx->signCtx.keyHandle);
 
 	_input = hse_get_shared_mem_addr(HSE_INPUT_SRAM);
 	_output_len = hse_get_shared_mem_addr(HSE_OUTPUTLEN_SRAM);
@@ -359,7 +368,7 @@ CK_DEFINE_FUNCTION(CK_RV, C_Sign)(
 	sign_srv = &srv_desc.hseSrv.signReq;
 	sign_scheme = &sign_srv->signScheme;
 
-	switch (gCtx.signCtx.mechanism->mechanism) {
+	switch (gCtx->signCtx.mechanism->mechanism) {
 		case CKM_SHA256_RSA_PKCS:
 
 			_sign0 = hse_get_shared_mem_addr(HSE_SIGN0_SRAM);
@@ -413,7 +422,7 @@ CK_DEFINE_FUNCTION(CK_RV, C_Sign)(
 	if (err)
 		return CKR_FUNCTION_FAILED;
 
-	switch (gCtx.signCtx.mechanism->mechanism) {
+	switch (gCtx->signCtx.mechanism->mechanism) {
 		case CKM_SHA256_RSA_PKCS:
 
 			hse_memcpy(pSignature, _sign0, *(uint32_t *)_output_len);
@@ -443,10 +452,12 @@ CK_DEFINE_FUNCTION(CK_RV, C_VerifyInit)(
 		CK_OBJECT_HANDLE hKey
 )
 {
-	if (gCtx.cryptokiInit == CK_FALSE)
+	struct globalCtx *gCtx = getCtx();
+
+	if (gCtx->cryptokiInit == CK_FALSE)
 		return CKR_CRYPTOKI_NOT_INITIALIZED;
 
-	if (gCtx.signCtx.init == CK_TRUE)
+	if (gCtx->signCtx.init == CK_TRUE)
 		return CKR_OPERATION_ACTIVE;
 
 	if (hSession != SESSION_ID)
@@ -455,12 +466,12 @@ CK_DEFINE_FUNCTION(CK_RV, C_VerifyInit)(
 	if (pMechanism == NULL)
 		return CKR_ARGUMENTS_BAD;
 
-	if (list_seek(&gCtx.objects, &hKey) == NULL)
+	if (list_seek(&gCtx->objects, &hKey) == NULL)
 		return CKR_KEY_HANDLE_INVALID;
 
-	gCtx.signCtx.init = CK_TRUE;
-	gCtx.signCtx.mechanism = pMechanism;
-	gCtx.signCtx.keyHandle = hKey;
+	gCtx->signCtx.init = CK_TRUE;
+	gCtx->signCtx.mechanism = pMechanism;
+	gCtx->signCtx.keyHandle = hKey;
 
 	return CKR_OK;
 }
@@ -473,6 +484,7 @@ CK_DEFINE_FUNCTION(CK_RV, C_Verify)(
 		CK_ULONG ulSignatureLen
 )
 {
+	struct globalCtx *gCtx = getCtx();
 	hseSrvDescriptor_t srv_desc;
 	hseSignSrv_t *sign_srv;
 	hseSignScheme_t *sign_scheme;
@@ -480,10 +492,10 @@ CK_DEFINE_FUNCTION(CK_RV, C_Verify)(
 	struct hse_keyObject *key;
 	int err;
 
-	if (gCtx.cryptokiInit == CK_FALSE)
+	if (gCtx->cryptokiInit == CK_FALSE)
 		return CKR_CRYPTOKI_NOT_INITIALIZED;
 
-	if (gCtx.signCtx.init == CK_FALSE)
+	if (gCtx->signCtx.init == CK_FALSE)
 		return CKR_OPERATION_NOT_INITIALIZED;
 
 	if (hSession != SESSION_ID)
@@ -492,7 +504,7 @@ CK_DEFINE_FUNCTION(CK_RV, C_Verify)(
 	if (pData == NULL || pSignature == NULL)
 		return CKR_ARGUMENTS_BAD;
 
-	key = (struct hse_keyObject *)list_seek(&gCtx.objects, &gCtx.signCtx.keyHandle);
+	key = (struct hse_keyObject *)list_seek(&gCtx->objects, &gCtx->signCtx.keyHandle);
 
 	_input = hse_get_shared_mem_addr(HSE_INPUT_SRAM);
 	_output_len = hse_get_shared_mem_addr(HSE_OUTPUTLEN_SRAM);
@@ -502,7 +514,7 @@ CK_DEFINE_FUNCTION(CK_RV, C_Verify)(
 	sign_srv = &srv_desc.hseSrv.signReq;
 	sign_scheme = &sign_srv->signScheme;
 
-	switch (gCtx.signCtx.mechanism->mechanism) {
+	switch (gCtx->signCtx.mechanism->mechanism) {
 		case CKM_SHA256_RSA_PKCS:
 
 			_sign0 = hse_get_shared_mem_addr(HSE_SIGN0_SRAM);
diff --git a/libpkcs/pkcs11_object.c b/libpkcs/pkcs11_object.c
index 672aa98..d25dcbd 100644
--- a/libpkcs/pkcs11_object.c
+++ b/libpkcs/pkcs11_object.c
@@ -12,28 +12,28 @@
 
 static uint16_t getkeybitlen(hseEccCurveId_t eccCurveId)
 {
-    switch(eccCurveId) {
-        case HSE_EC_SEC_SECP256R1:
-            return 256u;
-        case HSE_EC_SEC_SECP384R1:
-            return 384u;
-        case HSE_EC_SEC_SECP521R1:
-            return 521u;
-        case HSE_EC_BRAINPOOL_BRAINPOOLP256R1:
-            return 256u;
-        case HSE_EC_BRAINPOOL_BRAINPOOLP320R1:
-            return 320u;
-        case HSE_EC_BRAINPOOL_BRAINPOOLP384R1:
-            return 384u;
-        case HSE_EC_BRAINPOOL_BRAINPOOLP512R1:
-            return 512u;
-        case HSE_EC_25519_ED25519:
-            return 256u;
-        case HSE_EC_25519_CURVE25519:
-            return 256u;
-        default:
-            return 0u;
-    }
+	switch(eccCurveId) {
+		case HSE_EC_SEC_SECP256R1:
+			return 256u;
+		case HSE_EC_SEC_SECP384R1:
+			return 384u;
+		case HSE_EC_SEC_SECP521R1:
+			return 521u;
+		case HSE_EC_BRAINPOOL_BRAINPOOLP256R1:
+			return 256u;
+		case HSE_EC_BRAINPOOL_BRAINPOOLP320R1:
+			return 320u;
+		case HSE_EC_BRAINPOOL_BRAINPOOLP384R1:
+			return 384u;
+		case HSE_EC_BRAINPOOL_BRAINPOOLP512R1:
+			return 512u;
+		case HSE_EC_25519_ED25519:
+			return 256u;
+		case HSE_EC_25519_CURVE25519:
+			return 256u;
+		default:
+			return 0u;
+	}
 }
 
 static uint8_t gethsecurveid(char *oid)
@@ -126,6 +126,7 @@ CK_DEFINE_FUNCTION(CK_RV, C_CreateObject)(
 		CK_OBJECT_HANDLE_PTR phObject
 )
 {
+	struct globalCtx *gCtx = getCtx();
 	hseSrvDescriptor_t srv_desc;
 	hseKeyInfo_t key_info;
 	hseImportKeySrv_t *import_key_req;
@@ -136,7 +137,7 @@ CK_DEFINE_FUNCTION(CK_RV, C_CreateObject)(
 	CK_RV rc = CKR_OK;
 	int err;
 
-	if (gCtx.cryptokiInit == CK_FALSE) {
+	if (gCtx->cryptokiInit == CK_FALSE) {
 		rc = CKR_CRYPTOKI_NOT_INITIALIZED;
 		goto gen_err;
 	}
@@ -207,11 +208,11 @@ CK_DEFINE_FUNCTION(CK_RV, C_CreateObject)(
 
 	/* check if key is already in nvm catalog */
 	if (key->id[2] == 1) {
-		keytemp = (struct hse_keyObject *)list_seek(&gCtx.objects, &key->key_handle);
+		keytemp = (struct hse_keyObject *)list_seek(&gCtx->objects, &key->key_handle);
 		if (keytemp) {
 			key->nvm_ctr = keytemp->nvm_ctr + 1;
 			/* just delete the old one */
-			list_delete(&gCtx.objects, keytemp);
+			list_delete(&gCtx->objects, keytemp);
 		}
 	} else {
 		key->nvm_ctr = 0ul;
@@ -353,7 +354,7 @@ CK_DEFINE_FUNCTION(CK_RV, C_CreateObject)(
 
 	*phObject = key->key_handle;
 
-	list_append(&gCtx.objects, key);
+	list_append(&gCtx->objects, key);
 
 	return CKR_OK;
 class_err:
@@ -371,18 +372,19 @@ CK_DEFINE_FUNCTION(CK_RV, C_DestroyObject)(
 		CK_OBJECT_HANDLE hObject
 )
 {
+	struct globalCtx *gCtx = getCtx();
 	hseSrvDescriptor_t srv_desc;
 	void *_srv_desc;
 	struct hse_keyObject *pkey;
 	int err;
 
-	if (gCtx.cryptokiInit == CK_FALSE)
+	if (gCtx->cryptokiInit == CK_FALSE)
 		return CKR_CRYPTOKI_NOT_INITIALIZED;
 
 	if (hSession != SESSION_ID)
 		return CKR_SESSION_HANDLE_INVALID;
 
-	pkey = (struct hse_keyObject *)list_seek(&gCtx.objects, &hObject);
+	pkey = (struct hse_keyObject *)list_seek(&gCtx->objects, &hObject);
 	if (pkey == NULL)
 		return CKR_OBJECT_HANDLE_INVALID;
 
@@ -398,7 +400,7 @@ CK_DEFINE_FUNCTION(CK_RV, C_DestroyObject)(
 	if (err)
 		return CKR_FUNCTION_FAILED;
 
-	if (list_delete(&gCtx.objects, pkey) != 0)
+	if (list_delete(&gCtx->objects, pkey) != 0)
 		return CKR_FUNCTION_FAILED;
 
 	return CKR_OK;
@@ -410,10 +412,12 @@ CK_DEFINE_FUNCTION(CK_RV, C_FindObjectsInit)(
 	CK_ULONG ulCount
 )
 {
-	if (gCtx.cryptokiInit == CK_FALSE)
+	struct globalCtx *gCtx = getCtx();
+
+	if (gCtx->cryptokiInit == CK_FALSE)
 		return CKR_CRYPTOKI_NOT_INITIALIZED;
 
-	if (gCtx.findCtx.init == CK_TRUE)
+	if (gCtx->findCtx.init == CK_TRUE)
 		return CKR_OPERATION_ACTIVE;
 
 	if (hSession != SESSION_ID)
@@ -421,13 +425,13 @@ CK_DEFINE_FUNCTION(CK_RV, C_FindObjectsInit)(
 
 	if (ulCount != 0) {
 		if (pTemplate != NULL)
-			gCtx.findCtx.obj_class = (CK_OBJECT_CLASS *)getattr_pval(pTemplate, CKA_CLASS, ulCount);
+			gCtx->findCtx.obj_class = (CK_OBJECT_CLASS *)getattr_pval(pTemplate, CKA_CLASS, ulCount);
 		else
 			return CKR_ARGUMENTS_BAD;
 	}
 
-	gCtx.findCtx.init = CK_TRUE;
-	list_iterator_start(&gCtx.objects);
+	gCtx->findCtx.init = CK_TRUE;
+	list_iterator_start(&gCtx->objects);
 
 	return CKR_OK;
 }
@@ -439,14 +443,15 @@ CK_DEFINE_FUNCTION(CK_RV, C_FindObjects)(
 	CK_ULONG_PTR pulObjectCount
 )
 {
+	struct globalCtx *gCtx = getCtx();
 	struct hse_keyObject *key;
 	struct hse_findCtx *finder;
 	int i;
 
-	if (gCtx.cryptokiInit == CK_FALSE)
+	if (gCtx->cryptokiInit == CK_FALSE)
 		return CKR_CRYPTOKI_NOT_INITIALIZED;
 
-	if (gCtx.findCtx.init == CK_FALSE)
+	if (gCtx->findCtx.init == CK_FALSE)
 		return CKR_OPERATION_NOT_INITIALIZED;
 
 	if (hSession != SESSION_ID)
@@ -455,15 +460,15 @@ CK_DEFINE_FUNCTION(CK_RV, C_FindObjects)(
 	if (phObject == NULL || ulMaxObjectCount == 0 || pulObjectCount == NULL)
 		return CKR_ARGUMENTS_BAD;
 
-	if (!list_iterator_hasnext(&gCtx.objects)) {
+	if (!list_iterator_hasnext(&gCtx->objects)) {
 		*pulObjectCount = 0;
 		return CKR_OK;
 	}
 
-	finder = &gCtx.findCtx;
+	finder = &gCtx->findCtx;
 	i = 0;
 	do {
-		key = (struct hse_keyObject *)list_iterator_next(&gCtx.objects);
+		key = (struct hse_keyObject *)list_iterator_next(&gCtx->objects);
 
 		if (finder->obj_class == NULL || key->key_class == *finder->obj_class) {
 			phObject[i] = key->key_handle;
@@ -472,7 +477,7 @@ CK_DEFINE_FUNCTION(CK_RV, C_FindObjects)(
 
 		if (i > ulMaxObjectCount)
 			break;
-	} while (list_iterator_hasnext(&gCtx.objects));
+	} while (list_iterator_hasnext(&gCtx->objects));
 
 	*pulObjectCount = i;
 
@@ -483,17 +488,19 @@ CK_DEFINE_FUNCTION(CK_RV, C_FindObjectsFinal)(
 	CK_SESSION_HANDLE hSession
 )
 {
-	if (gCtx.cryptokiInit == CK_FALSE)
+	struct globalCtx *gCtx = getCtx();
+
+	if (gCtx->cryptokiInit == CK_FALSE)
 		return CKR_CRYPTOKI_NOT_INITIALIZED;
 
-	if(gCtx.findCtx.init == CK_FALSE)
+	if(gCtx->findCtx.init == CK_FALSE)
 		return CKR_OPERATION_NOT_INITIALIZED;
 
 	if (hSession != SESSION_ID)
 		return CKR_SESSION_HANDLE_INVALID;
 
-	gCtx.findCtx.init = CK_FALSE;
-	list_iterator_stop(&gCtx.objects);
+	gCtx->findCtx.init = CK_FALSE;
+	list_iterator_stop(&gCtx->objects);
 
 	return CKR_OK;
 }
-- 
2.17.1

